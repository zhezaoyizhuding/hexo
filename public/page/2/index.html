<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ZHENGRUI&#39;BLOG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="ZHENGRUI'BLOG">
<meta property="og:url" content="https://zhezaoyizhuding.github.io/page/2/index.html">
<meta property="og:site_name" content="ZHENGRUI'BLOG">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZHENGRUI'BLOG">
  
  
    <link rel="icon" href="/favicon.png">
  
  <!-- <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'> -->
  <!-- <link href="//fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <link href="//fonts.useso.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css">
  <link href='//fonts.useso.com/css?family=Open+Sans:300,600' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <a href="/" class="logo">ZHENGRUI&#39;BLOG</a>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about/index.html">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://zhezaoyizhuding.github.io"></form>
        </div>
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
        
        
      </nav>
    </div>
  </div>
</header>
      <nav id="mobile-nav" class="off">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about/index.html" class="mobile-nav-link">About</a>
  
  <div id="search-form-wrap-mobile">
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://zhezaoyizhuding.github.io"></form>
  </div>
</nav>
      <div class="outer">
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">16</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/28/设计模式之工厂模式/">设计模式之工厂模式</a>
          </li>
        
          <li>
            <a href="/2017/03/28/设计模式之观察者模式/">设计模式之观察者模式</a>
          </li>
        
          <li>
            <a href="/2017/03/28/设计模式之单例模式/">设计模式之单例模式</a>
          </li>
        
          <li>
            <a href="/2017/03/19/Java基础之内存管理/">Java基础之内存管理</a>
          </li>
        
          <li>
            <a href="/2017/03/19/Java基础之反射与类加载器/">Java基础之反射与类加载器</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AsycTask/">AsycTask</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BroadcastReceiver/">BroadcastReceiver</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Content-Provider/">Content Provider</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fragment/">Fragment</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Handler/">Handler</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Intent/">Intent</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IntentFilter/">IntentFilter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/List/">List</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Map/">Map</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLite/">SQLite</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Set/">Set</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/View/">View</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ViewGroup/">ViewGroup</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/activity/">activity</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/loader/">loader</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pull/">pull</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/push/">push</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/service/">service</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/view/">view</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事件分发/">事件分发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存管理/">内存管理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/创建型模式/">创建型模式</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单例模式/">单例模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/垃圾回收/">垃圾回收</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工厂方法模式/">工厂方法模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异常/">异常</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/抽象工厂模式/">抽象工厂模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/推送/">推送</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据存储/">数据存储</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/泛型/">泛型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/注解/">注解</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/注释/">注释</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单工厂模式/">简单工厂模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程/">线程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/缓存/">缓存</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/行为模式/">行为模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/观察者模式/">观察者模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/长连接/">长连接</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/集合/">集合</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AsycTask/" style="font-size: 10px;">AsycTask</a> <a href="/tags/BroadcastReceiver/" style="font-size: 10px;">BroadcastReceiver</a> <a href="/tags/Content-Provider/" style="font-size: 10px;">Content Provider</a> <a href="/tags/Fragment/" style="font-size: 10px;">Fragment</a> <a href="/tags/Handler/" style="font-size: 10px;">Handler</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/Intent/" style="font-size: 10px;">Intent</a> <a href="/tags/IntentFilter/" style="font-size: 10px;">IntentFilter</a> <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/List/" style="font-size: 10px;">List</a> <a href="/tags/Map/" style="font-size: 10px;">Map</a> <a href="/tags/SQLite/" style="font-size: 10px;">SQLite</a> <a href="/tags/Set/" style="font-size: 10px;">Set</a> <a href="/tags/View/" style="font-size: 10px;">View</a> <a href="/tags/ViewGroup/" style="font-size: 10px;">ViewGroup</a> <a href="/tags/activity/" style="font-size: 10px;">activity</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/hexo/" style="font-size: 13.33px;">hexo</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/loader/" style="font-size: 10px;">loader</a> <a href="/tags/pull/" style="font-size: 10px;">pull</a> <a href="/tags/push/" style="font-size: 10px;">push</a> <a href="/tags/service/" style="font-size: 10px;">service</a> <a href="/tags/view/" style="font-size: 10px;">view</a> <a href="/tags/事件分发/" style="font-size: 10px;">事件分发</a> <a href="/tags/内存管理/" style="font-size: 10px;">内存管理</a> <a href="/tags/创建型模式/" style="font-size: 13.33px;">创建型模式</a> <a href="/tags/单例模式/" style="font-size: 10px;">单例模式</a> <a href="/tags/垃圾回收/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/工厂方法模式/" style="font-size: 10px;">工厂方法模式</a> <a href="/tags/异常/" style="font-size: 10px;">异常</a> <a href="/tags/抽象工厂模式/" style="font-size: 10px;">抽象工厂模式</a> <a href="/tags/推送/" style="font-size: 10px;">推送</a> <a href="/tags/数据存储/" style="font-size: 10px;">数据存储</a> <a href="/tags/泛型/" style="font-size: 10px;">泛型</a> <a href="/tags/注解/" style="font-size: 10px;">注解</a> <a href="/tags/注释/" style="font-size: 10px;">注释</a> <a href="/tags/简单工厂模式/" style="font-size: 10px;">简单工厂模式</a> <a href="/tags/线程/" style="font-size: 10px;">线程</a> <a href="/tags/缓存/" style="font-size: 10px;">缓存</a> <a href="/tags/行为模式/" style="font-size: 10px;">行为模式</a> <a href="/tags/观察者模式/" style="font-size: 10px;">观察者模式</a> <a href="/tags/长连接/" style="font-size: 10px;">长连接</a> <a href="/tags/集合/" style="font-size: 10px;">集合</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">links</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://hexo.io">Hexo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
        <section id="main">
  
    <article id="post-Java基础之线程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/16/Java基础之线程/" class="article-date">
  <time datetime="2017-03-16T01:58:21.000Z" itemprop="datePublished">2017-03-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/16/Java基础之线程/">Java基础之线程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>所谓的多线程就是一个程序中存在多个顺序执行流，每个执行流便是一个线程。Java提供了优秀的多线程支持，下面将会详细介绍Java多线程编程的相关知识。</p>
<h3 id="二-线程与进程的比较"><a href="#二-线程与进程的比较" class="headerlink" title="二 线程与进程的比较"></a>二 线程与进程的比较</h3><p>现在的操作系统基本都支持多进程，即可以同时运行多个任务，每个任务通常是一个程序，每个运行的程序便是一个进程。而一个程序运行时往往有多个顺序执行流，这每个顺序执行流便是一个线程。</p>
<p>线程与进程的区别：</p>
<ul>
<li>线程比进程更轻，并发性更高</li>
<li>线程可以共享进程的资源，便于实现相互之间的通信</li>
<li>创建线程的代价比创建进程的代价小得多</li>
<li>java内置了多线程编程支持，可以非常方便的操作线程</li>
</ul>
<p>并发与并行的区别：</p>
<p>并行是某一时刻同时运行，并发是某一时刻只有一个指令运行，但是多个指令之间切换过快，所以看起来像是同时运行。</p>
<h3 id="三-创建线程的三种方式"><a href="#三-创建线程的三种方式" class="headerlink" title="三 创建线程的三种方式"></a>三 创建线程的三种方式</h3><h5 id="1-继承Thread类创建线程"><a href="#1-继承Thread类创建线程" class="headerlink" title="1.继承Thread类创建线程"></a>1.继承Thread类创建线程</h5><p>使用Thread类创建线程的步骤如下：</p>
<ol>
<li>定义Thread的子类并重写它的run方法，run方法的方法体里面就是线程需要完成的任务</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动线程</li>
</ol>
<p>代码示例：</p>
<p>抽空写</p>
<h5 id="2-实现Runnable接口创建线程"><a href="#2-实现Runnable接口创建线程" class="headerlink" title="2.实现Runnable接口创建线程"></a>2.实现Runnable接口创建线程</h5><p>步骤如下：</p>
<ol>
<li>实现接口Runnable接口，并实现它的run方法。</li>
<li>创建Runnable接口实现类的实例，并把它作为参数传给Thread的构造函数，创建Thread对象（即将该实例作为Thread类的Target），并调用它的start方法启动线程。（Runnable接口时函数式接口，可使用Lambda表达式）</li>
</ol>
<p>代码示例：</p>
<ul>
<li>使用Runnable创建线程的一个优势是多个线程之间可以共享线程类中的实例变量。这也是最常用的一种创建线程的方式，但一般都采用匿名内部类的方式简写。</li>
</ul>
<h5 id="3-使用Callable和Future创建线程"><a href="#3-使用Callable和Future创建线程" class="headerlink" title="3. 使用Callable和Future创建线程"></a>3. 使用Callable和Future创建线程</h5><p>从java5开始，java提供了一个Callable接口，接口中提供了一个call()方法来替代run()方法，它比run方法的功能更强大。主要有以下两点：</p>
<ul>
<li>call方法可以有返回值</li>
<li>call方法可以声明抛出异常</li>
</ul>
<p>由于Callable接口没有继承Runnable接口，且call方法有返回值，因此实现Callable接口的类无法作为Target传入Thread类中。为此java5提供了Future接口来包装Callable接口创建线程，该接口有一个FutureTask实现类，该类同时也实现了Runnable接口，因此该类的对象可以作为Target传入Thread类中来创建线程。</p>
<p>创建并启动有返回值的线程的步骤如下：</p>
<ol>
<li>创建Callable接口的实现类，并实现它的call方法。、</li>
<li>创建FutureTask类来包装Callable接口的实现类的对象（Callable是函数式接口，这一步可以是Lambda表达式）</li>
<li>将FutureTask对象作为Target传入Thread类中，创建线程。</li>
<li>使用FutureTask对象的get方法得到call的返回值</li>
</ol>
<p>Callab接口实现线程与Runnable接口类似，因此它也有Runnable接口的优势。</p>
<h5 id="4-创建线程的三种方式对比"><a href="#4-创建线程的三种方式对比" class="headerlink" title="4. 创建线程的三种方式对比"></a>4. 创建线程的三种方式对比</h5><p>使用Runnable和Callable接口创建线程的优势：</p>
<ul>
<li>因为是实现接口，还可以继承其他类，避免由于Java的单继承特性而带来的局限。</li>
<li>这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而将CPU，代码和数据分开，更清晰。</li>
</ul>
<p>劣势：</p>
<ul>
<li>编程稍稍复杂，且要访问当前线程，需要使用Thread.currentThread()方法获取当前线程的实例</li>
</ul>
<p>使用继承Thread类的方式优势：</p>
<ul>
<li>编程简单</li>
</ul>
<p>劣势：</p>
<p>因为已经继承了Thread类，无法再继承其他的类。</p>
<h3 id="三-线程的生命周期"><a href="#三-线程的生命周期" class="headerlink" title="三 线程的生命周期"></a>三 线程的生命周期</h3><p>Java中的线程总结起来可以划分为5个生命周期：</p>
<ul>
<li>新建：创建Thread类或其子类对象</li>
<li>就绪（可运行）：调用Thread类的start方法启动线程，此时线程处于可运行状态，但何时运行取决于JVM线程调度器的调度。一个就绪的线程只有获得CPU时间片才可以进入运行状态。</li>
<li>运行：获得CPU时间片开始运行。现在的操作系统基本上都是抢占式调度策略（当然也有些小型设备是协作式调度策略），即当前时间片用完，即会被其他线程抢占（取决于优先级）。</li>
<li>阻塞：有sleep、join或者IO造成的线程阻塞（调用suspend()也可以使线程挂起，但是该方法容易导致死锁，已不推荐使用）</li>
<li>死亡：run结束或者异常。（调用stop方法也可以结束线程，但该方法容易造成死锁，已不推荐使用）</li>
</ul>
<p>下面是线程状态转换图：</p>
<img src="/2017/03/16/Java基础之线程/Java线程状态转换图.png" alt="Java线程状态转换图" title="Java线程状态转换图">
<h3 id="四-Java中内置的用于线程控制的方法"><a href="#四-Java中内置的用于线程控制的方法" class="headerlink" title="四 Java中内置的用于线程控制的方法"></a>四 Java中内置的用于线程控制的方法</h3><p>常见的有以下几个方法：（详细请查看Thread源码）</p>
<ul>
<li>join：加入一个线程，是当前线程（调用join的线程所处的线程）阻塞，直到调用join的线程执行完。</li>
<li>setDaemon：将一个线程设置为后台线程（守护线程），该方法必须在start方法前调用；isDaemon判断一个线程是否是后台线程。</li>
<li>sleep：是当前正在执行的线程阻塞</li>
<li>yield：使当前正在执行的线程进入就绪状态。将机会让给与它优先级相同或者比它高的线程，如其优先级很高，完全有可能被JVM的线程调度器再次调用</li>
<li>setPriority：设置当前线程的优先级</li>
</ul>
<h3 id="五-线程同步"><a href="#五-线程同步" class="headerlink" title="五 线程同步"></a>五 线程同步</h3><h5 id="1-使用synchronized关键实现同步"><a href="#1-使用synchronized关键实现同步" class="headerlink" title="1. 使用synchronized关键实现同步"></a>1. 使用synchronized关键实现同步</h5><ul>
<li>同步代码块<br>使用synchronized对对象进行加锁，如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>（obj）&#123;</div><div class="line">   </div><div class="line">   <span class="comment">//TODO</span></div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>同步方法<br>使用synchronized对方法进行加锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> lock（Object obj）&#123;</div><div class="line"></div><div class="line">    <span class="comment">//TODO</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>synchronized关键字可以对代码块，方法加锁，但不能修饰构造器，成员变量等。</p>
<p>使用synchronized加锁后，线程什么情况下会释放锁：</p>
<ul>
<li>同步方法，代码块执行完毕</li>
<li>在同步方法，代码块执行中遇到了break，return</li>
<li>出现了未处理的异常和Error</li>
<li>调用wait方法</li>
</ul>
<p>下列情况下不会释放锁：</p>
<ul>
<li>调用sleep，yield方法</li>
<li>调用suspend方法</li>
</ul>
<h5 id="2-同步锁"><a href="#2-同步锁" class="headerlink" title="2. 同步锁"></a>2. 同步锁</h5><p>从java5开始java提供了接口Lock和ReadWriteLock来实现锁同步。Lock接口有个实现类ReentrantLock，ReadWriteLock有个实现类ReentrantReadWriteLock。使用这两个类可以实现锁同步。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">   lock.lock();</div><div class="line">   <span class="keyword">try</span>&#123;</div><div class="line">      <span class="comment">//需要保证线程安全的代码</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">finally</span>&#123;</div><div class="line">      lock.unlock();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java8又新增了一个StampedLock类，在大多数情况下它可以替代ReentrantReadWriteLock。</p>
<h3 id="六-线程通信"><a href="#六-线程通信" class="headerlink" title="六 线程通信"></a>六 线程通信</h3><h5 id="1-传统的线程通信"><a href="#1-传统的线程通信" class="headerlink" title="1.传统的线程通信"></a>1.传统的线程通信</h5><p>使用wait、notify、notifyAll实现线程通信，适用于使用synchronized关键字来保证线程同步的情况下。代码示例：</p>
<h5 id="2-使用Contition实现线程通信"><a href="#2-使用Contition实现线程通信" class="headerlink" title="2.使用Contition实现线程通信"></a>2.使用Contition实现线程通信</h5><p>若是使用Lock对象实现线程同步，则无法使用上述的线程通信的方法，java5提供了一个Condition类来实现线程通信。可通过Lock对象的newCondition()方法获得Condition对象，Condition对象中有await，signal，signalAll方法分别对应传统的wait，notify，notifyAll方法，用于实现线程通信。</p>
<h5 id="3-使用阻塞队列实现线程通信"><a href="#3-使用阻塞队列实现线程通信" class="headerlink" title="3.使用阻塞队列实现线程通信"></a>3.使用阻塞队列实现线程通信</h5><p>java5提供了一个BlockingQueue接口，它有一个特征：当生产者线程试图向BlockingQueue里放入元素时，若队列已满，则该线程被阻塞；当消费者试图从BlockingQueue里取出元素时，若队列为空，这该线程被阻塞。利用此原理可以实现线程通信。</p>
<p>该接口有几个实现类，可用于构造线程池。</p>
<h3 id="七-线程池"><a href="#七-线程池" class="headerlink" title="七 线程池"></a>七 线程池</h3><p>线程池即是一个对象池，传入的都是Runnable对象，底层使用数组或者集合来实现。java中内置了一个Executeors工厂类来实现线程池（它还有一个子类ForkjoinPool）,此外还可以使用其他的第三方框架，如ThreadPoolExecutor。</p>
<h3 id="八-ThreadLocal类"><a href="#八-ThreadLocal类" class="headerlink" title="八 ThreadLocal类"></a>八 ThreadLocal类</h3><p>在处理多线程并发问题上还有一个解决方案，是使用ThreadLocal类将需要并发的资源封装起来，这样当多个线程并发访问这些资源时，ThreadLocal类会为没一个线程均复制一份该资源的副本，从根本上解决了资源的共享冲突问题。但是此方式虽解决了冲突，但多个线程之间也无法共享资源。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/03/16/Java基础之线程/" data-id="cj0t8onj40007ponzg8yzyg38" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程/">线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础之集合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/13/Java基础之集合/" class="article-date">
  <time datetime="2017-03-13T08:42:33.000Z" itemprop="datePublished">2017-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/13/Java基础之集合/">Java基础之集合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>为了保存数量不确定的数据，以及具有映射关心的数据（也被称为关联数组），java从1.2开始提供了集合类。集合与数组不同，数组必须保存有确定数目的数据，且数组即可以保存基本数据也可以保存对象，而集合只能保存对象。集合类主要负责保存，盛装其他数据，因此集合类也被称作容器类。所有的集合都保存在java.util包下，从java1.5开始还在java.util.concurrent下提供了一下线程安全的集合类。</p>
<p>java中的集合类主要由两个接口派生而出：Collection和Map，它们是java集合框架的根接口。其继承结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Collection</div><div class="line">├List</div><div class="line">│├LinkedList</div><div class="line">│├ArrayList</div><div class="line">│└Vector</div><div class="line">│　└Stack</div><div class="line">├Queue</div><div class="line">└Set</div><div class="line">Map</div><div class="line">├Hashtable</div><div class="line">├HashMap</div><div class="line">└WeakHashMap</div></pre></td></tr></table></figure>
<h3 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h3><p>Collection是List，Set，Queue的父接口，因此在Collection中定义的接口在List，Set，Queue中均可使用。对集合的操作除了添加和删除之外，还有一个重要的操作就是遍历集合。下面来看一下集合中多种多样的遍历方法：</p>
<h5 id="1-使用Iterator遍历集合（推荐方法）"><a href="#1-使用Iterator遍历集合（推荐方法）" class="headerlink" title="1.使用Iterator遍历集合（推荐方法）"></a>1.使用Iterator遍历集合（推荐方法）</h5><p>使用Iterator遍历集合是集合遍历的传统方法，也是推荐方法。Iterator也是java集合框架中的一员，但是它不是用来盛装数据，它的作用主要就是用来遍历（迭代访问）Collection中的元素。我们可以通过Collection下的iterator()来获得这个集合的迭代器对象，并使用它的方法对集合进行遍历。Iterator中包含以下方法:</p>
<ul>
<li>boolean hasNext()<br>判断集合中的元素是否已遍历完，返回true，则还没遍历完</li>
<li>E next()<br>获取集合中的下一个元素</li>
<li>void remove()<br>删除集合中上一次next方法返回的元素</li>
<li>void forEachRemaining(Consumer action)<br>Java8新增的方法，可使用Lambda表达式遍历集合</li>
</ul>
<p>Iterator遍历集合代码示例：</p>
<h5 id="2-使用foreach循环迭代集合"><a href="#2-使用foreach循环迭代集合" class="headerlink" title="2.使用foreach循环迭代集合"></a>2.使用foreach循环迭代集合</h5><p>这是Java5新增的用于变异集合和数组的循环。</p>
<p>foreach遍历集合代码示例：</p>
<h5 id="3-使用Lambda表达式遍历集合"><a href="#3-使用Lambda表达式遍历集合" class="headerlink" title="3.使用Lambda表达式遍历集合"></a>3.使用Lambda表达式遍历集合</h5><p>Java从Java8开始新增Lambda表达式，在很多方面都简化了操作。在遍历集合方面就可以使用Lambda表达式，如：</p>
<ul>
<li><p>forEach(Consumer action)<br>Java8在Iterable接口中增加了一个forEach(Consumer action)方法，该方法的参数类型是一个函数式接口。而Iterable接口时Collection接口的父接口，因此可使用该方法遍历集合。</p>
</li>
<li><p>forEachRemaining(Consumer action)<br>Java8中为Iterator新增的方法，可用于遍历集合。</p>
</li>
</ul>
<p>同时我们还可以用Lambda表达式对集合进行其他的操作，比如：</p>
<p>Java8中为Collection新增了一个removeIf（Predicate filter）方法，Predicate也是函数式接口，可用它来过滤集合。</p>
<p>Java8中新增了Stream，IntStream，LongStream，DoubleStream等流式API，这些API中有大量的聚集函数，如求和，去平均值等。而Collection中亦提供了一个stream()，可返回该集合对应的流，然后再通过这些流式API操作集合。</p>
<h3 id="二-List"><a href="#二-List" class="headerlink" title="二 List"></a>二 List</h3><p>List是一个有序的，可重复的集合。List默认以元素的添加顺序来设置元素的索引（从0开始），因此可以通过索引来查找元素，也因此List允许重复的元素（不会无法分辨这两个元素）。</p>
<p>由于存在索引，List可以通过普通的for来迭代，同事List继承于Collection，可以使用Collection中的方法，同事它还有一个额外的方法listIterator用于List的迭代。</p>
<h5 id="1-ArrayList与Vector"><a href="#1-ArrayList与Vector" class="headerlink" title="1. ArrayList与Vector"></a>1. ArrayList与Vector</h5><p>ArrayList和Vector均是基于数组实现的List集合类，皆继承于List。它们的内部封装了一个动态的，允许再分配的Object[]数组，并使用initialCapacity参数来设置数组的长度（initialCapacity参数可以随着元素的增多而自动增长，默认是10），可通过ensureCapacity（int minCapacity）来一次性设置数组的initialCapacity值，减少重新分配内存的次数，提高性能。</p>
<p>Vector是一种古老的集合类，里面有一些命名很长的方法，现在已不推荐使用。它与ArrayList不同的是，它是线程安全的，而ArrayList不是。</p>
<p>Vector还有一个子类Stack，用于模拟栈这种数据结构，它也是线程安全的。但Stack也是一个古老的类，现已不推荐使用，要模拟栈可使用下文中ArrayDeque。</p>
<ul>
<li>固定长度的ArrayList<br>Java中有一个操作数组的工具类：Arrays，这个类中有一个方法asList可以将数组转换为一个List集合，但是这个ArrayList与上述介绍的不同，它不是继承于List，而是Arrays的内部类，这个集合只能遍历，而不能插入，删除。因此不推荐使用该方法将一个数组转换为集合。</li>
</ul>
<h5 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2. LinkedList"></a>2. LinkedList</h5><p>LinkedList也是List的实现类，但它同时还实现了Deque接口，提供额外的get，remove，insert方法在LinkedList的尾部和首部操作数据，因此LinkedList也可以被用作队列，双端队列，栈来使用。</p>
<p>LinkedList底层是用链表实现的，因此的它的访问性能较差，但插入、删除性能较好。一般迭代LinkedList时需要使用迭代器Iterator，而迭代ArrayList使用普通的for循环即可。</p>
<h3 id="三-Set"><a href="#三-Set" class="headerlink" title="三 Set"></a>三 Set</h3><p>Set集合是无序集合。它就像一个罐子，无法记住元素的添加顺序。通时它也不允许出现重复元素（因为Set是无序的，若出现重复元素，则无法区分），若试图将两个相同的元素添加到一个Set中，则添加操作失败，add()方法返回false，元素不会被加入。常见的Set有HashSet，TreeSet，EnumSet，它们均继承于Set。</p>
<h5 id="1-HashSet"><a href="#1-HashSet" class="headerlink" title="1. HashSet"></a>1. HashSet</h5><p>HashSet继承于Set，因此它具有Set的所有特点。同时它是通过Hash算法来计算元素的存储位置，具有很好的存取和查找性能。因为集合中只能存放对象，因此它们的存储位置实际上是通过对象的hashCode方法得到的。</p>
<p>但是HashSet的判重和Set的不同，Set判重是通过equals()方法比较两个元素的值是否相同，HashSet的判重不只用equals比较两个元素的值，还比较这两个对象hashCode方法的返回值是否相等。只有这两者都满足，HashSet才会判断这两个元素重复。如果equals满足二hashCode不满足，则HashSet会在两个不同的hashCode位置存放这两个对象，而不会判定其重复；如果equals不满足而hashCode满足，则两个元素会被计算到同一个存储位置，此时该位置则采取链式结构来存放这两个元素。此时会严重影响HashSet的性能。</p>
<p>因此，如果我们要重写该对象对应类的equals方法，则也应该重写它的hashCode方法，使得：如果两个对象通过equals方法返回为true，则他们的hashCode返回值也应该相同。</p>
<h5 id="2-LinkedHashSet"><a href="#2-LinkedHashSet" class="headerlink" title="2. LinkedHashSet"></a>2. LinkedHashSet</h5><p>LinkedHashSet继承于HashSet，它与HashSet的不同之处在于它以链表来维持元素的插入次序。即当遍历LinkedHashSet时，它会按照元素的添加顺序来访问集合里的元素。</p>
<p>因为LinkedHashSet要维护元素的插入顺序，因此它的性能要低于HashSet,但是当迭代访问集合里的全部元素时它有很好的性能。</p>
<h5 id="3-TreeSet"><a href="#3-TreeSet" class="headerlink" title="3. TreeSet"></a>3. TreeSet</h5><p>TreeSet是SortedSet的实现类（SortedSet是Set的子接口），它的底层实现是红黑树，可以确保集合中的元素一直处于排序状态。TreeSet中的排序分为自然排序和定制排序。</p>
<p>自然排序默认是升序，这也是TreeSet默认的排序方式。这种方式TreeSet中的元素要实现Comparable接口，并重写它的compareTo()方法，TreeSet在放入元素时会自动调用该元素中compareTo方法与集合中的元素比较大小。同时TreeSet中亦不允许重复元素，因此当compareTo返回0时，元素不会被放入集合中（返回正整数则说明a大约b，负整数则相反）。<br>应当注意：当把一个对象放入TreeSet中时，应当保证该对象的equals方法与compareTo方法得到的结果一致，即若equals方法返回true，则compareTo方法应当返回0。</p>
<p>定制排序：要实现定制排序，如降序排列，需要在创建TreeSet时传入一个Comparator对象负责集合元素的排序逻辑，由于Comparator也是函数式接口，因此可以使用Lambda表达式来代替Comparator对象。</p>
<h5 id="4-EnumSet"><a href="#4-EnumSet" class="headerlink" title="4. EnumSet"></a>4. EnumSet</h5><p>EnumSet是一个专门为枚举类设计的集合，其中的元素必须是指定枚举类型的枚举值。EnumSet集合是有序的，它安枚举类中枚举值的定义顺序来决定集合的元素顺序。EnumSet没有暴露任何构造器（即没有公有的构造器），要创建EnumSet需要调用它的类方法（静态方法）。</p>
<p>EnumSet在内部以位向量的方式存储，这种存储方式非常紧凑，高效，占用内存小，运行效率高。</p>
<h5 id="5-各Set实现类的性能分析"><a href="#5-各Set实现类的性能分析" class="headerlink" title="5. 各Set实现类的性能分析"></a>5. 各Set实现类的性能分析</h5><ul>
<li>HashSet和TreeSet是常用实现，HashSet的性能要比TreeSet好一些，因为TreeSet需要额外的红黑树来维持元素的次序。</li>
</ul>
<ul>
<li><p>LinkedHashSet与HashSet相比，在插入、删除方面，HashSet要快一些；但是在遍历时，LinkedHashSet要更快。</p>
</li>
<li><p>EnumSet是所有Set实现类中性能最好的，但它功能有限，只能保存同一个枚举类的枚举值作为集合元素。</p>
</li>
</ul>
<h3 id="四-Queue"><a href="#四-Queue" class="headerlink" title="四 Queue"></a>四 Queue</h3><p>Queue集合用于模拟队列这种数据结构，队列是先进先出（FIFO）的，头部保存存放时间最长的元素，尾部保存存放时间最短的元素，队尾插入，队首出。Queue还有一个子接口Deque，Deque表示一个双端队列，因此既可以模拟队列也可以模拟栈。Deque有ArrayDeque和LinkedList两个实现类。</p>
<h5 id="1-PriorityQueue"><a href="#1-PriorityQueue" class="headerlink" title="1. PriorityQueue"></a>1. PriorityQueue</h5><p>PriorityQueue并不是严格的队列。它的队列中的元素的顺序并不是按插入队列的顺序，而是按照队列中元素的大小排序。PriorityQueue有两种排序方式：自然排序和定制排序。这点和TreeSet基本一致，可参考上文中TreeSet的简介。</p>
<h5 id="2-Deque和ArrayDeque"><a href="#2-Deque和ArrayDeque" class="headerlink" title="2. Deque和ArrayDeque"></a>2. Deque和ArrayDeque</h5><p>上文已经介绍了Deque，它是Queue的子接口，是一个双端队列，里面定义一些可以在队尾和队首操作元素的方法，因此它既可以模拟栈，也可以模拟队列。它主要有两个实现类：ArrayDeque和LinkedList。</p>
<p>ArrayDeque底层结构和ArrayList类似，一般用它来模拟栈，而不用Stack。</p>
<h3 id="五-Map"><a href="#五-Map" class="headerlink" title="五 Map"></a>五 Map</h3><p>Map是一个key-value键值对。它的每个单元包含key和value两个数据，由key可以找到value。key可以为空但不可重复，其实将它们分开来看，key就是一个Set集合，而value可以看做List，事实上Map中也有相应的方法。可以把Map看做value均为空的Set，事实上要想遍历Map，就需要获取key的Set集合。</p>
<h5 id="1-HashMap和HashTable"><a href="#1-HashMap和HashTable" class="headerlink" title="1. HashMap和HashTable"></a>1. HashMap和HashTable</h5><p>HashMap和Hashtable均为Map接口的实现类，它们之间的关系类似于ArrayList和Vector的关系。Hashtable是一个古老的实现类，现在已不推荐使用。</p>
<p>HashMap和Hashtable有两点区别：</p>
<ul>
<li>Hashtable是线程安全的，而HashMap不是</li>
<li>Hashtable中的key和value均不能为空，而HashMap的可以</li>
</ul>
<p>同时放入key中的对象需要被hash，所以key中的元素均要实现equals和hashCode方法，且二者结果应当一致，即若equals结果为true，则这两个元素的hashCode值也要相等。（与HashSet相同，Java的要hash类均要实现hashCode方法）。</p>
<h5 id="2-LinkedHashMap"><a href="#2-LinkedHashMap" class="headerlink" title="2. LinkedHashMap"></a>2. LinkedHashMap</h5><p>LinkedHashMap是HashMap的子类，这俩的关系就像LinkedHashSet和HashSet的关系。使用一个链表来维持key的插入顺序。因此你可以在外部对元素排好序，然后让其顺序进入集合，就可以得到一个有序的HashMap，而不需要再对其进行排序。</p>
<h5 id="3-Properties"><a href="#3-Properties" class="headerlink" title="3. Properties"></a>3. Properties</h5><p>Properties是Hashtable的子类，也是一个古老的集合类，该类在处理属性文件是特别方便（属性文件即“属性名=属性值”的文件，如Windows上的ini文件）。可以把Properties看做一个key和value均为String的Map。该类可以与XML文件交互。</p>
<h5 id="4-SortedMap和TreeMap"><a href="#4-SortedMap和TreeMap" class="headerlink" title="4. SortedMap和TreeMap"></a>4. SortedMap和TreeMap</h5><p>TreeMap,SortedMap和Map的关心可以参照Set。TreeMap的实现与TreeSet类似，只是其中的元素换成了键值对，而所有对Set中元素的约束在TreeMap中均换成对key的约束。事实上在Java源码中Set的实现即是通过value均为null的Map完成的，所有Java中的Set和Map有很多相通之处。</p>
<h5 id="5-WeakHashMap"><a href="#5-WeakHashMap" class="headerlink" title="5. WeakHashMap"></a>5. WeakHashMap</h5><p>WeakHashMap即是key是弱引用的HashMap。若key被回收，则WeakHashMap会自动删除对应的key-value键值对。可使用它来做缓存。</p>
<h5 id="6-IdentityHashMap"><a href="#6-IdentityHashMap" class="headerlink" title="6. IdentityHashMap"></a>6. IdentityHashMap</h5><p>IdentityHashMap与HashMap不同处在于：IdentityHashMap在处理key相等问题的方式是使用“==”，而不是equals。</p>
<h5 id="7-EnumMap"><a href="#7-EnumMap" class="headerlink" title="7. EnumMap"></a>7. EnumMap</h5><p>EnumMap是使用枚举类实现的Map，它的key是枚举类中的枚举值，创建它时必须传入一个枚举类（类的class对象）。它有以下几个特点：</p>
<ul>
<li>内部以数组形式保存，紧凑，高效。</li>
<li>以枚举类中枚举值的定义顺序来维持key的顺序</li>
<li>key不能为空</li>
</ul>
<h3 id="六-线程安全的集合类"><a href="#六-线程安全的集合类" class="headerlink" title="六 线程安全的集合类"></a>六 线程安全的集合类</h3><h5 id="1-集合工具类Collections"><a href="#1-集合工具类Collections" class="headerlink" title="1. 集合工具类Collections"></a>1. 集合工具类Collections</h5><p>Java提供了一个操作集合的工具类：Collections，里面提供了大量的类方法用于对集合元素进行排序，查询，修改，同步，设置集合不可变等。（工具类中一般都是类方法，即静态方法）。</p>
<p>其中就有一种synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从而解决了多线程并发访问集合时的线程安全问题。读者可以通过查看Collections的源码来了解它的用法。</p>
<h5 id="2-线程安全的集合类"><a href="#2-线程安全的集合类" class="headerlink" title="2. 线程安全的集合类"></a>2. 线程安全的集合类</h5><p>从Java5开始，Java在java.util.concurrent包下面提供了大量线程安全的集合类，主要可分为以下两类：</p>
<ul>
<li><p>以Concurrent开头的集合类<br>如ConcurrentHashMap，ConcurrentSkipListMap，ConcurrentSkipListSet，ConcurrentLinkedQueue，ConcurrentLinkedDeque等</p>
</li>
<li><p>以CopyOnWrite开头的集合类<br>如CopyOnWriteArrayList，，CopyOnWriteArraySet等</p>
</li>
</ul>
<h3 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/03/13/Java基础之集合/" data-id="cj0t8onjn000jponzx4vzj9lz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/List/">List</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Map/">Map</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Set/">Set</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/集合/">集合</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android基础之消息推送" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/01/android基础之消息推送/" class="article-date">
  <time datetime="2017-03-01T06:28:10.000Z" itemprop="datePublished">2017-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/01/android基础之消息推送/">android基础之消息推送</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>消息推送现在是需要与服务器进行通信的app的基本需求，因此我们有必要了解一下android消息推送的机制。</p>
<h3 id="二-几种常见的消息推送的方案"><a href="#二-几种常见的消息推送的方案" class="headerlink" title="二 几种常见的消息推送的方案"></a>二 几种常见的消息推送的方案</h3><ul>
<li><p>轮询(Pull)方式：<br>应用程序应当阶段性的与服务器进行连接并查询是否有新的消息到达，你必须自己实现与服务器之间的通信，例如消息排队等。而且你还要考虑轮询的频率，如果太慢可能导致某些消息的延迟，如果太快，则会大量消耗网络带宽和电池。</p>
</li>
<li><p>SMS(Push)方式：<br>在Android平台上，你可以通过拦截SMS消息并且解析消息内容来了解服务器的意图，并获取其显示内容进行处理。但是这种方法需要向移动公司缴纳相应的费用。我们目前很难找到免费的短消息发送网关来实现这种方案。</p>
</li>
<li><p>长连接(Push)方式：<br>这个方案是现在使用较多的方案。下面主要介绍pull和这种消息推送的方案。</p>
</li>
</ul>
<h3 id="三-轮询（pull）原理介绍"><a href="#三-轮询（pull）原理介绍" class="headerlink" title="三 轮询（pull）原理介绍"></a>三 轮询（pull）原理介绍</h3><h5 id="1-原理（即是一个http请求）"><a href="#1-原理（即是一个http请求）" class="headerlink" title="1. 原理（即是一个http请求）"></a>1. 原理（即是一个http请求）</h5><p>其原理在于在android端的程序中，让一个SERVICE一直跑在后台，在规定时间之内调用服务器接口进行数据获取。这里的原理很简单，当然实现起来也不难；然后，这个类之中肯定要做网络数据请求，所以我们在Service中建立一个线程（因为在android系统中网络请求属于长时间操作，不能放主线程，不然会导致异常），在线程中和服务器进行通信。</p>
<p>最后，这个逻辑写完后，我们需要考虑一个问题，如何进行在规定时间内调用该服务器，当然可以用Thread+Handler(这个不是那么稳定),也可以使用AlamManager+Thread（比较稳定），因为我们需要其在后台一直运行，所以可以依靠系统的Alammanager这个类来实现，Alammanager是属于系统的一个闹钟提醒类，通过它我们能实现在规定间隔时间调用，并且也比较稳定，这个service被杀后会自己自动启动服务。</p>
<h5 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2. 代码示例"></a>2. 代码示例</h5><h3 id="四-android长连接（push）消息推送"><a href="#四-android长连接（push）消息推送" class="headerlink" title="四 android长连接（push）消息推送"></a>四 android长连接（push）消息推送</h3><h5 id="1-心跳包机制"><a href="#1-心跳包机制" class="headerlink" title="1. 心跳包机制"></a>1. 心跳包机制</h5><p>所谓的心跳包就是客户端定时放送简单的信息给服务器端，告诉它我还在而已。代码就是每隔几分钟发送一个固定信息给服务器端，服务器端回复一个固定信息。如果服务器端几分钟后没有收到客户端信息则视客户端断开。比如有些通信软件长时间不适用，要想知道它的状态是在线还是离线，就需要心跳包，定时发包收包。　 　</p>
<p>心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活在。事实上这是为了保活长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。 </p>
<p>在TCP机制里面，本身是存在有心跳包机制的，也就是TCP选项:SO_KEEPALIVE. 系统默认是设置的2小时的心跳频率。</p>
<h5 id="2-android系统的推送和iOS的推送的区别"><a href="#2-android系统的推送和iOS的推送的区别" class="headerlink" title="2.android系统的推送和iOS的推送的区别"></a>2.android系统的推送和iOS的推送的区别</h5><p>IOS长连接是由系统来维护的，也就是说苹果的IOS系统在系统级别维护了一个客户端和苹果服务器的长链接，IOS上的所有应用上的推送都是先将消息推送到苹果的服务器然后将苹果服务器通过这个系统级别的长链接推送到手机终端上，这样的的几个好处为：</p>
<ul>
<li>在手机终端始终只要维护一个长连接即可，而且由于这个长链接是系统级别的不会出现被杀死而无法推送的情况　</li>
<li>省电，不会出现每个应用都各自维护一个自己的长连接。</li>
<li>安全，只有在苹果注册的开发者才能够进行推送，等等。　</li>
</ul>
<p>android的长连接是由每个应用各自维护的，但是google也推出了和苹果技术架构相似的推送框架，C2DM,云端推送功能，但是由于google的服务器不在中国境内，其他的原因你懂的。所以导致这个推送无法使用，android的开发者不得不自己去维护一个长链接，于是每个应用如果都24小时在线，那么都得各自维护一个长连接，这种电量和流量的消耗是可想而知的。虽然国内也出现了各种推送平台，但是都无法达到只维护一个长连接这种消耗的级别。　</p>
<h5 id="3-几种基于长连接的消息推送方案"><a href="#3-几种基于长连接的消息推送方案" class="headerlink" title="3.几种基于长连接的消息推送方案"></a>3.几种基于长连接的消息推送方案</h5><ul>
<li>C2DM云端推送功能。</li>
<li>MQTT协议实现Android推送功能。</li>
<li>RSMB实现推送功能。</li>
<li>XMPP协议实现Android推送功能</li>
<li>使用第三方平台。如极光推送</li>
<li>自己搭</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/03/01/android基础之消息推送/" data-id="cj0t8onl3001yponzj6at0z74" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pull/">pull</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/push/">push</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/推送/">推送</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/长连接/">长连接</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android基础之事件分发机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/28/android基础之事件分发机制/" class="article-date">
  <time datetime="2017-02-28T10:25:28.000Z" itemprop="datePublished">2017-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/28/android基础之事件分发机制/">android基础之事件分发机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>在android开发中会经常遇到滑动冲突（比如ScrollView或是SliddingMenu与ListView的嵌套）的问题，需要我们深入的了解android事件响应机制才能解决，事件响应机制已经是android开发者必不可少的知识。</p>
<h3 id="二-涉及到事件响应的常用方法构成"><a href="#二-涉及到事件响应的常用方法构成" class="headerlink" title="二 涉及到事件响应的常用方法构成"></a>二 涉及到事件响应的常用方法构成</h3><p>用户在手指与屏幕接触过程中通过MotionEvent对象产生一系列事件，它有四种状态： </p>
<ul>
<li>MotionEvent.ACTION_DOWN　：手指按下屏幕的瞬间（一切事件的开始）</li>
<li>MotionEvent.ACTION_MOVE　：手指在屏幕上移动</li>
<li>MotionEvent.ACTION_UP　：手指离开屏幕瞬间</li>
<li>MotionEvent.ACTION_CANCEL 　：取消手势，一般由程序产生，不会由用户产生</li>
</ul>
<p>Android中的事件onClick, onLongClick，onScroll, onFling等等，都是由许多个Touch事件构成的（一个ACTION_DOWN， n个ACTION_MOVE，1个ACTION_UP）。</p>
<p>android 事件响应机制是先分发（先由外部的View接收，然后依次传递给其内层的最小View）再处理 （从最小View单元（事件源）开始依次向外层传递。）的形式实现的。</p>
<p>复杂性表现在：可以控制每层事件是否继续传递（分发和拦截协同实现），以及事件的具体消费（事件分发也具有事件消费能力）。</p>
<h3 id="三-android事件处理涉及到的三个重要函数"><a href="#三-android事件处理涉及到的三个重要函数" class="headerlink" title="三 android事件处理涉及到的三个重要函数"></a>三 android事件处理涉及到的三个重要函数</h3><h5 id="1-事件分发：public-boolean-dispatchTouchEvent-MotionEvent-ev"><a href="#1-事件分发：public-boolean-dispatchTouchEvent-MotionEvent-ev" class="headerlink" title="1.事件分发：public boolean dispatchTouchEvent(MotionEvent ev)"></a>1.事件分发：public boolean dispatchTouchEvent(MotionEvent ev)</h5><p>当有监听到事件时，首先由Activity进行捕获，进入事件分发处理流程。（因为activity没有事件拦截，View和ViewGroup有）会将事件传递给最外层View的dispatchTouchEvent(MotionEvent ev)方法，该方法对事件进行分发。 </p>
<ul>
<li><p>return true ：表示该View内部消化掉了所有事件。</p>
</li>
<li><p>return false ：事件在本层不再继续进行分发，并交由上层控件的onTouchEvent方法进行消费（如果本层控件已经是Activity，那么事件将被系统消费或处理）。　</p>
</li>
<li><p>如果事件分发返回系统默认的 super.dispatchTouchEvent(ev)，事件将分发给本层的事件拦截onInterceptTouchEvent 方法进行处理</p>
</li>
</ul>
<h5 id="2-事件拦截：public-boolean-onInterceptTouchEvent-MotionEvent-ev"><a href="#2-事件拦截：public-boolean-onInterceptTouchEvent-MotionEvent-ev" class="headerlink" title="2.事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)"></a>2.事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)</h5><ul>
<li><p>return true ：表示将事件进行拦截，并将拦截到的事件交由本层控件 的 onTouchEvent 进行处理；</p>
</li>
<li><p>return false ：则表示不对事件进行拦截，事件得以成功分发到子View。并由子View的dispatchTouchEvent进行处理。　</p>
</li>
<li><p>如果返回super.onInterceptTouchEvent(ev)，默认表示拦截该事件，并将事件传递给当前View的onTouchEvent方法，和return true一样。</p>
</li>
</ul>
<h5 id="3-事件响应：public-boolean-onTouchEvent-MotionEvent-ev"><a href="#3-事件响应：public-boolean-onTouchEvent-MotionEvent-ev" class="headerlink" title="3.事件响应：public boolean onTouchEvent(MotionEvent ev)"></a>3.事件响应：public boolean onTouchEvent(MotionEvent ev)</h5><p>在dispatchTouchEvent（事件分发）返回super.dispatchTouchEvent(ev)并且onInterceptTouchEvent（事件拦截返回true或super.onInterceptTouchEvent(ev)的情况下，那么事件会传递到onTouchEvent方法，该方法对事件进行响应。</p>
<ul>
<li><p>如果return true，表示onTouchEvent处理完事件后消费了此次事件。此时事件终结；</p>
</li>
<li><p>如果return fasle，则表示不响应事件，那么该事件将会不断向上层View的onTouchEvent方法传递，直到某个View的onTouchEvent方法返回true，如果到了最顶层View还是返回false，那么认为该事件不消耗，则在同一个事件系列中，当前View无法再次接收到事件，该事件会交由Activity的onTouchEvent进行处理；　　</p>
</li>
<li><p>如果return super.dispatchTouchEvent(ev)，则表示不响应事件，结果与return false一样。</p>
</li>
</ul>
<p>从以上过程中可以看出，dispatchTouchEvent无论返回true还是false，事件都不再进行分发，只有当其返回super.dispatchTouchEvent(ev)，才表明其具有向下层分发的愿望，但是是否能够分发成功，则需要经过事件拦截onInterceptTouchEvent的审核。事件是否向上传递处理是由onTouchEvent的返回值决定的。</p>
<p>下面是Touch事件传递机制流程图：</p>
<img src="/2017/02/28/android基础之事件分发机制/Touch事件分发机制流程图.png" alt="Touch事件分发机制流程图" title="Touch事件分发机制流程图">
<h3 id="四-View源码分析"><a href="#四-View源码分析" class="headerlink" title="四 View源码分析"></a>四 View源码分析</h3><p>Android中ImageView、textView、Button等继承于View但没有重写的dispatchTouchEvent方法，所以都用的View的该方法进行事件分发。</p>
<p>看View重要函数部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line"><span class="comment">//返回true,表示该View内部消化掉了所有事件。返回false，表示View内部只处理了ACTION_DOWN事件，事件继续传递，向上级View(ViewGroup)传递。</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mOnTouchListener != <span class="keyword">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;</div><div class="line">            mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</div><div class="line">  <span class="comment">//此处的onTouch方式就是回调的我们注册OnTouchListener时重写的onTouch()方法</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> onTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先进行三个条件的判断：</p>
<ul>
<li>查看是否给button设置了OnTouchListener()事件；</li>
<li>控件是否Enable；（控件默认都是enable的）</li>
<li>button里面实现的OnTouchListener监听里的onTouch()方法是否返回true；</li>
</ul>
<p>如果条件都满足，则该事件被消耗掉，不再进入onTouchEvent中处理。否则将事件将交给onTouchEvent方法处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">   /＊ 当前onTouch的组件必须是可点击的比如Button，ImageButton等等，此处CLICKABLE为<span class="keyword">true</span>，才会进入<span class="keyword">if</span>方法，最后返回<span class="keyword">true</span>。</div><div class="line"> 如果是ImageView、TexitView这些默认为不可点击的View,此处CLICKABLE为<span class="keyword">false</span>，最后返回<span class="keyword">false</span>。当然会有特殊情况，如果给这些View设置了onClick监听器，此处CLICKABLE也将为<span class="keyword">true</span>　　＊／</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  </div><div class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;</div><div class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">                ...</div><div class="line">                            <span class="keyword">if</span> (!post(mPerformClick)) &#123;</div><div class="line">                                performClick();<span class="comment">// 实际就是回调了我们注册的OnClickListener中重新的onClick()方法</span></div><div class="line">                            &#125;</div><div class="line">                 ...</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">               ...</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</div><div class="line">                ...</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">               ...</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</div><div class="line">    ...</div><div class="line"> ／／</div><div class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</div><div class="line">        ...</div><div class="line">        li.mOnClickListener.onClick(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(OnClickListener l)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!isClickable()) &#123;</div><div class="line">        setClickable(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    getListenerInfo().mOnClickListener = l;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只有我们注册OnTouchListener时重写的 onTouch()方法中:</p>
<ul>
<li>返回false —&gt; 执行onTouchEvent方法 —&gt; 导致onClick()回调方法执行　</li>
<li>返回true —&gt; onTouchEvent方法不执行 —&gt; 导致onClick()回调方法不会执行</li>
</ul>
<h3 id="五-ViewGroup源码分析"><a href="#五-ViewGroup源码分析" class="headerlink" title="五 ViewGroup源码分析"></a>五 ViewGroup源码分析</h3><p>Android中诸如LinearLayout等的五大布局控件，都是继承自ViewGroup，而ViewGroup本身是继承自View，所以ViewGroup的事件处理机制对这些控件都有效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;  </div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();  </div><div class="line">       <span class="keyword">final</span> <span class="keyword">float</span> xf = ev.getX();  </div><div class="line">       <span class="keyword">final</span> <span class="keyword">float</span> yf = ev.getY();  </div><div class="line">       <span class="keyword">final</span> <span class="keyword">float</span> scrolledXFloat = xf + mScrollX;  </div><div class="line">       <span class="keyword">final</span> <span class="keyword">float</span> scrolledYFloat = yf + mScrollY;  </div><div class="line">       <span class="keyword">final</span> Rect frame = mTempRect;  </div><div class="line"></div><div class="line">       <span class="comment">//这个值默认是false, 然后我们可以通过requestDisallowInterceptTouchEvent(boolean disallowIntercept)方法  </span></div><div class="line">       <span class="comment">//来改变disallowIntercept的值  </span></div><div class="line">       <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;  </div><div class="line"></div><div class="line">       <span class="comment">//这里是ACTION_DOWN的处理逻辑  </span></div><div class="line">       <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;  </div><div class="line">        <span class="comment">//清除mMotionTarget, 每次ACTION_DOWN都很设置mMotionTarget为null  </span></div><div class="line">           <span class="keyword">if</span> (mMotionTarget != <span class="keyword">null</span>) &#123;  </div><div class="line">               mMotionTarget = <span class="keyword">null</span>;  </div><div class="line">           &#125;  </div><div class="line"></div><div class="line">           <span class="comment">//disallowIntercept默认是false, 就看ViewGroup的onInterceptTouchEvent()方法  </span></div><div class="line">           <span class="keyword">if</span> (disallowIntercept || !onInterceptTouchEvent(ev)) &#123;  <span class="comment">//第一点</span></div><div class="line">               ev.setAction(MotionEvent.ACTION_DOWN);  </div><div class="line">               <span class="keyword">final</span> <span class="keyword">int</span> scrolledXInt = (<span class="keyword">int</span>) scrolledXFloat;  </div><div class="line">               <span class="keyword">final</span> <span class="keyword">int</span> scrolledYInt = (<span class="keyword">int</span>) scrolledYFloat;  </div><div class="line">               <span class="keyword">final</span> View[] children = mChildren;  </div><div class="line">               <span class="keyword">final</span> <span class="keyword">int</span> count = mChildrenCount;  </div><div class="line">               <span class="comment">//遍历其子View  </span></div><div class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  <span class="comment">//第二点</span></div><div class="line">                   <span class="keyword">final</span> View child = children[i];  </div><div class="line"></div><div class="line">                   <span class="comment">//如果该子View是VISIBLE或者该子View正在执行动画, 表示该View才  </span></div><div class="line">                   <span class="comment">//可以接受到Touch事件  </span></div><div class="line">                   <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE  </div><div class="line">                           || child.getAnimation() != <span class="keyword">null</span>) &#123;  </div><div class="line">                    <span class="comment">//获取子View的位置范围  </span></div><div class="line">                       child.getHitRect(frame);  </div><div class="line"></div><div class="line">                       <span class="comment">//如Touch到屏幕上的点在该子View上面  </span></div><div class="line">                       <span class="keyword">if</span> (frame.contains(scrolledXInt, scrolledYInt)) &#123;  </div><div class="line">                           <span class="comment">// offset the event to the view's coordinate system  </span></div><div class="line">                           <span class="keyword">final</span> <span class="keyword">float</span> xc = scrolledXFloat - child.mLeft;  </div><div class="line">                           <span class="keyword">final</span> <span class="keyword">float</span> yc = scrolledYFloat - child.mTop;  </div><div class="line">                           ev.setLocation(xc, yc);  </div><div class="line">                           child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class="line"></div><div class="line">                           <span class="comment">//调用该子View的dispatchTouchEvent()方法  </span></div><div class="line">                           <span class="keyword">if</span> (child.dispatchTouchEvent(ev))  &#123;  </div><div class="line">                               <span class="comment">// 如果child.dispatchTouchEvent(ev)返回true表示  </span></div><div class="line">                            <span class="comment">//该事件被消费了，设置mMotionTarget为该子View  </span></div><div class="line">                               mMotionTarget = child;  </div><div class="line">                               <span class="comment">//直接返回true  </span></div><div class="line">                               <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">                           &#125;  </div><div class="line">                           <span class="comment">// The event didn't get handled, try the next view.  </span></div><div class="line">                           <span class="comment">// Don't reset the event's location, it's not  </span></div><div class="line">                           <span class="comment">// necessary here.  </span></div><div class="line">                       &#125;  </div><div class="line">                   &#125;  </div><div class="line">               &#125;  </div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line"></div><div class="line">       <span class="comment">//判断是否为ACTION_UP或者ACTION_CANCEL  </span></div><div class="line">       <span class="keyword">boolean</span> isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  </div><div class="line">               (action == MotionEvent.ACTION_CANCEL);  </div><div class="line"></div><div class="line">       <span class="keyword">if</span> (isUpOrCancel) &#123;  </div><div class="line">           <span class="comment">//如果是ACTION_UP或者ACTION_CANCEL, 将disallowIntercept设置为默认的false  </span></div><div class="line">        <span class="comment">//假如我们调用了requestDisallowInterceptTouchEvent()方法来设置disallowIntercept为true  </span></div><div class="line">        <span class="comment">//当我们抬起手指或者取消Touch事件的时候要将disallowIntercept重置为false  </span></div><div class="line">        <span class="comment">//所以说上面的disallowIntercept默认在我们每次ACTION_DOWN的时候都是false  </span></div><div class="line">           mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;  </div><div class="line">       &#125;  </div><div class="line"></div><div class="line">       <span class="comment">// The event wasn't an ACTION_DOWN, dispatch it to our target if  </span></div><div class="line">       <span class="comment">// we have one.  </span></div><div class="line">       <span class="keyword">final</span> View target = mMotionTarget;  </div><div class="line">       <span class="comment">//mMotionTarget为null意味着没有找到消费Touch事件的View, 所以我们需要调用ViewGroup父类的  </span></div><div class="line">       <span class="comment">//dispatchTouchEvent()方法，也就是View的dispatchTouchEvent()方法  </span></div><div class="line">       <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;  </div><div class="line">           <span class="comment">// We don't have a target, this means we're handling the  </span></div><div class="line">           <span class="comment">// event as a regular view.  </span></div><div class="line">           ev.setLocation(xf, yf);  </div><div class="line">           <span class="keyword">if</span> ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != <span class="number">0</span>) &#123;  </div><div class="line">               ev.setAction(MotionEvent.ACTION_CANCEL);  </div><div class="line">               mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class="line">           &#125;  </div><div class="line">           <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);  </div><div class="line">       &#125;  </div><div class="line"></div><div class="line">       <span class="comment">//这个if里面的代码ACTION_DOWN不会执行，只有ACTION_MOVE  </span></div><div class="line">       <span class="comment">//ACTION_UP才会走到这里, 假如在ACTION_MOVE或者ACTION_UP拦截的  </span></div><div class="line">       <span class="comment">//Touch事件, 将ACTION_CANCEL派发给target，然后直接返回true  </span></div><div class="line">       <span class="comment">//表示消费了此Touch事件  </span></div><div class="line">       <span class="keyword">if</span> (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) &#123;  </div><div class="line">           <span class="keyword">final</span> <span class="keyword">float</span> xc = scrolledXFloat - (<span class="keyword">float</span>) target.mLeft;  </div><div class="line">           <span class="keyword">final</span> <span class="keyword">float</span> yc = scrolledYFloat - (<span class="keyword">float</span>) target.mTop;  </div><div class="line">           mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class="line">           ev.setAction(MotionEvent.ACTION_CANCEL);  </div><div class="line">           ev.setLocation(xc, yc);  </div><div class="line"></div><div class="line">           <span class="keyword">if</span> (!target.dispatchTouchEvent(ev)) &#123;  </div><div class="line">           &#125;  </div><div class="line">           <span class="comment">// clear the target  </span></div><div class="line">           mMotionTarget = <span class="keyword">null</span>;  </div><div class="line">           <span class="comment">// Don't dispatch this event to our own view, because we already  </span></div><div class="line">           <span class="comment">// saw it when intercepting; we just want to give the following  </span></div><div class="line">           <span class="comment">// event to the normal onTouchEvent().  </span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">       &#125;  </div><div class="line"></div><div class="line">       <span class="keyword">if</span> (isUpOrCancel) &#123;  </div><div class="line">           mMotionTarget = <span class="keyword">null</span>;  </div><div class="line">       &#125;  </div><div class="line"></div><div class="line">       <span class="comment">// finally offset the event to the target's coordinate system and  </span></div><div class="line">       <span class="comment">// dispatch the event.  </span></div><div class="line">       <span class="keyword">final</span> <span class="keyword">float</span> xc = scrolledXFloat - (<span class="keyword">float</span>) target.mLeft;  </div><div class="line">       <span class="keyword">final</span> <span class="keyword">float</span> yc = scrolledYFloat - (<span class="keyword">float</span>) target.mTop;  </div><div class="line">       ev.setLocation(xc, yc);  </div><div class="line"></div><div class="line">       <span class="keyword">if</span> ((target.mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != <span class="number">0</span>) &#123;  </div><div class="line">           ev.setAction(MotionEvent.ACTION_CANCEL);  </div><div class="line">           target.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class="line">           mMotionTarget = <span class="keyword">null</span>;  </div><div class="line">       &#125;  </div><div class="line"></div><div class="line">       <span class="comment">//如果没有拦截ACTION_MOVE, ACTION_DOWN的话，直接将Touch事件派发给target  </span></div><div class="line">       <span class="keyword">return</span> target.dispatchTouchEvent(ev);  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>dispatchTouchEvent作用：决定事件是否由onInterceptTouchEvent来拦截处理。 返回super.dispatchTouchEvent时，由onInterceptTouchEvent来决定事件的流向 返回false时，会继续分发事件，自己内部只处理了ACTION_DOWN 返回true时，不会继续分发事件，自己内部处理了所有事件（ACTION_DOWN,ACTION_MOVE,ACTION_UP）</p>
</li>
<li><p>onInterceptTouchEvent作用：拦截事件，用来决定事件是否传向子View 返回true时，拦截后交给自己的onTouchEvent处理 返回false时，拦截后交给子View来处理</p>
</li>
<li><p>onTouchEvent作用：事件最终到达这个方法 返回true时，内部处理所有的事件，换句话说，后续事件将继续传递给该view的onTouchEvent()处理 返回false时，事件会向上传递，由onToucEvent来接受，如果最上面View中的onTouchEvent也返回false的话，那么事件就会消失</p>
</li>
</ul>
<h3 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h3><ul>
<li><p>如果ViewGroup找到了能够处理该事件的View，则直接交给子View处理，自己的onTouchEvent不会被触发；　</p>
</li>
<li><p>可以通过复写onInterceptTouchEvent(ev)方法，拦截子View的事件（即return true），把事件交给自己处理，则会执行自己对应的onTouchEvent方法。</p>
</li>
<li><p>子View可以通过调用getParent().requestDisallowInterceptTouchEvent(true); 阻止ViewGroup对其MOVE或者UP事件进行拦截；　　</p>
</li>
<li><p>一个点击事件产生后，它的传递过程如下： Activity-&gt;Window-&gt;View。顶级View接收到事件之后，就会按相应规则去分发事件。如果一个View的onTouchEvent方法返回false，那么将会交给父容器的onTouchEvent方法进行处理，逐级往上，如果所有的View都不处理该事件，则交由Activity的onTouchEvent进行处理。　</p>
</li>
<li><p>如果某一个View开始处理事件，如果他不消耗ACTION_DOWN事件（也就是onTouchEvent返回false），则同一事件序列比如接下来进行ACTION_MOVE，则不会再交给该View处理。</p>
</li>
<li><p>ViewGroup默认不拦截任何事件。　</p>
</li>
<li><p>诸如TextView、ImageView这些不作为容器的View，一旦接受到事件，就调用onTouchEvent方法，它们本身没有onInterceptTouchEvent方法。正常情况下，它们都会消耗事件（返回true），除非它们是不可点击的（clickable和longClickable都为false），那么就会交由父容器的onTouchEvent处理。　</p>
</li>
<li><p>点击事件分发过程如下 dispatchTouchEvent—-&gt;OnTouchListener的onTouch方法—-&gt;onTouchEvent–&gt;OnClickListener的onClick方法。也就是说，我们平时调用的setOnClickListener，优先级是最低的，所以，onTouchEvent或OnTouchListener的onTouch方法如果返回true，则不响应onClick方法…</p>
</li>
</ul>
<img src="/2017/02/28/android基础之事件分发机制/android事件分发.png" alt="一个据说很牛的图" title="一个据说很牛的图">

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/02/28/android基础之事件分发机制/" data-id="cj0t8onkn0018ponzrnkq1839" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/View/">View</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/事件分发/">事件分发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android基础之SQLite" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/28/android基础之SQLite/" class="article-date">
  <time datetime="2017-02-28T10:03:32.000Z" itemprop="datePublished">2017-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/28/android基础之SQLite/">android基础之SQLite</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的SQL数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。从Android1.5开始，Android就自带SQLite数据库了。</p>
<h3 id="二-特性"><a href="#二-特性" class="headerlink" title="二 特性"></a>二 特性</h3><ol>
<li>ACID事务 　</li>
<li>零配置 – 无需安装和管理配置 </li>
<li>储存在单一磁盘文件中的一个完整的数据库</li>
<li>数据库文件可以在不同字节顺序的机器间自由的共享</li>
<li>支持数据库大小至2TB</li>
<li>足够小, 大致3万行C代码, 250K</li>
<li>比一些流行的数据库在大部分普通数据库操作要快</li>
<li>简单, 轻松的API</li>
<li>包含TCL绑定, 同时通过Wrapper支持其他语言的绑定</li>
<li>良好注释的源代码, 并且有着90%以上的测试覆盖率  </li>
<li>独立: 没有额外依赖</li>
<li>Source完全的Open, 你可以用于任何用途, 包括出售它</li>
<li>支持多种开发语言，C，PHP，Perl，Java，ASP.NET，Python　　</li>
</ol>
<h3 id="在Android中使用SQLite"><a href="#在Android中使用SQLite" class="headerlink" title="在Android中使用SQLite"></a>在Android中使用SQLite</h3><p>Activites 可以通过 Content Provider 或者 Service 访问一个数据库。</p>
<h5 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1.创建数据库"></a>1.创建数据库</h5><p>Android 不自动提供数据库。在 Android 应用程序中使用 SQLite，必须自己创建数据库，然后创建表、索引，填充数据。Android 提供了 SQLiteOpenHelper 帮助你创建一个数据库，你只要继承 SQLiteOpenHelper 类根据开发应用程序的需要，封装创建和更新数据库使用的逻辑就行了。　 </p>
<p>SQLiteOpenHelper 的子类，至少需要实现三个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> context  上下文环境（例如，一个 Activity）</div><div class="line">     * <span class="doctag">@param</span> name   数据库名字</div><div class="line">     * <span class="doctag">@param</span> factory  一个可选的游标工厂（通常是 Null）</div><div class="line">     * <span class="doctag">@param</span> version  数据库模型版本的整数</div><div class="line">     * </div><div class="line">     * 会调用父类 SQLiteOpenHelper的构造函数</div><div class="line">     */ </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DatabaseHelper</span><span class="params">(Context context, String name, CursorFactory factory, <span class="keyword">int</span> version)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, name, factory, version);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  在数据库第一次创建的时候会调用这个方法</div><div class="line">     *  </div><div class="line">     *根据需要对传入的SQLiteDatabase 对象填充表和初始化数据。</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 当数据库需要修改的时候（两个数据库版本不同），Android系统会主动的调用这个方法。</div><div class="line">     * 一般我们在这个方法里边删除数据库表，并建立新的数据库表.</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</div><div class="line">        <span class="comment">//三个参数，一个 SQLiteDatabase 对象，一个旧的版本号和一个新的版本号</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</div><div class="line">        <span class="comment">// 每次成功打开数据库后首先被执行</span></div><div class="line">        <span class="keyword">super</span>.onOpen(db);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继承SQLiteOpenHelper之后就拥有了以下两个方法：</p>
<ul>
<li>getReadableDatabase() 　创建或者打开一个查询数据库</li>
<li>getWritableDatabase()　创建或者打开一个可写数据库</li>
</ul>
<p>创建一个数据库代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">DatabaseHelper database = <span class="keyword">new</span> DatabaseHelper(context);<span class="comment">//传入一个上下文参数</span></div><div class="line">SQLiteDatabase db = <span class="keyword">null</span>;</div><div class="line">db = database.getWritableDatabase();</div></pre></td></tr></table></figure>
<p>上面这段代码会返回一个 SQLiteDatabase 类的实例，使用这个对象，你就可以查询或者修改数据库。SQLiteDatabase类为我们提供了很多种方法，而较常用的方法如下：</p>
<p>删除数据行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">int</span>) delete(String table,String whereClause,String[] whereArgs)</div></pre></td></tr></table></figure>
<p>添加数据行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">long</span>) insert(String table,String nullColumnHack,ContentValues values)</div></pre></td></tr></table></figure>
<p>更新数据行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">int</span>) update(String table, ContentValues values, String whereClause, String[] whereArgs)</div></pre></td></tr></table></figure>
<p>执行一个SQL语句，可以是一个select或其他的sql语句(没有返回值的sql语句)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">void</span>) execSQL(String sql)</div></pre></td></tr></table></figure>
<p>关闭数据库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">void</span>) close()</div></pre></td></tr></table></figure>
<p>查询指定的数据表返回一个带游标的数据集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*各参数说明： table：表名称 colums：列名称数组 selection：条件子句，相当于where selectionArgs：条件//*语句的参数数组 groupBy：分组 having：分组条件 orderBy：排序类 limit：分页查询的限制 Cursor：返回值，相*当于结果集ResultSet*/</span></div><div class="line">(Cursor) query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit)</div></pre></td></tr></table></figure>
<p>运行一个预置的SQL语句，返回带游标的数据集（与上面的语句最大的区别就是防止SQL注入）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(Cursor) rawQuery(String sql, String[] selectionArgs)</div></pre></td></tr></table></figure>
<p>当你完成了对数据库的操作（例如你的 Activity 已经关闭），需要调用 SQLiteDatabase 的 Close() 方法来释放掉数据库连接。</p>
<h5 id="2-创建表和索引"><a href="#2-创建表和索引" class="headerlink" title="2.创建表和索引"></a>2.创建表和索引</h5><p>为了创建表和索引，需要调用 SQLiteDatabase 的 execSQL() 方法来执行 DDL 语句。如果没有异常，这个方法没有返回值。 　　</p>
<p>例如，你可以执行如下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">db.execSQL("CREATE TABLE user(_id INTEGER PRIMARY KEY   </div><div class="line">       AUTOINCREMENT, username TEXT, password TEXT);");</div></pre></td></tr></table></figure>
<p>这条语句会创建一个名为 user的表，表有一个列名为 _id，并且是主键，这列的值是会自动增长的整数。另外还有两列：username( 字符 ) 和 password( 字符 )。 SQLite 会自动为主键列创建索引。 　　</p>
<p>通常情况下，第一次创建数据库时创建了表和索引。要 删除表和索引，需要使用 execSQL() 方法调用 DROP INDEX 和 DROP TABLE 语句。</p>
<h5 id="3-添加数据"><a href="#3-添加数据" class="headerlink" title="3.添加数据"></a>3.添加数据</h5><p>有两种方法可以给表添加数据。</p>
<p>a. 可以使用 execSQL() 方法执行 INSERT, UPDATE, DELETE 等语句来更新表的数据。execSQL() 方法适用于所有不返回结果的 SQL 语句。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String sql = "insert into user(username,password) values ('finch','123456');//插入操作的SQL语句</div><div class="line">db.execSQL(sql);//执行SQL语句</div></pre></td></tr></table></figure>
<p>b. 使用 SQLiteDatabase 对象的 insert()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ContentValues cv = <span class="keyword">new</span> ContentValues();</div><div class="line">cv.put(<span class="string">"username"</span>,<span class="string">"finch"</span>);<span class="comment">//添加用户名</span></div><div class="line">cv.put(<span class="string">"password"</span>,<span class="string">"123456"</span>); <span class="comment">//添加密码</span></div><div class="line">db.insert(<span class="string">"user"</span>,<span class="keyword">null</span>,cv);<span class="comment">//执行插入操作</span></div></pre></td></tr></table></figure>
<h5 id="4-更新数据"><a href="#4-更新数据" class="headerlink" title="4.更新数据"></a>4.更新数据</h5><p>a. 使用execSQL方式的实现</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String sql = "update [user] set password = '654321' where username="finch";//修改的SQL语句</div><div class="line">db.execSQL(sql);//执行修改</div></pre></td></tr></table></figure>
<p>b.使用SQLiteDatabase 对象的 update()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ContentValues cv = <span class="keyword">new</span> ContentValues();</div><div class="line">cv.put(<span class="string">"password"</span>,<span class="string">"654321"</span>);<span class="comment">//添加要更改的字段及内容</span></div><div class="line">String whereClause = <span class="string">"username=?"</span>;<span class="comment">//修改条件</span></div><div class="line">String[] whereArgs = &#123;<span class="string">"finch"</span>&#125;;<span class="comment">//修改条件的参数</span></div><div class="line">db.update(<span class="string">"user"</span>,cv,whereClause,whereArgs);<span class="comment">//执行修改</span></div></pre></td></tr></table></figure>
<p>该方法有四个参数：表名、列名和值的 ContentValues 对象、可选的 WHERE 条件、可选的填充 WHERE 语句的字符串，这些字符串会替换 WHERE 条件中的“？”标记，update() 根据条件，更新指定列的值。</p>
<h5 id="5-删除数据"><a href="#5-删除数据" class="headerlink" title="5.删除数据"></a>5.删除数据</h5><p>使用execSQL方式的实现</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String sql = "delete from user where username="finch";//删除操作的SQL语句</div><div class="line">db.execSQL(sql);//执行删除操作</div></pre></td></tr></table></figure>
<p>使用SQLiteDatabase 对象的delete()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String whereClause = <span class="string">"username=?"</span>;<span class="comment">//删除的条件</span></div><div class="line">String[] whereArgs = &#123;<span class="string">"finch"</span>&#125;;<span class="comment">//删除的条件参数</span></div><div class="line">db.delete(<span class="string">"user"</span>,whereClause,whereArgs);<span class="comment">//执行删除</span></div></pre></td></tr></table></figure>
<h5 id="6-查询数据"><a href="#6-查询数据" class="headerlink" title="6.查询数据"></a>6.查询数据</h5><p>使用 rawQuery() 直接调用 SELECT 语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Cursor c = db.rawQuery(<span class="string">"select * from user where username=?"</span>,<span class="keyword">new</span> Stirng[]&#123;<span class="string">"finch"</span>&#125;);</div><div class="line"></div><div class="line"><span class="keyword">if</span>(cursor.moveToFirst()) &#123;</div><div class="line">    String password = c.getString(c.getColumnIndex(<span class="string">"password"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回值是一个 cursor 对象，这个对象的方法可以迭代查询结果。 如果查询是动态的，使用这个方法就会非常复杂。例如，当你需要查询的列在程序编译的时候不能确定，这时候使用 query() 方法会方便很多。</p>
<p>通过query实现查询</p>
<p>query() 方法用 SELECT 语句段构建查询。 　　SELECT 语句内容作为 query() 方法的参数，比如：要查询的表名，要获取的字段名，WHERE 条件，包含可选的位置参数，去替代 WHERE 条件中位置参数的值，GROUP BY 条件，HAVING 条件。 　　除了表名，其他参数可以是 null。所以代码可写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Cursor c = db.query(<span class="string">"user"</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);<span class="comment">//查询并获得游标</span></div><div class="line"><span class="keyword">if</span>(c.moveToFirst())&#123;<span class="comment">//判断游标是否为空</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c.getCount();i++)&#123;　</div><div class="line">c.move(i);<span class="comment">//移动到指定记录</span></div><div class="line">String username = c.getString(c.getColumnIndex(<span class="string">"username"</span>);</div><div class="line">String password = c.getString(c.getColumnIndex(<span class="string">"password"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="7-使用游标"><a href="#7-使用游标" class="headerlink" title="7.使用游标"></a>7.使用游标</h5><p>不管你如何执行查询，都会返回一个 Cursor，这是 Android 的 SQLite 数据库游标，使用游标，你可以：</p>
<ul>
<li>通过使用 getCount() 方法得到结果集中有多少记录；　</li>
<li>通过 moveToFirst(), moveToNext(), 和 isAfterLast() 方法遍历所有记录；</li>
<li>通过 getColumnNames() 得到字段名；</li>
<li>通过 getColumnIndex() 转换成字段号；</li>
<li>通过 getString()，getInt() 等方法得到给定字段当前记录的值；</li>
<li>通过 requery() 方法重新执行查询得到游标；</li>
<li>通过 close() 方法释放游标资源；</li>
</ul>
<p>例如，下面代码遍历 user表:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Cursor result=db.rawQuery(<span class="string">"SELECT _id, username, password FROM user"</span>); </div><div class="line">    result.moveToFirst(); </div><div class="line">    <span class="keyword">while</span> (!result.isAfterLast()) &#123; </div><div class="line">        <span class="keyword">int</span> id=result.getInt(<span class="number">0</span>); </div><div class="line">        String name=result.getString(<span class="number">1</span>); </div><div class="line">        String password =result.getString(<span class="number">2</span>); </div><div class="line">        <span class="comment">// do something useful with these </span></div><div class="line">        result.moveToNext(); </div><div class="line">      &#125; </div><div class="line">      result.close();</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/02/28/android基础之SQLite/" data-id="cj0t8onjr000mponznzgv15z0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQLite/">SQLite</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android基础之进程间通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/28/android基础之进程间通信/" class="article-date">
  <time datetime="2017-02-28T10:00:00.000Z" itemprop="datePublished">2017-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/28/android基础之进程间通信/">android基础之进程间通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/02/28/android基础之进程间通信/" data-id="cj0t8onkw001mponzforfccof" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-android基础之数据存储" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/28/android基础之数据存储/" class="article-date">
  <time datetime="2017-02-28T09:42:52.000Z" itemprop="datePublished">2017-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/28/android基础之数据存储/">android基础之数据存储</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>Android提供了5种方式来让用户保存持久化应用程序数据。根据自己的需求来做选择，比如数据是否是应用程序私有的，是否能被其他程序访问，需要多少数据存储空间等。这五种数据存储方式分别是：</p>
<ul>
<li>使用SharedPreferences存储数据　</li>
<li>文件存储数据</li>
<li>SQLite数据库存储数据</li>
<li>使用ContentProvider存储数据</li>
<li>网络存储数据</li>
</ul>
<h3 id="二-五种存储方式介绍"><a href="#二-五种存储方式介绍" class="headerlink" title="二 五种存储方式介绍"></a>二 五种存储方式介绍</h3><h5 id="1-SharePreferences"><a href="#1-SharePreferences" class="headerlink" title="1. SharePreferences"></a>1. SharePreferences</h5><p>SharedPreference类提供了一个总体框架，使您可以保存和检索任何基本数据类型（ boolean, float, int, long, string）的持久键-值对（基于XML文件存储的“key-value”键值对数据）。将其以XML文件的形式保存起来。通常其存储在“data/data/程序包名/shared_prefs目录下。</p>
<h6 id="获取SharedPreferences对象（通过Context）"><a href="#获取SharedPreferences对象（通过Context）" class="headerlink" title="获取SharedPreferences对象（通过Context）"></a>获取SharedPreferences对象（通过Context）</h6><ul>
<li><p>getSharedPreferences (String name, int mode)<br>当我们有多个SharedPreferences的时候，根据第一个参数name获得相应的SharedPreferences对象。    </p>
</li>
<li><p>getPreferences (int mode)<br>如果你的Activity中只需要一个SharedPreferences的时候使用。</p>
</li>
</ul>
<p>这里的mode有四个选项：</p>
<ul>
<li><p>Context.MODE_PRIVAT<br>该SharedPreferences数据只能被本应用程序读、写。</p>
</li>
<li><p>Context.MODE_WORLD_READABLE<br>该SharedPreferences数据能被其他应用程序读，但不能写。</p>
</li>
<li><p>Context.MODE_WORLD_WRITEABLE<br>该SharedPreferences数据能被其他应用程序读和写。</p>
</li>
<li><p>Context.MODE_MULTI_PROCESS<br>sdk2.3后添加的选项，当多个进程同时读写同一个SharedPreferences时它会检查文件是否修改。</p>
</li>
</ul>
<h6 id="向Shared-Preferences中写入值"><a href="#向Shared-Preferences中写入值" class="headerlink" title="向Shared Preferences中写入值"></a>向Shared Preferences中写入值</h6><p>主要步骤：</p>
<ul>
<li>首先要通过 SharedPreferences.Editor获取到Editor对象；</li>
<li>然后通过Editor的putBoolean() 或 putString()等方法存入值；</li>
<li>最后调用Editor的commit()方法提交；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Use 0 or MODE_PRIVATE for the default operation </span></div><div class="line">SharedPreferences settings = getSharedPreferences(<span class="string">"fanrunqi"</span>, <span class="number">0</span>);</div><div class="line">SharedPreferences.Editor editor = settings.edit();</div><div class="line">editor.putBoolean(<span class="string">"isAmazing"</span>, <span class="keyword">true</span>); </div><div class="line"></div><div class="line"><span class="comment">// 提交本次编辑</span></div><div class="line">editor.commit();</div></pre></td></tr></table></figure>
<p>同时Edit还有两个常用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">editor.remove(String key) ：下一次commit的时候会移除key对应的键值对</div><div class="line"></div><div class="line">editor.clear()：移除所有键值对</div></pre></td></tr></table></figure>
<h6 id="从Shared-Preferences中读取值"><a href="#从Shared-Preferences中读取值" class="headerlink" title="从Shared Preferences中读取值"></a>从Shared Preferences中读取值</h6><p>读取值使用 SharedPreference对象的getBoolean()或getString()等方法就行了,如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SharedPreferences settings = getSharedPreferences(<span class="string">"fanrunqi"</span>, <span class="number">0</span>);</div><div class="line"><span class="keyword">boolean</span> isAmazing= settings.getBoolean(<span class="string">"isAmazing"</span>,<span class="keyword">true</span>);</div></pre></td></tr></table></figure>
<h6 id="Shared-Preferences的优缺点"><a href="#Shared-Preferences的优缺点" class="headerlink" title="Shared Preferences的优缺点"></a>Shared Preferences的优缺点</h6><p>可以看出来Preferences是很轻量级的应用，使用起来也很方便，简洁。但存储数据类型比较单一（只有基本数据类型），无法进行条件查询，只能在不复杂的存储需求下使用，比如保存配置信息等。</p>
<h5 id="2-文件存储"><a href="#2-文件存储" class="headerlink" title="2.文件存储"></a>2.文件存储</h5><h6 id="文件的内部存储（存储在手机中）"><a href="#文件的内部存储（存储在手机中）" class="headerlink" title="文件的内部存储（存储在手机中）"></a>文件的内部存储（存储在手机中）</h6><p>当文件被保存在内部存储中时，默认情况下，文件是应用程序私有的，其他应用不能访问。当用户卸载应用程序时这些文件也跟着被删除。文件默认存储位置：/data/data/包名/files/文件名。</p>
<p><strong>a. 创建和写入一个内部存储的私有文件</strong> </p>
<ul>
<li>调用Context的openFileOutput()函数，填入文件名和操作模式，它会返回一个FileOutputStream对象。</li>
<li>通过FileOutputStream对象的write()函数写入数据。</li>
<li>FileOutputStream对象的close ()函数关闭流</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">String FILENAME = <span class="string">"a.txt"</span>;</div><div class="line">String string = <span class="string">"fanrunqi"</span>;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);</div><div class="line">    fos.write(string.getBytes());</div><div class="line">    fos.close();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 openFileOutput(String name, int mode)方法中:</p>
<p>name参数:　用于指定文件名称，不能包含路径分隔符“/” ，如果文件不存在，Android 会自动创建它。<br>mode参数：用于指定操作模式，分为四种：</p>
<ul>
<li><p>Context.MODE_PRIVATE = 0<br>为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容。</p>
</li>
<li><p>Context.MODE_APPEND = 32768<br>该模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。　</p>
</li>
<li><p>Context.MODE_WORLD_READABLE = 1<br>表示当前文件可以被其他应用读取。</p>
</li>
<li><p>MODE_WORLD_WRITEABLE<br>表示当前文件可以被其他应用写入。</p>
</li>
</ul>
<p><strong>b. 读取一个内部存储的私有文件</strong></p>
<p>步骤：</p>
<ul>
<li>调用openFileInput( )，参数中填入文件名，会返回一个FileInputStream对象。</li>
<li>使用流对象的 read()方法读取字节</li>
<li>调用流的close()方法关闭流</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">String FILENAME = <span class="string">"a.txt"</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            FileInputStream inStream = openFileInput(FILENAME);</div><div class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">            <span class="keyword">while</span> ((len = inStream.read(buf)) != -<span class="number">1</span>) &#123;</div><div class="line">                sb.append(<span class="keyword">new</span> String(buf, <span class="number">0</span>, len));</div><div class="line">            &#125;</div><div class="line">            inStream.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>其他一些经常用到的方法：</p>
<ul>
<li>getFilesDir()：　得到内存储文件的绝对路径</li>
<li>getDir()：　在内存储空间中创建或打开一个已经存在的目录</li>
<li>deleteFile()：　删除保存在内部存储的文件。　 </li>
<li>fileList()：　返回当前由应用程序保存的文件的数组（内存储目录下的全部文件）。</li>
</ul>
<p><strong>c.获取编译时的静态文件</strong></p>
<p>如果你想在应用编译时保存静态文件，应该把文件保存在项目的　res/raw/　目录下，你可以通过 openRawResource()方法去打开它（传入参数R.raw.filename），这个方法返回一个 InputStream流对象你可以读取文件但是不能修改原始文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">InputStream is = <span class="keyword">this</span>.getResources().openRawResource(R.raw.filename);</div></pre></td></tr></table></figure>
<p><strong>d. 获取内存缓存文件</strong></p>
<p>有时候我们只想缓存一些数据而不是持久化保存，可以使用getCacheDir（）去打开一个文件，文件的存储目录（ /data/data/包名/cache ）是一个应用专门来保存临时缓存文件的内存目录。当设备的内部存储空间比较低的时候，Android可能会删除这些缓存文件来恢复空间，但是你不应该依赖系统来回收，要自己维护这些缓存文件把它们的大小限制在一个合理的范围内，比如1ＭＢ．当你卸载应用的时候这些缓存文件也会被移除。</p>
<h6 id="文件的外部存储（sdcard）"><a href="#文件的外部存储（sdcard）" class="headerlink" title="文件的外部存储（sdcard）"></a>文件的外部存储（sdcard）</h6><p>因为内部存储容量限制，有时候需要存储数据比较大的时候需要用到外部存储，使用外部存储分为以下几个步骤：</p>
<p><strong>a. 添加外部存储访问限权</strong></p>
<p>首先，要在AndroidManifest.xml中加入访问SDCard的权限，如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 在SDCard中创建与删除文件权限 --&gt; </div><div class="line">   &lt;uses-permission android:name=<span class="string">"android.permission.MOUNT_UNMOUNT_FILESYSTEMS"</span>/&gt; </div><div class="line"></div><div class="line">   &lt;!-- 往SDCard写入数据权限 --&gt; </div><div class="line">   &lt;uses-permission android:name=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</div></pre></td></tr></table></figure>
<p><strong>b. 检测外部存储的可用性</strong></p>
<p>在使用外部存储时我们需要检测其状态，它可能被连接到计算机、丢失或者只读等。下面代码将说明如何检查状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取外存储的状态</span></div><div class="line">String state = Environment.getExternalStorageState();</div><div class="line"><span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(state)) &#123;</div><div class="line">    <span class="comment">// 可读可写</span></div><div class="line">    mExternalStorageAvailable = mExternalStorageWriteable = <span class="keyword">true</span>;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123;</div><div class="line">    <span class="comment">// 可读</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 可能有很多其他的状态，但是我们只需要知道，不能读也不能写  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>c. 访问外部存储器中的文件</strong></p>
<p>1) 如果 API 版本大于或等于８，使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getExternalFilesDir (String type)</div></pre></td></tr></table></figure>
<p>该方法打开一个外存储目录，此方法需要一个类型，指定你想要的子目录，如类型参数DIRECTORY_MUSIC和 DIRECTORY_RINGTONES（传null就是你应用程序的文件目录的根目录）。通过指定目录的类型，确保Android的媒体扫描仪将扫描分类系统中的文件（例如，铃声被确定为铃声）。如果用户卸载应用程序，这个目录及其所有内容将被删除。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">File file = <span class="keyword">new</span> File(getExternalFilesDir(<span class="keyword">null</span>), <span class="string">"fanrunqi.jpg"</span>);</div></pre></td></tr></table></figure>
<p>2) 如果API 版本小于 8 （7或者更低）,使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getExternalStorageDirectory ()</div></pre></td></tr></table></figure>
<p>通过该方法打开外存储的根目录，你应该在以下目录下写入你的应用数据，这样当卸载应用程序时该目录及其所有内容也将被删除。目录：/Android/data/<package_name>/files/</package_name></p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))&#123;  </div><div class="line">            File sdCardDir = Environment.getExternalStorageDirectory();<span class="comment">//获取SDCard目录  "/sdcard"        </span></div><div class="line"></div><div class="line">               File saveFile = <span class="keyword">new</span> File(sdCardDir,<span class="string">"a.txt"</span>); </div><div class="line"></div><div class="line">               <span class="comment">//写数据</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    FileOutputStream fos= <span class="keyword">new</span> FileOutputStream(saveFile); </div><div class="line">                    fos.write(<span class="string">"fanrunqi"</span>.getBytes()); </div><div class="line">                    fos.close();</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; </div><div class="line"></div><div class="line">                <span class="comment">//读数据</span></div><div class="line">                 <span class="keyword">try</span> &#123;</div><div class="line">                    FileInputStream fis= <span class="keyword">new</span> FileInputStream(saveFile); </div><div class="line">                    <span class="keyword">int</span> len =<span class="number">0</span>;</div><div class="line">                    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">                    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line">                    <span class="keyword">while</span>((len=fis.read(buf))!=-<span class="number">1</span>)&#123;</div><div class="line">                        sb.append(<span class="keyword">new</span> String(buf, <span class="number">0</span>, len));</div><div class="line">                    &#125;</div><div class="line">                    fis.close();</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;  </div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>我们也可以在　/Android/data/package_name/cache/目录下做外部缓存。</p>
<h5 id="3-网路存储"><a href="#3-网路存储" class="headerlink" title="3. 网路存储"></a>3. 网路存储</h5><p>网路存储即是通过HttpUrlConnection或者HttpClint或者okhttp等http框架从服务器中获取数据。</p>
<h5 id="4-SQLite存储"><a href="#4-SQLite存储" class="headerlink" title="4.SQLite存储"></a>4.SQLite存储</h5><p>请看我的另一篇博客《android基础之SQLite》</p>
<h5 id="5-ContentProvider存储"><a href="#5-ContentProvider存储" class="headerlink" title="5.ContentProvider存储"></a>5.ContentProvider存储</h5><p>看我的另一篇博客《android基础之Content Provider》</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三 总结"></a>三 总结</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/02/28/android基础之数据存储/" data-id="cj0t8onkp001bponzz3yzpkpv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据存储/">数据存储</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android基础之缓存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/28/android基础之缓存/" class="article-date">
  <time datetime="2017-02-28T09:10:22.000Z" itemprop="datePublished">2017-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/28/android基础之缓存/">android基础之缓存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>移动开发本质上就是手机和服务器之间进行通信，需要从服务端获取数据。反复通过网络获取数据是比较耗时的，特别是访问比较多的时候，会极大影响了性能，Android中可通过缓存机制来减少频繁的网络操作，减少流量、提升性能。android中缓存分为一级缓存，二级缓存和图片的三级缓存(就是网络)。</p>
<p>Android缓存分为内存缓存（一级缓存）和文件缓存（二级缓存）。在早期，各大图片缓存框架流行之前，常用的内存缓存方式是软引用（SoftReference）和弱引用（WeakReference），如大部分的使用方式：HashMap<string url,="" softreference<drawable="">&gt; imageCache;这种形式。从Android 2.3（Level 9）开始，垃圾回收器更倾向于回收SoftReference或WeakReference对象，这使得SoftReference和WeakReference变得不是那么实用有效。同时，到了Android 3.0（Level 11）之后，图片数据Bitmap被放置到了内存的堆区域，而堆区域的内存是由GC管理的，开发者也就不需要进行图片资源的释放工作，但这也使得图片数据的释放无法预知，增加了造成OOM的可能。因此，在Android3.1以后，Android推出了LruCache这个内存缓存类和DiskLruCache这个磁盘缓存类。</string></p>
<p>当Android端需要获得数据时比如获取网络中的图片，我们首先从内存中查找（按键查找），内存中没有的再从磁盘文件或sqlite中去查找，若磁盘中也没有才通过网络获取（图片的3级缓存策略）；当获得来自网络的数据，就以key-value对的方式先缓存到内存（一级缓存），同时缓存到文件或sqlite中（二级缓存）。注意：内存缓存会造成堆内存泄露，所有一级缓存通常要严格控制缓存的大小，一般控制在系统内存的1/4。</p>
<h3 id="二-内存缓存（一级缓存）"><a href="#二-内存缓存（一级缓存）" class="headerlink" title="二 内存缓存（一级缓存）"></a>二 内存缓存（一级缓存）</h3><p>android中使用LruCache做内存缓存。在介绍这个类之前先了解一下LRU算法。</p>
<h5 id="1-LRU算法"><a href="#1-LRU算法" class="headerlink" title="1.LRU算法"></a>1.LRU算法</h5><p>LRU，全称Least Rencetly Used，即最近最少使用，是一种非常常用的置换算法，也即淘汰最长时间未使用的对象。LRU在操作系统中的页面置换算法中广泛使用，我们的内存或缓存空间是有限的，当新加入一个对象时，造成我们的缓存空间不足了，此时就需要根据某种算法对缓存中原有数据进行淘汰货删除，而LRU选择的是将最长时间未使用的对象进行淘汰。</p>
<h5 id="2-LruCache实现原理"><a href="#2-LruCache实现原理" class="headerlink" title="2.LruCache实现原理"></a>2.LruCache实现原理</h5><p>根据LRU算法的思想，要实现LRU最核心的是要有一种数据结构能够基于访问顺序来保存缓存中的对象，这样我们就能够很方便的知道哪个对象是最近访问的，哪个对象是最长时间未访问的。LruCache选择的是LinkedHashMap这个数据结构，LinkedHashMap是一个双向循环链表，在构造LinkedHashMap时，通过一个boolean值来指定LinkedHashMap中保存数据的方式，LinkedHashMap的一个构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line">     * 初始化LinkedHashMap </div><div class="line">     * 第一个参数：initialCapacity，初始大小 </div><div class="line">     * 第二个参数：loadFactor，负载因子=0.75f </div><div class="line">     * 第三个参数：accessOrder=true，基于访问顺序；accessOrder=false，基于插入顺序 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);  </div><div class="line">        init();  </div><div class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>显然，在LruCache中选择的是accessOrder = true；此时，当accessOrder 设置为 true时，每当我们更新（即调用put方法）或访问（即调用get方法）map中的结点时，LinkedHashMap内部都会将这个结点移动到链表的尾部，因此，在链表的尾部是最近刚刚使用的结点，在链表的头部是是最近最少使用的结点，当我们的缓存空间不足时，就应该持续把链表头部结点移除掉，直到有剩余空间放置新结点。<br>可以看到，LinkedHashMap完成了LruCache中的核心功能，那LruCache中剩下要做的就是定义缓存空间总容量，当前保存数据已使用的容量，对外提供put、get方法。</p>
<h5 id="3-LruCache源码分析"><a href="#3-LruCache源码分析" class="headerlink" title="3.LruCache源码分析"></a>3.LruCache源码分析</h5><p>在了解了LruCache的核心原理之后，就可以开始分析LruCache的源码了。</p>
<h6 id="3-1关键字段"><a href="#3-1关键字段" class="headerlink" title="3.1关键字段"></a>3.1关键字段</h6><p>根据上面的分析，首先要有总容量、已使用容量、linkedHashMap这几个关键字段，LruCache中提供了下面三个关键字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//核心数据结构  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;K, V&gt; map;  </div><div class="line">    <span class="comment">// 当前缓存数据所占的大小  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;  </div><div class="line">    <span class="comment">//缓存空间总容量  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</div></pre></td></tr></table></figure>
<p>要注意的是size字段，因为map中可以存放各种类型的数据，这些数据的大小测量方式也是不一样的，比如Bitmap类型的数据和String类型的数据计算他们的大小方式肯定不同，因此，LruCache中在计算放入数据大小的方法sizeOf中，只是简单的返回了1，需要我们重写这个方法，自己去定义数据的测量方式。因此，我们在使用LruCache的时候，经常会看到这种方式： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_SIZE = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;<span class="comment">//4Mib  </span></div><div class="line">    LruCache&lt;String,Bitmap&gt; bitmapCache = <span class="keyword">new</span> LruCache&lt;String,Bitmap&gt;(CACHE_SIZE)&#123;  </div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;  </div><div class="line">            <span class="keyword">return</span> value.getByteCount();<span class="comment">//自定义Bitmap数据大小的计算方式  </span></div><div class="line">        &#125;  </div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<h6 id="3-2-构造方法"><a href="#3-2-构造方法" class="headerlink" title="3.2 构造方法"></a>3.2 构造方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.maxSize = maxSize;</div><div class="line">    <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LruCache只有一个唯一的构造方法，在构造方法中，给定了缓存空间的总大小，初始化了LinkedHashMap核心数据结构，在LinkedHashMap中的第三个参数指定为true，也就设置了accessOrder=true，表示这个LinkedHashMap将是基于数据的访问顺序进行排序。</p>
<h6 id="3-3-sizeOf-和safeSizeOf-方法测量数据类型大小"><a href="#3-3-sizeOf-和safeSizeOf-方法测量数据类型大小" class="headerlink" title="3.3 sizeOf()和safeSizeOf()方法测量数据类型大小"></a>3.3 sizeOf()和safeSizeOf()方法测量数据类型大小</h6><p>根据上面的解释，由于各种数据类型大小测量的标准不统一，具体测量的方法应该由使用者来实现，如上面给出的一个在实现LruCache时重写sizeOf的一种常用实现方式。通过多态的性质，再具体调用sizeOf时会调用我们重写的方法进行测量，LruCache对sizeOf()的调用进行一层封装，如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">safeSizeOf</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = sizeOf(key, value);</div><div class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Negative size: "</span> + key + <span class="string">"="</span> + value);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>里面其实就是调用sizeOf()方法，返回sizeOf计算的大小。<br>上面就是LruCache的基本内容，下面就需要提供LruCache的核心功能了。</p>
<h6 id="3-4-put方法缓存数据"><a href="#3-4-put方法缓存数据" class="headerlink" title="3.4 put方法缓存数据"></a>3.4 put方法缓存数据</h6><p>首先看一下它的源码实现：    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * 给对应key缓存value，并且将该value移动到链表的尾部。</div><div class="line">   */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null || value == null"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">      V previous;</div><div class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="comment">// 记录 put 的次数</span></div><div class="line">        putCount++;</div><div class="line">        <span class="comment">// 通过键值对，计算出要保存对象value的大小，并更新当前缓存大小</span></div><div class="line">        size += safeSizeOf(key, value);</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 如果 之前存在key，用新的value覆盖原来的数据， 并返回 之前key 的value</div><div class="line">         * 记录在 previous</div><div class="line">         */</div><div class="line">        previous = map.put(key, value);</div><div class="line">        <span class="comment">// 如果之前存在key，并且之前的value不为null</span></div><div class="line">        <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 计算出 之前value的大小，因为前面size已经加上了新的value数据的大小，此时，需要再次更新size，减去原来value的大小</span></div><div class="line">            size -= safeSizeOf(key, previous);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果之前存在key，并且之前的value不为null</span></div><div class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * previous值被剔除了，此次添加的 value 已经作为key的 新值</div><div class="line">         * 告诉 自定义 的 entryRemoved 方法</div><div class="line">         */</div><div class="line">        entryRemoved(<span class="keyword">false</span>, key, previous, value);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//裁剪缓存容量（在当前缓存数据大小超过了总容量maxSize时，才会真正去执行LRU）</span></div><div class="line">    trimToSize(maxSize);</div><div class="line">      <span class="keyword">return</span> previous;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，put()方法主要有以下几步：<br>1）key和value判空，说明LruCache中不允许key和value为null；<br>2）通过safeSizeOf()获取要加入对象数据的大小，并更新当前缓存数据的大小；<br>3）将新的对象数据放入到缓存中，即调用LinkedHashMap的put方法，如果原来存在该key时，直接替换掉原来的value值，并返回之前的value值，得到之前value的大小，更新当前缓存数据的size大小；如果原来不存在该key，则直接加入缓存即可；<br>4）清理缓存空间</p>
<h6 id="3-5-trimToSize-清理缓存空间"><a href="#3-5-trimToSize-清理缓存空间" class="headerlink" title="3.5 trimToSize()清理缓存空间"></a>3.5 trimToSize()清理缓存空间</h6><p>当我们加入一个数据时（put），为了保证当前数据的缓存所占大小没有超过我们指定的总大小，通过调用trimToSize()来对缓存空间进行管理控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 循环进行LRU，直到当前所占容量大小没有超过指定的总容量大小</div><div class="line">     */</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        K key;</div><div class="line">        V value;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="comment">// 一些异常情况的处理</span></div><div class="line">            <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="number">0</span>)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                        getClass().getName() + <span class="string">".sizeOf() is reporting inconsistent results!"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 首先判断当前缓存数据大小是否超过了指定的缓存空间总大小。如果没有超过，即缓存中还可以存入数据，直接跳出循环，清理完毕</span></div><div class="line">            <span class="keyword">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/**</span></div><div class="line">             * 执行到这，表示当前缓存数据已超过了总容量，需要执行LRU，即将最近最少使用的数据清除掉，直到数据所占缓存空间没有超标;</div><div class="line">             * 根据前面的原理分析，知道，在链表中，链表的头结点是最近最少使用的数据，因此，最先清除掉链表前面的结点</div><div class="line">             */</div><div class="line">            Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</div><div class="line">            key = toEvict.getKey();</div><div class="line">            value = toEvict.getValue();</div><div class="line">            map.remove(key);</div><div class="line">            <span class="comment">// 移除掉后，更新当前数据缓存的大小</span></div><div class="line">            size -= safeSizeOf(key, value);</div><div class="line">            <span class="comment">// 更新移除的结点数量</span></div><div class="line">            evictionCount++;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 通知某个结点被移除，类似于回调</div><div class="line">         */</div><div class="line">        entryRemoved(<span class="keyword">true</span>, key, value, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>trimToSize()方法的作用就是为了保证当前数据的缓存大小不能超过我们指定的缓存总大小，如果超过了，就会开始移除最近最少使用的数据，直到size符合要求。trimToSize()方法在put()的时候一定会调用，在get()的时候有可能会调用。</p>
<h6 id="3-6-get方法获取缓存数据"><a href="#3-6-get方法获取缓存数据" class="headerlink" title="3.6 get方法获取缓存数据"></a>3.6 get方法获取缓存数据</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 根据key查询缓存，如果该key对应的value存在于缓存，直接返回value；</div><div class="line">* 访问到这个结点时，LinkHashMap会将它移动到双向循环链表的的尾部。</div><div class="line">* 如果如果没有缓存的值，则返回null。（如果开发者重写了create()的话，返回创建的value）</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    V mapValue;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="comment">// LinkHashMap 如果设置按照访问顺序的话，这里每次get都会重整数据顺序</span></div><div class="line">        mapValue = map.get(key);</div><div class="line">        <span class="comment">// 计算 命中次数</span></div><div class="line">        <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</div><div class="line">            hitCount++;</div><div class="line">            <span class="keyword">return</span> mapValue;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 计算 丢失次数</span></div><div class="line">        missCount++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 官方解释：</div><div class="line">     * 尝试创建一个值，这可能需要很长时间，并且Map可能在create()返回的值时有所不同。如果在create()执行的时</div><div class="line">     * 候，用这个key执行了put方法，那么此时就发生了冲突，我们在Map中删除这个创建的值，释放被创建的值，保留put进去的值。</div><div class="line">     */</div><div class="line">    V createdValue = create(key);</div><div class="line">    <span class="keyword">if</span> (createdValue == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/***************************</span></div><div class="line">     * 不覆写create方法走不到下面 *</div><div class="line">     ***************************/</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 正常情况走不到这里</div><div class="line">     * 走到这里的话 说明 实现了自定义的 create(K key) 逻辑</div><div class="line">     * 因为默认的 create(K key) 逻辑为null</div><div class="line">     */</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="comment">// 记录 create 的次数</span></div><div class="line">        createCount++;</div><div class="line">        <span class="comment">// 将自定义create创建的值，放入LinkedHashMap中，如果key已经存在，会返回 之前相同key 的值</span></div><div class="line">        mapValue = map.put(key, createdValue);</div><div class="line"></div><div class="line">        <span class="comment">// 如果之前存在相同key的value，即有冲突。</span></div><div class="line">        <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line">             * 有冲突</div><div class="line">             * 所以 撤销 刚才的 操作</div><div class="line">             * 将 之前相同key 的值 重新放回去</div><div class="line">             */</div><div class="line">            map.put(key, mapValue);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 拿到键值对，计算出在容量中的相对长度，然后加上</span></div><div class="line">            size += safeSizeOf(key, createdValue);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果上面 判断出了 将要放入的值发生冲突</span></div><div class="line">    <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 刚才create的值被删除了，原来的 之前相同key 的值被重新添加回去了</div><div class="line">         * 告诉 自定义 的 entryRemoved 方法</div><div class="line">         */</div><div class="line">        entryRemoved(<span class="keyword">false</span>, key, createdValue, mapValue);</div><div class="line">        <span class="keyword">return</span> mapValue;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 上面 进行了 size += 操作 所以这里要重整长度</span></div><div class="line">        trimToSize(maxSize);</div><div class="line">        <span class="keyword">return</span> createdValue;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get()方法的思路就是：<br>   1）先尝试从map缓存中获取value，即mapVaule = map.get(key);如果mapVaule != null，说明缓存中存在该对象，直接返回即可；<br>   2）如果mapVaule == null，说明缓存中不存在该对象，大多数情况下会直接返回null；但是如果我们重写了create()方法，在缓存没有该数据的时候自己去创建一个，则会继续往下走，中间可能会出现冲突，看注释；<br>   3）注意：在我们通过LinkedHashMap进行get(key)或put(key,value)时都会对链表进行调整，即将刚刚访问get或加入put的结点放入到链表尾部。</p>
<h6 id="3-7-entryRemoved"><a href="#3-7-entryRemoved" class="headerlink" title="3.7 entryRemoved()"></a>3.7 entryRemoved()</h6><p>entryRemoved的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 1.当被回收或者删掉时调用。该方法当value被回收释放存储空间时被remove调用</div><div class="line">* 或者替换条目值时put调用，默认实现什么都没做。</div><div class="line">* 2.该方法没用同步调用，如果其他线程访问缓存时，该方法也会执行。</div><div class="line">* 3.evicted=true：如果该条目被删除空间 （表示 进行了trimToSize or remove）  evicted=false：put冲突后 或 get里成功create后</div><div class="line">* 导致</div><div class="line">* 4.newValue!=null，那么则被put()或get()调用。</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">entryRemoved</span><span class="params">(<span class="keyword">boolean</span> evicted, K key, V oldValue, V newValue)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>entryRemoved方法是一个空方法，说明这个也是让开发者自己根据需求去重写的。entryRemoved()主要作用就是在结点数据value需要被删除或回收的时候，给开发者的回调。开发者就可以在这个方法里面实现一些自己的逻辑：<br>（1）可以进行资源的回收；<br>（2）可以实现二级内存缓存，可以进一步提高性能，<br>思路如下：重写LruCache的entryRemoved()函数，把删除掉的item，再次存入另外一个LinkedHashMap<string, softweakreference<bitmap="">&gt;中，这个数据结构当做二级缓存，每次获得图片的时候，先判断LruCache中是否缓存，没有的话，再判断这个二级缓存中是否有，如果都没有再从sdcard上获取。sdcard上也没有的话，就从网络服务器上拉取。entryRemoved()在LruCache中有四个地方进行了调用：put()、get()、trimToSize()、remove()中进行了调用。</string,></p>
<h6 id="3-8-LruCache的线程安全性"><a href="#3-8-LruCache的线程安全性" class="headerlink" title="3.8 LruCache的线程安全性"></a>3.8 LruCache的线程安全性</h6><p>LruCache是线程安全的，因为在put、get、trimToSize、remove的方法中都加入synchronized进行同步控制。</p>
<h5 id="4-LruCache代码示例"><a href="#4-LruCache代码示例" class="headerlink" title="4.LruCache代码示例"></a>4.LruCache代码示例</h5><p>使用步骤：</p>
<ul>
<li>在构造LruCache时提供一个总的缓存大小；</li>
<li>重写sizeOf方法，对存入map的数据大小进行自定义测量；</li>
<li>根据需要，决定是否要重写entryRemoved()方法；</li>
<li>使用LruCache提供的put和get方法进行数据的缓存</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> LruCache&lt;String, Bitmap&gt; mMemoryCache;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 获得虚拟机能提供的最大内存，超过这个大小会抛出OutOfMemory的异常</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">1024</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 用１／８的内存大小作为内存缓存</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> cacheSize = maxMemory / <span class="number">8</span>;</div><div class="line"></div><div class="line">    mMemoryCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap bitmap)</span> </span>&#123;</div><div class="line">            <span class="comment">// 这里返回的不是item的个数，是cache的size（单位1024个字节）</span></div><div class="line">            <span class="keyword">return</span> bitmap.getByteCount() / <span class="number">1024</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBitmapToMemoryCache</span><span class="params">(String key, Bitmap bitmap)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (getBitmapFromMemCache(key) == <span class="keyword">null</span>) &#123;</div><div class="line">        mMemoryCache.put(key, bitmap);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmapFromMemCache</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mMemoryCache.get(key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当为ImageView加载一张图片时，会先在LruCache 中看看有没有缓存这张图片，如果有的话直接更新到ImageView中，如果没有的话，一个后台线程会被触发来加载这张图片。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBitmap</span><span class="params">(<span class="keyword">int</span> resId, ImageView imageView)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> String imageKey = String.valueOf(resId);</div><div class="line"></div><div class="line">    <span class="comment">// 查看下内存缓存中是否缓存了这张图片</span></div><div class="line">    <span class="keyword">final</span> Bitmap bitmap = getBitmapFromMemCache(imageKey);</div><div class="line">    <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">        mImageView.setImageBitmap(bitmap);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mImageView.setImageResource(R.drawable.image_placeholder);</div><div class="line">BitmapWorkerTask task = <span class="keyword">new</span> BitmapWorkerTask(mImageView);</div><div class="line">        task.execute(resId);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在图片加载的Task中，需要把加载好的图片加入到内存缓存中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapWorkerTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Integer</span>, <span class="title">Void</span>, <span class="title">Bitmap</span>&gt; </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 在后台完成</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">doInBackground</span><span class="params">(Integer... params)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Bitmap bitmap = decodeSampledBitmapFromResource(</div><div class="line">                getResources(), params[<span class="number">0</span>], <span class="number">100</span>, <span class="number">100</span>));</div><div class="line">    addBitmapToMemoryCache(String.valueOf(params[<span class="number">0</span>]), bitmap);</div><div class="line">        <span class="keyword">return</span> bitmap;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h5><ul>
<li>LruCache 自身并没有释放内存，只是 LinkedHashMap中将数据移除了，如果数据还在别的地方被引用了，还是有泄漏问题，还需要手动释放内存；</li>
<li>覆写 entryRemoved 方法能知道 LruCache 数据移除是是否发生了冲突（冲突是指在map.put()的时候，对应的key中是否存在原来的值），也可以去手动释放资源；</li>
</ul>
<h3 id="三-磁盘缓存（二级缓存）"><a href="#三-磁盘缓存（二级缓存）" class="headerlink" title="三 磁盘缓存（二级缓存）"></a>三 磁盘缓存（二级缓存）</h3><p>LruCache是一种内存缓存策略，但是当存在大量图片的时候，我们指定的缓存内存空间可能很快就会用完，这个时候，LruCache就会频繁的进行trimToSize()操作，不断的将最近最少使用的数据移除，当再次需要该数据时，又得从网络上重新加载，这样就有可能造成OOM。为此，Google提供了一种磁盘缓存的解决方案——DiskLruCache（DiskLruCache并没有集成到Android源码中，在Android Doc的例子中有讲解）。</p>
<h5 id="1-DiskLruCache实现原理"><a href="#1-DiskLruCache实现原理" class="headerlink" title="1. DiskLruCache实现原理"></a>1. DiskLruCache实现原理</h5><p>我们可以先来直观看一下，使用了DiskLruCache缓存策略的APP，缓存目录中是什么样子，如下图：</p>
<img src="/2017/02/28/android基础之缓存/文件缓存结果图.png" alt="文件缓存结果图" title="文件缓存结果图">
<p>可以看到，缓存目录中有一堆文件名很长的文件，这些文件就是我们缓存的一张张图片数据，在最后有一个文件名journal的文件，这个journal文件是DiskLruCache的一个日志文件，即保存着每张缓存图片的操作记录，journal文件正是实现DiskLruCache的核心。看到出现了journal文件，基本可以说明这个APP使用了DiskLruCache缓存策略。</p>
<p>根据对LruCache的分析，要实现LRU，最重要的是要有一种数据结构能够基于访问顺序来保存缓存中的对象，LinkedHashMap是一种非常合适的数据结构，为此，DiskLruCache也选择了LinkedHashMap作为维护访问顺序的数据结构，但是，对于DiskLruCache来说，单单LinkedHashMap是不够的，因为我们不能像LruCache一样，直接将数据放置到LinkedHashMap的value中，也就是处于内存当中，在DiskLruCache中，数据是缓存到了本地文件，这里的LinkedHashMap中的value只是保存的是value的一些简要信息Entry，如唯一的文件名称、大小、是否可读等信息，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</div><div class="line">    <span class="comment">/** Lengths of this entry's files. */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] lengths;</div><div class="line">    <span class="comment">/** True if this entry has ever been published */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> readable;</div><div class="line">    <span class="comment">/** The ongoing edit or null if this entry is not being edited. */</span></div><div class="line">    <span class="keyword">private</span> Editor currentEditor;</div><div class="line">    <span class="comment">/** The sequence number of the most recently committed edit to this entry. */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequenceNumber;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Entry</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.key = key;</div><div class="line">        <span class="keyword">this</span>.lengths = <span class="keyword">new</span> <span class="keyword">long</span>[valueCount];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLengths</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> size : lengths) &#123;</div><div class="line">            result.append(<span class="string">' '</span>).append(size);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result.toString();</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Set lengths using decimal numbers like "10123".</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setLengths</span><span class="params">(String[] strings)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (strings.length != valueCount) &#123;</div><div class="line">            <span class="keyword">throw</span> invalidLengths(strings);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++) &#123;</div><div class="line">                lengths[i] = Long.parseLong(strings[i]);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</div><div class="line">            <span class="keyword">throw</span> invalidLengths(strings);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> IOException <span class="title">invalidLengths</span><span class="params">(String[] strings)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal line: "</span> + Arrays.toString(strings));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">getCleanFile</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> File(directory, key + <span class="string">"."</span> + i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">getDirtyFile</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> File(directory, key + <span class="string">"."</span> + i + <span class="string">".tmp"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DiskLruCache中对于LinkedHashMap定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;String, Entry&gt; lruEntries</div><div class="line">	= <span class="keyword">new</span> LinkedHashMap&lt;String, Entry&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</div></pre></td></tr></table></figure>
<p>在LruCache中，由于数据是直接缓存中内存中，map中数据的建立是在使用LruCache缓存的过程中逐步建立的，而对于DiskLruCache，由于数据是缓存在本地文件，相当于是持久保存下来的一个文件，即使程序退出文件还在，因此，map中数据的建立，除了在使用DiskLruCache过程中建立外，map还应该包括之前已经存在的缓存文件，因此，在获取DiskLruCache的实例时，DiskLruCache会去读取journal这个日志文件，根据这个日志文件中的信息，建立map的初始数据，同时，会根据journal这个日志文件，维护本地的缓存文件。构造DiskLruCache的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskLruCache <span class="title">open</span><span class="params">(File directory, <span class="keyword">int</span> appVersion, <span class="keyword">int</span> valueCount, <span class="keyword">long</span> maxSize)</span></span></div><div class="line">    <span class="keyword">throws</span> IOException &#123;</div><div class="line">    <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (valueCount &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"valueCount &lt;= 0"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// prefer to pick up where we left off</span></div><div class="line">    DiskLruCache cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</div><div class="line">    <span class="keyword">if</span> (cache.journalFile.exists()) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        cache.readJournal();</div><div class="line">        cache.processJournal();</div><div class="line">        cache.journalWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(cache.journalFile, <span class="keyword">true</span>),IO_BUFFER_SIZE);</div><div class="line">                <span class="keyword">return</span> cache;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException journalIsCorrupt) &#123;</div><div class="line">            <span class="comment">//                System.logW("DiskLruCache " + directory + " is corrupt: "</span></div><div class="line">            <span class="comment">//                        + journalIsCorrupt.getMessage() + ", removing");</span></div><div class="line">            cache.delete();</div><div class="line">        &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    <span class="comment">// create a new empty cache</span></div><div class="line">    directory.mkdirs();</div><div class="line">    cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</div><div class="line">    cache.rebuildJournal();</div><div class="line">    <span class="keyword">return</span> cache;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<br>cache.readJournal();<br>cache.processJournal();<br>正是去读取journal日志文件，建立起map中的初始数据，同时维护缓存文件。</p>
<h5 id="2-journal日志文件"><a href="#2-journal日志文件" class="headerlink" title="2.journal日志文件"></a>2.journal日志文件</h5><p>journal日志文件到底保存了什么信息呢，一个标准的journal日志文件信息如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">libcore.io.DiskLruCache    //第一行，固定内容，声明</div><div class="line">1                                        //第二行，cache的版本号，恒为1</div><div class="line">1                                        //第三行，APP的版本号</div><div class="line">2                                        //第四行，一个key，可以存放多少条数据valueCount    </div><div class="line">                                           //第五行，空行分割行</div><div class="line">DIRTY 335c4c6028171cfddfbaae1a9c313c52</div><div class="line">CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934</div><div class="line">REMOVE 335c4c6028171cfddfbaae1a9c313c52</div><div class="line">DIRTY 1ab96a171faeeee38496d8b330771a7a</div><div class="line">CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234</div><div class="line">READ 335c4c6028171cfddfbaae1a9c313c52</div><div class="line">READ 3400330d1dfc7f3f7f4b8d4d803dfcf6</div></pre></td></tr></table></figure>
<p>前五行称为journal日志文件的头，下面部分的每一行会以四种前缀之一开始：DIRTY、CLEAN、REMOVE、READ。</p>
<p>以一个DIRTY前缀开始的，后面紧跟着缓存图片的key。以DIRTY这个这个前缀开头，意味着这是一条脏数据。每当我们调用一次DiskLruCache的edit()方法时，都会向journal文件中写入一条DIRTY记录，表示我们正准备写入一条缓存数据，但不知结果如何。然后调用commit()方法表示写入缓存成功，这时会向journal中写入一条CLEAN记录，意味着这条“脏”数据被“洗干净了”，调用abort()方法表示写入缓存失败，这时会向journal中写入一条REMOVE记录。也就是说，每一行DIRTY的key，后面都应该有一行对应的CLEAN或者REMOVE的记录，否则这条数据就是“脏”的，会被自动删除掉。</p>
<p>在CLEAN前缀和key后面还有一个数值，代表的是该条缓存数据的大小。</p>
<h5 id="3-DiskLruCache中的工作流程"><a href="#3-DiskLruCache中的工作流程" class="headerlink" title="3.DiskLruCache中的工作流程"></a>3.DiskLruCache中的工作流程</h5><p><strong>1.</strong>初始化：通过open()方法，获取DiskLruCache的实例，在open方法中通过readJournal(); 方法读取journal日志文件，根据journal日志文件信息建立map中的初始数据；然后再调用processJournal();方法对刚刚建立起的map数据进行分析，分析的工作，一个是计算当前有效缓存文件（即被CLEAN的）的大小，一个是清理无用缓存文件；</p>
<p><strong>2.</strong>数据缓存与获取缓存：上面的初始化工作完成后，我们就可以在程序中进行数据的缓存功能和获取缓存的功能了；缓存数据的操作是借助DiskLruCache.Editor这个类完成的，这个类也是不能new的，需要调用DiskLruCache的edit()方法来获取实例，如：public Editor edit(String key) throws IOException。在写入完成后，需要进行commit()。</p>
<p>如下一个简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;    </div><div class="line">    <span class="meta">@Override</span>    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    </div><div class="line">        <span class="keyword">try</span> &#123;    </div><div class="line">            String imageUrl = <span class="string">"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg"</span>;    </div><div class="line">            String key = hashKeyForDisk(imageUrl);  <span class="comment">//MD5对url进行加密，这个主要是为了获得统一的16位字符  </span></div><div class="line">            DiskLruCache.Editor editor = mDiskLruCache.edit(key);  <span class="comment">//拿到Editor，往journal日志中写入DIRTY记录  </span></div><div class="line">            <span class="keyword">if</span> (editor != <span class="keyword">null</span>) &#123;    </div><div class="line">                OutputStream outputStream = editor.newOutputStream(<span class="number">0</span>);    </div><div class="line">                <span class="keyword">if</span> (downloadUrlToStream(imageUrl, outputStream)) &#123;  <span class="comment">//downloadUrlToStream方法为下载图片的方法，并且将输出流放到outputStream  </span></div><div class="line">                    editor.commit();  <span class="comment">//完成后记得commit()，成功后，再往journal日志中写入CLEAN记录  </span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;    </div><div class="line">                    editor.abort();  <span class="comment">//失败后，要remove缓存文件，往journal文件中写入REMOVE记录  </span></div><div class="line">                &#125;    </div><div class="line">            &#125;    </div><div class="line">            mDiskLruCache.flush();  <span class="comment">//将缓存操作同步到journal日志文件，不一定要在这里就调用  </span></div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;    </div><div class="line">            e.printStackTrace();    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<p><strong>注意</strong>每次调用edit()时，会向journal日志文件写入DIRTY为前缀的一条记录；文件保存成功后，调用commit()时，也会向journal日志中写入一条CLEAN为前缀的一条记录，如果失败，需要调用abort()，abort()里面会向journal文件写入一条REMOVE为前缀的记录。</p>
<p>获取缓存数据是通过get()方法实现的，如下一个简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;    </div><div class="line">    String imageUrl = <span class="string">"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg"</span>;    </div><div class="line">    String key = hashKeyForDisk(imageUrl);  <span class="comment">//MD5对url进行加密，这个主要是为了获得统一的16位字符  </span></div><div class="line">     <span class="comment">//通过get拿到value的Snapshot，里面封装了输入流、key等信息，调用get会向journal文件写入READ为前缀的记录  </span></div><div class="line">    DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key);   </div><div class="line">    <span class="keyword">if</span> (snapShot != <span class="keyword">null</span>) &#123;    </div><div class="line">        InputStream is = snapShot.getInputStream(<span class="number">0</span>);    </div><div class="line">        Bitmap bitmap = BitmapFactory.decodeStream(is);    </div><div class="line">        mImage.setImageBitmap(bitmap);    </div><div class="line">    &#125;    </div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;    </div><div class="line">    e.printStackTrace();    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>3.</strong>合适的地方进行flush()</p>
<p>在上面进行数据缓存或获取缓存的时候，调用不同的方法会往journal中写入不同前缀的一行记录，记录写入是通过IO下的Writer写入的，要真正生效，还需要调用writer的flush()方法，而DiskLruCache中的flush()方法中封装了writer.flush()的操作，因此，我们只需要在合适地方调用DiskLruCache中的flush()方法即可。其作用也就是将操作记录同步到journal文件中，这是一个消耗效率的IO操作，我们不用每次一往journal中写数据后就调用flush，这样对效率影响较大，可以在Activity的onPause()中调用一下即可。</p>
<h5 id="4-DiskLruCache总结"><a href="#4-DiskLruCache总结" class="headerlink" title="4.DiskLruCache总结"></a>4.DiskLruCache总结</h5><ul>
<li>我们可以在在UI线程中检测内存缓存，即主线程中可以直接使用LruCache；</li>
<li>使用DiskLruCache时，由于缓存或获取都需要对本地文件进行操作，因此需要另开一个线程，在子线程中检测磁盘缓存、保存缓存数据，磁盘操作从来不应该在UI线程中实现；</li>
<li>LruCache内存缓存的核心是LinkedHashMap，而DiskLruCache的核心是LinkedHashMap和journal日志文件，相当于把journal看作是一块“内存”，LinkedHashMap的value只保存文件的简要信息，对缓存文件的所有操作都会记录在journal日志文件中。</li>
</ul>
<h5 id="5-DiskLruCache优化"><a href="#5-DiskLruCache优化" class="headerlink" title="5.DiskLruCache优化"></a>5.DiskLruCache优化</h5><p>DiskLruCache是基于日志文件journal的，这就决定了每次对缓存文件的操作都需要进行日志文件的记录，我们可以不用journal文件，在第一次构造DiskLruCache的时候，直接从程序访问缓存目录下的缓存文件，并将每个缓存文件的访问时间作为初始值记录在map的value中，每次访问或保存缓存都更新相应key对应的缓存文件的访问时间，这样就避免了频繁的IO操作，这种情况下就需要使用单例模式对DiskLruCache进行构造了，下面要说的Acache轻量级的数据缓存类就是这种实现方式。</p>
<h3 id="四-一个轻量级缓存框架——ACache"><a href="#四-一个轻量级缓存框架——ACache" class="headerlink" title="四 一个轻量级缓存框架——ACache"></a>四 一个轻量级缓存框架——ACache</h3><p>ACache是一个轻量级的开源cache框架，实际上就是一个叫ACache的java类。已经在商业项目中使用，运行效果不错。</p>
<p>ACache类似于SharedPreferences，但是比SharedPreferences功能更加强大，SharedPreferences只能保存一些基本数据类型、Serializable、Bundle等数据。而Acache可以缓存如下数据：普通的字符串、JsonObject、JsonArray、Bitmap、Drawable、序列化的java对象，和 byte数据。</p>
<p>主要特色：</p>
<ul>
<li>轻，轻到只有一个JAVA文件。</li>
<li>可配置，可以配置缓存路径，缓存大小，缓存数量等。</li>
<li>可以设置缓存超时时间，缓存超时自动失效，并被删除。</li>
<li>支持多进程</li>
</ul>
<p>应用场景：</p>
<ul>
<li>替换SharePreference当做配置文件</li>
<li>可以缓存网络请求数据，比如oschina的android客户端可以缓存http请求的新闻内容，缓存时间假设为1个小时，超时后自动失效，让客户端重新请求新的数据，减少客户端流量，同时减少服务器并发量。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsListActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> List&lt;News&gt; list;</div><div class="line">  <span class="keyword">private</span> ListView listView;</div><div class="line">  <span class="keyword">private</span> LoadImageAdapter adapter;<span class="comment">//适配器</span></div><div class="line">  <span class="keyword">private</span> ACache acache;<span class="comment">//缓存框架</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    <span class="keyword">super</span>.setContentView(R.layout.load_img_listview_activity);</div><div class="line">    acache=ACache.get(<span class="keyword">this</span>);<span class="comment">//创建ACache组件</span></div><div class="line">    initView();<span class="comment">//初始化界面，代码不贴了</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span></span>&#123;</div><div class="line">   String cacheData=acache.getAsString(<span class="string">"newsList"</span>);<span class="comment">//从缓存中取数据</span></div><div class="line">   <span class="keyword">if</span>(cacheData!=<span class="keyword">null</span>)&#123;<span class="comment">//如果缓存中有，就不访问网络</span></div><div class="line">   List&lt;News&gt; newsList=gson.fromJson(cacheData, <span class="keyword">new</span> TypeToken&lt;List&lt;News&gt;&gt;()&#123;&#125;.getType());<span class="comment">//将json转为List</span></div><div class="line">      list.addAll(newsList);</div><div class="line">      adapter.notifyDataSetChanged();</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">     <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">       SystemClock.sleep(<span class="number">2000</span>);<span class="comment">//模拟网络耗时</span></div><div class="line">       String json=request();<span class="comment">//模拟从网络中获取json数据</span></div><div class="line">       acache.put(<span class="string">"newslist"</span>, json, <span class="number">60</span>*<span class="number">60</span>*<span class="number">1</span>);<span class="comment">//将数据存入缓存中，有效时间设置为1小时</span></div><div class="line">       List&lt;News&gt; newsList=gson.fromJson(json, <span class="keyword">new</span> TypeToken&lt;List&lt;News&gt;&gt;()&#123;&#125;.getType());</div><div class="line">       list.addAll(newsList);</div><div class="line">       handler.sendEmptyMessage(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">         </div><div class="line">  &#125;).start();</div><div class="line">&#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 模拟网络请求方法</div><div class="line">     * <span class="doctag">@return</span> json数据</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">request</span><span class="params">()</span></span>&#123;</div><div class="line">   News news=<span class="keyword">null</span>;</div><div class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">       news=<span class="keyword">new</span> News();</div><div class="line">       news.setId(i);</div><div class="line">       news.setImgUrl(<span class="string">"course/img/face_"</span>+i+<span class="string">".png"</span>);</div><div class="line">       news.setTitle(<span class="string">"新闻标题"</span>+i);</div><div class="line">       news.setSummary(<span class="string">"测试"</span>+i);</div><div class="line">       list.add(news);</div><div class="line">   &#125;</div><div class="line">   Gson gson=<span class="keyword">new</span> Gson();</div><div class="line">   <span class="keyword">return</span> gson.toJson(list);    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> Handler handler=<span class="keyword">new</span> Handler()</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">       <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">       <span class="keyword">switch</span>(msg.what)&#123;</div><div class="line">           <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">             notify_layout.setVisibility(View.GONE);</div><div class="line">             adapter.notifyDataSetChanged();</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/02/28/android基础之缓存/" data-id="cj0t8onkr001fponz39dlnpv6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/缓存/">缓存</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android基础之自定义View与ViewGroup" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/28/android基础之自定义View与ViewGroup/" class="article-date">
  <time datetime="2017-02-28T08:02:37.000Z" itemprop="datePublished">2017-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/28/android基础之自定义View与ViewGroup/">android基础之自定义View与ViewGroup</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>在android应用开发过程中，固定的一些控件和属性可能满足不了开发的需求，所以在一些特殊情况下，我们需要自定义控件与属性。ViewGroup亦继承于View，下面看View的绘制过程：</p>
<img src="/2017/02/28/android基础之自定义View与ViewGroup/View绘制过程.png" alt="View绘制过程" title="View绘制过程">
<h3 id="二-自定义View"><a href="#二-自定义View" class="headerlink" title="二 自定义View"></a>二 自定义View</h3><h5 id="1-实现步骤"><a href="#1-实现步骤" class="headerlink" title="1. 实现步骤"></a>1. 实现步骤</h5><ol>
<li>继承View类或其子类　</li>
<li>复写view中的一些函数</li>
<li>为自定义View类增加属性（两种方式）</li>
<li>绘制控件（导入布局）</li>
<li>响应用户事件</li>
<li>定义回调函数（根据自己需求来选择）</li>
</ol>
<h5 id="2-哪些方法需要被重写"><a href="#2-哪些方法需要被重写" class="headerlink" title="2.哪些方法需要被重写"></a>2.哪些方法需要被重写</h5><ul>
<li><p>onDraw()<br>view中onDraw()是个空函数，也就是说具体的视图都要覆写该函数来实现自己的绘制。对于ViewGroup则不需要实现该函数，因为作为容器是“没有内容“的（但必须实现dispatchDraw()函数，告诉子view绘制自己）。</p>
</li>
<li><p>onLayout()<br>主要是为viewGroup类型布局子视图用的，在View中这个函数为空函数。</p>
</li>
<li><p>onMeasure()<br>用于计算视图大小（即长和宽）的方式，并通过setMeasuredDimension(width, height)保存计算结果。</p>
</li>
<li><p>onTouchEvent<br>定义触屏事件来响应用户操作。</p>
</li>
</ul>
<p>还有一些不常用的方法：</p>
<ul>
<li>onKeyDown  当按下某个键盘时 　</li>
<li>onKeyUp 当松开某个键盘时 　 　　 　　</li>
<li>onTrackballEvent 当发生轨迹球事件时 　 　　 　　</li>
<li>onSizeChange() 当该组件的大小被改变时 　 　　 　　</li>
<li>onFinishInflate() 回调方法，当应用从XML加载该组件并用它构建界面之后调用的方法 　 　　 　　</li>
<li>onWindowFocusChanged(boolean) 当该组件得到、失去焦点时 　 　　</li>
<li>onAttachedToWindow() 当把该组件放入到某个窗口时 　 　　 　　</li>
<li>onDetachedFromWindow() 当把该组件从某个窗口上分离时触发的方法 　 　　 　　</li>
<li>onWindowVisibilityChanged(int): 当包含该组件的窗口的可见性发生改变时触发的方法 　</li>
</ul>
<h5 id="3-自定义控件的三种方式"><a href="#3-自定义控件的三种方式" class="headerlink" title="3. 自定义控件的三种方式"></a>3. 自定义控件的三种方式</h5><ul>
<li><p>继承已有的控件<br>当要实现的控件和已有的控件在很多方面比较类似, 通过对已有控件的扩展来满足要求。</p>
</li>
<li><p>继承一个布局文件<br>一般用于自定义组合控件，在构造函数中通过inflater和addView()方法加载自定义控件的布局文件形成图形界面（不需要onDraw方法）。</p>
</li>
<li><p>继承view<br>通过onDraw方法来绘制出组件界面。</p>
</li>
</ul>
<h5 id="4-自定义属性的两种方法"><a href="#4-自定义属性的两种方法" class="headerlink" title="4. 自定义属性的两种方法"></a>4. 自定义属性的两种方法</h5><ul>
<li>在布局文件中直接加入属性，在构造函数中去获得。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"</div><div class="line">    android:layout_width="match_parent"</div><div class="line">    android:layout_height="match_parent"</div><div class="line">    &gt;</div><div class="line">     &lt;com.example.demo.myView</div><div class="line">         android:layout_width="wrap_content"</div><div class="line">         android:layout_height="wrap_content" </div><div class="line">         Text="@string/hello_world"</div><div class="line">         /&gt;</div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>
<p>获取属性值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">myView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line"><span class="keyword">int</span> textId = attrs.getAttributeResourceValue(<span class="keyword">null</span>, <span class="string">"Text"</span>, <span class="number">0</span>);</div><div class="line">String text = context.getResources().getText(textId).toString();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>在res/values/ 下建立一个attrs.xml 来声明自定义view的属性。</li>
</ul>
<p>可以定义的属性有：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name = "名称"&gt; </div><div class="line">//参考某一资源ID (name可以随便命名)</div><div class="line">&lt;attr name = "background" format = "reference" /&gt; </div><div class="line">//颜色值 </div><div class="line">&lt;attr name = "textColor" format = "color" /&gt; </div><div class="line">//布尔值</div><div class="line">&lt;attr name = "focusable" format = "boolean" /&gt; </div><div class="line">//尺寸值 </div><div class="line">&lt;attr name = "layout_width" format = "dimension" /&gt; </div><div class="line">//浮点值 </div><div class="line">&lt;attr name = "fromAlpha" format = "float" /&gt; </div><div class="line">//整型值 </div><div class="line">&lt;attr name = "frameDuration" format="integer" /&gt; </div><div class="line">//字符串 </div><div class="line">&lt;attr name = "text" format = "string" /&gt; </div><div class="line">//百分数 </div><div class="line">&lt;attr name = "pivotX" format = "fraction" /&gt; </div><div class="line"></div><div class="line">//枚举值 </div><div class="line">&lt;attr name="orientation"&gt; </div><div class="line">&lt;enum name="horizontal" value="0" /&gt; </div><div class="line">&lt;enum name="vertical" value="1" /&gt; </div><div class="line">&lt;/attr&gt; </div><div class="line"></div><div class="line">//位或运算 </div><div class="line">&lt;attr name="windowSoftInputMode"&gt; </div><div class="line">&lt;flag name = "stateUnspecified" value = "0" /&gt; </div><div class="line">&lt;flag name = "stateUnchanged" value = "1" /&gt; </div><div class="line">&lt;/attr&gt; </div><div class="line"></div><div class="line">//多类型</div><div class="line">&lt;attr name = "background" format = "reference|color" /&gt; </div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure>
<p>attrs.xml进行属性声明</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;declare-styleable name="myView"&gt;</div><div class="line">        &lt;attr name="text" format="string"/&gt;</div><div class="line">        &lt;attr name="textColor" format="color"/&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<p>添加到布局文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"</div><div class="line">    android:layout_width="match_parent"</div><div class="line">    android:layout_height="match_parent"</div><div class="line">    xmlns:myview="http://schemas.android.com/apk/com.example.demo"</div><div class="line">    &gt;</div><div class="line">     &lt;com.example.demo.myView</div><div class="line">         android:layout_width="wrap_content"</div><div class="line">         android:layout_height="wrap_content" </div><div class="line">         myview:text = "test"</div><div class="line">         myview:textColor ="#ff0000"</div><div class="line">         /&gt;</div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>
<p>这里注意命名空间： xmlns:前缀=”<a href="http://schemas.android.com/apk/res/包名（或res-auto）”" target="_blank" rel="external">http://schemas.android.com/apk/res/包名（或res-auto）”</a>.</p>
<p>在构造函数中获取属性值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">myView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.myView); </div><div class="line">        String text = a.getString(R.styleable.myView_text); </div><div class="line">        <span class="keyword">int</span> textColor = a.getColor(R.styleable.myView_textColor, Color.WHITE); </div><div class="line"></div><div class="line">        a.recycle();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">myView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.myView); </div><div class="line">        <span class="keyword">int</span> n = a.getIndexCount();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">            <span class="keyword">int</span> attr = a.getIndex(i);</div><div class="line">            <span class="keyword">switch</span> (attr) &#123;</div><div class="line">            <span class="keyword">case</span> R.styleable.myView_text:</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> R.styleable.myView_textColor:</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">       a.recycle();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="5-代码示例"><a href="#5-代码示例" class="headerlink" title="5.代码示例"></a>5.代码示例</h5><p>实现一个随手指移动的小球。具体步骤：</p>
<ul>
<li>在res/values/ 下建立一个attrs.xml 来声明自定义view的属性</li>
<li>一个继承View并复写部分函数的自定义view的类</li>
<li>一个展示自定义view 的容器界面</li>
</ul>
<p>a .自定义view命名为myView，它有一个属性值，格式为color</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;declare-styleable name="myView"&gt;</div><div class="line">        &lt;attr name="TextColor" format="color"/&gt;</div><div class="line">    &lt;/declare-styleable&gt;        </div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<p>b. 在构造函数获取获得view的属性配置和复写onDraw和onTouchEvent函数实现绘制界面和用户事件响应</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myView</span> <span class="keyword">extends</span> <span class="title">View</span></span>&#123;</div><div class="line">    <span class="comment">//定义画笔和初始位置</span></div><div class="line">    Paint p = <span class="keyword">new</span> Paint();</div><div class="line">    <span class="keyword">public</span> <span class="keyword">float</span> currentX = <span class="number">50</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">float</span> currentY = <span class="number">50</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> textColor;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">myView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        <span class="comment">//获取资源文件里面的属性，由于这里只有一个属性值，不用遍历数组，直接通过R文件拿出color值</span></div><div class="line">        <span class="comment">//把属性放在资源文件里，方便设置和复用</span></div><div class="line">        TypedArray array = context.obtainStyledAttributes(attrs,R.styleable.myView);</div><div class="line">        textColor = array.getColor(R.styleable.myView_TextColor,Color.BLACK);</div><div class="line">        array.recycle();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">        <span class="comment">//画一个蓝色的圆形</span></div><div class="line">        p.setColor(Color.BLUE);</div><div class="line">        canvas.drawCircle(currentX,currentY,<span class="number">30</span>,p);</div><div class="line">        <span class="comment">//设置文字和颜色，这里的颜色是资源文件values里面的值</span></div><div class="line">        p.setColor(textColor);</div><div class="line">        canvas.drawText(<span class="string">"BY finch"</span>,currentX-<span class="number">30</span>,currentY+<span class="number">50</span>,p);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">        currentX = event.getX();</div><div class="line">        currentY = event.getY();</div><div class="line">        invalidate();<span class="comment">//重新绘制图形</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里通过不断的更新当前位置坐标和重新绘制图形实现效果，要注意的是使用TypedArray后一定要记得recycle(). 否则会对下次调用产生影响。</p>
<p>c. 把myView加入到activity_main.xml布局里面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"</div><div class="line">    xmlns:tools="http://schemas.android.com/tools"</div><div class="line">    android:layout_width="match_parent"</div><div class="line">    android:layout_height="match_parent"</div><div class="line">    xmlns:myview="http://schemas.android.com/apk/res-auto"</div><div class="line">    android:paddingBottom="@dimen/activity_vertical_margin"</div><div class="line">    android:paddingLeft="@dimen/activity_horizontal_margin"</div><div class="line">    android:paddingRight="@dimen/activity_horizontal_margin"</div><div class="line">    android:paddingTop="@dimen/activity_vertical_margin"</div><div class="line">    tools:context="finch.scu.cn.myview.MainActivity"&gt;</div><div class="line"></div><div class="line"></div><div class="line">    &lt;finch.scu.cn.myview.myView</div><div class="line">        android:layout_width="match_parent"</div><div class="line">        android:layout_height="match_parent"</div><div class="line">        myview:TextColor="#ff0000"</div><div class="line">        /&gt;</div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>
<p>d. 最后是MainActivity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注：具体的view要根据具体的需求来，比如我们要侧滑删除的listview我们可以继承listview，监听侧滑事件，显示删除按钮实现功能。</p>
<h3 id="三-自定义ViewGroup"><a href="#三-自定义ViewGroup" class="headerlink" title="三 自定义ViewGroup"></a>三 自定义ViewGroup</h3><p>自定义ViewGroup比自定义View要麻烦一些，因为ViewGroup需要去计算子View的大小以此来改变ViewGroup的大小，同时我们还要知道子View的摆放顺序。</p>
<h5 id="1-源码分析"><a href="#1-源码分析" class="headerlink" title="1.源码分析"></a>1.源码分析</h5><p>等我看了再说</p>
<p>自定义ViewGroup的时候一般复写：</p>
<ul>
<li>onMeasure()方法：<br>计算childView的测量值以及模式，以及设置自己的宽和高　 　　 </li>
<li>onLayout()方法<br>对其所有childView的位置进行定位</li>
</ul>
<h5 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2.代码示例"></a>2.代码示例</h5><ul>
<li>onMeasure方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 获得它的父容器为它设置的测量模式和大小</span></div><div class="line">        <span class="keyword">int</span> sizeWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        <span class="keyword">int</span> modeWidth = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        <span class="keyword">int</span> sizeHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">        <span class="keyword">int</span> modeHeight = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">        <span class="comment">// 用于warp_content情况下，来记录父view宽和高</span></div><div class="line">        <span class="keyword">int</span> width = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 取每一行宽度的最大值</span></div><div class="line">        <span class="keyword">int</span> lineWidth = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 每一行的高度累加</span></div><div class="line">        <span class="keyword">int</span> lineHeight = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 获得子view的个数</span></div><div class="line">        <span class="keyword">int</span> cCount = getChildCount();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cCount; i++)</div><div class="line">        &#123;</div><div class="line">            View child = getChildAt(i);</div><div class="line">            <span class="comment">// 测量子View的宽和高（子view在布局文件中是wrap_content）</span></div><div class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">            <span class="comment">// 得到LayoutParams</span></div><div class="line">            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">            <span class="comment">// 根据测量宽度加上Margin值算出子view的实际宽度（上文中有说明）</span></div><div class="line">            <span class="keyword">int</span> childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</div><div class="line">            <span class="comment">// 根据测量高度加上Margin值算出子view的实际高度</span></div><div class="line">            <span class="keyword">int</span> childHeight = child.getMeasuredHeight() + lp.topMargin+ lp.bottomMargin;</div><div class="line"></div><div class="line">            <span class="comment">// 这里的父view是有padding值的，如果再添加一个元素就超出最大宽度就换行</span></div><div class="line">            <span class="keyword">if</span> (lineWidth + childWidth &gt; sizeWidth - getPaddingLeft() - getPaddingRight())</div><div class="line">            &#123;</div><div class="line">                <span class="comment">// 父view宽度=以前父view宽度、当前行宽的最大值</span></div><div class="line">                width = Math.max(width, lineWidth);</div><div class="line">                <span class="comment">// 换行了，当前行宽=第一个view的宽度</span></div><div class="line">                lineWidth = childWidth;</div><div class="line">                <span class="comment">// 父view的高度=各行高度之和</span></div><div class="line">                height += lineHeight;</div><div class="line">                <span class="comment">//换行了，当前行高=第一个view的高度</span></div><div class="line">                lineHeight = childHeight;</div><div class="line">            &#125; <span class="keyword">else</span>&#123;</div><div class="line">                <span class="comment">// 叠加行宽</span></div><div class="line">                lineWidth += childWidth;</div><div class="line">                <span class="comment">// 得到当前行最大的高度</span></div><div class="line">                lineHeight = Math.max(lineHeight, childHeight);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 最后一个控件</span></div><div class="line">            <span class="keyword">if</span> (i == cCount - <span class="number">1</span>)</div><div class="line">            &#123;</div><div class="line">                width = Math.max(lineWidth, width);</div><div class="line">                height += lineHeight;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * EXACTLY对应match_parent 或具体值</div><div class="line">         * AT_MOST对应wrap_content</div><div class="line">         * 在FlowLayout布局文件中</div><div class="line">         * android:layout_width="fill_parent"</div><div class="line">         * android:layout_height="wrap_content"</div><div class="line">         *</div><div class="line">         * 如果是MeasureSpec.EXACTLY则直接使用父ViewGroup传入的宽和高，否则设置为自己计算的宽和高。</div><div class="line">         */</div><div class="line">        setMeasuredDimension(</div><div class="line">                modeWidth == MeasureSpec.EXACTLY ? sizeWidth : width + getPaddingLeft() + getPaddingRight(),</div><div class="line">                modeHeight == MeasureSpec.EXACTLY ? sizeHeight : height + getPaddingTop()+ getPaddingBottom()</div><div class="line">        );</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>onLayout方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//存储所有的View</span></div><div class="line">    <span class="keyword">private</span> List&lt;List&lt;View&gt;&gt; mAllViews = <span class="keyword">new</span> ArrayList&lt;List&lt;View&gt;&gt;();</div><div class="line">    <span class="comment">//存储每一行的高度</span></div><div class="line">    <span class="keyword">private</span> List&lt;Integer&gt; mLineHeight = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span></div><div class="line">    &#123;</div><div class="line">        mAllViews.clear();</div><div class="line">        mLineHeight.clear();</div><div class="line"></div><div class="line">        <span class="comment">// 当前ViewGroup的宽度</span></div><div class="line">        <span class="keyword">int</span> width = getWidth();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> lineWidth = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> lineHeight = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 存储每一行所有的childView</span></div><div class="line">        List&lt;View&gt; lineViews = <span class="keyword">new</span> ArrayList&lt;View&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> cCount = getChildCount();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cCount; i++)</div><div class="line">        &#123;</div><div class="line">            View child = getChildAt(i);</div><div class="line">            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">            <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</div><div class="line">            <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</div><div class="line"></div><div class="line">            lineWidth += childWidth + lp.leftMargin + lp.rightMargin;</div><div class="line">            lineHeight = Math.max(lineHeight, childHeight + lp.topMargin+ lp.bottomMargin);</div><div class="line">            lineViews.add(child);</div><div class="line"></div><div class="line">            <span class="comment">// 换行，在onMeasure中childWidth是加上Margin值的</span></div><div class="line">            <span class="keyword">if</span> (childWidth + lineWidth + lp.leftMargin + lp.rightMargin &gt; width - getPaddingLeft() - getPaddingRight())</div><div class="line">            &#123;</div><div class="line">                <span class="comment">// 记录行高</span></div><div class="line">                mLineHeight.add(lineHeight);</div><div class="line">                <span class="comment">// 记录当前行的Views</span></div><div class="line">                mAllViews.add(lineViews);</div><div class="line"></div><div class="line">                <span class="comment">// 新行的行宽和行高</span></div><div class="line">                lineWidth = <span class="number">0</span>;</div><div class="line">                lineHeight = childHeight + lp.topMargin + lp.bottomMargin;</div><div class="line">                <span class="comment">// 新行的View集合</span></div><div class="line">                lineViews = <span class="keyword">new</span> ArrayList&lt;View&gt;();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 处理最后一行</span></div><div class="line">        mLineHeight.add(lineHeight);</div><div class="line">        mAllViews.add(lineViews);</div><div class="line"></div><div class="line">        <span class="comment">// 设置子View的位置</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> left = getPaddingLeft();</div><div class="line">        <span class="keyword">int</span> top = getPaddingTop();</div><div class="line"></div><div class="line">        <span class="comment">// 行数</span></div><div class="line">        <span class="keyword">int</span> lineNum = mAllViews.size();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lineNum; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 当前行的所有的View</span></div><div class="line">            lineViews = mAllViews.get(i);</div><div class="line">            lineHeight = mLineHeight.get(i);</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lineViews.size(); j++)</div><div class="line">            &#123;</div><div class="line">                View child = lineViews.get(j);</div><div class="line">                <span class="comment">// 判断child的状态</span></div><div class="line">                <span class="keyword">if</span> (child.getVisibility() == View.GONE)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">                <span class="keyword">int</span> lc = left + lp.leftMargin;</div><div class="line">                <span class="keyword">int</span> tc = top + lp.topMargin;</div><div class="line">                <span class="keyword">int</span> rc = lc + child.getMeasuredWidth();</div><div class="line">                <span class="keyword">int</span> bc = tc + child.getMeasuredHeight();</div><div class="line"></div><div class="line">                <span class="comment">// 为子View进行布局</span></div><div class="line">                child.layout(lc, tc, rc, bc);</div><div class="line"></div><div class="line">                left += child.getMeasuredWidth() + lp.leftMargin+ lp.rightMargin;</div><div class="line">            &#125;</div><div class="line">            left = getPaddingLeft() ;</div><div class="line">            top += lineHeight ;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 因为我们只需要支持margin，所以直接使用系统的MarginLayoutParams</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MarginLayoutParams(getContext(), attrs);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>MainActivity.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">    LayoutInflater mInflater;</div><div class="line">    <span class="meta">@InjectView</span>(R.id.id_flowlayout1)</div><div class="line">    FlowLayout idFlowlayout1;</div><div class="line">    <span class="meta">@InjectView</span>(R.id.id_flowlayout2)</div><div class="line">    FlowLayout idFlowlayout2;</div><div class="line">    <span class="keyword">private</span> String[] mVals = <span class="keyword">new</span> String[]</div><div class="line">            &#123;<span class="string">"Do"</span>, <span class="string">"one thing"</span>, <span class="string">"at a time"</span>, <span class="string">"and do well."</span>, <span class="string">"Never"</span>, <span class="string">"forget"</span>,</div><div class="line">                    <span class="string">"to say"</span>, <span class="string">"thanks."</span>, <span class="string">"Keep on"</span>, <span class="string">"going "</span>, <span class="string">"never give up."</span>&#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        ButterKnife.inject(<span class="keyword">this</span>);</div><div class="line">        mInflater = LayoutInflater.from(<span class="keyword">this</span>);</div><div class="line">        initFlowlayout2();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initFlowlayout2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mVals.length; i++) &#123;</div><div class="line">            <span class="keyword">final</span> RelativeLayout rl2 = (RelativeLayout) mInflater.inflate(R.layout.flow_layout, idFlowlayout2, <span class="keyword">false</span>);</div><div class="line">            TextView tv2 = (TextView) rl2.findViewById(R.id.tv);</div><div class="line">            tv2.setText(mVals[i]);</div><div class="line">            rl2.setTag(i);</div><div class="line">            idFlowlayout2.addView(rl2);</div><div class="line">            rl2.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                    <span class="keyword">int</span> i = (<span class="keyword">int</span>) v.getTag();</div><div class="line">                    addViewToFlowlayout1(i);</div><div class="line">                    rl2.setBackgroundResource(R.drawable.flow_layout_disable_bg);</div><div class="line">                    rl2.setClickable(<span class="keyword">false</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewToFlowlayout1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">        RelativeLayout rl1 = (RelativeLayout) mInflater.inflate(R.layout.flow_layout, idFlowlayout1, <span class="keyword">false</span>);</div><div class="line">        ImageView iv = (ImageView) rl1.findViewById(R.id.iv);</div><div class="line">        iv.setVisibility(View.VISIBLE);</div><div class="line">        TextView tv1 = (TextView) rl1.findViewById(R.id.tv);</div><div class="line">        tv1.setText(mVals[i]);</div><div class="line">        rl1.setTag(i);</div><div class="line">        idFlowlayout1.addView(rl1);</div><div class="line">        rl1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                <span class="keyword">int</span> i = (<span class="keyword">int</span>) v.getTag();</div><div class="line">                idFlowlayout1.removeView(v);</div><div class="line">                View view = idFlowlayout2.getChildAt(i);</div><div class="line">                view.setClickable(<span class="keyword">true</span>);</div><div class="line">                view.setBackgroundResource(R.drawable.flow_layout_bg);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/02/28/android基础之自定义View与ViewGroup/" data-id="cj0t8onl60023ponz3aae8t4e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ViewGroup/">ViewGroup</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/view/">view</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android基础之BroadcastReceiver" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/27/android基础之BroadcastReceiver/" class="article-date">
  <time datetime="2017-02-27T06:48:31.000Z" itemprop="datePublished">2017-02-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/27/android基础之BroadcastReceiver/">android基础之BroadcastReceiver</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-BroadcastReceiver简介"><a href="#一-BroadcastReceiver简介" class="headerlink" title="一 BroadcastReceiver简介"></a>一 BroadcastReceiver简介</h3><p>广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。如：在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。</p>
<p>BroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。</p>
<p>当系统或应用发出广播时，将会扫描系统中的所有广播接收者，通过action匹配将广播发送给相应的接收者，接收者收到广播后将会产生一个广播接收者的实例，执行其中的onReceiver()这个方法；特别需要注意的是这个实例的生命周期只有10秒，如果10秒内没执行结束onReceiver()，系统将会报错。在onReceiver()执行完毕之后，该实例将会被销毁，所以不要在onReceiver()中执行耗时操作，也不要在里面创建子线程处理业务（因为可能子线程没处理完，接收者就被回收了，那么子线程也会跟着被回收掉）；正确的处理方法就是通过in调用activity或者service处理业务。</p>
<h3 id="二-BroadcastReceiver的两种注册方式"><a href="#二-BroadcastReceiver的两种注册方式" class="headerlink" title="二 BroadcastReceiver的两种注册方式"></a>二 BroadcastReceiver的两种注册方式</h3><h5 id="1-静态注册（推荐）"><a href="#1-静态注册（推荐）" class="headerlink" title="1.静态注册（推荐）"></a>1.静态注册（推荐）</h5><p>静态注册的广播接收者是一个常驻在系统中的全局监听器，当你在应用中配置了一个静态的BroadcastReceiver，安装了应用后而无论应用是否处于运行状态，广播接收者都是已经常驻在系统中了。同时应用里的所有receiver都在清单文件里面，方便查看。　 　　 　　要销毁掉静态注册的广播接收者，可以通过调用PackageManager将Receiver禁用。</p>
<p>在AndroidManifest.xml的application里面定义receiver并设置要接收的action。下面是代码示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt; receiver android:name = ".MyBroadcastReceiver" &gt; </div><div class="line"></div><div class="line"> &lt; intent-filter android:priority = "777" &gt;             </div><div class="line">&lt;action android:name = "android.provider.Telephony.SMS_RECEIVED" /&gt;</div><div class="line">&lt;/ intent-filter &gt; </div><div class="line"></div><div class="line">&lt;/ receiver &gt;</div></pre></td></tr></table></figure>
<p>这里的priority取值是　-1000到1000，值越大优先级越高，同时注意加上系统接收短信的限权。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt; uses-permission android:name =<span class="string">"android.permission.RECEIVE_SMS"</span> /&gt;</div></pre></td></tr></table></figure>
<h5 id="2-动态注册"><a href="#2-动态注册" class="headerlink" title="2.动态注册"></a>2.动态注册</h5><p>在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    MyBroadcastReceiver receiver;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 动态注册广播 (代码执行到这才会开始监听广播消息，并对广播消息作为相应的处理)</span></div><div class="line">        receiver = <span class="keyword">new</span> MyBroadcastReceiver();</div><div class="line">        IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter( <span class="string">"android.provider.Telephony.SMS_RECEIVED"</span> );</div><div class="line">        registerReceiver( receiver , intentFilter);</div><div class="line"></div><div class="line">        <span class="keyword">super</span>.onResume();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="comment">// 撤销注册 (撤销注册后广播接收者将不会再监听系统的广播消息)</span></div><div class="line">        unregisterReceiver(receiver);</div><div class="line">        <span class="keyword">super</span>.onPause();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接收广播示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">// action 名称</span></div><div class="line">String SMS_RECEIVED = <span class="string">"android.provider.Telephony.SMS_RECEIVED"</span> ;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (intent.getAction().equals( SMS_RECEIVED )) &#123;</div><div class="line">           <span class="comment">// 一个receiver可以接收多个action的，即可以有多个intent-filter，需要在onReceive里面对intent.getAction(action name)进行判断。</span></div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-静态注册和动态注册的区别"><a href="#3-静态注册和动态注册的区别" class="headerlink" title="3.静态注册和动态注册的区别"></a>3.静态注册和动态注册的区别</h5><ol>
<li>静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者； 　　动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。</li>
<li>当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。　 　　动态注册的广播接收者将会导致应用报错 　　而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。</li>
</ol>
<h3 id="三-发送广播"><a href="#三-发送广播" class="headerlink" title="三 发送广播"></a>三 发送广播</h3><p>发送广播主要有两种类型：</p>
<h5 id="1-普通广播"><a href="#1-普通广播" class="headerlink" title="1.普通广播"></a>1.普通广播</h5><p>应用在需要通知各个广播接收者的情况下使用，如 开机启动，使用方法：sendBroadcast()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"android.provider.Telephony.SMS_RECEIVED"</span>); </div><div class="line"><span class="comment">//通过intent传递少量数据</span></div><div class="line">intent.putExtra(<span class="string">"data"</span>, <span class="string">"finch"</span>); </div><div class="line"><span class="comment">// 发送普通广播</span></div><div class="line">sendBroadcast(Intent);</div></pre></td></tr></table></figure>
<p>普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，所有满足条件的 BroadcastReceiver 都会随机地执行其 onReceive() 方法。 　　同级别接收是先后是随机的；级别低的收到广播； 　　消息传递的效率比较高，并且无法中断广播的传播。</p>
<h5 id="有序广播"><a href="#有序广播" class="headerlink" title="有序广播"></a>有序广播</h5><p>应用在需要有特定拦截的场景下使用，如黑名单短信、电话拦截。</p>
<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sendOrderedBroadcast(intent, receiverPermission);</div></pre></td></tr></table></figure>
<p>receiverPermission ：一个接收器必须持以接收您的广播。如果为 null ，不经许可的要求（一般都为null）,如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//发送有序广播</span></div><div class="line">sendOrderedBroadcast(intent, <span class="keyword">null</span>);</div></pre></td></tr></table></figure>
<p>在有序广播中，我们可以在前一个广播接收者将处理好的数据传送给后面的广播接收者，也可以调用abortBroadcast()来终结广播的传播。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context arg0, Intent intent)</span> </span>&#123;</div><div class="line">　　<span class="comment">//获取上一个广播的bundle数据</span></div><div class="line">　　Bundle bundle = getResultExtras(<span class="keyword">true</span>);<span class="comment">//true：前一个广播没有结果时创建新的Bundle；false：不创建Bundle</span></div><div class="line">　　bundle.putString(<span class="string">"key"</span>, <span class="string">"777"</span>);</div><div class="line">　　<span class="comment">//将bundle数据放入广播中传给下一个广播接收者</span></div><div class="line">　　setResultExtras(bundle);　</div><div class="line">　　</div><div class="line">　　<span class="comment">//终止广播传给下一个广播接收者</span></div><div class="line">　　abortBroadcast();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>高级别的广播收到该广播后，可以决定把该广播是否截断掉。 　　同级别接收是先后是随机的，如果先接收到的把广播截断了，同级别的例外的接收者是无法收到该广播。 　</p>
<h5 id="异步广播"><a href="#异步广播" class="headerlink" title="异步广播"></a>异步广播</h5><p>使用方法：sendStickyBroadcast() ：</p>
<p>发出的Intent当接收Activity（动态注册）重新处于onResume状态之后就能重新接受到其Intent.（the Intent will be held to be re-broadcast to future receivers）。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Activity处于活跃的时候又会接受到它</p>
<p>发这个广播需要权限：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.BROADCAST_STICKY"</span> /&gt;</div></pre></td></tr></table></figure>
<p>卸载该广播：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">removeStickyBroadcast(intent);</div></pre></td></tr></table></figure>
<p>在卸载之前该intent会保留，接收者在可接收状态都能获得。</p>
<h5 id="异步有序广播"><a href="#异步有序广播" class="headerlink" title="异步有序广播"></a>异步有序广播</h5><p>使用方法：sendStickyOrderedBroadcast(intent, resultReceiver, scheduler, initialCode, initialData, initialExtras)：</p>
<p>这个方法具有有序广播的特性也有异步广播的特性；同时需要限权：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.BROADCAST_STICKY"</span> /&gt;</div></pre></td></tr></table></figure>
<h3 id="四-安全性"><a href="#四-安全性" class="headerlink" title="四 安全性"></a>四 安全性</h3><p>BroadcastReceiver的设计初衷就是从全局考虑的，可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言BroadcastReceiver是存在安全性问题的，相应问题及解决如下：   </p>
<ul>
<li>当应用程序发送某个广播时系统会将发送的Intent与系统中所有注册的BroadcastReceiver的IntentFilter进行匹配，若匹配成功则执行相应的onReceive函数。可以通过类似sendBroadcast(Intent, String)的接口在发送广播时指定接收者必须具备的permission。或通过Intent.setPackage设置广播仅对某个程序有效。</li>
<li>当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。对于动态注册的广播可以通过类似registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)的接口指定发送者必须具备的permission，对于静态注册的广播可以通过android:exported=”false”属性表示接收者对外部应用程序不可用，即不接受来自外部的广播。</li>
<li>上面两个问题其实都可以通过LocalBroadcastManager来解决，LocalBroadcastManager只会将广播限定在当前应用程序中。</li>
<li>使用android:protectionLevel</li>
</ul>
<p>android引入了LocalBroadcastManager解决在第4部分安全性介绍的一些问题，LocalBroadcastManager除了能解决BroadcastReceiver进程间安全性问题外，相对Context操作的BroadcastReceiver而言还具有更高的运行效率。使用LocalBroadcastManager需要引入Android Support Library，如何引入见Add Support Package。<br>本地广播通过LocalBroadcastManager.getInstance(context).sendBroadcast(intent)发送广播，LocalBroadcastManager.getInstance(context).registerReceiver注册服务，通过LocalBroadcastManager.getInstance(context).unregisterReceiver取消注册服务，其他同普通广播.</p>
<h3 id="五-一些常用的系统广播的action-和permission"><a href="#五-一些常用的系统广播的action-和permission" class="headerlink" title="五 一些常用的系统广播的action 和permission"></a>五 一些常用的系统广播的action 和permission</h3><h5 id="1-开机启动"><a href="#1-开机启动" class="headerlink" title="1.开机启动"></a>1.开机启动</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;action android:name=<span class="string">"android.intent.action.BOOT_COMPLETED"</span>/&gt; </div><div class="line"></div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.RECEIVE_BOOT_COMPLETED"</span> /&gt;</div></pre></td></tr></table></figure>
<h5 id="2-网络状态"><a href="#2-网络状态" class="headerlink" title="2.网络状态"></a>2.网络状态</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;action android:name=<span class="string">"android.net.conn.CONNECTIVITY_CHANGE"</span>/&gt;  </div><div class="line"></div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span>/&gt;</div></pre></td></tr></table></figure>
<p>网络是否可用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNetworkAvailable</span><span class="params">(Context context)</span> </span>&#123;  </div><div class="line">        ConnectivityManager mgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);  </div><div class="line">        NetworkInfo[] info = mgr.getAllNetworkInfo();  </div><div class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; info.length; i++) &#123;  </div><div class="line">      <span class="keyword">if</span> (info[i].getState() == NetworkInfo.State.CONNECTED) &#123;  </div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="3-电量变化"><a href="#3-电量变化" class="headerlink" title="3.电量变化"></a>3.电量变化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;action android:name=<span class="string">"android.intent.action.BATTERY_CHANGED"</span>/&gt;</div></pre></td></tr></table></figure>
<p>BroadcastReceiver 的onReceive方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;  </div><div class="line">        <span class="keyword">int</span> currLevel = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, <span class="number">0</span>);  <span class="comment">//当前电量  　</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> total = intent.getIntExtra(BatteryManager.EXTRA_SCALE, <span class="number">1</span>);    <span class="comment">//总电量  </span></div><div class="line">        <span class="keyword">int</span> percent = currLevel * <span class="number">100</span> / total;  </div><div class="line">        Log.i(TAG, <span class="string">"battery: "</span> + percent + <span class="string">"%"</span>);  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h3><ul>
<li>静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。</li>
<li>动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：1)这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。2)这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。</li>
<li>广播发出的时候，广播接收者接收的顺序如下：<br>1)当广播为普通广播时，有如下的接收顺序：  </li>
</ul>
<p>a、无视优先级<br>b、动态优先于静态<br>c、同优先级的动态广播接收器，先注册的大于后注册的<br>d、同优先级的静态广播接收器，先扫描的大于后扫描的　   </p>
<p>2）如果广播为有序广播，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：　<br>   　　 　　<br>a、优先级高的先接收　 　<br>b、同优先级的动静态广播接收器，动态优先于静态 　　<br>c、同优先级的动态广播接收器，先注册的大于后注册的 　　<br>d、同优先级的静态广播接收器，先扫描的大于后扫描的　   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/02/27/android基础之BroadcastReceiver/" data-id="cj0t8onj7000bponzqkmg05zf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BroadcastReceiver/">BroadcastReceiver</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>
</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <a href="/" class="logo">ZHENGRUI&#39;BLOG</a>
      &copy; 2017 zhengrui<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
    </div>
    

<script src="/js/jquery.min.js"></script>
<script src="/js/jquery.scrollLoading.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>