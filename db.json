<<<<<<< HEAD
{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-alex/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/js/jquery.scrollLoading.js","path":"js/jquery.scrollLoading.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/logo.png","path":"css/images/logo.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/logo@2x.png","path":"css/images/logo@2x.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY.png","path":"css/images/logoDIY.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY1.png","path":"css/images/logoDIY1.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY@2x.png","path":"css/images/logoDIY@2x.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/preloader.gif","path":"css/images/preloader.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/preloader@2x.gif","path":"css/images/preloader@2x.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-alex/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1488618504613},{"_id":"themes/hexo-theme-alex/_config.yml","hash":"ca4b7f45d37e50b44694dc382e7efbabe8031450","modified":1488618504623},{"_id":"themes/hexo-theme-alex/LICENSE","hash":"3975b7883caeb33f61fada7c0ef4add7ab189849","modified":1488618504618},{"_id":"themes/hexo-theme-alex/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1488618504762},{"_id":"themes/hexo-theme-alex/README.md","hash":"16ecb6438be08568d74c8004dbfc6302443d3cf7","modified":1488618504621},{"_id":"source/_posts/android基础之BroadcastReceiver.md","hash":"342460d7a06b0f76d14b268dfcc80463f67b595f","modified":1488892833393},{"_id":"source/_posts/android基础之Content-Providers.md","hash":"597177bd36f01ffab6961a78ac92c06d16a1032d","modified":1488892833393},{"_id":"source/_posts/android基础之Handler与AsycTask.md","hash":"032973bfecd6c0c85c219498421897abf3ab3ad7","modified":1489063662022},{"_id":"source/_posts/android基础之Fragments.md","hash":"12fa4fd214288d7a5fe33703ff8f5c583456110d","modified":1488892833408},{"_id":"source/_posts/android基础之Intents与Intent-Filters.md","hash":"54c43c29b923fe20a3f319e080570c42d5c5d903","modified":1489063662053},{"_id":"source/_posts/android基础之SQLite.md","hash":"b5bb90b94ae1c05873ac634bea451e8e39d341ca","modified":1489063662069},{"_id":"source/_posts/android基础之Service.md","hash":"49a1cf8e30a15f0d02742d1191fc4dd7abc58e02","modified":1488892833443},{"_id":"source/_posts/android基础之activity.md","hash":"883c8cdae9d4fd6c8a4162387edd48a6f6320da5","modified":1488618504198},{"_id":"source/_posts/android基础之loaders.md","hash":"2fdadfdfc3faebf37716c708442250a985b7756c","modified":1489063662069},{"_id":"source/_posts/android基础之事件分发机制.md","hash":"47abbe822597aaed83c455bf8d7c4e27240c4485","modified":1489063662069},{"_id":"source/_posts/android基础之数据存储.md","hash":"8dd38b7ff4752b487123eda0b357a42a1e5c87b9","modified":1488618504210},{"_id":"source/_posts/android基础之消息推送.md","hash":"e5b0daec1280a70265aa492fec5d6c051336dbf2","modified":1488618504212},{"_id":"source/_posts/android基础之缓存.md","hash":"7d2a32bc46cfd39b09b1005d139d4743a222d0db","modified":1489065398164},{"_id":"source/_posts/android基础之自定义View与ViewGroup.md","hash":"d937576cb8f13e24c071dd8b3681c73cd0bf71fc","modified":1488618504217},{"_id":"source/_posts/android基础之进程间通信.md","hash":"cbfc60b60fc51d0401e9ab44a42d3a07f6797ab3","modified":1488618504219},{"_id":"source/_posts/hexo搭建博客指南（一）-建站.md","hash":"b3c8ba76e5e9ad1a5649ed8416fa6a3f2fab51cf","modified":1488618504222},{"_id":"source/_posts/hexo搭建博客指南（二）-主题配置.md","hash":"8c8a96f91c6fda079957e7082ec9a503a6dea400","modified":1488618504225},{"_id":"themes/hexo-theme-alex/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1488618504738},{"_id":"themes/hexo-theme-alex/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1488618504741},{"_id":"themes/hexo-theme-alex/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1488618504743},{"_id":"themes/hexo-theme-alex/layout/layout.ejs","hash":"078e67744bd4e7ceba679fb812ee97e8002e5275","modified":1488618504754},{"_id":"themes/hexo-theme-alex/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1488618504757},{"_id":"themes/hexo-theme-alex/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1488618504758},{"_id":"themes/hexo-theme-alex/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1488618504760},{"_id":"themes/hexo-theme-alex/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1488618504766},{"_id":"source/_posts/android基础之Fragments/Fragment显示图.png","hash":"690d35d73cede5e01eafba3fdd882ad0757e8009","modified":1488892833424},{"_id":"source/_posts/android基础之Fragments/Fragment与Activity生命周期对比.png","hash":"21a7ffdf3a9e7e39f0e4a8856e327d8a18ff21cc","modified":1488892833408},{"_id":"themes/hexo-theme-alex/layout/_widget/archive.ejs","hash":"985fbeb01142b9d526cda8ebc372c1d361d69a6b","modified":1488618504721},{"_id":"themes/hexo-theme-alex/layout/_widget/category.ejs","hash":"36ab37878129d152e3cbdeb839c08e52af1acd58","modified":1488618504725},{"_id":"themes/hexo-theme-alex/layout/_widget/links.ejs","hash":"318be0f32af263da1be4008ccf20787f822ed432","modified":1488618504727},{"_id":"themes/hexo-theme-alex/layout/_widget/tagcloud.ejs","hash":"34dc8cdd96cdb41dd11cb7513f13714373e5104a","modified":1488618504736},{"_id":"themes/hexo-theme-alex/layout/_widget/recent_posts.ejs","hash":"feba7c00fa59ba13bf870b358a499fde4473d335","modified":1488618504731},{"_id":"themes/hexo-theme-alex/layout/_widget/tag.ejs","hash":"b3f321ddda6be2702a286d5b11af9533509506fb","modified":1488618504733},{"_id":"themes/hexo-theme-alex/layout/_partial/after-footer.ejs","hash":"a1c591be86d0e0c6449569350f426ebdd380e2da","modified":1488618504634},{"_id":"themes/hexo-theme-alex/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1488618504637},{"_id":"themes/hexo-theme-alex/layout/_partial/archive.ejs","hash":"b1bb284854b49b33f8e4e1dd7b19ad23c2ef400b","modified":1488618504644},{"_id":"themes/hexo-theme-alex/layout/_partial/article.ejs","hash":"01201725258ad2aaee606cd4dfdebc21b646def1","modified":1488618504654},{"_id":"themes/hexo-theme-alex/layout/_partial/footer.ejs","hash":"bc42c074cc9e9afaced1468c609133383ec18b7f","modified":1488618504663},{"_id":"themes/hexo-theme-alex/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1488618504670},{"_id":"themes/hexo-theme-alex/layout/_partial/head.ejs","hash":"b9c850fb9b2b2d1ed1b00ede0fb84aba2f0a2ad5","modified":1488618504683},{"_id":"themes/hexo-theme-alex/layout/_partial/mobile-nav.ejs","hash":"0ba828315ec227b50e6b1b1c3324d96cc5969b12","modified":1488618504690},{"_id":"themes/hexo-theme-alex/layout/_partial/header.ejs","hash":"440864ad9678ee76215681a181b8614bd19573f0","modified":1488618504687},{"_id":"themes/hexo-theme-alex/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1488618504719},{"_id":"themes/hexo-theme-alex/source/css/_extend.styl","hash":"62d2a9d209cd703bea93cc1d56ee65414548de0f","modified":1488618504769},{"_id":"themes/hexo-theme-alex/source/css/_variables.styl","hash":"1bc807ac8d56ad3db8b5a1aea34d991d225ed96c","modified":1488618504816},{"_id":"themes/hexo-theme-alex/source/css/_retina.styl","hash":"1c0d8ae08c7853af2238ddbf4d51b6c16b3b8424","modified":1488618504803},{"_id":"themes/hexo-theme-alex/source/css/style.styl","hash":"a84823539dd8e1dd737cda043d60d99e84bb056f","modified":1488618504855},{"_id":"themes/hexo-theme-alex/source/js/jquery.scrollLoading.js","hash":"1a3eab1ab2c4644fe1ada921bd1bdb083268a751","modified":1488618504922},{"_id":"themes/hexo-theme-alex/source/js/script.js","hash":"26f3e43ae838afa8ebc91fa1732374f8836a9f17","modified":1488618504923},{"_id":"themes/hexo-theme-alex/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1488618504856},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1488618504857},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1488618504856},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1488618504858},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1488618504858},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1488618504859},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1488618504865},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1488618504877},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1488618504889},{"_id":"source/_posts/android基础之Fragments/Fragment生命周期图.png","hash":"f100e3a864b1be55e28bb2ae6f69580c4874dbbc","modified":1488892833424},{"_id":"source/_posts/android基础之Service/Service生命周期图.png","hash":"8f58fa262d06b6ea8e20ca738da45a6c06d42ecb","modified":1488892833445},{"_id":"source/_posts/android基础之activity/activity生命周期图.png","hash":"ca76d44f5128a045a225f3597fad78a811f0c70d","modified":1488618504202},{"_id":"source/_posts/android基础之activity/activity回调方法汇总.png","hash":"283ffc1469fb33b9df2501d34328db84f14cdf0f","modified":1488618504200},{"_id":"source/_posts/android基础之activity/Activity状态保存示意图.png","hash":"a3fb8aab955cb5e40f1b18d7e1b5c1c2b5df37f6","modified":1488618504199},{"_id":"themes/hexo-theme-alex/source/js/jquery.min.js","hash":"a6eedf84389e1bc9f757bc2d19538f8c8d1cae9d","modified":1488618504916},{"_id":"themes/hexo-theme-alex/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1488618504699},{"_id":"themes/hexo-theme-alex/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1488618504704},{"_id":"themes/hexo-theme-alex/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1488618504696},{"_id":"themes/hexo-theme-alex/layout/_partial/post/nav.ejs","hash":"f26d30355ba9144c51e700e8edc6a4ab6144ff9a","modified":1488618504707},{"_id":"themes/hexo-theme-alex/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1488618504712},{"_id":"themes/hexo-theme-alex/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1488618504714},{"_id":"themes/hexo-theme-alex/source/css/_partial/archive.styl","hash":"88c83feb723a7e1b8aec22c844b2855a9476c936","modified":1488618504771},{"_id":"themes/hexo-theme-alex/source/css/_partial/article.styl","hash":"2c0bb6ea7103d1ccb7ca25f17a4ee600189fdc84","modified":1488618504776},{"_id":"themes/hexo-theme-alex/source/css/_partial/footer.styl","hash":"64da3db168cca46d063a83a51914900393158edd","modified":1488618504781},{"_id":"themes/hexo-theme-alex/source/css/_partial/header.styl","hash":"2a6ae848e2aa80a040e051ea799a50bc63d0c1a7","modified":1488618504783},{"_id":"themes/hexo-theme-alex/source/css/_partial/highlight.styl","hash":"f39e8380fc92d8625d7361cb6cc4a749973f3f63","modified":1488618504789},{"_id":"themes/hexo-theme-alex/source/css/_partial/comment.styl","hash":"cbf757e5b22a7c6dbdd02eb485b9f04179543fe7","modified":1488618504778},{"_id":"themes/hexo-theme-alex/source/css/_partial/mobile.styl","hash":"373dff761e77307b707a63b96d881952729cbe76","modified":1488618504791},{"_id":"themes/hexo-theme-alex/source/css/_partial/sidebar-aside.styl","hash":"431c4672d1cf4c85b6ed2822bc12f6001c3e610a","modified":1488618504793},{"_id":"themes/hexo-theme-alex/source/css/_partial/sidebar-bottom.styl","hash":"bc5487b9a0bfe5f745423331824d3f3637ccd430","modified":1488618504795},{"_id":"themes/hexo-theme-alex/source/css/_partial/tablet.styl","hash":"3332acee57bada31635c3fc8d9e3d45dbeb06032","modified":1488618504800},{"_id":"themes/hexo-theme-alex/source/css/_partial/sidebar.styl","hash":"6649a55ff3645508e41be92c5217cc1ca88fcf0a","modified":1488618504798},{"_id":"themes/hexo-theme-alex/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1488618504808},{"_id":"themes/hexo-theme-alex/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1488618504811},{"_id":"themes/hexo-theme-alex/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1488618504821},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1488618504831},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1488618504847},{"_id":"themes/hexo-theme-alex/source/css/images/logo.png","hash":"d1f41cf04419f22cd15b9e36e0658a7654796036","modified":1488618504848},{"_id":"themes/hexo-theme-alex/source/css/images/logo@2x.png","hash":"f02ae098f6676a0e8d945f13d8150965a2f66985","modified":1488618504849},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY.png","hash":"1d8447ba649e78a1b9b30cecf3424f9c29fa23a9","modified":1488618504849},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY1.png","hash":"649ede0e15de250b8c965932c3802a84bea4141d","modified":1488618504850},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY@2x.png","hash":"82ee4b7dfaf1a57e2ac5c6a6ce4bcc6a1c372b57","modified":1488618504850},{"_id":"themes/hexo-theme-alex/source/css/images/preloader.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1488618504851},{"_id":"themes/hexo-theme-alex/source/css/images/preloader@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1488618504852},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1488618504859},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1488618504862},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1488618504863},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1488618504864},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1488618504865},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1488618504864},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1488618504844},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1488618504839}],"Category":[{"name":"android","_id":"cj02g6grz00027c02xlure3bg"},{"name":"hexo","_id":"cj02g6gt100177c0242c1hm4t"}],"Data":[],"Page":[],"Post":[{"title":"android基础之BroadcastReceiver","date":"2017-02-27T06:48:31.000Z","_content":"\n### 一 BroadcastReceiver简介\n\n广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。如：在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。\n\nBroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。\n\n当系统或应用发出广播时，将会扫描系统中的所有广播接收者，通过action匹配将广播发送给相应的接收者，接收者收到广播后将会产生一个广播接收者的实例，执行其中的onReceiver()这个方法；特别需要注意的是这个实例的生命周期只有10秒，如果10秒内没执行结束onReceiver()，系统将会报错。在onReceiver()执行完毕之后，该实例将会被销毁，所以不要在onReceiver()中执行耗时操作，也不要在里面创建子线程处理业务（因为可能子线程没处理完，接收者就被回收了，那么子线程也会跟着被回收掉）；正确的处理方法就是通过in调用activity或者service处理业务。\n\n### 二 BroadcastReceiver的两种注册方式\n\n##### 1.静态注册（推荐）\n\n静态注册的广播接收者是一个常驻在系统中的全局监听器，当你在应用中配置了一个静态的BroadcastReceiver，安装了应用后而无论应用是否处于运行状态，广播接收者都是已经常驻在系统中了。同时应用里的所有receiver都在清单文件里面，方便查看。　 　　 　　要销毁掉静态注册的广播接收者，可以通过调用PackageManager将Receiver禁用。\n\n在AndroidManifest.xml的application里面定义receiver并设置要接收的action。下面是代码示例：\n\n```java\n< receiver android:name = \".MyBroadcastReceiver\" > \n\n < intent-filter android:priority = \"777\" >             \n<action android:name = \"android.provider.Telephony.SMS_RECEIVED\" />\n</ intent-filter > \n\n</ receiver >\n```\n\n这里的priority取值是　-1000到1000，值越大优先级越高，同时注意加上系统接收短信的限权。\n\n```java\n< uses-permission android:name =\"android.permission.RECEIVE_SMS\" />\n```\n\n##### 2.动态注册\n\n在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载. \n\n```java\npublic class MainActivity extends Activity {\n    MyBroadcastReceiver receiver;\n    @Override\n     protected void onResume() {\n        // 动态注册广播 (代码执行到这才会开始监听广播消息，并对广播消息作为相应的处理)\n        receiver = new MyBroadcastReceiver();\n        IntentFilter intentFilter = new IntentFilter( \"android.provider.Telephony.SMS_RECEIVED\" );\n        registerReceiver( receiver , intentFilter);\n\n        super.onResume();\n    }\n    @Override\n    protected void onPause() {  \n        // 撤销注册 (撤销注册后广播接收者将不会再监听系统的广播消息)\n        unregisterReceiver(receiver);\n        super.onPause();\n    }\n}\n```\n\n接收广播示例：\n\n```java\npublic class MyBroadcastReceiver extends BroadcastReceiver {\n\n// action 名称\nString SMS_RECEIVED = \"android.provider.Telephony.SMS_RECEIVED\" ;\n\n    public void onReceive(Context context, Intent intent) {\n\n       if (intent.getAction().equals( SMS_RECEIVED )) {\n           // 一个receiver可以接收多个action的，即可以有多个intent-filter，需要在onReceive里面对intent.getAction(action name)进行判断。\n       }\n    }\n}\n```\n\n##### 3.静态注册和动态注册的区别\n\n1. 静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者； 　　动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。\n2. 当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。　 　　动态注册的广播接收者将会导致应用报错 　　而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。\n\n### 三 发送广播\n\n发送广播主要有两种类型：\n\n##### 1.普通广播\n\n应用在需要通知各个广播接收者的情况下使用，如 开机启动，使用方法：sendBroadcast()。\n\n```java\nIntent intent = new Intent(\"android.provider.Telephony.SMS_RECEIVED\"); \n//通过intent传递少量数据\nintent.putExtra(\"data\", \"finch\"); \n// 发送普通广播\nsendBroadcast(Intent); \n```\n\n普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，所有满足条件的 BroadcastReceiver 都会随机地执行其 onReceive() 方法。 　　同级别接收是先后是随机的；级别低的收到广播； 　　消息传递的效率比较高，并且无法中断广播的传播。\n\n##### 有序广播\n\n应用在需要有特定拦截的场景下使用，如黑名单短信、电话拦截。\n\n使用方法：\n\n```java\nsendOrderedBroadcast(intent, receiverPermission);\n```\n\nreceiverPermission ：一个接收器必须持以接收您的广播。如果为 null ，不经许可的要求（一般都为null）,如：\n\n\n```java\n//发送有序广播\nsendOrderedBroadcast(intent, null);\n```\n\n在有序广播中，我们可以在前一个广播接收者将处理好的数据传送给后面的广播接收者，也可以调用abortBroadcast()来终结广播的传播。\n\n```java\npublic void onReceive(Context arg0, Intent intent) {\n　　//获取上一个广播的bundle数据\n　　Bundle bundle = getResultExtras(true);//true：前一个广播没有结果时创建新的Bundle；false：不创建Bundle\n　　bundle.putString(\"key\", \"777\");\n　　//将bundle数据放入广播中传给下一个广播接收者\n　　setResultExtras(bundle);　\n　　\n　　//终止广播传给下一个广播接收者\n　　abortBroadcast();\n}\n```\n\n高级别的广播收到该广播后，可以决定把该广播是否截断掉。 　　同级别接收是先后是随机的，如果先接收到的把广播截断了，同级别的例外的接收者是无法收到该广播。 　\n\n##### 异步广播\n\n使用方法：sendStickyBroadcast() ：\n\n发出的Intent当接收Activity（动态注册）重新处于onResume状态之后就能重新接受到其Intent.（the Intent will be held to be re-broadcast to future receivers）。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Activity处于活跃的时候又会接受到它\n\n发这个广播需要权限：\n\n```java\n<uses-permission android:name=\"android.permission.BROADCAST_STICKY\" />\n```\n\n卸载该广播：\n\n```java\nremoveStickyBroadcast(intent);\n```\n\n在卸载之前该intent会保留，接收者在可接收状态都能获得。\n\n##### 异步有序广播\n\n使用方法：sendStickyOrderedBroadcast(intent, resultReceiver, scheduler, initialCode, initialData, initialExtras)：\n\n这个方法具有有序广播的特性也有异步广播的特性；同时需要限权：\n\n```java\n<uses-permission android:name=\"android.permission.BROADCAST_STICKY\" /> \n```\n\n### 四 安全性\n\nBroadcastReceiver的设计初衷就是从全局考虑的，可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言BroadcastReceiver是存在安全性问题的，相应问题及解决如下：   \n\n- 当应用程序发送某个广播时系统会将发送的Intent与系统中所有注册的BroadcastReceiver的IntentFilter进行匹配，若匹配成功则执行相应的onReceive函数。可以通过类似sendBroadcast(Intent, String)的接口在发送广播时指定接收者必须具备的permission。或通过Intent.setPackage设置广播仅对某个程序有效。\n- 当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。对于动态注册的广播可以通过类似registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)的接口指定发送者必须具备的permission，对于静态注册的广播可以通过android:exported=\"false\"属性表示接收者对外部应用程序不可用，即不接受来自外部的广播。\n- 上面两个问题其实都可以通过LocalBroadcastManager来解决，LocalBroadcastManager只会将广播限定在当前应用程序中。\n- 使用android:protectionLevel\n\nandroid引入了LocalBroadcastManager解决在第4部分安全性介绍的一些问题，LocalBroadcastManager除了能解决BroadcastReceiver进程间安全性问题外，相对Context操作的BroadcastReceiver而言还具有更高的运行效率。使用LocalBroadcastManager需要引入Android Support Library，如何引入见Add Support Package。\n本地广播通过LocalBroadcastManager.getInstance(context).sendBroadcast(intent)发送广播，LocalBroadcastManager.getInstance(context).registerReceiver注册服务，通过LocalBroadcastManager.getInstance(context).unregisterReceiver取消注册服务，其他同普通广播.\n\n### 五 一些常用的系统广播的action 和permission\n\n##### 1.开机启动\n\n```java\n<action android:name=\"android.intent.action.BOOT_COMPLETED\"/> \n\n<uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\" />  \n\n```\n\n##### 2.网络状态\n\n```java\n<action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\"/>  \n\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/> \n\n```\n\n网络是否可用的方法：\n\n```java\npublic static boolean isNetworkAvailable(Context context) {  \n        ConnectivityManager mgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);  \n        NetworkInfo[] info = mgr.getAllNetworkInfo();  \n        if (info != null) {  \n            for (int i = 0; i < info.length; i++) {  \n      if (info[i].getState() == NetworkInfo.State.CONNECTED) {  \n                    return true;  \n                }  \n            }  \n        }  \n        return false;  \n    } \n```\n\n##### 3.电量变化\n\n```java\n<action android:name=\"android.intent.action.BATTERY_CHANGED\"/>  \n```\n\nBroadcastReceiver 的onReceive方法：\n\n```java\npublic void onReceive(Context context, Intent intent) {  \n        int currLevel = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, 0);  //当前电量  　\n\n        int total = intent.getIntExtra(BatteryManager.EXTRA_SCALE, 1);    //总电量  \n        int percent = currLevel * 100 / total;  \n        Log.i(TAG, \"battery: \" + percent + \"%\");  \n    }  \n\n```\n\n\n\n### 六 总结\n\n- 静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。\n- 动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：1)这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。2)这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。\n- 广播发出的时候，广播接收者接收的顺序如下：    \n1)当广播为普通广播时，有如下的接收顺序：  \n\na、无视优先级   \nb、动态优先于静态    \nc、同优先级的动态广播接收器，先注册的大于后注册的   \nd、同优先级的静态广播接收器，先扫描的大于后扫描的　   \n\n2）如果广播为有序广播，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：　 \n   　　 　　\na、优先级高的先接收　 　  \nb、同优先级的动静态广播接收器，动态优先于静态 　　  \nc、同优先级的动态广播接收器，先注册的大于后注册的 　　  \nd、同优先级的静态广播接收器，先扫描的大于后扫描的　   ","source":"_posts/android基础之BroadcastReceiver.md","raw":"---\ntitle: android基础之BroadcastReceiver\ndate: 2017-02-27 14:48:31\ncategories: android\ntags:\n- android\n- java\n- BroadcastReceiver\n---\n\n### 一 BroadcastReceiver简介\n\n广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。如：在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。\n\nBroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。\n\n当系统或应用发出广播时，将会扫描系统中的所有广播接收者，通过action匹配将广播发送给相应的接收者，接收者收到广播后将会产生一个广播接收者的实例，执行其中的onReceiver()这个方法；特别需要注意的是这个实例的生命周期只有10秒，如果10秒内没执行结束onReceiver()，系统将会报错。在onReceiver()执行完毕之后，该实例将会被销毁，所以不要在onReceiver()中执行耗时操作，也不要在里面创建子线程处理业务（因为可能子线程没处理完，接收者就被回收了，那么子线程也会跟着被回收掉）；正确的处理方法就是通过in调用activity或者service处理业务。\n\n### 二 BroadcastReceiver的两种注册方式\n\n##### 1.静态注册（推荐）\n\n静态注册的广播接收者是一个常驻在系统中的全局监听器，当你在应用中配置了一个静态的BroadcastReceiver，安装了应用后而无论应用是否处于运行状态，广播接收者都是已经常驻在系统中了。同时应用里的所有receiver都在清单文件里面，方便查看。　 　　 　　要销毁掉静态注册的广播接收者，可以通过调用PackageManager将Receiver禁用。\n\n在AndroidManifest.xml的application里面定义receiver并设置要接收的action。下面是代码示例：\n\n```java\n< receiver android:name = \".MyBroadcastReceiver\" > \n\n < intent-filter android:priority = \"777\" >             \n<action android:name = \"android.provider.Telephony.SMS_RECEIVED\" />\n</ intent-filter > \n\n</ receiver >\n```\n\n这里的priority取值是　-1000到1000，值越大优先级越高，同时注意加上系统接收短信的限权。\n\n```java\n< uses-permission android:name =\"android.permission.RECEIVE_SMS\" />\n```\n\n##### 2.动态注册\n\n在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载. \n\n```java\npublic class MainActivity extends Activity {\n    MyBroadcastReceiver receiver;\n    @Override\n     protected void onResume() {\n        // 动态注册广播 (代码执行到这才会开始监听广播消息，并对广播消息作为相应的处理)\n        receiver = new MyBroadcastReceiver();\n        IntentFilter intentFilter = new IntentFilter( \"android.provider.Telephony.SMS_RECEIVED\" );\n        registerReceiver( receiver , intentFilter);\n\n        super.onResume();\n    }\n    @Override\n    protected void onPause() {  \n        // 撤销注册 (撤销注册后广播接收者将不会再监听系统的广播消息)\n        unregisterReceiver(receiver);\n        super.onPause();\n    }\n}\n```\n\n接收广播示例：\n\n```java\npublic class MyBroadcastReceiver extends BroadcastReceiver {\n\n// action 名称\nString SMS_RECEIVED = \"android.provider.Telephony.SMS_RECEIVED\" ;\n\n    public void onReceive(Context context, Intent intent) {\n\n       if (intent.getAction().equals( SMS_RECEIVED )) {\n           // 一个receiver可以接收多个action的，即可以有多个intent-filter，需要在onReceive里面对intent.getAction(action name)进行判断。\n       }\n    }\n}\n```\n\n##### 3.静态注册和动态注册的区别\n\n1. 静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者； 　　动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。\n2. 当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。　 　　动态注册的广播接收者将会导致应用报错 　　而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。\n\n### 三 发送广播\n\n发送广播主要有两种类型：\n\n##### 1.普通广播\n\n应用在需要通知各个广播接收者的情况下使用，如 开机启动，使用方法：sendBroadcast()。\n\n```java\nIntent intent = new Intent(\"android.provider.Telephony.SMS_RECEIVED\"); \n//通过intent传递少量数据\nintent.putExtra(\"data\", \"finch\"); \n// 发送普通广播\nsendBroadcast(Intent); \n```\n\n普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，所有满足条件的 BroadcastReceiver 都会随机地执行其 onReceive() 方法。 　　同级别接收是先后是随机的；级别低的收到广播； 　　消息传递的效率比较高，并且无法中断广播的传播。\n\n##### 有序广播\n\n应用在需要有特定拦截的场景下使用，如黑名单短信、电话拦截。\n\n使用方法：\n\n```java\nsendOrderedBroadcast(intent, receiverPermission);\n```\n\nreceiverPermission ：一个接收器必须持以接收您的广播。如果为 null ，不经许可的要求（一般都为null）,如：\n\n\n```java\n//发送有序广播\nsendOrderedBroadcast(intent, null);\n```\n\n在有序广播中，我们可以在前一个广播接收者将处理好的数据传送给后面的广播接收者，也可以调用abortBroadcast()来终结广播的传播。\n\n```java\npublic void onReceive(Context arg0, Intent intent) {\n　　//获取上一个广播的bundle数据\n　　Bundle bundle = getResultExtras(true);//true：前一个广播没有结果时创建新的Bundle；false：不创建Bundle\n　　bundle.putString(\"key\", \"777\");\n　　//将bundle数据放入广播中传给下一个广播接收者\n　　setResultExtras(bundle);　\n　　\n　　//终止广播传给下一个广播接收者\n　　abortBroadcast();\n}\n```\n\n高级别的广播收到该广播后，可以决定把该广播是否截断掉。 　　同级别接收是先后是随机的，如果先接收到的把广播截断了，同级别的例外的接收者是无法收到该广播。 　\n\n##### 异步广播\n\n使用方法：sendStickyBroadcast() ：\n\n发出的Intent当接收Activity（动态注册）重新处于onResume状态之后就能重新接受到其Intent.（the Intent will be held to be re-broadcast to future receivers）。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Activity处于活跃的时候又会接受到它\n\n发这个广播需要权限：\n\n```java\n<uses-permission android:name=\"android.permission.BROADCAST_STICKY\" />\n```\n\n卸载该广播：\n\n```java\nremoveStickyBroadcast(intent);\n```\n\n在卸载之前该intent会保留，接收者在可接收状态都能获得。\n\n##### 异步有序广播\n\n使用方法：sendStickyOrderedBroadcast(intent, resultReceiver, scheduler, initialCode, initialData, initialExtras)：\n\n这个方法具有有序广播的特性也有异步广播的特性；同时需要限权：\n\n```java\n<uses-permission android:name=\"android.permission.BROADCAST_STICKY\" /> \n```\n\n### 四 安全性\n\nBroadcastReceiver的设计初衷就是从全局考虑的，可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言BroadcastReceiver是存在安全性问题的，相应问题及解决如下：   \n\n- 当应用程序发送某个广播时系统会将发送的Intent与系统中所有注册的BroadcastReceiver的IntentFilter进行匹配，若匹配成功则执行相应的onReceive函数。可以通过类似sendBroadcast(Intent, String)的接口在发送广播时指定接收者必须具备的permission。或通过Intent.setPackage设置广播仅对某个程序有效。\n- 当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。对于动态注册的广播可以通过类似registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)的接口指定发送者必须具备的permission，对于静态注册的广播可以通过android:exported=\"false\"属性表示接收者对外部应用程序不可用，即不接受来自外部的广播。\n- 上面两个问题其实都可以通过LocalBroadcastManager来解决，LocalBroadcastManager只会将广播限定在当前应用程序中。\n- 使用android:protectionLevel\n\nandroid引入了LocalBroadcastManager解决在第4部分安全性介绍的一些问题，LocalBroadcastManager除了能解决BroadcastReceiver进程间安全性问题外，相对Context操作的BroadcastReceiver而言还具有更高的运行效率。使用LocalBroadcastManager需要引入Android Support Library，如何引入见Add Support Package。\n本地广播通过LocalBroadcastManager.getInstance(context).sendBroadcast(intent)发送广播，LocalBroadcastManager.getInstance(context).registerReceiver注册服务，通过LocalBroadcastManager.getInstance(context).unregisterReceiver取消注册服务，其他同普通广播.\n\n### 五 一些常用的系统广播的action 和permission\n\n##### 1.开机启动\n\n```java\n<action android:name=\"android.intent.action.BOOT_COMPLETED\"/> \n\n<uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\" />  \n\n```\n\n##### 2.网络状态\n\n```java\n<action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\"/>  \n\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/> \n\n```\n\n网络是否可用的方法：\n\n```java\npublic static boolean isNetworkAvailable(Context context) {  \n        ConnectivityManager mgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);  \n        NetworkInfo[] info = mgr.getAllNetworkInfo();  \n        if (info != null) {  \n            for (int i = 0; i < info.length; i++) {  \n      if (info[i].getState() == NetworkInfo.State.CONNECTED) {  \n                    return true;  \n                }  \n            }  \n        }  \n        return false;  \n    } \n```\n\n##### 3.电量变化\n\n```java\n<action android:name=\"android.intent.action.BATTERY_CHANGED\"/>  \n```\n\nBroadcastReceiver 的onReceive方法：\n\n```java\npublic void onReceive(Context context, Intent intent) {  \n        int currLevel = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, 0);  //当前电量  　\n\n        int total = intent.getIntExtra(BatteryManager.EXTRA_SCALE, 1);    //总电量  \n        int percent = currLevel * 100 / total;  \n        Log.i(TAG, \"battery: \" + percent + \"%\");  \n    }  \n\n```\n\n\n\n### 六 总结\n\n- 静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。\n- 动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：1)这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。2)这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。\n- 广播发出的时候，广播接收者接收的顺序如下：    \n1)当广播为普通广播时，有如下的接收顺序：  \n\na、无视优先级   \nb、动态优先于静态    \nc、同优先级的动态广播接收器，先注册的大于后注册的   \nd、同优先级的静态广播接收器，先扫描的大于后扫描的　   \n\n2）如果广播为有序广播，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：　 \n   　　 　　\na、优先级高的先接收　 　  \nb、同优先级的动静态广播接收器，动态优先于静态 　　  \nc、同优先级的动态广播接收器，先注册的大于后注册的 　　  \nd、同优先级的静态广播接收器，先扫描的大于后扫描的　   ","slug":"android基础之BroadcastReceiver","published":1,"updated":"2017-03-07T13:20:33.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj02g6grk00007c02sriciazn","content":"<h3 id=\"一-BroadcastReceiver简介\"><a href=\"#一-BroadcastReceiver简介\" class=\"headerlink\" title=\"一 BroadcastReceiver简介\"></a>一 BroadcastReceiver简介</h3><p>广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。如：在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。</p>\n<p>BroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。</p>\n<p>当系统或应用发出广播时，将会扫描系统中的所有广播接收者，通过action匹配将广播发送给相应的接收者，接收者收到广播后将会产生一个广播接收者的实例，执行其中的onReceiver()这个方法；特别需要注意的是这个实例的生命周期只有10秒，如果10秒内没执行结束onReceiver()，系统将会报错。在onReceiver()执行完毕之后，该实例将会被销毁，所以不要在onReceiver()中执行耗时操作，也不要在里面创建子线程处理业务（因为可能子线程没处理完，接收者就被回收了，那么子线程也会跟着被回收掉）；正确的处理方法就是通过in调用activity或者service处理业务。</p>\n<h3 id=\"二-BroadcastReceiver的两种注册方式\"><a href=\"#二-BroadcastReceiver的两种注册方式\" class=\"headerlink\" title=\"二 BroadcastReceiver的两种注册方式\"></a>二 BroadcastReceiver的两种注册方式</h3><h5 id=\"1-静态注册（推荐）\"><a href=\"#1-静态注册（推荐）\" class=\"headerlink\" title=\"1.静态注册（推荐）\"></a>1.静态注册（推荐）</h5><p>静态注册的广播接收者是一个常驻在系统中的全局监听器，当你在应用中配置了一个静态的BroadcastReceiver，安装了应用后而无论应用是否处于运行状态，广播接收者都是已经常驻在系统中了。同时应用里的所有receiver都在清单文件里面，方便查看。　 　　 　　要销毁掉静态注册的广播接收者，可以通过调用PackageManager将Receiver禁用。</p>\n<p>在AndroidManifest.xml的application里面定义receiver并设置要接收的action。下面是代码示例：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt; receiver android:name = \".MyBroadcastReceiver\" &gt; </div><div class=\"line\"></div><div class=\"line\"> &lt; intent-filter android:priority = \"777\" &gt;             </div><div class=\"line\">&lt;action android:name = \"android.provider.Telephony.SMS_RECEIVED\" /&gt;</div><div class=\"line\">&lt;/ intent-filter &gt; </div><div class=\"line\"></div><div class=\"line\">&lt;/ receiver &gt;</div></pre></td></tr></table></figure>\n<p>这里的priority取值是　-1000到1000，值越大优先级越高，同时注意加上系统接收短信的限权。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt; uses-permission android:name =<span class=\"string\">\"android.permission.RECEIVE_SMS\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"2-动态注册\"><a href=\"#2-动态注册\" class=\"headerlink\" title=\"2.动态注册\"></a>2.动态注册</h5><p>在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">    MyBroadcastReceiver receiver;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 动态注册广播 (代码执行到这才会开始监听广播消息，并对广播消息作为相应的处理)</span></div><div class=\"line\">        receiver = <span class=\"keyword\">new</span> MyBroadcastReceiver();</div><div class=\"line\">        IntentFilter intentFilter = <span class=\"keyword\">new</span> IntentFilter( <span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span> );</div><div class=\"line\">        registerReceiver( receiver , intentFilter);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">super</span>.onResume();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">// 撤销注册 (撤销注册后广播接收者将不会再监听系统的广播消息)</span></div><div class=\"line\">        unregisterReceiver(receiver);</div><div class=\"line\">        <span class=\"keyword\">super</span>.onPause();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接收广播示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBroadcastReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// action 名称</span></div><div class=\"line\">String SMS_RECEIVED = <span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span> ;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (intent.getAction().equals( SMS_RECEIVED )) &#123;</div><div class=\"line\">           <span class=\"comment\">// 一个receiver可以接收多个action的，即可以有多个intent-filter，需要在onReceive里面对intent.getAction(action name)进行判断。</span></div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"3-静态注册和动态注册的区别\"><a href=\"#3-静态注册和动态注册的区别\" class=\"headerlink\" title=\"3.静态注册和动态注册的区别\"></a>3.静态注册和动态注册的区别</h5><ol>\n<li>静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者； 　　动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。</li>\n<li>当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。　 　　动态注册的广播接收者将会导致应用报错 　　而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。</li>\n</ol>\n<h3 id=\"三-发送广播\"><a href=\"#三-发送广播\" class=\"headerlink\" title=\"三 发送广播\"></a>三 发送广播</h3><p>发送广播主要有两种类型：</p>\n<h5 id=\"1-普通广播\"><a href=\"#1-普通广播\" class=\"headerlink\" title=\"1.普通广播\"></a>1.普通广播</h5><p>应用在需要通知各个广播接收者的情况下使用，如 开机启动，使用方法：sendBroadcast()。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span>); </div><div class=\"line\"><span class=\"comment\">//通过intent传递少量数据</span></div><div class=\"line\">intent.putExtra(<span class=\"string\">\"data\"</span>, <span class=\"string\">\"finch\"</span>); </div><div class=\"line\"><span class=\"comment\">// 发送普通广播</span></div><div class=\"line\">sendBroadcast(Intent);</div></pre></td></tr></table></figure>\n<p>普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，所有满足条件的 BroadcastReceiver 都会随机地执行其 onReceive() 方法。 　　同级别接收是先后是随机的；级别低的收到广播； 　　消息传递的效率比较高，并且无法中断广播的传播。</p>\n<h5 id=\"有序广播\"><a href=\"#有序广播\" class=\"headerlink\" title=\"有序广播\"></a>有序广播</h5><p>应用在需要有特定拦截的场景下使用，如黑名单短信、电话拦截。</p>\n<p>使用方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sendOrderedBroadcast(intent, receiverPermission);</div></pre></td></tr></table></figure>\n<p>receiverPermission ：一个接收器必须持以接收您的广播。如果为 null ，不经许可的要求（一般都为null）,如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//发送有序广播</span></div><div class=\"line\">sendOrderedBroadcast(intent, <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<p>在有序广播中，我们可以在前一个广播接收者将处理好的数据传送给后面的广播接收者，也可以调用abortBroadcast()来终结广播的传播。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context arg0, Intent intent)</span> </span>&#123;</div><div class=\"line\">　　<span class=\"comment\">//获取上一个广播的bundle数据</span></div><div class=\"line\">　　Bundle bundle = getResultExtras(<span class=\"keyword\">true</span>);<span class=\"comment\">//true：前一个广播没有结果时创建新的Bundle；false：不创建Bundle</span></div><div class=\"line\">　　bundle.putString(<span class=\"string\">\"key\"</span>, <span class=\"string\">\"777\"</span>);</div><div class=\"line\">　　<span class=\"comment\">//将bundle数据放入广播中传给下一个广播接收者</span></div><div class=\"line\">　　setResultExtras(bundle);　</div><div class=\"line\">　　</div><div class=\"line\">　　<span class=\"comment\">//终止广播传给下一个广播接收者</span></div><div class=\"line\">　　abortBroadcast();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>高级别的广播收到该广播后，可以决定把该广播是否截断掉。 　　同级别接收是先后是随机的，如果先接收到的把广播截断了，同级别的例外的接收者是无法收到该广播。 　</p>\n<h5 id=\"异步广播\"><a href=\"#异步广播\" class=\"headerlink\" title=\"异步广播\"></a>异步广播</h5><p>使用方法：sendStickyBroadcast() ：</p>\n<p>发出的Intent当接收Activity（动态注册）重新处于onResume状态之后就能重新接受到其Intent.（the Intent will be held to be re-broadcast to future receivers）。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Activity处于活跃的时候又会接受到它</p>\n<p>发这个广播需要权限：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.BROADCAST_STICKY\"</span> /&gt;</div></pre></td></tr></table></figure>\n<p>卸载该广播：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">removeStickyBroadcast(intent);</div></pre></td></tr></table></figure>\n<p>在卸载之前该intent会保留，接收者在可接收状态都能获得。</p>\n<h5 id=\"异步有序广播\"><a href=\"#异步有序广播\" class=\"headerlink\" title=\"异步有序广播\"></a>异步有序广播</h5><p>使用方法：sendStickyOrderedBroadcast(intent, resultReceiver, scheduler, initialCode, initialData, initialExtras)：</p>\n<p>这个方法具有有序广播的特性也有异步广播的特性；同时需要限权：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.BROADCAST_STICKY\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"四-安全性\"><a href=\"#四-安全性\" class=\"headerlink\" title=\"四 安全性\"></a>四 安全性</h3><p>BroadcastReceiver的设计初衷就是从全局考虑的，可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言BroadcastReceiver是存在安全性问题的，相应问题及解决如下：   </p>\n<ul>\n<li>当应用程序发送某个广播时系统会将发送的Intent与系统中所有注册的BroadcastReceiver的IntentFilter进行匹配，若匹配成功则执行相应的onReceive函数。可以通过类似sendBroadcast(Intent, String)的接口在发送广播时指定接收者必须具备的permission。或通过Intent.setPackage设置广播仅对某个程序有效。</li>\n<li>当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。对于动态注册的广播可以通过类似registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)的接口指定发送者必须具备的permission，对于静态注册的广播可以通过android:exported=”false”属性表示接收者对外部应用程序不可用，即不接受来自外部的广播。</li>\n<li>上面两个问题其实都可以通过LocalBroadcastManager来解决，LocalBroadcastManager只会将广播限定在当前应用程序中。</li>\n<li>使用android:protectionLevel</li>\n</ul>\n<p>android引入了LocalBroadcastManager解决在第4部分安全性介绍的一些问题，LocalBroadcastManager除了能解决BroadcastReceiver进程间安全性问题外，相对Context操作的BroadcastReceiver而言还具有更高的运行效率。使用LocalBroadcastManager需要引入Android Support Library，如何引入见Add Support Package。<br>本地广播通过LocalBroadcastManager.getInstance(context).sendBroadcast(intent)发送广播，LocalBroadcastManager.getInstance(context).registerReceiver注册服务，通过LocalBroadcastManager.getInstance(context).unregisterReceiver取消注册服务，其他同普通广播.</p>\n<h3 id=\"五-一些常用的系统广播的action-和permission\"><a href=\"#五-一些常用的系统广播的action-和permission\" class=\"headerlink\" title=\"五 一些常用的系统广播的action 和permission\"></a>五 一些常用的系统广播的action 和permission</h3><h5 id=\"1-开机启动\"><a href=\"#1-开机启动\" class=\"headerlink\" title=\"1.开机启动\"></a>1.开机启动</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;action android:name=<span class=\"string\">\"android.intent.action.BOOT_COMPLETED\"</span>/&gt; </div><div class=\"line\"></div><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.RECEIVE_BOOT_COMPLETED\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"2-网络状态\"><a href=\"#2-网络状态\" class=\"headerlink\" title=\"2.网络状态\"></a>2.网络状态</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;action android:name=<span class=\"string\">\"android.net.conn.CONNECTIVITY_CHANGE\"</span>/&gt;  </div><div class=\"line\"></div><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.ACCESS_NETWORK_STATE\"</span>/&gt;</div></pre></td></tr></table></figure>\n<p>网络是否可用的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isNetworkAvailable</span><span class=\"params\">(Context context)</span> </span>&#123;  </div><div class=\"line\">        ConnectivityManager mgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);  </div><div class=\"line\">        NetworkInfo[] info = mgr.getAllNetworkInfo();  </div><div class=\"line\">        <span class=\"keyword\">if</span> (info != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; info.length; i++) &#123;  </div><div class=\"line\">      <span class=\"keyword\">if</span> (info[i].getState() == NetworkInfo.State.CONNECTED) &#123;  </div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h5 id=\"3-电量变化\"><a href=\"#3-电量变化\" class=\"headerlink\" title=\"3.电量变化\"></a>3.电量变化</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;action android:name=<span class=\"string\">\"android.intent.action.BATTERY_CHANGED\"</span>/&gt;</div></pre></td></tr></table></figure>\n<p>BroadcastReceiver 的onReceive方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">int</span> currLevel = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, <span class=\"number\">0</span>);  <span class=\"comment\">//当前电量  　</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> total = intent.getIntExtra(BatteryManager.EXTRA_SCALE, <span class=\"number\">1</span>);    <span class=\"comment\">//总电量  </span></div><div class=\"line\">        <span class=\"keyword\">int</span> percent = currLevel * <span class=\"number\">100</span> / total;  </div><div class=\"line\">        Log.i(TAG, <span class=\"string\">\"battery: \"</span> + percent + <span class=\"string\">\"%\"</span>);  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"六-总结\"><a href=\"#六-总结\" class=\"headerlink\" title=\"六 总结\"></a>六 总结</h3><ul>\n<li>静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。</li>\n<li>动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：1)这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。2)这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。</li>\n<li>广播发出的时候，广播接收者接收的顺序如下：<br>1)当广播为普通广播时，有如下的接收顺序：  </li>\n</ul>\n<p>a、无视优先级<br>b、动态优先于静态<br>c、同优先级的动态广播接收器，先注册的大于后注册的<br>d、同优先级的静态广播接收器，先扫描的大于后扫描的　   </p>\n<p>2）如果广播为有序广播，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：　<br>   　　 　　<br>a、优先级高的先接收　 　<br>b、同优先级的动静态广播接收器，动态优先于静态 　　<br>c、同优先级的动态广播接收器，先注册的大于后注册的 　　<br>d、同优先级的静态广播接收器，先扫描的大于后扫描的　   </p>\n","excerpt":"","more":"<h3 id=\"一-BroadcastReceiver简介\"><a href=\"#一-BroadcastReceiver简介\" class=\"headerlink\" title=\"一 BroadcastReceiver简介\"></a>一 BroadcastReceiver简介</h3><p>广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。如：在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。</p>\n<p>BroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。</p>\n<p>当系统或应用发出广播时，将会扫描系统中的所有广播接收者，通过action匹配将广播发送给相应的接收者，接收者收到广播后将会产生一个广播接收者的实例，执行其中的onReceiver()这个方法；特别需要注意的是这个实例的生命周期只有10秒，如果10秒内没执行结束onReceiver()，系统将会报错。在onReceiver()执行完毕之后，该实例将会被销毁，所以不要在onReceiver()中执行耗时操作，也不要在里面创建子线程处理业务（因为可能子线程没处理完，接收者就被回收了，那么子线程也会跟着被回收掉）；正确的处理方法就是通过in调用activity或者service处理业务。</p>\n<h3 id=\"二-BroadcastReceiver的两种注册方式\"><a href=\"#二-BroadcastReceiver的两种注册方式\" class=\"headerlink\" title=\"二 BroadcastReceiver的两种注册方式\"></a>二 BroadcastReceiver的两种注册方式</h3><h5 id=\"1-静态注册（推荐）\"><a href=\"#1-静态注册（推荐）\" class=\"headerlink\" title=\"1.静态注册（推荐）\"></a>1.静态注册（推荐）</h5><p>静态注册的广播接收者是一个常驻在系统中的全局监听器，当你在应用中配置了一个静态的BroadcastReceiver，安装了应用后而无论应用是否处于运行状态，广播接收者都是已经常驻在系统中了。同时应用里的所有receiver都在清单文件里面，方便查看。　 　　 　　要销毁掉静态注册的广播接收者，可以通过调用PackageManager将Receiver禁用。</p>\n<p>在AndroidManifest.xml的application里面定义receiver并设置要接收的action。下面是代码示例：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt; receiver android:name = \".MyBroadcastReceiver\" &gt; </div><div class=\"line\"></div><div class=\"line\"> &lt; intent-filter android:priority = \"777\" &gt;             </div><div class=\"line\">&lt;action android:name = \"android.provider.Telephony.SMS_RECEIVED\" /&gt;</div><div class=\"line\">&lt;/ intent-filter &gt; </div><div class=\"line\"></div><div class=\"line\">&lt;/ receiver &gt;</div></pre></td></tr></table></figure>\n<p>这里的priority取值是　-1000到1000，值越大优先级越高，同时注意加上系统接收短信的限权。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt; uses-permission android:name =<span class=\"string\">\"android.permission.RECEIVE_SMS\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"2-动态注册\"><a href=\"#2-动态注册\" class=\"headerlink\" title=\"2.动态注册\"></a>2.动态注册</h5><p>在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">    MyBroadcastReceiver receiver;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 动态注册广播 (代码执行到这才会开始监听广播消息，并对广播消息作为相应的处理)</span></div><div class=\"line\">        receiver = <span class=\"keyword\">new</span> MyBroadcastReceiver();</div><div class=\"line\">        IntentFilter intentFilter = <span class=\"keyword\">new</span> IntentFilter( <span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span> );</div><div class=\"line\">        registerReceiver( receiver , intentFilter);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">super</span>.onResume();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">// 撤销注册 (撤销注册后广播接收者将不会再监听系统的广播消息)</span></div><div class=\"line\">        unregisterReceiver(receiver);</div><div class=\"line\">        <span class=\"keyword\">super</span>.onPause();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接收广播示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBroadcastReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// action 名称</span></div><div class=\"line\">String SMS_RECEIVED = <span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span> ;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (intent.getAction().equals( SMS_RECEIVED )) &#123;</div><div class=\"line\">           <span class=\"comment\">// 一个receiver可以接收多个action的，即可以有多个intent-filter，需要在onReceive里面对intent.getAction(action name)进行判断。</span></div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"3-静态注册和动态注册的区别\"><a href=\"#3-静态注册和动态注册的区别\" class=\"headerlink\" title=\"3.静态注册和动态注册的区别\"></a>3.静态注册和动态注册的区别</h5><ol>\n<li>静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者； 　　动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。</li>\n<li>当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。　 　　动态注册的广播接收者将会导致应用报错 　　而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。</li>\n</ol>\n<h3 id=\"三-发送广播\"><a href=\"#三-发送广播\" class=\"headerlink\" title=\"三 发送广播\"></a>三 发送广播</h3><p>发送广播主要有两种类型：</p>\n<h5 id=\"1-普通广播\"><a href=\"#1-普通广播\" class=\"headerlink\" title=\"1.普通广播\"></a>1.普通广播</h5><p>应用在需要通知各个广播接收者的情况下使用，如 开机启动，使用方法：sendBroadcast()。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span>); </div><div class=\"line\"><span class=\"comment\">//通过intent传递少量数据</span></div><div class=\"line\">intent.putExtra(<span class=\"string\">\"data\"</span>, <span class=\"string\">\"finch\"</span>); </div><div class=\"line\"><span class=\"comment\">// 发送普通广播</span></div><div class=\"line\">sendBroadcast(Intent);</div></pre></td></tr></table></figure>\n<p>普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，所有满足条件的 BroadcastReceiver 都会随机地执行其 onReceive() 方法。 　　同级别接收是先后是随机的；级别低的收到广播； 　　消息传递的效率比较高，并且无法中断广播的传播。</p>\n<h5 id=\"有序广播\"><a href=\"#有序广播\" class=\"headerlink\" title=\"有序广播\"></a>有序广播</h5><p>应用在需要有特定拦截的场景下使用，如黑名单短信、电话拦截。</p>\n<p>使用方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sendOrderedBroadcast(intent, receiverPermission);</div></pre></td></tr></table></figure>\n<p>receiverPermission ：一个接收器必须持以接收您的广播。如果为 null ，不经许可的要求（一般都为null）,如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//发送有序广播</span></div><div class=\"line\">sendOrderedBroadcast(intent, <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<p>在有序广播中，我们可以在前一个广播接收者将处理好的数据传送给后面的广播接收者，也可以调用abortBroadcast()来终结广播的传播。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context arg0, Intent intent)</span> </span>&#123;</div><div class=\"line\">　　<span class=\"comment\">//获取上一个广播的bundle数据</span></div><div class=\"line\">　　Bundle bundle = getResultExtras(<span class=\"keyword\">true</span>);<span class=\"comment\">//true：前一个广播没有结果时创建新的Bundle；false：不创建Bundle</span></div><div class=\"line\">　　bundle.putString(<span class=\"string\">\"key\"</span>, <span class=\"string\">\"777\"</span>);</div><div class=\"line\">　　<span class=\"comment\">//将bundle数据放入广播中传给下一个广播接收者</span></div><div class=\"line\">　　setResultExtras(bundle);　</div><div class=\"line\">　　</div><div class=\"line\">　　<span class=\"comment\">//终止广播传给下一个广播接收者</span></div><div class=\"line\">　　abortBroadcast();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>高级别的广播收到该广播后，可以决定把该广播是否截断掉。 　　同级别接收是先后是随机的，如果先接收到的把广播截断了，同级别的例外的接收者是无法收到该广播。 　</p>\n<h5 id=\"异步广播\"><a href=\"#异步广播\" class=\"headerlink\" title=\"异步广播\"></a>异步广播</h5><p>使用方法：sendStickyBroadcast() ：</p>\n<p>发出的Intent当接收Activity（动态注册）重新处于onResume状态之后就能重新接受到其Intent.（the Intent will be held to be re-broadcast to future receivers）。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Activity处于活跃的时候又会接受到它</p>\n<p>发这个广播需要权限：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.BROADCAST_STICKY\"</span> /&gt;</div></pre></td></tr></table></figure>\n<p>卸载该广播：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">removeStickyBroadcast(intent);</div></pre></td></tr></table></figure>\n<p>在卸载之前该intent会保留，接收者在可接收状态都能获得。</p>\n<h5 id=\"异步有序广播\"><a href=\"#异步有序广播\" class=\"headerlink\" title=\"异步有序广播\"></a>异步有序广播</h5><p>使用方法：sendStickyOrderedBroadcast(intent, resultReceiver, scheduler, initialCode, initialData, initialExtras)：</p>\n<p>这个方法具有有序广播的特性也有异步广播的特性；同时需要限权：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.BROADCAST_STICKY\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"四-安全性\"><a href=\"#四-安全性\" class=\"headerlink\" title=\"四 安全性\"></a>四 安全性</h3><p>BroadcastReceiver的设计初衷就是从全局考虑的，可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言BroadcastReceiver是存在安全性问题的，相应问题及解决如下：   </p>\n<ul>\n<li>当应用程序发送某个广播时系统会将发送的Intent与系统中所有注册的BroadcastReceiver的IntentFilter进行匹配，若匹配成功则执行相应的onReceive函数。可以通过类似sendBroadcast(Intent, String)的接口在发送广播时指定接收者必须具备的permission。或通过Intent.setPackage设置广播仅对某个程序有效。</li>\n<li>当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。对于动态注册的广播可以通过类似registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)的接口指定发送者必须具备的permission，对于静态注册的广播可以通过android:exported=”false”属性表示接收者对外部应用程序不可用，即不接受来自外部的广播。</li>\n<li>上面两个问题其实都可以通过LocalBroadcastManager来解决，LocalBroadcastManager只会将广播限定在当前应用程序中。</li>\n<li>使用android:protectionLevel</li>\n</ul>\n<p>android引入了LocalBroadcastManager解决在第4部分安全性介绍的一些问题，LocalBroadcastManager除了能解决BroadcastReceiver进程间安全性问题外，相对Context操作的BroadcastReceiver而言还具有更高的运行效率。使用LocalBroadcastManager需要引入Android Support Library，如何引入见Add Support Package。<br>本地广播通过LocalBroadcastManager.getInstance(context).sendBroadcast(intent)发送广播，LocalBroadcastManager.getInstance(context).registerReceiver注册服务，通过LocalBroadcastManager.getInstance(context).unregisterReceiver取消注册服务，其他同普通广播.</p>\n<h3 id=\"五-一些常用的系统广播的action-和permission\"><a href=\"#五-一些常用的系统广播的action-和permission\" class=\"headerlink\" title=\"五 一些常用的系统广播的action 和permission\"></a>五 一些常用的系统广播的action 和permission</h3><h5 id=\"1-开机启动\"><a href=\"#1-开机启动\" class=\"headerlink\" title=\"1.开机启动\"></a>1.开机启动</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;action android:name=<span class=\"string\">\"android.intent.action.BOOT_COMPLETED\"</span>/&gt; </div><div class=\"line\"></div><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.RECEIVE_BOOT_COMPLETED\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"2-网络状态\"><a href=\"#2-网络状态\" class=\"headerlink\" title=\"2.网络状态\"></a>2.网络状态</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;action android:name=<span class=\"string\">\"android.net.conn.CONNECTIVITY_CHANGE\"</span>/&gt;  </div><div class=\"line\"></div><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.ACCESS_NETWORK_STATE\"</span>/&gt;</div></pre></td></tr></table></figure>\n<p>网络是否可用的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isNetworkAvailable</span><span class=\"params\">(Context context)</span> </span>&#123;  </div><div class=\"line\">        ConnectivityManager mgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);  </div><div class=\"line\">        NetworkInfo[] info = mgr.getAllNetworkInfo();  </div><div class=\"line\">        <span class=\"keyword\">if</span> (info != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; info.length; i++) &#123;  </div><div class=\"line\">      <span class=\"keyword\">if</span> (info[i].getState() == NetworkInfo.State.CONNECTED) &#123;  </div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h5 id=\"3-电量变化\"><a href=\"#3-电量变化\" class=\"headerlink\" title=\"3.电量变化\"></a>3.电量变化</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;action android:name=<span class=\"string\">\"android.intent.action.BATTERY_CHANGED\"</span>/&gt;</div></pre></td></tr></table></figure>\n<p>BroadcastReceiver 的onReceive方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">int</span> currLevel = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, <span class=\"number\">0</span>);  <span class=\"comment\">//当前电量  　</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> total = intent.getIntExtra(BatteryManager.EXTRA_SCALE, <span class=\"number\">1</span>);    <span class=\"comment\">//总电量  </span></div><div class=\"line\">        <span class=\"keyword\">int</span> percent = currLevel * <span class=\"number\">100</span> / total;  </div><div class=\"line\">        Log.i(TAG, <span class=\"string\">\"battery: \"</span> + percent + <span class=\"string\">\"%\"</span>);  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"六-总结\"><a href=\"#六-总结\" class=\"headerlink\" title=\"六 总结\"></a>六 总结</h3><ul>\n<li>静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。</li>\n<li>动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：1)这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。2)这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。</li>\n<li>广播发出的时候，广播接收者接收的顺序如下：<br>1)当广播为普通广播时，有如下的接收顺序：  </li>\n</ul>\n<p>a、无视优先级<br>b、动态优先于静态<br>c、同优先级的动态广播接收器，先注册的大于后注册的<br>d、同优先级的静态广播接收器，先扫描的大于后扫描的　   </p>\n<p>2）如果广播为有序广播，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：　<br>   　　 　　<br>a、优先级高的先接收　 　<br>b、同优先级的动静态广播接收器，动态优先于静态 　　<br>c、同优先级的动态广播接收器，先注册的大于后注册的 　　<br>d、同优先级的静态广播接收器，先扫描的大于后扫描的　   </p>\n"},{"title":"android基础之Content Provider","date":"2017-02-27T06:32:42.000Z","_content":"\n### 一 概述\n\nContentProvider（内容提供者）是Android的四大组件之一，通过它可以向其他的应用程序共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。而且Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。\n\n但注意ContentProvider它也只是一个中间人，真正操作的数据源可能是数据库，也可以是文件、xml或网络等其他存储方式。\n\n### Uri类简介\n\n```java\nUri uri = Uri.parse(\"content://com.changcheng.provider.contactprovider/contact\")\n```\n\n在Content Provider中使用的查询字符串有别于标准的SQL查询。很多诸如select, add, delete, modify等操作我们都使用一种特殊的URI来进行，这种URI由3个部分组成， “content://”, 代表数据的路径，和一个可选的标识数据的ID。以下是一些示例URI:    \n\n```java\ncontent://media/internal/images  //这个URI将返回设备上存储的所有图片\ncontent://contacts/people/  //这个URI将返回设备上的所有联系人信息\ncontent://contacts/people/45  //这个URI返回单个结果（联系人信息中ID为45的联系人记录）\n```\n\n尽管这种查询字符串格式很常见，但是它看起来还是有点令人迷惑。为此，Android提供一系列的帮助类（在android.provider包下），里面包含了很多以类变量形式给出的查询字符串，这种方式更容易让我们理解一点，因此，如上面content://contacts/people/45这个URI就可以写成如下形式：\n\n```java\nUri person = ContentUris.withAppendedId(People.CONTENT_URI,  45);\n```\n\n然后执行数据查询:\n\n```java\nCursor cur = managedQuery(person, null, null, null);\n```\n\n这个查询返回一个包含所有数据字段的游标，我们可以通过迭代这个游标来获取所有的数据.\n\n### 三 ContentProvider类简介\n\n##### 1.主要方法\n\n- public boolean onCreate()   \nContentProvider创建后　或　打开系统后其它应用第一次访问该ContentProvider时调用。      \n- public Uri insert(Uri uri, ContentValues values)    \n外部应用向ContentProvider中添加数据。    \n- public int delete(Uri uri, String selection, String[] selectionArgs)     \n外部应用从ContentProvider删除数据。    \n- public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)         \n外部应用更新ContentProvider中的数据。    \n- public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)　    \n供外部应用从ContentProvider中获取数据。 　    \n- public String getType(Uri uri)     \n该方法用于返回当前Url所代表数据的MIME类型  \n\n##### 2.创建步骤\n\n要创建我们自己的Content Provider的话，我们需要遵循以下几步：\n\n1.创建一个继承了ContentProvider父类的类   \n2.定义一个名为CONTENT_URI，并且是public static final的Uri类型的类变量，你必须为其指定一个唯一的字符串值，最好的方案是以类的全名称， 如:\n\n\n```java\npublic static final Uri CONTENT_URI = Uri.parse( “content://com.google.android.MyContentProvider”);\n```\n\n3.定义你要返回给客户端的数据列名。如果你正在使用Android数据库，必须为其定义一个叫_id的列，它用来表示每条记录的唯一性。     \n4.创建你的数据存储系统。大多数Content Provider使用Android文件系统或SQLite数据库来保持数据，但是你也可以以任何你想要的方式来存储。      \n5.如果你要存储字节型数据，比如位图文件等，数据列其实是一个表示实际保存文件的URI字符串，通过它来读取对应的文件数据。处理这种数据类型的Content Provider需要实现一个名为_data的字段，_data字段列出了该文件在Android文件系统上的精确路径。这个字段不仅是供客户端使用，而且也可以供ContentResolver使用。客户端可以调用ContentResolver.openOutputStream()方法来处理该URI指向的文件资源；如果是ContentResolver本身的话，由于其持有的权限比客户端要高，所以它能直接访问该数据文件。    \n6.声明public static String型的变量，用于指定要从游标处返回的数据列。    \n7.查询返回一个Cursor类型的对象。所有执行写操作的方法如insert(), update() 以及delete()都将被监听。我们可以通过使用ContentResover().notifyChange()方法来通知监听器关于数据更新的信息。     \n8.在AndroidMenifest.xml中使用<provider>标签来设置Content Provider。    \n9.如果你要处理的数据类型是一种比较新的类型，你就必须先定义一个新的MIME类型，以供ContentProvider.geType(url)来返回。MIME类型有两种形式:一种是为指定的单个记录的，还有一种是为多条记录的。这里给出一种常用的格式：   \n- vnd.android.cursor.item/vnd.yourcompanyname.contenttype （单个记录的MIME类型）   \n比如, 一个请求列车信息的URI如content://com.example.transportationprovider/trains/122 可能就会返回typevnd.android.cursor.item/vnd.example.rail这样一个MIME类型。   \n- vnd.android.cursor.dir/vnd.yourcompanyname.contenttype （多个记录的MIME类型）     \n比如, 一个请求所有列车信息的URI如content://com.example.transportationprovider/trains 可能就会返回vnd.android.cursor.dir/vnd.example.rail这样一个MIME 类型。\n\n下面是一个Content Provider代码示例：\n\n\n> 代码\n\n一个名为MyContentProvider的Content Provider创建完成了，它用于从Sqlite数据库中添加和读取记录。\n\n### 四 ContentResolver\n\n一个ContentProvider新建好了之后，我们需要一个ContentResolver类来获取其共享出的数据。\n\n##### 1.ContentResolver的主要方法\n\n- public Uri insert(Uri uri, ContentValues values)　//添加\n- public int delete(Uri uri, String selection, String[] selectionArgs)　//删除\n- public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)　//更新\n- public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)//获取\n\n\n示例代码：\n\n```java\nContentResolver resolver =  getContentResolver();\nUri uri = Uri.parse(\"content://cn.scu.myprovider/user\");\n\n//插入\nContentValues values = new ContentValues();\nvalues.put(\"name\", \"fanrunqi\");\nvalues.put(\"age\", 24);\nresolver.insert(uri, values);  \n\n//查询\nCursor cursor = resolver.query(uri, null, null, null, \"userid desc\");\nwhile(cursor.moveToNext()){\n   //操作\n}\n\n//更新\nContentValues updateValues = new ContentValues();\nupdateValues.put(\"name\", \"finch\");\nUri updateIdUri = ContentUris.withAppendedId(uri, 1);\nresolver.update(updateIdUri, updateValues, null, null);\n\n//删除\nUri deleteIdUri = ContentUris.withAppendedId(uri, 2);\nresolver.delete(deleteIdUri, null, null);\n```\n\n##### 使用ContentResolver获取数据的步骤\n\n1. 通过getContentResolver()方法得到ContentResol1.ver对象。\n2. 调用ContentResolver类的query()方法查询数据，该方法会返回一个Cursor对象。\n3. 对得到的Cursor对象进行分析，得到需要的数据。\n4. 调用Cursor类的close()方法将Cursor对象关闭。\n\n示例代码（与上面ContentProvider处的代码相连）：\n\n> 代码\n\n\n### 五 总结\n\n\n\n\n      \n\n\n\n\n\n\n\n","source":"_posts/android基础之Content-Providers.md","raw":"---\ntitle: android基础之Content Provider\ndate: 2017-02-27 14:32:42\ncategories: android\ntags:\n- android\n- java\n- Content Provider\n---\n\n### 一 概述\n\nContentProvider（内容提供者）是Android的四大组件之一，通过它可以向其他的应用程序共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。而且Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。\n\n但注意ContentProvider它也只是一个中间人，真正操作的数据源可能是数据库，也可以是文件、xml或网络等其他存储方式。\n\n### Uri类简介\n\n```java\nUri uri = Uri.parse(\"content://com.changcheng.provider.contactprovider/contact\")\n```\n\n在Content Provider中使用的查询字符串有别于标准的SQL查询。很多诸如select, add, delete, modify等操作我们都使用一种特殊的URI来进行，这种URI由3个部分组成， “content://”, 代表数据的路径，和一个可选的标识数据的ID。以下是一些示例URI:    \n\n```java\ncontent://media/internal/images  //这个URI将返回设备上存储的所有图片\ncontent://contacts/people/  //这个URI将返回设备上的所有联系人信息\ncontent://contacts/people/45  //这个URI返回单个结果（联系人信息中ID为45的联系人记录）\n```\n\n尽管这种查询字符串格式很常见，但是它看起来还是有点令人迷惑。为此，Android提供一系列的帮助类（在android.provider包下），里面包含了很多以类变量形式给出的查询字符串，这种方式更容易让我们理解一点，因此，如上面content://contacts/people/45这个URI就可以写成如下形式：\n\n```java\nUri person = ContentUris.withAppendedId(People.CONTENT_URI,  45);\n```\n\n然后执行数据查询:\n\n```java\nCursor cur = managedQuery(person, null, null, null);\n```\n\n这个查询返回一个包含所有数据字段的游标，我们可以通过迭代这个游标来获取所有的数据.\n\n### 三 ContentProvider类简介\n\n##### 1.主要方法\n\n- public boolean onCreate()   \nContentProvider创建后　或　打开系统后其它应用第一次访问该ContentProvider时调用。      \n- public Uri insert(Uri uri, ContentValues values)    \n外部应用向ContentProvider中添加数据。    \n- public int delete(Uri uri, String selection, String[] selectionArgs)     \n外部应用从ContentProvider删除数据。    \n- public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)         \n外部应用更新ContentProvider中的数据。    \n- public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)　    \n供外部应用从ContentProvider中获取数据。 　    \n- public String getType(Uri uri)     \n该方法用于返回当前Url所代表数据的MIME类型  \n\n##### 2.创建步骤\n\n要创建我们自己的Content Provider的话，我们需要遵循以下几步：\n\n1.创建一个继承了ContentProvider父类的类   \n2.定义一个名为CONTENT_URI，并且是public static final的Uri类型的类变量，你必须为其指定一个唯一的字符串值，最好的方案是以类的全名称， 如:\n\n\n```java\npublic static final Uri CONTENT_URI = Uri.parse( “content://com.google.android.MyContentProvider”);\n```\n\n3.定义你要返回给客户端的数据列名。如果你正在使用Android数据库，必须为其定义一个叫_id的列，它用来表示每条记录的唯一性。     \n4.创建你的数据存储系统。大多数Content Provider使用Android文件系统或SQLite数据库来保持数据，但是你也可以以任何你想要的方式来存储。      \n5.如果你要存储字节型数据，比如位图文件等，数据列其实是一个表示实际保存文件的URI字符串，通过它来读取对应的文件数据。处理这种数据类型的Content Provider需要实现一个名为_data的字段，_data字段列出了该文件在Android文件系统上的精确路径。这个字段不仅是供客户端使用，而且也可以供ContentResolver使用。客户端可以调用ContentResolver.openOutputStream()方法来处理该URI指向的文件资源；如果是ContentResolver本身的话，由于其持有的权限比客户端要高，所以它能直接访问该数据文件。    \n6.声明public static String型的变量，用于指定要从游标处返回的数据列。    \n7.查询返回一个Cursor类型的对象。所有执行写操作的方法如insert(), update() 以及delete()都将被监听。我们可以通过使用ContentResover().notifyChange()方法来通知监听器关于数据更新的信息。     \n8.在AndroidMenifest.xml中使用<provider>标签来设置Content Provider。    \n9.如果你要处理的数据类型是一种比较新的类型，你就必须先定义一个新的MIME类型，以供ContentProvider.geType(url)来返回。MIME类型有两种形式:一种是为指定的单个记录的，还有一种是为多条记录的。这里给出一种常用的格式：   \n- vnd.android.cursor.item/vnd.yourcompanyname.contenttype （单个记录的MIME类型）   \n比如, 一个请求列车信息的URI如content://com.example.transportationprovider/trains/122 可能就会返回typevnd.android.cursor.item/vnd.example.rail这样一个MIME类型。   \n- vnd.android.cursor.dir/vnd.yourcompanyname.contenttype （多个记录的MIME类型）     \n比如, 一个请求所有列车信息的URI如content://com.example.transportationprovider/trains 可能就会返回vnd.android.cursor.dir/vnd.example.rail这样一个MIME 类型。\n\n下面是一个Content Provider代码示例：\n\n\n> 代码\n\n一个名为MyContentProvider的Content Provider创建完成了，它用于从Sqlite数据库中添加和读取记录。\n\n### 四 ContentResolver\n\n一个ContentProvider新建好了之后，我们需要一个ContentResolver类来获取其共享出的数据。\n\n##### 1.ContentResolver的主要方法\n\n- public Uri insert(Uri uri, ContentValues values)　//添加\n- public int delete(Uri uri, String selection, String[] selectionArgs)　//删除\n- public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)　//更新\n- public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)//获取\n\n\n示例代码：\n\n```java\nContentResolver resolver =  getContentResolver();\nUri uri = Uri.parse(\"content://cn.scu.myprovider/user\");\n\n//插入\nContentValues values = new ContentValues();\nvalues.put(\"name\", \"fanrunqi\");\nvalues.put(\"age\", 24);\nresolver.insert(uri, values);  \n\n//查询\nCursor cursor = resolver.query(uri, null, null, null, \"userid desc\");\nwhile(cursor.moveToNext()){\n   //操作\n}\n\n//更新\nContentValues updateValues = new ContentValues();\nupdateValues.put(\"name\", \"finch\");\nUri updateIdUri = ContentUris.withAppendedId(uri, 1);\nresolver.update(updateIdUri, updateValues, null, null);\n\n//删除\nUri deleteIdUri = ContentUris.withAppendedId(uri, 2);\nresolver.delete(deleteIdUri, null, null);\n```\n\n##### 使用ContentResolver获取数据的步骤\n\n1. 通过getContentResolver()方法得到ContentResol1.ver对象。\n2. 调用ContentResolver类的query()方法查询数据，该方法会返回一个Cursor对象。\n3. 对得到的Cursor对象进行分析，得到需要的数据。\n4. 调用Cursor类的close()方法将Cursor对象关闭。\n\n示例代码（与上面ContentProvider处的代码相连）：\n\n> 代码\n\n\n### 五 总结\n\n\n\n\n      \n\n\n\n\n\n\n\n","slug":"android基础之Content-Providers","published":1,"updated":"2017-03-07T13:20:33.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj02g6grz00017c026ym2ojm9","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>ContentProvider（内容提供者）是Android的四大组件之一，通过它可以向其他的应用程序共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。而且Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。</p>\n<p>但注意ContentProvider它也只是一个中间人，真正操作的数据源可能是数据库，也可以是文件、xml或网络等其他存储方式。</p>\n<h3 id=\"Uri类简介\"><a href=\"#Uri类简介\" class=\"headerlink\" title=\"Uri类简介\"></a>Uri类简介</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri uri = Uri.parse(<span class=\"string\">\"content://com.changcheng.provider.contactprovider/contact\"</span>)</div></pre></td></tr></table></figure>\n<p>在Content Provider中使用的查询字符串有别于标准的SQL查询。很多诸如select, add, delete, modify等操作我们都使用一种特殊的URI来进行，这种URI由3个部分组成， “content://”, 代表数据的路径，和一个可选的标识数据的ID。以下是一些示例URI:    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">content:<span class=\"comment\">//media/internal/images  //这个URI将返回设备上存储的所有图片</span></div><div class=\"line\">content:<span class=\"comment\">//contacts/people/  //这个URI将返回设备上的所有联系人信息</span></div><div class=\"line\">content:<span class=\"comment\">//contacts/people/45  //这个URI返回单个结果（联系人信息中ID为45的联系人记录）</span></div></pre></td></tr></table></figure>\n<p>尽管这种查询字符串格式很常见，但是它看起来还是有点令人迷惑。为此，Android提供一系列的帮助类（在android.provider包下），里面包含了很多以类变量形式给出的查询字符串，这种方式更容易让我们理解一点，因此，如上面content://contacts/people/45这个URI就可以写成如下形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri person = ContentUris.withAppendedId(People.CONTENT_URI,  <span class=\"number\">45</span>);</div></pre></td></tr></table></figure>\n<p>然后执行数据查询:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cursor cur = managedQuery(person, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<p>这个查询返回一个包含所有数据字段的游标，我们可以通过迭代这个游标来获取所有的数据.</p>\n<h3 id=\"三-ContentProvider类简介\"><a href=\"#三-ContentProvider类简介\" class=\"headerlink\" title=\"三 ContentProvider类简介\"></a>三 ContentProvider类简介</h3><h5 id=\"1-主要方法\"><a href=\"#1-主要方法\" class=\"headerlink\" title=\"1.主要方法\"></a>1.主要方法</h5><ul>\n<li>public boolean onCreate()<br>ContentProvider创建后　或　打开系统后其它应用第一次访问该ContentProvider时调用。      </li>\n<li>public Uri insert(Uri uri, ContentValues values)<br>外部应用向ContentProvider中添加数据。    </li>\n<li>public int delete(Uri uri, String selection, String[] selectionArgs)<br>外部应用从ContentProvider删除数据。    </li>\n<li>public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)<br>外部应用更新ContentProvider中的数据。    </li>\n<li>public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)　<br>供外部应用从ContentProvider中获取数据。 　    </li>\n<li>public String getType(Uri uri)<br>该方法用于返回当前Url所代表数据的MIME类型  </li>\n</ul>\n<h5 id=\"2-创建步骤\"><a href=\"#2-创建步骤\" class=\"headerlink\" title=\"2.创建步骤\"></a>2.创建步骤</h5><p>要创建我们自己的Content Provider的话，我们需要遵循以下几步：</p>\n<p>1.创建一个继承了ContentProvider父类的类<br>2.定义一个名为CONTENT_URI，并且是public static final的Uri类型的类变量，你必须为其指定一个唯一的字符串值，最好的方案是以类的全名称， 如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Uri CONTENT_URI = Uri.parse( “content:<span class=\"comment\">//com.google.android.MyContentProvider”);</span></div></pre></td></tr></table></figure>\n<p>3.定义你要返回给客户端的数据列名。如果你正在使用Android数据库，必须为其定义一个叫_id的列，它用来表示每条记录的唯一性。<br>4.创建你的数据存储系统。大多数Content Provider使用Android文件系统或SQLite数据库来保持数据，但是你也可以以任何你想要的方式来存储。<br>5.如果你要存储字节型数据，比如位图文件等，数据列其实是一个表示实际保存文件的URI字符串，通过它来读取对应的文件数据。处理这种数据类型的Content Provider需要实现一个名为_data的字段，_data字段列出了该文件在Android文件系统上的精确路径。这个字段不仅是供客户端使用，而且也可以供ContentResolver使用。客户端可以调用ContentResolver.openOutputStream()方法来处理该URI指向的文件资源；如果是ContentResolver本身的话，由于其持有的权限比客户端要高，所以它能直接访问该数据文件。<br>6.声明public static String型的变量，用于指定要从游标处返回的数据列。<br>7.查询返回一个Cursor类型的对象。所有执行写操作的方法如insert(), update() 以及delete()都将被监听。我们可以通过使用ContentResover().notifyChange()方法来通知监听器关于数据更新的信息。<br>8.在AndroidMenifest.xml中使用<provider>标签来设置Content Provider。<br>9.如果你要处理的数据类型是一种比较新的类型，你就必须先定义一个新的MIME类型，以供ContentProvider.geType(url)来返回。MIME类型有两种形式:一种是为指定的单个记录的，还有一种是为多条记录的。这里给出一种常用的格式：   </provider></p>\n<ul>\n<li>vnd.android.cursor.item/vnd.yourcompanyname.contenttype （单个记录的MIME类型）<br>比如, 一个请求列车信息的URI如content://com.example.transportationprovider/trains/122 可能就会返回typevnd.android.cursor.item/vnd.example.rail这样一个MIME类型。   </li>\n<li>vnd.android.cursor.dir/vnd.yourcompanyname.contenttype （多个记录的MIME类型）<br>比如, 一个请求所有列车信息的URI如content://com.example.transportationprovider/trains 可能就会返回vnd.android.cursor.dir/vnd.example.rail这样一个MIME 类型。</li>\n</ul>\n<p>下面是一个Content Provider代码示例：</p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<p>一个名为MyContentProvider的Content Provider创建完成了，它用于从Sqlite数据库中添加和读取记录。</p>\n<h3 id=\"四-ContentResolver\"><a href=\"#四-ContentResolver\" class=\"headerlink\" title=\"四 ContentResolver\"></a>四 ContentResolver</h3><p>一个ContentProvider新建好了之后，我们需要一个ContentResolver类来获取其共享出的数据。</p>\n<h5 id=\"1-ContentResolver的主要方法\"><a href=\"#1-ContentResolver的主要方法\" class=\"headerlink\" title=\"1.ContentResolver的主要方法\"></a>1.ContentResolver的主要方法</h5><ul>\n<li>public Uri insert(Uri uri, ContentValues values)　//添加</li>\n<li>public int delete(Uri uri, String selection, String[] selectionArgs)　//删除</li>\n<li>public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)　//更新</li>\n<li>public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)//获取</li>\n</ul>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">ContentResolver resolver =  getContentResolver();</div><div class=\"line\">Uri uri = Uri.parse(<span class=\"string\">\"content://cn.scu.myprovider/user\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//插入</span></div><div class=\"line\">ContentValues values = <span class=\"keyword\">new</span> ContentValues();</div><div class=\"line\">values.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"fanrunqi\"</span>);</div><div class=\"line\">values.put(<span class=\"string\">\"age\"</span>, <span class=\"number\">24</span>);</div><div class=\"line\">resolver.insert(uri, values);  </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//查询</span></div><div class=\"line\">Cursor cursor = resolver.query(uri, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"string\">\"userid desc\"</span>);</div><div class=\"line\"><span class=\"keyword\">while</span>(cursor.moveToNext())&#123;</div><div class=\"line\">   <span class=\"comment\">//操作</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//更新</span></div><div class=\"line\">ContentValues updateValues = <span class=\"keyword\">new</span> ContentValues();</div><div class=\"line\">updateValues.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"finch\"</span>);</div><div class=\"line\">Uri updateIdUri = ContentUris.withAppendedId(uri, <span class=\"number\">1</span>);</div><div class=\"line\">resolver.update(updateIdUri, updateValues, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//删除</span></div><div class=\"line\">Uri deleteIdUri = ContentUris.withAppendedId(uri, <span class=\"number\">2</span>);</div><div class=\"line\">resolver.delete(deleteIdUri, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<h5 id=\"使用ContentResolver获取数据的步骤\"><a href=\"#使用ContentResolver获取数据的步骤\" class=\"headerlink\" title=\"使用ContentResolver获取数据的步骤\"></a>使用ContentResolver获取数据的步骤</h5><ol>\n<li>通过getContentResolver()方法得到ContentResol1.ver对象。</li>\n<li>调用ContentResolver类的query()方法查询数据，该方法会返回一个Cursor对象。</li>\n<li>对得到的Cursor对象进行分析，得到需要的数据。</li>\n<li>调用Cursor类的close()方法将Cursor对象关闭。</li>\n</ol>\n<p>示例代码（与上面ContentProvider处的代码相连）：</p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<h3 id=\"五-总结\"><a href=\"#五-总结\" class=\"headerlink\" title=\"五 总结\"></a>五 总结</h3>","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>ContentProvider（内容提供者）是Android的四大组件之一，通过它可以向其他的应用程序共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。而且Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。</p>\n<p>但注意ContentProvider它也只是一个中间人，真正操作的数据源可能是数据库，也可以是文件、xml或网络等其他存储方式。</p>\n<h3 id=\"Uri类简介\"><a href=\"#Uri类简介\" class=\"headerlink\" title=\"Uri类简介\"></a>Uri类简介</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri uri = Uri.parse(<span class=\"string\">\"content://com.changcheng.provider.contactprovider/contact\"</span>)</div></pre></td></tr></table></figure>\n<p>在Content Provider中使用的查询字符串有别于标准的SQL查询。很多诸如select, add, delete, modify等操作我们都使用一种特殊的URI来进行，这种URI由3个部分组成， “content://”, 代表数据的路径，和一个可选的标识数据的ID。以下是一些示例URI:    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">content:<span class=\"comment\">//media/internal/images  //这个URI将返回设备上存储的所有图片</span></div><div class=\"line\">content:<span class=\"comment\">//contacts/people/  //这个URI将返回设备上的所有联系人信息</span></div><div class=\"line\">content:<span class=\"comment\">//contacts/people/45  //这个URI返回单个结果（联系人信息中ID为45的联系人记录）</span></div></pre></td></tr></table></figure>\n<p>尽管这种查询字符串格式很常见，但是它看起来还是有点令人迷惑。为此，Android提供一系列的帮助类（在android.provider包下），里面包含了很多以类变量形式给出的查询字符串，这种方式更容易让我们理解一点，因此，如上面content://contacts/people/45这个URI就可以写成如下形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri person = ContentUris.withAppendedId(People.CONTENT_URI,  <span class=\"number\">45</span>);</div></pre></td></tr></table></figure>\n<p>然后执行数据查询:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cursor cur = managedQuery(person, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<p>这个查询返回一个包含所有数据字段的游标，我们可以通过迭代这个游标来获取所有的数据.</p>\n<h3 id=\"三-ContentProvider类简介\"><a href=\"#三-ContentProvider类简介\" class=\"headerlink\" title=\"三 ContentProvider类简介\"></a>三 ContentProvider类简介</h3><h5 id=\"1-主要方法\"><a href=\"#1-主要方法\" class=\"headerlink\" title=\"1.主要方法\"></a>1.主要方法</h5><ul>\n<li>public boolean onCreate()<br>ContentProvider创建后　或　打开系统后其它应用第一次访问该ContentProvider时调用。      </li>\n<li>public Uri insert(Uri uri, ContentValues values)<br>外部应用向ContentProvider中添加数据。    </li>\n<li>public int delete(Uri uri, String selection, String[] selectionArgs)<br>外部应用从ContentProvider删除数据。    </li>\n<li>public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)<br>外部应用更新ContentProvider中的数据。    </li>\n<li>public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)　<br>供外部应用从ContentProvider中获取数据。 　    </li>\n<li>public String getType(Uri uri)<br>该方法用于返回当前Url所代表数据的MIME类型  </li>\n</ul>\n<h5 id=\"2-创建步骤\"><a href=\"#2-创建步骤\" class=\"headerlink\" title=\"2.创建步骤\"></a>2.创建步骤</h5><p>要创建我们自己的Content Provider的话，我们需要遵循以下几步：</p>\n<p>1.创建一个继承了ContentProvider父类的类<br>2.定义一个名为CONTENT_URI，并且是public static final的Uri类型的类变量，你必须为其指定一个唯一的字符串值，最好的方案是以类的全名称， 如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Uri CONTENT_URI = Uri.parse( “content:<span class=\"comment\">//com.google.android.MyContentProvider”);</span></div></pre></td></tr></table></figure>\n<p>3.定义你要返回给客户端的数据列名。如果你正在使用Android数据库，必须为其定义一个叫_id的列，它用来表示每条记录的唯一性。<br>4.创建你的数据存储系统。大多数Content Provider使用Android文件系统或SQLite数据库来保持数据，但是你也可以以任何你想要的方式来存储。<br>5.如果你要存储字节型数据，比如位图文件等，数据列其实是一个表示实际保存文件的URI字符串，通过它来读取对应的文件数据。处理这种数据类型的Content Provider需要实现一个名为_data的字段，_data字段列出了该文件在Android文件系统上的精确路径。这个字段不仅是供客户端使用，而且也可以供ContentResolver使用。客户端可以调用ContentResolver.openOutputStream()方法来处理该URI指向的文件资源；如果是ContentResolver本身的话，由于其持有的权限比客户端要高，所以它能直接访问该数据文件。<br>6.声明public static String型的变量，用于指定要从游标处返回的数据列。<br>7.查询返回一个Cursor类型的对象。所有执行写操作的方法如insert(), update() 以及delete()都将被监听。我们可以通过使用ContentResover().notifyChange()方法来通知监听器关于数据更新的信息。<br>8.在AndroidMenifest.xml中使用<provider>标签来设置Content Provider。<br>9.如果你要处理的数据类型是一种比较新的类型，你就必须先定义一个新的MIME类型，以供ContentProvider.geType(url)来返回。MIME类型有两种形式:一种是为指定的单个记录的，还有一种是为多条记录的。这里给出一种常用的格式：   </p>\n<ul>\n<li>vnd.android.cursor.item/vnd.yourcompanyname.contenttype （单个记录的MIME类型）<br>比如, 一个请求列车信息的URI如content://com.example.transportationprovider/trains/122 可能就会返回typevnd.android.cursor.item/vnd.example.rail这样一个MIME类型。   </li>\n<li>vnd.android.cursor.dir/vnd.yourcompanyname.contenttype （多个记录的MIME类型）<br>比如, 一个请求所有列车信息的URI如content://com.example.transportationprovider/trains 可能就会返回vnd.android.cursor.dir/vnd.example.rail这样一个MIME 类型。</li>\n</ul>\n<p>下面是一个Content Provider代码示例：</p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<p>一个名为MyContentProvider的Content Provider创建完成了，它用于从Sqlite数据库中添加和读取记录。</p>\n<h3 id=\"四-ContentResolver\"><a href=\"#四-ContentResolver\" class=\"headerlink\" title=\"四 ContentResolver\"></a>四 ContentResolver</h3><p>一个ContentProvider新建好了之后，我们需要一个ContentResolver类来获取其共享出的数据。</p>\n<h5 id=\"1-ContentResolver的主要方法\"><a href=\"#1-ContentResolver的主要方法\" class=\"headerlink\" title=\"1.ContentResolver的主要方法\"></a>1.ContentResolver的主要方法</h5><ul>\n<li>public Uri insert(Uri uri, ContentValues values)　//添加</li>\n<li>public int delete(Uri uri, String selection, String[] selectionArgs)　//删除</li>\n<li>public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)　//更新</li>\n<li>public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)//获取</li>\n</ul>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">ContentResolver resolver =  getContentResolver();</div><div class=\"line\">Uri uri = Uri.parse(<span class=\"string\">\"content://cn.scu.myprovider/user\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//插入</span></div><div class=\"line\">ContentValues values = <span class=\"keyword\">new</span> ContentValues();</div><div class=\"line\">values.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"fanrunqi\"</span>);</div><div class=\"line\">values.put(<span class=\"string\">\"age\"</span>, <span class=\"number\">24</span>);</div><div class=\"line\">resolver.insert(uri, values);  </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//查询</span></div><div class=\"line\">Cursor cursor = resolver.query(uri, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"string\">\"userid desc\"</span>);</div><div class=\"line\"><span class=\"keyword\">while</span>(cursor.moveToNext())&#123;</div><div class=\"line\">   <span class=\"comment\">//操作</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//更新</span></div><div class=\"line\">ContentValues updateValues = <span class=\"keyword\">new</span> ContentValues();</div><div class=\"line\">updateValues.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"finch\"</span>);</div><div class=\"line\">Uri updateIdUri = ContentUris.withAppendedId(uri, <span class=\"number\">1</span>);</div><div class=\"line\">resolver.update(updateIdUri, updateValues, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//删除</span></div><div class=\"line\">Uri deleteIdUri = ContentUris.withAppendedId(uri, <span class=\"number\">2</span>);</div><div class=\"line\">resolver.delete(deleteIdUri, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<h5 id=\"使用ContentResolver获取数据的步骤\"><a href=\"#使用ContentResolver获取数据的步骤\" class=\"headerlink\" title=\"使用ContentResolver获取数据的步骤\"></a>使用ContentResolver获取数据的步骤</h5><ol>\n<li>通过getContentResolver()方法得到ContentResol1.ver对象。</li>\n<li>调用ContentResolver类的query()方法查询数据，该方法会返回一个Cursor对象。</li>\n<li>对得到的Cursor对象进行分析，得到需要的数据。</li>\n<li>调用Cursor类的close()方法将Cursor对象关闭。</li>\n</ol>\n<p>示例代码（与上面ContentProvider处的代码相连）：</p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<h3 id=\"五-总结\"><a href=\"#五-总结\" class=\"headerlink\" title=\"五 总结\"></a>五 总结</h3>"},{"title":"android基础之Fragments","date":"2017-02-27T06:31:31.000Z","_content":"\n### 一 概述   \nFragment表现Activity中用户界面的一个行为或者是一部分。你可以在一个单独的activity上把多个fragment组合成为一个多区域的UI，并且可以在多个activity中再使用。你可以认为fragment是activity的一个模块零件，它有自己的生命周期，接收它自己的输入事件，并且可以在activity运行时添加或者删除。\n\nFragment必须总是被嵌入到一个activity之中，并且fragment的生命周期直接受其宿主activity的生命周期的影响。例如，一旦activity被暂停，它里面所有的fragment也被暂停，一旦activity被销毁，它里面所有的fragment也被销毁。然而，当activity正在运行时（处于resumed的生命周期状态），你可以单独的操控每个fragment，比如添加或者删除。当你执行这样一项事务时，可以将它添加到后台的一个栈中，这个栈由activity管理着——activity里面的每个后台栈内容实体是fragment发生过的一条事务记录。这个后台栈允许用户通过按BACK键回退一项fragment事务（往后导航）。\n\n当你添加一个fragment作为某个activity布局的一部分时，它就存在于这个activity视图体系内部的ViewGroup之中，并且定义了它自己的视图布局。你可以通过在activity布局文件中声明fragment，用<fragment>元素把fragment插入到activity的布局中，或者是用应用程序源码将它添加到一个存在的ViewGroup中。然而，fragment并不是一个定要作为activity布局的一部分；fragment也可以为activity隐身工作。   \n\n### 二 Fragment的继承结构   \n继承 Object\n实现 ComponentCallbacks2 View.OnCreateContextMenuListener \n      \n```java \njava.lang.Object\n   ↳ \tandroid.app.Fragment\n```\n直接子类：\nDialogFragment, ListFragment, PreferenceFragment, WebViewFragment      \n\n### 三 Fragment设计哲学  \nFragment被设计出来主要为了适应平板等大屏幕移动设备。有了fragment，你可以不必去管理视图体系的复杂变化。通过将activity的布局分割成若干个fragment，可以在运行时编辑activity的呈现，并且那些变化会被保存在由activity管理的后台栈里面。  \n如下图所示，一个Activity中的两个Fragment分别在手机和平板的显示情况：    \n{% asset_img Fragment显示图.png Fragment显示图 %}     \n\n### 四 Fragment的生命周期   \n下面是Activity的生命周期：     \n{% asset_img Fragment生命周期图.png Fragment生命周期图 %}    \n管理fragment生命周期与管理activity生命周期很相像。像activity一样，fragment也有三种状态：    \n- Resumed    \nfragment在运行中的activity可见。    \n- Paused    \n 另一个activity处于前台且得到焦点，但是这个fragment所在的activity仍然可见（前台activity部分透明，或者没有覆盖全屏）。   \n- Stopped   \nfragment不可见。要么宿主activity已经停止，要么fragment已经从activity上移除，但已被添加到后台栈中。一个停止的fragment仍然活着（所有状态和成员信息仍然由系统保留着）。但是，它对用户来讲已经不再可见，并且如果activity被杀掉，它也将被杀掉。     \n同activity类似的还有，你也可以用Bundle保存fragment状态，万一activity的进程被杀掉了，并且在activity被重新创建时，你需要恢复fragment状态。在回调执行fragment的onSaveInstanceState()期间可以保存状态，在onCreate()，onCreateView()，或者onActvityCreate()中可以恢复状态。      \n在生命周期方面,activity与fragment之间一个很重要的不同，就是在各自的后台栈中是如何存储的。当activity停止时，默认情况下，activity被安置在由系统管理的activity后台栈中（因此用户可以按BACK键回退导航，就像在Tasks和后台栈中讨论的那样）。但是，仅当你在一个事务被移除时，通过显式调用addToBackStack()请求保存的实例，该fragment才被置于由宿主activity管理的后台栈。     \n除此之外，管理fragment的生命周期与管理activity的生命周期非常相似。所以，管理activity生命周期的实践同样也适用于fragment。你需要了解的，仅仅是activity的生命周期如何影响fragment的的。    \n\n### 五 与Activity生命周期协调合作 \n下面是Activity与Fragment生命周期图对比：    \n{% asset_img Fragment与Activity生命周期对比.png Fragment与Activity生命周期对比 %}      \nfragment所生存的activity生命周期直接影响着fragment的生命周期，由此针对activity的每一个生命周期回调都会引发一个fragment类似的回调。例如，当activity接收到onPause()时，这个activity之中的每个fragment都会接收到onPause()。     \nFragment有一些额外的生命周期回调方法，然而，为了处理像是创建和销毁fragment界面，它与activity进行独特的交互。这些额外的回调方法是：     \n- onAttach()     \n 当fragment被绑定到activity时调用（Activity会被传入）。 \n-  onCreateView()    \n创建与fragment相关的视图体系时被调用。     \n- onActivityCreated()     \n当activity的onCreate()函数返回时被调用。     \n- onDestroyView()     \n当与fragment关联的视图体系正被移除时被调用。     \n- onDetach()    \n当fragment正与activity解除关联时被调用。      \n\nfragment的生命周期流程实际上是受其宿主activity影响，如上图所示。在这张图中，可以看到activity的每个连续状态是如何决定fragment可能接收到哪个回调函数的。例如，当activity接收到它的onCreate()回调时，activity之中的fragment接收到的仅仅是onActivityCreated()回调。\n\n一旦activity处于resumed状态，则可以在activity中自由的添加或者移除fragment。因此，只有当activity处于resumed状态时，fragment的生命周期才可以独立变化。\n\n然而，当activity离开恢复状态时，fragment再一次被activity推入它的生命周期中。\n\n### 六 向Fragment中添加用户界面    \nfragment常被用作activity用户界面的一部分，并且将本身的布局构建到activity中去。     \n为了给fragment提供一个布局，你必须实现onCreateView()回调函数，在绘制fragment布局时Android系统会调用它。实现这个函数时需要返回fragment所属的根View。     \n\n> 注意：如果你的fragment时ListFragment的子类，默认实现从onCreateView()返回一个ListView，所以你不需要实现它。    \n   \n为了从onCreateView()返回一个布局，你可以从layout resource定义的XML文件inflate它。为了便于你这样做，onCreateView()提供一个LayoutInflater对象。   \n例如，下面是一个fragment子类，它的布局从example_fragment.xml载入的：    \n\n```java  \npublic static class ExampleFragment extends Fragment {\n\t\t@Override\n\t\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container,\n\t\t\t\t\t\t\t\t Bundle savedInstanceState) {\n\t\t\t// Inflate the layout for this fragment\n\t\t\treturn inflater.inflate(R.layout.example_fragment, container, false);\n\t\t}\n\t}\n```\n\n传入onCreateView()的参数container 是你的frament布局将要被插入的父ViewGroup（来自activity的布局）。如果fragment处于resumed状态（恢复状态在操纵fragment生命周期一节中将作更多讨论），参数savedInstanceState是属于Bundle类，它提供了fragment之前实例的相关数据。     \n\ninflate()函数需要以下三个参数：     \n- 要inflate的布局的资源ID。      \n- 被inflate的布局的父ViewGroup。传入container很重要，这是为了让系统将布局参数应用到被inflate的布局的根view中去，由其将要嵌入的父view指定。    \n- 一个布尔值，表明在inflate期间被infalte的布局是否应该附上ViewGroup（第二个参数）。（在这个例子中传入的是false，因为系统已经将被inflate的布局插入到容器中（container）——传入true会在最终的布局里创建一个多余的ViewGroup。）       \n\n现在你已经知道了如何创建一个有布局的fragment。下一步，则需要将fragment添加到activity中。      \n\n### 七 将Fragment添加到Activity中    \n通常，fragment构建了其宿主activity的部分界面，它被作为activity全部视图层次体系的一部分被嵌入进去。在acitivity布局中添加fragment有两种方法：     \n\n##### 在activity的布局文件里声明fragment\n\n像这样，你可以像为view一样为fragment指定布局属性。例如，下面含有两个fragment的布局文件：\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t\tandroid:orientation=\"horizontal\"\n\t\tandroid:layout_width=\"match_parent\"\n\t\tandroid:layout_height=\"match_parent\">\n\t\t<fragment android:name=\"com.example.news.ArticleListFragment\"\n\t\t\t\tandroid:id=\"@+id/list\"\n\t\t\t\tandroid:layout_weight=\"1\"\n\t\t\t\tandroid:layout_width=\"0dp\"\n\t\t\t\tandroid:layout_height=\"match_parent\" />\n\t\t<fragment android:name=\"com.example.news.ArticleReaderFragment\"\n\t\t\t\tandroid:id=\"@+id/viewer\"\n\t\t\t\tandroid:layout_weight=\"2\"\n\t\t\t\tandroid:layout_width=\"0dp\"\n\t\t\t\tandroid:layout_height=\"match_parent\" />\n\t</LinearLayout>\n```\n\n<fragment>中的android:name 属性指定了布局中实例化的Fragment类。\n\n当系统创建activity布局时，它实例化了布局文件中指定的每一个fragment，并为它们调用onCreateView()函数，以获取每一个fragment的布局。系统直接在<fragment>元素的位置插入fragment返回的View。\n\n> 注意：每个fragment都需要一个唯一的标识，如果重启activity，系统可用来恢复fragment（并且可用来捕捉fragment的事务处理，例如移除）。为fragment提供ID有三种方法：   \n- 用android:id属性提供一个唯一的标识。   \n- 用android:tag属性提供一个唯一的字符串。   \n- 如果上述两个属性都没有，系统会使用其容器视图（view）的ID。 \n\n##### 通过java代码将fragment添加到已存在的ViewGroup中\n\n在activity运行的任何时候，你都可以将fragment添加到activity布局中。你仅需要简单指定用来放置fragment的ViewGroup。\n\n你应当使用FragmentTransaction的API来对activity中的fragment进行操作（例如添加，移除，或者替换fragment）。你可以像下面这样从Activity中取得FragmentTransaction的实例：\n\n```java\nFragmentManager fragmentManager = getFragmentManager()\n\tFragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n```\n\n可以用add()函数添加fragment，并指定要添加的fragment以及要将其插入到哪个视图（view）之中：\n\n```java\nExampleFragment fragment = new ExampleFragment();\n\tfragmentTransaction.add(R.id.fragment_container, fragment);\n\tfragmentTransaction.commit();\n```\n\n传入add()函数的第一个参数是fragment被放置的ViewGroup，它由资源ID（resource ID）指定，第二个参数就是要添加的fragment。一旦通过FragmentTransaction 做了更改，都应当使用commit()使变化生效。\n\n##### 添加无界面的Fragment\n\n上面的例子是如何将fragment添加到activity中去，目的是提供一个用户界面。然而，也可以使用fragment为activity提供后台动作，却不呈现多余的用户界面。\n\n想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。\n\n想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。  \n\n\n### 八 Fragment事务后台栈     \n\n在activity中使用fragment的一大特点是具有添加、删除、替换，和执行其它动作的能力，以响应用户的互动。提交给activity的每一系列变化被称为事务，并且可以用FragmentTransaction 中的APIs处理。你也可以将每一个事务保存在由activity管理的后台栈中，并且允许用户导航回退fragment变更（类似于activity的导航回退）。  \n\n你可以从FragmentManager中获取FragmentTransaction实例，像这样：\n\n```java\nFragmentManager fragmentManager = getFragmentManager();\n FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n```\n\n每项事务是在同一时间内要执行的一系列的变更。你可以为一个给定的事务用相关方法设置想要执行的所有变化，例如add()，remove()，和replace()。然后，用commit()将事务提交给activity。然而，在调用commit()之前，为了将事务添加到fragment事务后台栈中，你可能会想调用addToBackStatck()。这个后台栈由activity管理，并且允许用户通过按BACK键回退到前一个fragment状态。   \n举个例子，下面的代码是如何使用另一个fragment代替一个fragment，并且将之前的状态保留在后台栈中：\n\n```java\n// Create new fragment and transaction\n Fragment newFragment = new ExampleFragment();\n FragmentTransaction transaction = getFragmentManager().beginTransaction();\n\n // Replace whatever is in the fragment_container view with this fragment,\n // and add the transaction to the back stack\n transaction.replace(R.id.fragment_container, newFragment);\n transaction.addToBackStack(null);\n\n // Commit the transaction\n transaction.commit();\n```\n\n在这个例子中，newFragment替换了当前在布局容器中用R.id.fragment_container标识的所有的fragment（如果有的话），替代的事务被保存在后台栈中，因此用户可以回退该事务，可通过按BACK键还原之前的fragment。如果添加多个变更事务（例如另一个add()或者remove()）并调用addToBackStack()，那么在调用commit()之前的所有应用的变更被作为一个单独的事务添加到后台栈中，并且BACK键可以将它们一起回退。\n\n将变更添加到FragmentTransaction中的顺序注意以下两点：     \n- 必须要在最后调用commit()   \n- 如果你正将多个fragment添加到同一个容器中，那么添加顺序决定了它们在视图层次（view hierarchy）里显示的顺序。 \n\n在执行删除fragment事务时，如果没有调用addToBackStack()，那么事务一提交fragment就会被销毁，而且用户也无法回退它。然而，当移除一个fragment时，如果调用了addToBackStack()，那么之后fragment会被停止，如果用户回退，它将被恢复过来。     \n> 提示：对于每一个fragment事务，在提交之前通过调用setTransition()来应用一系列事务动作。     \n\n调用commit()并不立刻执行事务，相反，而是采取预约方式，一旦activity的界面线程（主线程）准备好便可运行起来。然而，如果有必要的话，你可以从界面线程调用executePendingTransations()立即执行由commit()提交的事务。但这样做，通常是没有必要的，除非其它线程的工作依赖与该项事务。\n\n> 警告：只能在activity保存状态（当用户离开activity时）之前用commit()提交事务。如果你尝试在那时之后提交，会抛出一个异常。这是因为如果activity需要被恢复，提交后的状态会被丢失。对于这类丢失提交的情况，可使用commitAllowingStateLoss() \n\n\n### 九 与Activity交互      \n##### 1.Fragment可以得到宿主Activity的引用\n尽管Fragment被实现为一个对象，它独立于Activity并可以在多个Activity中使用，一个给定的fragment实例直接被捆绑在包含它的Activity中。特别是，fragment可以通过getActivity()函数访问Activity，并且很容易的执行类似于查找activity布局中的视图的任务：\n\n```java\nView listView = getActivity().findViewById(R.id.list);\n```\n\n##### 2.Activity获取Fragment的引用\n同样的，activity能够调用fragment的函数findFragmentById()或者findFragmentByTag()，从FragmentManager中获取Fragment的索引，例如：\n\n```java\nExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);\n```\n\n##### 3.创建Activity时间回调函数\n\n在一些情况下，你可能需要fragment与activity共享事件。这样做的一个好方法是在fragment内部定义一个回调接口，并需要宿主activity实现它。当activity通过接口接收到回调时，可以在必要时与布局中的其它fragment共享信息。    \n举个例子，如果新闻应用的actvity中有两个fragment——一个显示文章列表（fragment A），另一个显示一篇文章（fragment B）——然后fragment A 必须要告诉activity列表项何时被选种，这样，activity可以通知fragment B显示这篇文章。这种情况下，在fragment A内部声明接口OnArticleSelectedListener：\n\n```java\npublic static class FragmentA extends ListFragment {\n    ...\n    // Container Activity must implement this interface\n    public interface OnArticleSelectedListener {\n        public void onArticleSelected(Uri articleUri);\n    }\n    ...\n}\n```\n\n然后fragment的宿主activity实现了OnArticleSelectedListener接口，并且重写onArticleSelected()以通知fragment B来自于fragment A的事件。为了确保宿主activity实现了这个接口，fragment A的onAttach()回调函数（当添加fragment到activity中时系统会调用它）通过作为参数传入onAttach()的activity的类型转换来实例化一个OnArticleSelectedListener实例。\n\n```java\npublic static class FragmentA extends ListFragment {\n    OnArticleSelectedListener mListener;\n    ...\n    @Override\n    public void onAttach(Activity activity) {\n        super.onAttach(activity);\n        try {\n            mListener = (OnArticleSelectedListener) activity;\n        } catch (ClassCastException e) {\n            throw new ClassCastException(activity.toString() + \" must implement OnArticleSelectedListener\");\n        }\n    }\n    ...\n}\n```\n\n如果activity没有实现这个接口，那么fragment会抛出一个ClassCaseException异常。一旦成功，mListener成员会保留一个activity的OnArticleSelectedListener实现的引用，由此fragment A可以通过调用由OnArticleSelectedListener接口定义的方法与activity共享事件。例如，如果fragment A是ListFragment的子类，每次用户点击列表项时，系统都会调用fragment的onListItemClick()事件，然后fragment调用onArticleSelected()来与activity共享事件。\n\n```java\npublic static class FragmentA extends ListFragment {\n    OnArticleSelectedListener mListener;\n    ...\n    @Override\n    public void onListItemClick(ListView l, View v, int position, long id) {\n        // Append the clicked item's row ID with the content provider Uri\n        Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);\n        // Send the event and Uri to the host activity\n        mListener.onArticleSelected(noteUri);\n    }\n    ...\n}\n```\n\n传递给onListItemClick()的参数id是点击的列表项行id，activity（或者其它fragment）用以从应用的ContentProvider获取文章。\n\n#####　添加items到Action Bar\n\n你的fragments可以通过实现onCreateOptionsMenu()来构建菜单项到activity的Options Menu（因此Action Bar也一样）。为了使用这个方法接收到调用，不管怎样，你必须在onCreate()期间调用setHasOptionsMenu()，来指明想要添加项目到Options Menu的那个fragment（否则，fragment将接收不到onCreateOptionsMenu()的调用）。     \n任何想要在fragment中的Options Menu添加的项目都追加到已有的菜单项后面。当菜单项被选中时，fragment也会接收到对onOptionsItemSelected()的回调。    \n你也可以通过调用registerForContextMenu()在fragment布局中注册一个view以提供一个context menu。当用户打开context menu时，fragment接收到对onCreateContextMenu()的回调。当用户选中一个项目时，fragment接收到对onContextItemSelected()的回调。\n\n> 注意：尽管你的fragment会接收到为添加到每个菜单项被选择菜单项的回调，但当用户选择一个菜单项时，activity会首先接收到对应的回调。如果activity的选择菜单项回调的实现没有处理被选中的项目，那么该事件被传递给fragment的回调。这同样适用于Options Menu和context menu。\n\n### 十 总结\n\n\n\n","source":"_posts/android基础之Fragments.md","raw":"---\ntitle: android基础之Fragments\ndate: 2017-02-27 14:31:31\ncategories: android\ntags:\n- android\n- java\n- Fragment\n---\n\n### 一 概述   \nFragment表现Activity中用户界面的一个行为或者是一部分。你可以在一个单独的activity上把多个fragment组合成为一个多区域的UI，并且可以在多个activity中再使用。你可以认为fragment是activity的一个模块零件，它有自己的生命周期，接收它自己的输入事件，并且可以在activity运行时添加或者删除。\n\nFragment必须总是被嵌入到一个activity之中，并且fragment的生命周期直接受其宿主activity的生命周期的影响。例如，一旦activity被暂停，它里面所有的fragment也被暂停，一旦activity被销毁，它里面所有的fragment也被销毁。然而，当activity正在运行时（处于resumed的生命周期状态），你可以单独的操控每个fragment，比如添加或者删除。当你执行这样一项事务时，可以将它添加到后台的一个栈中，这个栈由activity管理着——activity里面的每个后台栈内容实体是fragment发生过的一条事务记录。这个后台栈允许用户通过按BACK键回退一项fragment事务（往后导航）。\n\n当你添加一个fragment作为某个activity布局的一部分时，它就存在于这个activity视图体系内部的ViewGroup之中，并且定义了它自己的视图布局。你可以通过在activity布局文件中声明fragment，用<fragment>元素把fragment插入到activity的布局中，或者是用应用程序源码将它添加到一个存在的ViewGroup中。然而，fragment并不是一个定要作为activity布局的一部分；fragment也可以为activity隐身工作。   \n\n### 二 Fragment的继承结构   \n继承 Object\n实现 ComponentCallbacks2 View.OnCreateContextMenuListener \n      \n```java \njava.lang.Object\n   ↳ \tandroid.app.Fragment\n```\n直接子类：\nDialogFragment, ListFragment, PreferenceFragment, WebViewFragment      \n\n### 三 Fragment设计哲学  \nFragment被设计出来主要为了适应平板等大屏幕移动设备。有了fragment，你可以不必去管理视图体系的复杂变化。通过将activity的布局分割成若干个fragment，可以在运行时编辑activity的呈现，并且那些变化会被保存在由activity管理的后台栈里面。  \n如下图所示，一个Activity中的两个Fragment分别在手机和平板的显示情况：    \n{% asset_img Fragment显示图.png Fragment显示图 %}     \n\n### 四 Fragment的生命周期   \n下面是Activity的生命周期：     \n{% asset_img Fragment生命周期图.png Fragment生命周期图 %}    \n管理fragment生命周期与管理activity生命周期很相像。像activity一样，fragment也有三种状态：    \n- Resumed    \nfragment在运行中的activity可见。    \n- Paused    \n 另一个activity处于前台且得到焦点，但是这个fragment所在的activity仍然可见（前台activity部分透明，或者没有覆盖全屏）。   \n- Stopped   \nfragment不可见。要么宿主activity已经停止，要么fragment已经从activity上移除，但已被添加到后台栈中。一个停止的fragment仍然活着（所有状态和成员信息仍然由系统保留着）。但是，它对用户来讲已经不再可见，并且如果activity被杀掉，它也将被杀掉。     \n同activity类似的还有，你也可以用Bundle保存fragment状态，万一activity的进程被杀掉了，并且在activity被重新创建时，你需要恢复fragment状态。在回调执行fragment的onSaveInstanceState()期间可以保存状态，在onCreate()，onCreateView()，或者onActvityCreate()中可以恢复状态。      \n在生命周期方面,activity与fragment之间一个很重要的不同，就是在各自的后台栈中是如何存储的。当activity停止时，默认情况下，activity被安置在由系统管理的activity后台栈中（因此用户可以按BACK键回退导航，就像在Tasks和后台栈中讨论的那样）。但是，仅当你在一个事务被移除时，通过显式调用addToBackStack()请求保存的实例，该fragment才被置于由宿主activity管理的后台栈。     \n除此之外，管理fragment的生命周期与管理activity的生命周期非常相似。所以，管理activity生命周期的实践同样也适用于fragment。你需要了解的，仅仅是activity的生命周期如何影响fragment的的。    \n\n### 五 与Activity生命周期协调合作 \n下面是Activity与Fragment生命周期图对比：    \n{% asset_img Fragment与Activity生命周期对比.png Fragment与Activity生命周期对比 %}      \nfragment所生存的activity生命周期直接影响着fragment的生命周期，由此针对activity的每一个生命周期回调都会引发一个fragment类似的回调。例如，当activity接收到onPause()时，这个activity之中的每个fragment都会接收到onPause()。     \nFragment有一些额外的生命周期回调方法，然而，为了处理像是创建和销毁fragment界面，它与activity进行独特的交互。这些额外的回调方法是：     \n- onAttach()     \n 当fragment被绑定到activity时调用（Activity会被传入）。 \n-  onCreateView()    \n创建与fragment相关的视图体系时被调用。     \n- onActivityCreated()     \n当activity的onCreate()函数返回时被调用。     \n- onDestroyView()     \n当与fragment关联的视图体系正被移除时被调用。     \n- onDetach()    \n当fragment正与activity解除关联时被调用。      \n\nfragment的生命周期流程实际上是受其宿主activity影响，如上图所示。在这张图中，可以看到activity的每个连续状态是如何决定fragment可能接收到哪个回调函数的。例如，当activity接收到它的onCreate()回调时，activity之中的fragment接收到的仅仅是onActivityCreated()回调。\n\n一旦activity处于resumed状态，则可以在activity中自由的添加或者移除fragment。因此，只有当activity处于resumed状态时，fragment的生命周期才可以独立变化。\n\n然而，当activity离开恢复状态时，fragment再一次被activity推入它的生命周期中。\n\n### 六 向Fragment中添加用户界面    \nfragment常被用作activity用户界面的一部分，并且将本身的布局构建到activity中去。     \n为了给fragment提供一个布局，你必须实现onCreateView()回调函数，在绘制fragment布局时Android系统会调用它。实现这个函数时需要返回fragment所属的根View。     \n\n> 注意：如果你的fragment时ListFragment的子类，默认实现从onCreateView()返回一个ListView，所以你不需要实现它。    \n   \n为了从onCreateView()返回一个布局，你可以从layout resource定义的XML文件inflate它。为了便于你这样做，onCreateView()提供一个LayoutInflater对象。   \n例如，下面是一个fragment子类，它的布局从example_fragment.xml载入的：    \n\n```java  \npublic static class ExampleFragment extends Fragment {\n\t\t@Override\n\t\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container,\n\t\t\t\t\t\t\t\t Bundle savedInstanceState) {\n\t\t\t// Inflate the layout for this fragment\n\t\t\treturn inflater.inflate(R.layout.example_fragment, container, false);\n\t\t}\n\t}\n```\n\n传入onCreateView()的参数container 是你的frament布局将要被插入的父ViewGroup（来自activity的布局）。如果fragment处于resumed状态（恢复状态在操纵fragment生命周期一节中将作更多讨论），参数savedInstanceState是属于Bundle类，它提供了fragment之前实例的相关数据。     \n\ninflate()函数需要以下三个参数：     \n- 要inflate的布局的资源ID。      \n- 被inflate的布局的父ViewGroup。传入container很重要，这是为了让系统将布局参数应用到被inflate的布局的根view中去，由其将要嵌入的父view指定。    \n- 一个布尔值，表明在inflate期间被infalte的布局是否应该附上ViewGroup（第二个参数）。（在这个例子中传入的是false，因为系统已经将被inflate的布局插入到容器中（container）——传入true会在最终的布局里创建一个多余的ViewGroup。）       \n\n现在你已经知道了如何创建一个有布局的fragment。下一步，则需要将fragment添加到activity中。      \n\n### 七 将Fragment添加到Activity中    \n通常，fragment构建了其宿主activity的部分界面，它被作为activity全部视图层次体系的一部分被嵌入进去。在acitivity布局中添加fragment有两种方法：     \n\n##### 在activity的布局文件里声明fragment\n\n像这样，你可以像为view一样为fragment指定布局属性。例如，下面含有两个fragment的布局文件：\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t\tandroid:orientation=\"horizontal\"\n\t\tandroid:layout_width=\"match_parent\"\n\t\tandroid:layout_height=\"match_parent\">\n\t\t<fragment android:name=\"com.example.news.ArticleListFragment\"\n\t\t\t\tandroid:id=\"@+id/list\"\n\t\t\t\tandroid:layout_weight=\"1\"\n\t\t\t\tandroid:layout_width=\"0dp\"\n\t\t\t\tandroid:layout_height=\"match_parent\" />\n\t\t<fragment android:name=\"com.example.news.ArticleReaderFragment\"\n\t\t\t\tandroid:id=\"@+id/viewer\"\n\t\t\t\tandroid:layout_weight=\"2\"\n\t\t\t\tandroid:layout_width=\"0dp\"\n\t\t\t\tandroid:layout_height=\"match_parent\" />\n\t</LinearLayout>\n```\n\n<fragment>中的android:name 属性指定了布局中实例化的Fragment类。\n\n当系统创建activity布局时，它实例化了布局文件中指定的每一个fragment，并为它们调用onCreateView()函数，以获取每一个fragment的布局。系统直接在<fragment>元素的位置插入fragment返回的View。\n\n> 注意：每个fragment都需要一个唯一的标识，如果重启activity，系统可用来恢复fragment（并且可用来捕捉fragment的事务处理，例如移除）。为fragment提供ID有三种方法：   \n- 用android:id属性提供一个唯一的标识。   \n- 用android:tag属性提供一个唯一的字符串。   \n- 如果上述两个属性都没有，系统会使用其容器视图（view）的ID。 \n\n##### 通过java代码将fragment添加到已存在的ViewGroup中\n\n在activity运行的任何时候，你都可以将fragment添加到activity布局中。你仅需要简单指定用来放置fragment的ViewGroup。\n\n你应当使用FragmentTransaction的API来对activity中的fragment进行操作（例如添加，移除，或者替换fragment）。你可以像下面这样从Activity中取得FragmentTransaction的实例：\n\n```java\nFragmentManager fragmentManager = getFragmentManager()\n\tFragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n```\n\n可以用add()函数添加fragment，并指定要添加的fragment以及要将其插入到哪个视图（view）之中：\n\n```java\nExampleFragment fragment = new ExampleFragment();\n\tfragmentTransaction.add(R.id.fragment_container, fragment);\n\tfragmentTransaction.commit();\n```\n\n传入add()函数的第一个参数是fragment被放置的ViewGroup，它由资源ID（resource ID）指定，第二个参数就是要添加的fragment。一旦通过FragmentTransaction 做了更改，都应当使用commit()使变化生效。\n\n##### 添加无界面的Fragment\n\n上面的例子是如何将fragment添加到activity中去，目的是提供一个用户界面。然而，也可以使用fragment为activity提供后台动作，却不呈现多余的用户界面。\n\n想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。\n\n想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。  \n\n\n### 八 Fragment事务后台栈     \n\n在activity中使用fragment的一大特点是具有添加、删除、替换，和执行其它动作的能力，以响应用户的互动。提交给activity的每一系列变化被称为事务，并且可以用FragmentTransaction 中的APIs处理。你也可以将每一个事务保存在由activity管理的后台栈中，并且允许用户导航回退fragment变更（类似于activity的导航回退）。  \n\n你可以从FragmentManager中获取FragmentTransaction实例，像这样：\n\n```java\nFragmentManager fragmentManager = getFragmentManager();\n FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n```\n\n每项事务是在同一时间内要执行的一系列的变更。你可以为一个给定的事务用相关方法设置想要执行的所有变化，例如add()，remove()，和replace()。然后，用commit()将事务提交给activity。然而，在调用commit()之前，为了将事务添加到fragment事务后台栈中，你可能会想调用addToBackStatck()。这个后台栈由activity管理，并且允许用户通过按BACK键回退到前一个fragment状态。   \n举个例子，下面的代码是如何使用另一个fragment代替一个fragment，并且将之前的状态保留在后台栈中：\n\n```java\n// Create new fragment and transaction\n Fragment newFragment = new ExampleFragment();\n FragmentTransaction transaction = getFragmentManager().beginTransaction();\n\n // Replace whatever is in the fragment_container view with this fragment,\n // and add the transaction to the back stack\n transaction.replace(R.id.fragment_container, newFragment);\n transaction.addToBackStack(null);\n\n // Commit the transaction\n transaction.commit();\n```\n\n在这个例子中，newFragment替换了当前在布局容器中用R.id.fragment_container标识的所有的fragment（如果有的话），替代的事务被保存在后台栈中，因此用户可以回退该事务，可通过按BACK键还原之前的fragment。如果添加多个变更事务（例如另一个add()或者remove()）并调用addToBackStack()，那么在调用commit()之前的所有应用的变更被作为一个单独的事务添加到后台栈中，并且BACK键可以将它们一起回退。\n\n将变更添加到FragmentTransaction中的顺序注意以下两点：     \n- 必须要在最后调用commit()   \n- 如果你正将多个fragment添加到同一个容器中，那么添加顺序决定了它们在视图层次（view hierarchy）里显示的顺序。 \n\n在执行删除fragment事务时，如果没有调用addToBackStack()，那么事务一提交fragment就会被销毁，而且用户也无法回退它。然而，当移除一个fragment时，如果调用了addToBackStack()，那么之后fragment会被停止，如果用户回退，它将被恢复过来。     \n> 提示：对于每一个fragment事务，在提交之前通过调用setTransition()来应用一系列事务动作。     \n\n调用commit()并不立刻执行事务，相反，而是采取预约方式，一旦activity的界面线程（主线程）准备好便可运行起来。然而，如果有必要的话，你可以从界面线程调用executePendingTransations()立即执行由commit()提交的事务。但这样做，通常是没有必要的，除非其它线程的工作依赖与该项事务。\n\n> 警告：只能在activity保存状态（当用户离开activity时）之前用commit()提交事务。如果你尝试在那时之后提交，会抛出一个异常。这是因为如果activity需要被恢复，提交后的状态会被丢失。对于这类丢失提交的情况，可使用commitAllowingStateLoss() \n\n\n### 九 与Activity交互      \n##### 1.Fragment可以得到宿主Activity的引用\n尽管Fragment被实现为一个对象，它独立于Activity并可以在多个Activity中使用，一个给定的fragment实例直接被捆绑在包含它的Activity中。特别是，fragment可以通过getActivity()函数访问Activity，并且很容易的执行类似于查找activity布局中的视图的任务：\n\n```java\nView listView = getActivity().findViewById(R.id.list);\n```\n\n##### 2.Activity获取Fragment的引用\n同样的，activity能够调用fragment的函数findFragmentById()或者findFragmentByTag()，从FragmentManager中获取Fragment的索引，例如：\n\n```java\nExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);\n```\n\n##### 3.创建Activity时间回调函数\n\n在一些情况下，你可能需要fragment与activity共享事件。这样做的一个好方法是在fragment内部定义一个回调接口，并需要宿主activity实现它。当activity通过接口接收到回调时，可以在必要时与布局中的其它fragment共享信息。    \n举个例子，如果新闻应用的actvity中有两个fragment——一个显示文章列表（fragment A），另一个显示一篇文章（fragment B）——然后fragment A 必须要告诉activity列表项何时被选种，这样，activity可以通知fragment B显示这篇文章。这种情况下，在fragment A内部声明接口OnArticleSelectedListener：\n\n```java\npublic static class FragmentA extends ListFragment {\n    ...\n    // Container Activity must implement this interface\n    public interface OnArticleSelectedListener {\n        public void onArticleSelected(Uri articleUri);\n    }\n    ...\n}\n```\n\n然后fragment的宿主activity实现了OnArticleSelectedListener接口，并且重写onArticleSelected()以通知fragment B来自于fragment A的事件。为了确保宿主activity实现了这个接口，fragment A的onAttach()回调函数（当添加fragment到activity中时系统会调用它）通过作为参数传入onAttach()的activity的类型转换来实例化一个OnArticleSelectedListener实例。\n\n```java\npublic static class FragmentA extends ListFragment {\n    OnArticleSelectedListener mListener;\n    ...\n    @Override\n    public void onAttach(Activity activity) {\n        super.onAttach(activity);\n        try {\n            mListener = (OnArticleSelectedListener) activity;\n        } catch (ClassCastException e) {\n            throw new ClassCastException(activity.toString() + \" must implement OnArticleSelectedListener\");\n        }\n    }\n    ...\n}\n```\n\n如果activity没有实现这个接口，那么fragment会抛出一个ClassCaseException异常。一旦成功，mListener成员会保留一个activity的OnArticleSelectedListener实现的引用，由此fragment A可以通过调用由OnArticleSelectedListener接口定义的方法与activity共享事件。例如，如果fragment A是ListFragment的子类，每次用户点击列表项时，系统都会调用fragment的onListItemClick()事件，然后fragment调用onArticleSelected()来与activity共享事件。\n\n```java\npublic static class FragmentA extends ListFragment {\n    OnArticleSelectedListener mListener;\n    ...\n    @Override\n    public void onListItemClick(ListView l, View v, int position, long id) {\n        // Append the clicked item's row ID with the content provider Uri\n        Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);\n        // Send the event and Uri to the host activity\n        mListener.onArticleSelected(noteUri);\n    }\n    ...\n}\n```\n\n传递给onListItemClick()的参数id是点击的列表项行id，activity（或者其它fragment）用以从应用的ContentProvider获取文章。\n\n#####　添加items到Action Bar\n\n你的fragments可以通过实现onCreateOptionsMenu()来构建菜单项到activity的Options Menu（因此Action Bar也一样）。为了使用这个方法接收到调用，不管怎样，你必须在onCreate()期间调用setHasOptionsMenu()，来指明想要添加项目到Options Menu的那个fragment（否则，fragment将接收不到onCreateOptionsMenu()的调用）。     \n任何想要在fragment中的Options Menu添加的项目都追加到已有的菜单项后面。当菜单项被选中时，fragment也会接收到对onOptionsItemSelected()的回调。    \n你也可以通过调用registerForContextMenu()在fragment布局中注册一个view以提供一个context menu。当用户打开context menu时，fragment接收到对onCreateContextMenu()的回调。当用户选中一个项目时，fragment接收到对onContextItemSelected()的回调。\n\n> 注意：尽管你的fragment会接收到为添加到每个菜单项被选择菜单项的回调，但当用户选择一个菜单项时，activity会首先接收到对应的回调。如果activity的选择菜单项回调的实现没有处理被选中的项目，那么该事件被传递给fragment的回调。这同样适用于Options Menu和context menu。\n\n### 十 总结\n\n\n\n","slug":"android基础之Fragments","published":1,"updated":"2017-03-07T13:20:33.408Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj02g6grz00047c02ahjlarri","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Fragment表现Activity中用户界面的一个行为或者是一部分。你可以在一个单独的activity上把多个fragment组合成为一个多区域的UI，并且可以在多个activity中再使用。你可以认为fragment是activity的一个模块零件，它有自己的生命周期，接收它自己的输入事件，并且可以在activity运行时添加或者删除。</p>\n<p>Fragment必须总是被嵌入到一个activity之中，并且fragment的生命周期直接受其宿主activity的生命周期的影响。例如，一旦activity被暂停，它里面所有的fragment也被暂停，一旦activity被销毁，它里面所有的fragment也被销毁。然而，当activity正在运行时（处于resumed的生命周期状态），你可以单独的操控每个fragment，比如添加或者删除。当你执行这样一项事务时，可以将它添加到后台的一个栈中，这个栈由activity管理着——activity里面的每个后台栈内容实体是fragment发生过的一条事务记录。这个后台栈允许用户通过按BACK键回退一项fragment事务（往后导航）。</p>\n<p>当你添加一个fragment作为某个activity布局的一部分时，它就存在于这个activity视图体系内部的ViewGroup之中，并且定义了它自己的视图布局。你可以通过在activity布局文件中声明fragment，用<fragment>元素把fragment插入到activity的布局中，或者是用应用程序源码将它添加到一个存在的ViewGroup中。然而，fragment并不是一个定要作为activity布局的一部分；fragment也可以为activity隐身工作。   </fragment></p>\n<h3 id=\"二-Fragment的继承结构\"><a href=\"#二-Fragment的继承结构\" class=\"headerlink\" title=\"二 Fragment的继承结构\"></a>二 Fragment的继承结构</h3><p>继承 Object<br>实现 ComponentCallbacks2 View.OnCreateContextMenuListener </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.lang.Object</div><div class=\"line\">   ↳ \tandroid.app.Fragment</div></pre></td></tr></table></figure>\n<p>直接子类：<br>DialogFragment, ListFragment, PreferenceFragment, WebViewFragment      </p>\n<h3 id=\"三-Fragment设计哲学\"><a href=\"#三-Fragment设计哲学\" class=\"headerlink\" title=\"三 Fragment设计哲学\"></a>三 Fragment设计哲学</h3><p>Fragment被设计出来主要为了适应平板等大屏幕移动设备。有了fragment，你可以不必去管理视图体系的复杂变化。通过将activity的布局分割成若干个fragment，可以在运行时编辑activity的呈现，并且那些变化会被保存在由activity管理的后台栈里面。<br>如下图所示，一个Activity中的两个Fragment分别在手机和平板的显示情况：<br><img src=\"/2017/02/27/android基础之Fragments/Fragment显示图.png\" alt=\"Fragment显示图\" title=\"Fragment显示图\">     </p>\n<h3 id=\"四-Fragment的生命周期\"><a href=\"#四-Fragment的生命周期\" class=\"headerlink\" title=\"四 Fragment的生命周期\"></a>四 Fragment的生命周期</h3><p>下面是Activity的生命周期：<br><img src=\"/2017/02/27/android基础之Fragments/Fragment生命周期图.png\" alt=\"Fragment生命周期图\" title=\"Fragment生命周期图\"><br>管理fragment生命周期与管理activity生命周期很相像。像activity一样，fragment也有三种状态：    </p>\n<ul>\n<li>Resumed<br>fragment在运行中的activity可见。    </li>\n<li>Paused<br>另一个activity处于前台且得到焦点，但是这个fragment所在的activity仍然可见（前台activity部分透明，或者没有覆盖全屏）。   </li>\n<li>Stopped<br>fragment不可见。要么宿主activity已经停止，要么fragment已经从activity上移除，但已被添加到后台栈中。一个停止的fragment仍然活着（所有状态和成员信息仍然由系统保留着）。但是，它对用户来讲已经不再可见，并且如果activity被杀掉，它也将被杀掉。<br>同activity类似的还有，你也可以用Bundle保存fragment状态，万一activity的进程被杀掉了，并且在activity被重新创建时，你需要恢复fragment状态。在回调执行fragment的onSaveInstanceState()期间可以保存状态，在onCreate()，onCreateView()，或者onActvityCreate()中可以恢复状态。<br>在生命周期方面,activity与fragment之间一个很重要的不同，就是在各自的后台栈中是如何存储的。当activity停止时，默认情况下，activity被安置在由系统管理的activity后台栈中（因此用户可以按BACK键回退导航，就像在Tasks和后台栈中讨论的那样）。但是，仅当你在一个事务被移除时，通过显式调用addToBackStack()请求保存的实例，该fragment才被置于由宿主activity管理的后台栈。<br>除此之外，管理fragment的生命周期与管理activity的生命周期非常相似。所以，管理activity生命周期的实践同样也适用于fragment。你需要了解的，仅仅是activity的生命周期如何影响fragment的的。    </li>\n</ul>\n<h3 id=\"五-与Activity生命周期协调合作\"><a href=\"#五-与Activity生命周期协调合作\" class=\"headerlink\" title=\"五 与Activity生命周期协调合作\"></a>五 与Activity生命周期协调合作</h3><p>下面是Activity与Fragment生命周期图对比：<br><img src=\"/2017/02/27/android基础之Fragments/Fragment与Activity生命周期对比.png\" alt=\"Fragment与Activity生命周期对比\" title=\"Fragment与Activity生命周期对比\"><br>fragment所生存的activity生命周期直接影响着fragment的生命周期，由此针对activity的每一个生命周期回调都会引发一个fragment类似的回调。例如，当activity接收到onPause()时，这个activity之中的每个fragment都会接收到onPause()。<br>Fragment有一些额外的生命周期回调方法，然而，为了处理像是创建和销毁fragment界面，它与activity进行独特的交互。这些额外的回调方法是：     </p>\n<ul>\n<li>onAttach()<br>当fragment被绑定到activity时调用（Activity会被传入）。 </li>\n<li>onCreateView()<br>创建与fragment相关的视图体系时被调用。     </li>\n<li>onActivityCreated()<br>当activity的onCreate()函数返回时被调用。     </li>\n<li>onDestroyView()<br>当与fragment关联的视图体系正被移除时被调用。     </li>\n<li>onDetach()<br>当fragment正与activity解除关联时被调用。      </li>\n</ul>\n<p>fragment的生命周期流程实际上是受其宿主activity影响，如上图所示。在这张图中，可以看到activity的每个连续状态是如何决定fragment可能接收到哪个回调函数的。例如，当activity接收到它的onCreate()回调时，activity之中的fragment接收到的仅仅是onActivityCreated()回调。</p>\n<p>一旦activity处于resumed状态，则可以在activity中自由的添加或者移除fragment。因此，只有当activity处于resumed状态时，fragment的生命周期才可以独立变化。</p>\n<p>然而，当activity离开恢复状态时，fragment再一次被activity推入它的生命周期中。</p>\n<h3 id=\"六-向Fragment中添加用户界面\"><a href=\"#六-向Fragment中添加用户界面\" class=\"headerlink\" title=\"六 向Fragment中添加用户界面\"></a>六 向Fragment中添加用户界面</h3><p>fragment常被用作activity用户界面的一部分，并且将本身的布局构建到activity中去。<br>为了给fragment提供一个布局，你必须实现onCreateView()回调函数，在绘制fragment布局时Android系统会调用它。实现这个函数时需要返回fragment所属的根View。     </p>\n<blockquote>\n<p>注意：如果你的fragment时ListFragment的子类，默认实现从onCreateView()返回一个ListView，所以你不需要实现它。    </p>\n</blockquote>\n<p>为了从onCreateView()返回一个布局，你可以从layout resource定义的XML文件inflate它。为了便于你这样做，onCreateView()提供一个LayoutInflater对象。<br>例如，下面是一个fragment子类，它的布局从example_fragment.xml载入的：    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">onCreateView</span><span class=\"params\">(LayoutInflater inflater, ViewGroup container,</span></span></div><div class=\"line\">\t\t\t\t\t\t\t\t Bundle savedInstanceState) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// Inflate the layout for this fragment</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> inflater.inflate(R.layout.example_fragment, container, <span class=\"keyword\">false</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>传入onCreateView()的参数container 是你的frament布局将要被插入的父ViewGroup（来自activity的布局）。如果fragment处于resumed状态（恢复状态在操纵fragment生命周期一节中将作更多讨论），参数savedInstanceState是属于Bundle类，它提供了fragment之前实例的相关数据。     </p>\n<p>inflate()函数需要以下三个参数：     </p>\n<ul>\n<li>要inflate的布局的资源ID。      </li>\n<li>被inflate的布局的父ViewGroup。传入container很重要，这是为了让系统将布局参数应用到被inflate的布局的根view中去，由其将要嵌入的父view指定。    </li>\n<li>一个布尔值，表明在inflate期间被infalte的布局是否应该附上ViewGroup（第二个参数）。（在这个例子中传入的是false，因为系统已经将被inflate的布局插入到容器中（container）——传入true会在最终的布局里创建一个多余的ViewGroup。）       </li>\n</ul>\n<p>现在你已经知道了如何创建一个有布局的fragment。下一步，则需要将fragment添加到activity中。      </p>\n<h3 id=\"七-将Fragment添加到Activity中\"><a href=\"#七-将Fragment添加到Activity中\" class=\"headerlink\" title=\"七 将Fragment添加到Activity中\"></a>七 将Fragment添加到Activity中</h3><p>通常，fragment构建了其宿主activity的部分界面，它被作为activity全部视图层次体系的一部分被嵌入进去。在acitivity布局中添加fragment有两种方法：     </p>\n<h5 id=\"在activity的布局文件里声明fragment\"><a href=\"#在activity的布局文件里声明fragment\" class=\"headerlink\" title=\"在activity的布局文件里声明fragment\"></a>在activity的布局文件里声明fragment</h5><p>像这样，你可以像为view一样为fragment指定布局属性。例如，下面含有两个fragment的布局文件：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\">\t&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"</div><div class=\"line\">\t\tandroid:orientation=\"horizontal\"</div><div class=\"line\">\t\tandroid:layout_width=\"match_parent\"</div><div class=\"line\">\t\tandroid:layout_height=\"match_parent\"&gt;</div><div class=\"line\">\t\t&lt;fragment android:name=\"com.example.news.ArticleListFragment\"</div><div class=\"line\">\t\t\t\tandroid:id=\"@+id/list\"</div><div class=\"line\">\t\t\t\tandroid:layout_weight=\"1\"</div><div class=\"line\">\t\t\t\tandroid:layout_width=\"0dp\"</div><div class=\"line\">\t\t\t\tandroid:layout_height=\"match_parent\" /&gt;</div><div class=\"line\">\t\t&lt;fragment android:name=\"com.example.news.ArticleReaderFragment\"</div><div class=\"line\">\t\t\t\tandroid:id=\"@+id/viewer\"</div><div class=\"line\">\t\t\t\tandroid:layout_weight=\"2\"</div><div class=\"line\">\t\t\t\tandroid:layout_width=\"0dp\"</div><div class=\"line\">\t\t\t\tandroid:layout_height=\"match_parent\" /&gt;</div><div class=\"line\">\t&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>\n<p><fragment>中的android:name 属性指定了布局中实例化的Fragment类。</fragment></p>\n<p>当系统创建activity布局时，它实例化了布局文件中指定的每一个fragment，并为它们调用onCreateView()函数，以获取每一个fragment的布局。系统直接在<fragment>元素的位置插入fragment返回的View。</fragment></p>\n<blockquote>\n<p>注意：每个fragment都需要一个唯一的标识，如果重启activity，系统可用来恢复fragment（并且可用来捕捉fragment的事务处理，例如移除）。为fragment提供ID有三种方法：   </p>\n<ul>\n<li>用android:id属性提供一个唯一的标识。   </li>\n<li>用android:tag属性提供一个唯一的字符串。   </li>\n<li>如果上述两个属性都没有，系统会使用其容器视图（view）的ID。 </li>\n</ul>\n</blockquote>\n<h5 id=\"通过java代码将fragment添加到已存在的ViewGroup中\"><a href=\"#通过java代码将fragment添加到已存在的ViewGroup中\" class=\"headerlink\" title=\"通过java代码将fragment添加到已存在的ViewGroup中\"></a>通过java代码将fragment添加到已存在的ViewGroup中</h5><p>在activity运行的任何时候，你都可以将fragment添加到activity布局中。你仅需要简单指定用来放置fragment的ViewGroup。</p>\n<p>你应当使用FragmentTransaction的API来对activity中的fragment进行操作（例如添加，移除，或者替换fragment）。你可以像下面这样从Activity中取得FragmentTransaction的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">FragmentManager fragmentManager = getFragmentManager()</div><div class=\"line\">\tFragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</div></pre></td></tr></table></figure>\n<p>可以用add()函数添加fragment，并指定要添加的fragment以及要将其插入到哪个视图（view）之中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ExampleFragment fragment = <span class=\"keyword\">new</span> ExampleFragment();</div><div class=\"line\">\tfragmentTransaction.add(R.id.fragment_container, fragment);</div><div class=\"line\">\tfragmentTransaction.commit();</div></pre></td></tr></table></figure>\n<p>传入add()函数的第一个参数是fragment被放置的ViewGroup，它由资源ID（resource ID）指定，第二个参数就是要添加的fragment。一旦通过FragmentTransaction 做了更改，都应当使用commit()使变化生效。</p>\n<h5 id=\"添加无界面的Fragment\"><a href=\"#添加无界面的Fragment\" class=\"headerlink\" title=\"添加无界面的Fragment\"></a>添加无界面的Fragment</h5><p>上面的例子是如何将fragment添加到activity中去，目的是提供一个用户界面。然而，也可以使用fragment为activity提供后台动作，却不呈现多余的用户界面。</p>\n<p>想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。</p>\n<p>想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。  </p>\n<h3 id=\"八-Fragment事务后台栈\"><a href=\"#八-Fragment事务后台栈\" class=\"headerlink\" title=\"八 Fragment事务后台栈\"></a>八 Fragment事务后台栈</h3><p>在activity中使用fragment的一大特点是具有添加、删除、替换，和执行其它动作的能力，以响应用户的互动。提交给activity的每一系列变化被称为事务，并且可以用FragmentTransaction 中的APIs处理。你也可以将每一个事务保存在由activity管理的后台栈中，并且允许用户导航回退fragment变更（类似于activity的导航回退）。  </p>\n<p>你可以从FragmentManager中获取FragmentTransaction实例，像这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">FragmentManager fragmentManager = getFragmentManager();</div><div class=\"line\"> FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</div></pre></td></tr></table></figure>\n<p>每项事务是在同一时间内要执行的一系列的变更。你可以为一个给定的事务用相关方法设置想要执行的所有变化，例如add()，remove()，和replace()。然后，用commit()将事务提交给activity。然而，在调用commit()之前，为了将事务添加到fragment事务后台栈中，你可能会想调用addToBackStatck()。这个后台栈由activity管理，并且允许用户通过按BACK键回退到前一个fragment状态。<br>举个例子，下面的代码是如何使用另一个fragment代替一个fragment，并且将之前的状态保留在后台栈中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Create new fragment and transaction</span></div><div class=\"line\"> Fragment newFragment = <span class=\"keyword\">new</span> ExampleFragment();</div><div class=\"line\"> FragmentTransaction transaction = getFragmentManager().beginTransaction();</div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">// Replace whatever is in the fragment_container view with this fragment,</span></div><div class=\"line\"> <span class=\"comment\">// and add the transaction to the back stack</span></div><div class=\"line\"> transaction.replace(R.id.fragment_container, newFragment);</div><div class=\"line\"> transaction.addToBackStack(<span class=\"keyword\">null</span>);</div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">// Commit the transaction</span></div><div class=\"line\"> transaction.commit();</div></pre></td></tr></table></figure>\n<p>在这个例子中，newFragment替换了当前在布局容器中用R.id.fragment_container标识的所有的fragment（如果有的话），替代的事务被保存在后台栈中，因此用户可以回退该事务，可通过按BACK键还原之前的fragment。如果添加多个变更事务（例如另一个add()或者remove()）并调用addToBackStack()，那么在调用commit()之前的所有应用的变更被作为一个单独的事务添加到后台栈中，并且BACK键可以将它们一起回退。</p>\n<p>将变更添加到FragmentTransaction中的顺序注意以下两点：     </p>\n<ul>\n<li>必须要在最后调用commit()   </li>\n<li>如果你正将多个fragment添加到同一个容器中，那么添加顺序决定了它们在视图层次（view hierarchy）里显示的顺序。 </li>\n</ul>\n<p>在执行删除fragment事务时，如果没有调用addToBackStack()，那么事务一提交fragment就会被销毁，而且用户也无法回退它。然而，当移除一个fragment时，如果调用了addToBackStack()，那么之后fragment会被停止，如果用户回退，它将被恢复过来。     </p>\n<blockquote>\n<p>提示：对于每一个fragment事务，在提交之前通过调用setTransition()来应用一系列事务动作。     </p>\n</blockquote>\n<p>调用commit()并不立刻执行事务，相反，而是采取预约方式，一旦activity的界面线程（主线程）准备好便可运行起来。然而，如果有必要的话，你可以从界面线程调用executePendingTransations()立即执行由commit()提交的事务。但这样做，通常是没有必要的，除非其它线程的工作依赖与该项事务。</p>\n<blockquote>\n<p>警告：只能在activity保存状态（当用户离开activity时）之前用commit()提交事务。如果你尝试在那时之后提交，会抛出一个异常。这是因为如果activity需要被恢复，提交后的状态会被丢失。对于这类丢失提交的情况，可使用commitAllowingStateLoss() </p>\n</blockquote>\n<h3 id=\"九-与Activity交互\"><a href=\"#九-与Activity交互\" class=\"headerlink\" title=\"九 与Activity交互\"></a>九 与Activity交互</h3><h5 id=\"1-Fragment可以得到宿主Activity的引用\"><a href=\"#1-Fragment可以得到宿主Activity的引用\" class=\"headerlink\" title=\"1.Fragment可以得到宿主Activity的引用\"></a>1.Fragment可以得到宿主Activity的引用</h5><p>尽管Fragment被实现为一个对象，它独立于Activity并可以在多个Activity中使用，一个给定的fragment实例直接被捆绑在包含它的Activity中。特别是，fragment可以通过getActivity()函数访问Activity，并且很容易的执行类似于查找activity布局中的视图的任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">View listView = getActivity().findViewById(R.id.list);</div></pre></td></tr></table></figure>\n<h5 id=\"2-Activity获取Fragment的引用\"><a href=\"#2-Activity获取Fragment的引用\" class=\"headerlink\" title=\"2.Activity获取Fragment的引用\"></a>2.Activity获取Fragment的引用</h5><p>同样的，activity能够调用fragment的函数findFragmentById()或者findFragmentByTag()，从FragmentManager中获取Fragment的索引，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);</div></pre></td></tr></table></figure>\n<h5 id=\"3-创建Activity时间回调函数\"><a href=\"#3-创建Activity时间回调函数\" class=\"headerlink\" title=\"3.创建Activity时间回调函数\"></a>3.创建Activity时间回调函数</h5><p>在一些情况下，你可能需要fragment与activity共享事件。这样做的一个好方法是在fragment内部定义一个回调接口，并需要宿主activity实现它。当activity通过接口接收到回调时，可以在必要时与布局中的其它fragment共享信息。<br>举个例子，如果新闻应用的actvity中有两个fragment——一个显示文章列表（fragment A），另一个显示一篇文章（fragment B）——然后fragment A 必须要告诉activity列表项何时被选种，这样，activity可以通知fragment B显示这篇文章。这种情况下，在fragment A内部声明接口OnArticleSelectedListener：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentA</span> <span class=\"keyword\">extends</span> <span class=\"title\">ListFragment</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"comment\">// Container Activity must implement this interface</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnArticleSelectedListener</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onArticleSelected</span><span class=\"params\">(Uri articleUri)</span></span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后fragment的宿主activity实现了OnArticleSelectedListener接口，并且重写onArticleSelected()以通知fragment B来自于fragment A的事件。为了确保宿主activity实现了这个接口，fragment A的onAttach()回调函数（当添加fragment到activity中时系统会调用它）通过作为参数传入onAttach()的activity的类型转换来实例化一个OnArticleSelectedListener实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentA</span> <span class=\"keyword\">extends</span> <span class=\"title\">ListFragment</span> </span>&#123;</div><div class=\"line\">    OnArticleSelectedListener mListener;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAttach</span><span class=\"params\">(Activity activity)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onAttach(activity);</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            mListener = (OnArticleSelectedListener) activity;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassCastException e) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassCastException(activity.toString() + <span class=\"string\">\" must implement OnArticleSelectedListener\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果activity没有实现这个接口，那么fragment会抛出一个ClassCaseException异常。一旦成功，mListener成员会保留一个activity的OnArticleSelectedListener实现的引用，由此fragment A可以通过调用由OnArticleSelectedListener接口定义的方法与activity共享事件。例如，如果fragment A是ListFragment的子类，每次用户点击列表项时，系统都会调用fragment的onListItemClick()事件，然后fragment调用onArticleSelected()来与activity共享事件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentA</span> <span class=\"keyword\">extends</span> <span class=\"title\">ListFragment</span> </span>&#123;</div><div class=\"line\">    OnArticleSelectedListener mListener;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onListItemClick</span><span class=\"params\">(ListView l, View v, <span class=\"keyword\">int</span> position, <span class=\"keyword\">long</span> id)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Append the clicked item's row ID with the content provider Uri</span></div><div class=\"line\">        Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);</div><div class=\"line\">        <span class=\"comment\">// Send the event and Uri to the host activity</span></div><div class=\"line\">        mListener.onArticleSelected(noteUri);</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>传递给onListItemClick()的参数id是点击的列表项行id，activity（或者其它fragment）用以从应用的ContentProvider获取文章。</p>\n<p>#####　添加items到Action Bar</p>\n<p>你的fragments可以通过实现onCreateOptionsMenu()来构建菜单项到activity的Options Menu（因此Action Bar也一样）。为了使用这个方法接收到调用，不管怎样，你必须在onCreate()期间调用setHasOptionsMenu()，来指明想要添加项目到Options Menu的那个fragment（否则，fragment将接收不到onCreateOptionsMenu()的调用）。<br>任何想要在fragment中的Options Menu添加的项目都追加到已有的菜单项后面。当菜单项被选中时，fragment也会接收到对onOptionsItemSelected()的回调。<br>你也可以通过调用registerForContextMenu()在fragment布局中注册一个view以提供一个context menu。当用户打开context menu时，fragment接收到对onCreateContextMenu()的回调。当用户选中一个项目时，fragment接收到对onContextItemSelected()的回调。</p>\n<blockquote>\n<p>注意：尽管你的fragment会接收到为添加到每个菜单项被选择菜单项的回调，但当用户选择一个菜单项时，activity会首先接收到对应的回调。如果activity的选择菜单项回调的实现没有处理被选中的项目，那么该事件被传递给fragment的回调。这同样适用于Options Menu和context menu。</p>\n</blockquote>\n<h3 id=\"十-总结\"><a href=\"#十-总结\" class=\"headerlink\" title=\"十 总结\"></a>十 总结</h3>","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Fragment表现Activity中用户界面的一个行为或者是一部分。你可以在一个单独的activity上把多个fragment组合成为一个多区域的UI，并且可以在多个activity中再使用。你可以认为fragment是activity的一个模块零件，它有自己的生命周期，接收它自己的输入事件，并且可以在activity运行时添加或者删除。</p>\n<p>Fragment必须总是被嵌入到一个activity之中，并且fragment的生命周期直接受其宿主activity的生命周期的影响。例如，一旦activity被暂停，它里面所有的fragment也被暂停，一旦activity被销毁，它里面所有的fragment也被销毁。然而，当activity正在运行时（处于resumed的生命周期状态），你可以单独的操控每个fragment，比如添加或者删除。当你执行这样一项事务时，可以将它添加到后台的一个栈中，这个栈由activity管理着——activity里面的每个后台栈内容实体是fragment发生过的一条事务记录。这个后台栈允许用户通过按BACK键回退一项fragment事务（往后导航）。</p>\n<p>当你添加一个fragment作为某个activity布局的一部分时，它就存在于这个activity视图体系内部的ViewGroup之中，并且定义了它自己的视图布局。你可以通过在activity布局文件中声明fragment，用<fragment>元素把fragment插入到activity的布局中，或者是用应用程序源码将它添加到一个存在的ViewGroup中。然而，fragment并不是一个定要作为activity布局的一部分；fragment也可以为activity隐身工作。   </p>\n<h3 id=\"二-Fragment的继承结构\"><a href=\"#二-Fragment的继承结构\" class=\"headerlink\" title=\"二 Fragment的继承结构\"></a>二 Fragment的继承结构</h3><p>继承 Object<br>实现 ComponentCallbacks2 View.OnCreateContextMenuListener </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.lang.Object</div><div class=\"line\">   ↳ \tandroid.app.Fragment</div></pre></td></tr></table></figure>\n<p>直接子类：<br>DialogFragment, ListFragment, PreferenceFragment, WebViewFragment      </p>\n<h3 id=\"三-Fragment设计哲学\"><a href=\"#三-Fragment设计哲学\" class=\"headerlink\" title=\"三 Fragment设计哲学\"></a>三 Fragment设计哲学</h3><p>Fragment被设计出来主要为了适应平板等大屏幕移动设备。有了fragment，你可以不必去管理视图体系的复杂变化。通过将activity的布局分割成若干个fragment，可以在运行时编辑activity的呈现，并且那些变化会被保存在由activity管理的后台栈里面。<br>如下图所示，一个Activity中的两个Fragment分别在手机和平板的显示情况：<br><img src=\"/2017/02/27/android基础之Fragments/Fragment显示图.png\" alt=\"Fragment显示图\" title=\"Fragment显示图\">     </p>\n<h3 id=\"四-Fragment的生命周期\"><a href=\"#四-Fragment的生命周期\" class=\"headerlink\" title=\"四 Fragment的生命周期\"></a>四 Fragment的生命周期</h3><p>下面是Activity的生命周期：<br><img src=\"/2017/02/27/android基础之Fragments/Fragment生命周期图.png\" alt=\"Fragment生命周期图\" title=\"Fragment生命周期图\"><br>管理fragment生命周期与管理activity生命周期很相像。像activity一样，fragment也有三种状态：    </p>\n<ul>\n<li>Resumed<br>fragment在运行中的activity可见。    </li>\n<li>Paused<br>另一个activity处于前台且得到焦点，但是这个fragment所在的activity仍然可见（前台activity部分透明，或者没有覆盖全屏）。   </li>\n<li>Stopped<br>fragment不可见。要么宿主activity已经停止，要么fragment已经从activity上移除，但已被添加到后台栈中。一个停止的fragment仍然活着（所有状态和成员信息仍然由系统保留着）。但是，它对用户来讲已经不再可见，并且如果activity被杀掉，它也将被杀掉。<br>同activity类似的还有，你也可以用Bundle保存fragment状态，万一activity的进程被杀掉了，并且在activity被重新创建时，你需要恢复fragment状态。在回调执行fragment的onSaveInstanceState()期间可以保存状态，在onCreate()，onCreateView()，或者onActvityCreate()中可以恢复状态。<br>在生命周期方面,activity与fragment之间一个很重要的不同，就是在各自的后台栈中是如何存储的。当activity停止时，默认情况下，activity被安置在由系统管理的activity后台栈中（因此用户可以按BACK键回退导航，就像在Tasks和后台栈中讨论的那样）。但是，仅当你在一个事务被移除时，通过显式调用addToBackStack()请求保存的实例，该fragment才被置于由宿主activity管理的后台栈。<br>除此之外，管理fragment的生命周期与管理activity的生命周期非常相似。所以，管理activity生命周期的实践同样也适用于fragment。你需要了解的，仅仅是activity的生命周期如何影响fragment的的。    </li>\n</ul>\n<h3 id=\"五-与Activity生命周期协调合作\"><a href=\"#五-与Activity生命周期协调合作\" class=\"headerlink\" title=\"五 与Activity生命周期协调合作\"></a>五 与Activity生命周期协调合作</h3><p>下面是Activity与Fragment生命周期图对比：<br><img src=\"/2017/02/27/android基础之Fragments/Fragment与Activity生命周期对比.png\" alt=\"Fragment与Activity生命周期对比\" title=\"Fragment与Activity生命周期对比\"><br>fragment所生存的activity生命周期直接影响着fragment的生命周期，由此针对activity的每一个生命周期回调都会引发一个fragment类似的回调。例如，当activity接收到onPause()时，这个activity之中的每个fragment都会接收到onPause()。<br>Fragment有一些额外的生命周期回调方法，然而，为了处理像是创建和销毁fragment界面，它与activity进行独特的交互。这些额外的回调方法是：     </p>\n<ul>\n<li>onAttach()<br>当fragment被绑定到activity时调用（Activity会被传入）。 </li>\n<li>onCreateView()<br>创建与fragment相关的视图体系时被调用。     </li>\n<li>onActivityCreated()<br>当activity的onCreate()函数返回时被调用。     </li>\n<li>onDestroyView()<br>当与fragment关联的视图体系正被移除时被调用。     </li>\n<li>onDetach()<br>当fragment正与activity解除关联时被调用。      </li>\n</ul>\n<p>fragment的生命周期流程实际上是受其宿主activity影响，如上图所示。在这张图中，可以看到activity的每个连续状态是如何决定fragment可能接收到哪个回调函数的。例如，当activity接收到它的onCreate()回调时，activity之中的fragment接收到的仅仅是onActivityCreated()回调。</p>\n<p>一旦activity处于resumed状态，则可以在activity中自由的添加或者移除fragment。因此，只有当activity处于resumed状态时，fragment的生命周期才可以独立变化。</p>\n<p>然而，当activity离开恢复状态时，fragment再一次被activity推入它的生命周期中。</p>\n<h3 id=\"六-向Fragment中添加用户界面\"><a href=\"#六-向Fragment中添加用户界面\" class=\"headerlink\" title=\"六 向Fragment中添加用户界面\"></a>六 向Fragment中添加用户界面</h3><p>fragment常被用作activity用户界面的一部分，并且将本身的布局构建到activity中去。<br>为了给fragment提供一个布局，你必须实现onCreateView()回调函数，在绘制fragment布局时Android系统会调用它。实现这个函数时需要返回fragment所属的根View。     </p>\n<blockquote>\n<p>注意：如果你的fragment时ListFragment的子类，默认实现从onCreateView()返回一个ListView，所以你不需要实现它。    </p>\n</blockquote>\n<p>为了从onCreateView()返回一个布局，你可以从layout resource定义的XML文件inflate它。为了便于你这样做，onCreateView()提供一个LayoutInflater对象。<br>例如，下面是一个fragment子类，它的布局从example_fragment.xml载入的：    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">onCreateView</span><span class=\"params\">(LayoutInflater inflater, ViewGroup container,</div><div class=\"line\">\t\t\t\t\t\t\t\t Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// Inflate the layout for this fragment</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> inflater.inflate(R.layout.example_fragment, container, <span class=\"keyword\">false</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>传入onCreateView()的参数container 是你的frament布局将要被插入的父ViewGroup（来自activity的布局）。如果fragment处于resumed状态（恢复状态在操纵fragment生命周期一节中将作更多讨论），参数savedInstanceState是属于Bundle类，它提供了fragment之前实例的相关数据。     </p>\n<p>inflate()函数需要以下三个参数：     </p>\n<ul>\n<li>要inflate的布局的资源ID。      </li>\n<li>被inflate的布局的父ViewGroup。传入container很重要，这是为了让系统将布局参数应用到被inflate的布局的根view中去，由其将要嵌入的父view指定。    </li>\n<li>一个布尔值，表明在inflate期间被infalte的布局是否应该附上ViewGroup（第二个参数）。（在这个例子中传入的是false，因为系统已经将被inflate的布局插入到容器中（container）——传入true会在最终的布局里创建一个多余的ViewGroup。）       </li>\n</ul>\n<p>现在你已经知道了如何创建一个有布局的fragment。下一步，则需要将fragment添加到activity中。      </p>\n<h3 id=\"七-将Fragment添加到Activity中\"><a href=\"#七-将Fragment添加到Activity中\" class=\"headerlink\" title=\"七 将Fragment添加到Activity中\"></a>七 将Fragment添加到Activity中</h3><p>通常，fragment构建了其宿主activity的部分界面，它被作为activity全部视图层次体系的一部分被嵌入进去。在acitivity布局中添加fragment有两种方法：     </p>\n<h5 id=\"在activity的布局文件里声明fragment\"><a href=\"#在activity的布局文件里声明fragment\" class=\"headerlink\" title=\"在activity的布局文件里声明fragment\"></a>在activity的布局文件里声明fragment</h5><p>像这样，你可以像为view一样为fragment指定布局属性。例如，下面含有两个fragment的布局文件：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\">\t&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"</div><div class=\"line\">\t\tandroid:orientation=\"horizontal\"</div><div class=\"line\">\t\tandroid:layout_width=\"match_parent\"</div><div class=\"line\">\t\tandroid:layout_height=\"match_parent\"&gt;</div><div class=\"line\">\t\t&lt;fragment android:name=\"com.example.news.ArticleListFragment\"</div><div class=\"line\">\t\t\t\tandroid:id=\"@+id/list\"</div><div class=\"line\">\t\t\t\tandroid:layout_weight=\"1\"</div><div class=\"line\">\t\t\t\tandroid:layout_width=\"0dp\"</div><div class=\"line\">\t\t\t\tandroid:layout_height=\"match_parent\" /&gt;</div><div class=\"line\">\t\t&lt;fragment android:name=\"com.example.news.ArticleReaderFragment\"</div><div class=\"line\">\t\t\t\tandroid:id=\"@+id/viewer\"</div><div class=\"line\">\t\t\t\tandroid:layout_weight=\"2\"</div><div class=\"line\">\t\t\t\tandroid:layout_width=\"0dp\"</div><div class=\"line\">\t\t\t\tandroid:layout_height=\"match_parent\" /&gt;</div><div class=\"line\">\t&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>\n<p><fragment>中的android:name 属性指定了布局中实例化的Fragment类。</p>\n<p>当系统创建activity布局时，它实例化了布局文件中指定的每一个fragment，并为它们调用onCreateView()函数，以获取每一个fragment的布局。系统直接在<fragment>元素的位置插入fragment返回的View。</p>\n<blockquote>\n<p>注意：每个fragment都需要一个唯一的标识，如果重启activity，系统可用来恢复fragment（并且可用来捕捉fragment的事务处理，例如移除）。为fragment提供ID有三种方法：   </p>\n<ul>\n<li>用android:id属性提供一个唯一的标识。   </li>\n<li>用android:tag属性提供一个唯一的字符串。   </li>\n<li>如果上述两个属性都没有，系统会使用其容器视图（view）的ID。 </li>\n</ul>\n</blockquote>\n<h5 id=\"通过java代码将fragment添加到已存在的ViewGroup中\"><a href=\"#通过java代码将fragment添加到已存在的ViewGroup中\" class=\"headerlink\" title=\"通过java代码将fragment添加到已存在的ViewGroup中\"></a>通过java代码将fragment添加到已存在的ViewGroup中</h5><p>在activity运行的任何时候，你都可以将fragment添加到activity布局中。你仅需要简单指定用来放置fragment的ViewGroup。</p>\n<p>你应当使用FragmentTransaction的API来对activity中的fragment进行操作（例如添加，移除，或者替换fragment）。你可以像下面这样从Activity中取得FragmentTransaction的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">FragmentManager fragmentManager = getFragmentManager()</div><div class=\"line\">\tFragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</div></pre></td></tr></table></figure>\n<p>可以用add()函数添加fragment，并指定要添加的fragment以及要将其插入到哪个视图（view）之中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ExampleFragment fragment = <span class=\"keyword\">new</span> ExampleFragment();</div><div class=\"line\">\tfragmentTransaction.add(R.id.fragment_container, fragment);</div><div class=\"line\">\tfragmentTransaction.commit();</div></pre></td></tr></table></figure>\n<p>传入add()函数的第一个参数是fragment被放置的ViewGroup，它由资源ID（resource ID）指定，第二个参数就是要添加的fragment。一旦通过FragmentTransaction 做了更改，都应当使用commit()使变化生效。</p>\n<h5 id=\"添加无界面的Fragment\"><a href=\"#添加无界面的Fragment\" class=\"headerlink\" title=\"添加无界面的Fragment\"></a>添加无界面的Fragment</h5><p>上面的例子是如何将fragment添加到activity中去，目的是提供一个用户界面。然而，也可以使用fragment为activity提供后台动作，却不呈现多余的用户界面。</p>\n<p>想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。</p>\n<p>想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。  </p>\n<h3 id=\"八-Fragment事务后台栈\"><a href=\"#八-Fragment事务后台栈\" class=\"headerlink\" title=\"八 Fragment事务后台栈\"></a>八 Fragment事务后台栈</h3><p>在activity中使用fragment的一大特点是具有添加、删除、替换，和执行其它动作的能力，以响应用户的互动。提交给activity的每一系列变化被称为事务，并且可以用FragmentTransaction 中的APIs处理。你也可以将每一个事务保存在由activity管理的后台栈中，并且允许用户导航回退fragment变更（类似于activity的导航回退）。  </p>\n<p>你可以从FragmentManager中获取FragmentTransaction实例，像这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">FragmentManager fragmentManager = getFragmentManager();</div><div class=\"line\"> FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</div></pre></td></tr></table></figure>\n<p>每项事务是在同一时间内要执行的一系列的变更。你可以为一个给定的事务用相关方法设置想要执行的所有变化，例如add()，remove()，和replace()。然后，用commit()将事务提交给activity。然而，在调用commit()之前，为了将事务添加到fragment事务后台栈中，你可能会想调用addToBackStatck()。这个后台栈由activity管理，并且允许用户通过按BACK键回退到前一个fragment状态。<br>举个例子，下面的代码是如何使用另一个fragment代替一个fragment，并且将之前的状态保留在后台栈中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Create new fragment and transaction</span></div><div class=\"line\"> Fragment newFragment = <span class=\"keyword\">new</span> ExampleFragment();</div><div class=\"line\"> FragmentTransaction transaction = getFragmentManager().beginTransaction();</div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">// Replace whatever is in the fragment_container view with this fragment,</span></div><div class=\"line\"> <span class=\"comment\">// and add the transaction to the back stack</span></div><div class=\"line\"> transaction.replace(R.id.fragment_container, newFragment);</div><div class=\"line\"> transaction.addToBackStack(<span class=\"keyword\">null</span>);</div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">// Commit the transaction</span></div><div class=\"line\"> transaction.commit();</div></pre></td></tr></table></figure>\n<p>在这个例子中，newFragment替换了当前在布局容器中用R.id.fragment_container标识的所有的fragment（如果有的话），替代的事务被保存在后台栈中，因此用户可以回退该事务，可通过按BACK键还原之前的fragment。如果添加多个变更事务（例如另一个add()或者remove()）并调用addToBackStack()，那么在调用commit()之前的所有应用的变更被作为一个单独的事务添加到后台栈中，并且BACK键可以将它们一起回退。</p>\n<p>将变更添加到FragmentTransaction中的顺序注意以下两点：     </p>\n<ul>\n<li>必须要在最后调用commit()   </li>\n<li>如果你正将多个fragment添加到同一个容器中，那么添加顺序决定了它们在视图层次（view hierarchy）里显示的顺序。 </li>\n</ul>\n<p>在执行删除fragment事务时，如果没有调用addToBackStack()，那么事务一提交fragment就会被销毁，而且用户也无法回退它。然而，当移除一个fragment时，如果调用了addToBackStack()，那么之后fragment会被停止，如果用户回退，它将被恢复过来。     </p>\n<blockquote>\n<p>提示：对于每一个fragment事务，在提交之前通过调用setTransition()来应用一系列事务动作。     </p>\n</blockquote>\n<p>调用commit()并不立刻执行事务，相反，而是采取预约方式，一旦activity的界面线程（主线程）准备好便可运行起来。然而，如果有必要的话，你可以从界面线程调用executePendingTransations()立即执行由commit()提交的事务。但这样做，通常是没有必要的，除非其它线程的工作依赖与该项事务。</p>\n<blockquote>\n<p>警告：只能在activity保存状态（当用户离开activity时）之前用commit()提交事务。如果你尝试在那时之后提交，会抛出一个异常。这是因为如果activity需要被恢复，提交后的状态会被丢失。对于这类丢失提交的情况，可使用commitAllowingStateLoss() </p>\n</blockquote>\n<h3 id=\"九-与Activity交互\"><a href=\"#九-与Activity交互\" class=\"headerlink\" title=\"九 与Activity交互\"></a>九 与Activity交互</h3><h5 id=\"1-Fragment可以得到宿主Activity的引用\"><a href=\"#1-Fragment可以得到宿主Activity的引用\" class=\"headerlink\" title=\"1.Fragment可以得到宿主Activity的引用\"></a>1.Fragment可以得到宿主Activity的引用</h5><p>尽管Fragment被实现为一个对象，它独立于Activity并可以在多个Activity中使用，一个给定的fragment实例直接被捆绑在包含它的Activity中。特别是，fragment可以通过getActivity()函数访问Activity，并且很容易的执行类似于查找activity布局中的视图的任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">View listView = getActivity().findViewById(R.id.list);</div></pre></td></tr></table></figure>\n<h5 id=\"2-Activity获取Fragment的引用\"><a href=\"#2-Activity获取Fragment的引用\" class=\"headerlink\" title=\"2.Activity获取Fragment的引用\"></a>2.Activity获取Fragment的引用</h5><p>同样的，activity能够调用fragment的函数findFragmentById()或者findFragmentByTag()，从FragmentManager中获取Fragment的索引，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);</div></pre></td></tr></table></figure>\n<h5 id=\"3-创建Activity时间回调函数\"><a href=\"#3-创建Activity时间回调函数\" class=\"headerlink\" title=\"3.创建Activity时间回调函数\"></a>3.创建Activity时间回调函数</h5><p>在一些情况下，你可能需要fragment与activity共享事件。这样做的一个好方法是在fragment内部定义一个回调接口，并需要宿主activity实现它。当activity通过接口接收到回调时，可以在必要时与布局中的其它fragment共享信息。<br>举个例子，如果新闻应用的actvity中有两个fragment——一个显示文章列表（fragment A），另一个显示一篇文章（fragment B）——然后fragment A 必须要告诉activity列表项何时被选种，这样，activity可以通知fragment B显示这篇文章。这种情况下，在fragment A内部声明接口OnArticleSelectedListener：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentA</span> <span class=\"keyword\">extends</span> <span class=\"title\">ListFragment</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"comment\">// Container Activity must implement this interface</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnArticleSelectedListener</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onArticleSelected</span><span class=\"params\">(Uri articleUri)</span></span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后fragment的宿主activity实现了OnArticleSelectedListener接口，并且重写onArticleSelected()以通知fragment B来自于fragment A的事件。为了确保宿主activity实现了这个接口，fragment A的onAttach()回调函数（当添加fragment到activity中时系统会调用它）通过作为参数传入onAttach()的activity的类型转换来实例化一个OnArticleSelectedListener实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentA</span> <span class=\"keyword\">extends</span> <span class=\"title\">ListFragment</span> </span>&#123;</div><div class=\"line\">    OnArticleSelectedListener mListener;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAttach</span><span class=\"params\">(Activity activity)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onAttach(activity);</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            mListener = (OnArticleSelectedListener) activity;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassCastException e) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassCastException(activity.toString() + <span class=\"string\">\" must implement OnArticleSelectedListener\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果activity没有实现这个接口，那么fragment会抛出一个ClassCaseException异常。一旦成功，mListener成员会保留一个activity的OnArticleSelectedListener实现的引用，由此fragment A可以通过调用由OnArticleSelectedListener接口定义的方法与activity共享事件。例如，如果fragment A是ListFragment的子类，每次用户点击列表项时，系统都会调用fragment的onListItemClick()事件，然后fragment调用onArticleSelected()来与activity共享事件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentA</span> <span class=\"keyword\">extends</span> <span class=\"title\">ListFragment</span> </span>&#123;</div><div class=\"line\">    OnArticleSelectedListener mListener;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onListItemClick</span><span class=\"params\">(ListView l, View v, <span class=\"keyword\">int</span> position, <span class=\"keyword\">long</span> id)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Append the clicked item's row ID with the content provider Uri</span></div><div class=\"line\">        Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);</div><div class=\"line\">        <span class=\"comment\">// Send the event and Uri to the host activity</span></div><div class=\"line\">        mListener.onArticleSelected(noteUri);</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>传递给onListItemClick()的参数id是点击的列表项行id，activity（或者其它fragment）用以从应用的ContentProvider获取文章。</p>\n<p>#####　添加items到Action Bar</p>\n<p>你的fragments可以通过实现onCreateOptionsMenu()来构建菜单项到activity的Options Menu（因此Action Bar也一样）。为了使用这个方法接收到调用，不管怎样，你必须在onCreate()期间调用setHasOptionsMenu()，来指明想要添加项目到Options Menu的那个fragment（否则，fragment将接收不到onCreateOptionsMenu()的调用）。<br>任何想要在fragment中的Options Menu添加的项目都追加到已有的菜单项后面。当菜单项被选中时，fragment也会接收到对onOptionsItemSelected()的回调。<br>你也可以通过调用registerForContextMenu()在fragment布局中注册一个view以提供一个context menu。当用户打开context menu时，fragment接收到对onCreateContextMenu()的回调。当用户选中一个项目时，fragment接收到对onContextItemSelected()的回调。</p>\n<blockquote>\n<p>注意：尽管你的fragment会接收到为添加到每个菜单项被选择菜单项的回调，但当用户选择一个菜单项时，activity会首先接收到对应的回调。如果activity的选择菜单项回调的实现没有处理被选中的项目，那么该事件被传递给fragment的回调。这同样适用于Options Menu和context menu。</p>\n</blockquote>\n<h3 id=\"十-总结\"><a href=\"#十-总结\" class=\"headerlink\" title=\"十 总结\"></a>十 总结</h3>"},{"title":"android基础之Handler与AsycTask","date":"2017-02-27T06:47:53.000Z","_content":"\n### 一 概述\n\nHandler是Android中用于线程间通信的机制。\n\n当程序第一次启动的时候，Android会同时启动一条主线程（ Main Thread）来负责处理与UI相关的事件，我们叫做UI线程。Android的UI操作并不是线程安全的（出于性能优化考虑），意味着如果多个线程并发操作UI线程，可能导致线程安全问题。为了解决Android应用多线程问题—Android平台只允许UI线程修改Activity里的UI，这样如果在主线程中执行耗时操作就会导致UI阻塞，若超过5秒就会造成ANR。\n\n因此我们需要另开线程来处理这些耗时操作，而处理的结果我们可能需要传给主线程用于UI更新，这是就需要线程间的通信。Handler即是Android中用于线程间通信的机制，现在市场一些android的线程通信框架基本上都是基于Handler实现的，如下文将要介绍的已经置于android源码中AsycTask，和现在比较流行的EventBus。\n\n### 二 Handler的主要作用\n\n通过翻看的Handler的源码可知，Handler主要有两个作用。\n\n##### 1.线程延时\n\nHandler中内置了线程延时的方法：\n\n- final boolean postAtTime(Runnable r, long uptimeMillis)\n- final boolean postDelayed(Runnable r, long delayMillis)\n\n##### 2.线程通信\n\n主要步骤：\n\n- 在新启动的线程中发送消息     \n使用Handler对象的sendMessage()方法或者SendEmptyMessage()方法发送消息。   \n\n- 在主线程中获取处理消息   \n重写Handler类中处理消息的方法（void handleMessage(Message msg)），当新启动的线程发送消息时，消息发送到与之关联的MessageQueue。而Hanlder不断地从MessageQueue中获取并处理消息。\n\n### 三 Handler与UI线程通信示例\n\n- 首先要进行Handler 申明，复写handleMessage方法( 放在主线程中)\n\n```java\nprivate Handler handler = new Handler() {\n\n        @Override\n        public void handleMessage(Message msg) {\n            // TODO 接收消息并且去更新UI线程上的控件内容\n            if (msg.what == UPDATE) {\n                // 更新界面上的textview\n                tv.setText(String.valueOf(msg.obj));\n            }\n            super.handleMessage(msg);\n        }\n    };\n```\n\n- 子线程发送Message给ui线程表示自己任务已经执行完成，主线程可以做相应的操作了。\n\n```java\nnew Thread() {\n            @Override\n            public void run() {\n                // TODO 子线程中通过handler发送消息给handler接收，由handler去更新TextView的值\n                try {\n                       //do something\n\n                        Message msg = new Message();\n                        msg.what = UPDATE;                  \n                        msg.obj = \"更新后的值\" ;\n                        handler.sendMessage(msg);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }.start();\n```\n\n### 四 Handler原理分析\n\n##### 1.Handler的构造函数\n\n1. public　Handler() \n2. public　Handler(Callbackcallback)\n3. public　Handler(Looperlooper)\n4. public　Handler(Looperlooper, Callbackcallback) \n\n\n- 第1个和第2个构造函数都没有传递Looper，这两个构造函数都将通过调用Looper.myLooper()获取当前线程绑定的Looper对象，然后将该Looper对象保存到名为mLooper的成员字段中。 　   \n下面来看1,2个函数源码：\n\n```java\n    public Handler() {\n        this(null, false);\n    }\n\n    public Handler(Callback callback) {\n        this(callback, false);\n    }\n\n    //他们会调用Handler的内部构造方法\n\n    public Handler(Callback callback, boolean async) {\n        if (FIND_POTENTIAL_LEAKS) {\n      final Class<? extends Handler> klass = getClass();\n      if ((klass.isAnonymousClass() ||klass.isMemberClass()\n         || klass.isLocalClass()) &&\n                    (klass.getModifiers() & Modifier.STATIC) == 0) {\n                Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +\n                    klass.getCanonicalName());\n            }\n        }\n     /************************************\n        mLooper = Looper.myLooper();\n        if (mLooper == null) {\n            throw new RuntimeException(\n                \"Can't create handler inside thread that has not called Looper.prepare()\");\n        }\n        mQueue = mLooper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n```\n\n通过Looper.myLooper()获取了当前线程保存的Looper实例，又通过这个Looper实例获取了其中保存的MessageQueue（消息队列）。每个Handler 对应一个Looper对象，产生一个MessageQueue\n\n- 第3个和第4个构造函数传递了Looper对象，这两个构造函数会将该Looper保存到名为mLooper的成员字段中。 　   \n下面来看3、4个函数源码： \n\n```java\n    public Handler(Looper looper) {\n        this(looper, null, false);\n    }　\n\n    public Handler(Looper looper, Callback callback) {\n        this(looper, callback, false);\n    }\n   //他们会调用Handler的内部构造方法\n\n    public Handler(Looper looper, Callback callback, boolean async) {\n        mLooper = looper;\n        mQueue = looper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n```\n\n- 第2个和第4个构造函数还传递了Callback对象，Callback是Handler中的内部接口，需要实现其内部的handleMessage方法，Callback代码如下:\n\n```java\n     public interface Callback {\n         public boolean More ...handleMessage(Message msg);\n     }\n```\n\nHandler.Callback是用来处理Message的一种手段，如果没有传递该参数，那么就应该重写Handler的handleMessage方法，也就是说为了使得Handler能够处理Message，我们有两种办法： 　　 \n\n　\n1. 向Hanlder的构造函数传入一个Handler.Callback对象，并实现Handler.Callback的handleMessage方法  　    \n2. 无需向Hanlder的构造函数传入Handler.Callback对象，但是需要重写Handler本身的handleMessage方法 　\n\n也就是说无论哪种方式，我们都得通过某种方式实现handleMessage方法，这点与Java中对Thread的设计有异曲同工之处。\n\n##### Handler发送消息的几个方法的源码\n\n```java\n   public final boolean sendMessage(Message msg)\n    {\n        return sendMessageDelayed(msg, 0);\n    }\n\n   public final boolean sendEmptyMessageDelayed(int what, long delayMillis) {\n        Message msg = Message.obtain();\n        msg.what = what;\n        return sendMessageDelayed(msg, delayMillis);\n    }\n\n public final boolean sendMessageDelayed(Message msg, long delayMillis)\n    {\n        if (delayMillis < 0) {\n            delayMillis = 0;\n        }\n        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n    }\n\n public boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        if (queue == null) {\n            RuntimeException e = new RuntimeException(\n                    this + \" sendMessageAtTime() called with no mQueue\");\n            Log.w(\"Looper\", e.getMessage(), e);\n            return false;\n        }\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n\n```\n\n我们可以看出他们最后都调用了sendMessageAtTime（），然后返回了enqueueMessage方法，下面看一下此方法源码：\n\n```java\n    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n　　　　　　//把当前的handler作为msg的target属性\n        msg.target = this;\n        if (mAsynchronous) {\n            msg.setAsynchronous(true);\n        }\n        return queue.enqueueMessage(msg, uptimeMillis);\n    }\n```\n\n在该方法中有两件事需要注意： \n\n- msg.target = this   \n该代码将Message的target绑定为当前的Handler\n- queue.enqueueMessage   \n变量queue表示的是Handler所绑定的消息队列MessageQueue，通过调用queue.enqueueMessage(msg, uptimeMillis)我们将Message放入到消息队列中。\n\n### 五 Looper原理分析\n\n我们一般在主线程申明Handler，有时我们需要继承Thread类实现自己的线程功能，当我们在里面申明Handler的时候会报错。其原因是主线程中已经实现了两个重要的Looper方法，下面看一看ActivityThread.java中main方法的源码：\n\n```java\npublic static void main(String[] args) {\n            //......省略\n        Looper.prepareMainLooper();//>\n\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false);\n\n        if (sMainThreadHandler == null) {\n            sMainThreadHandler = thread.getHandler();\n        }\n\n        AsyncTask.init();\n\n        if (false) {\n            Looper.myLooper().setMessageLogging(new\n   LogPrinter(Log.DEBUG, \"ActivityThread\"));\n        }\n\n        Looper.loop();//>\n\n        throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n    }\n}\n```\n\n首先看prepare()方法\n\n```java\n     public static void prepare() {\n         prepare(true);\n     }\n \n     private static void prepare(boolean quitAllowed) {\n　　　　　//证了一个线程中只有一个Looper实例\n         if (sThreadLocal.get() != null) {\n             throw new RuntimeException(\"Only one Looper may be created per thread\");\n         }\n         sThreadLocal.set(new Looper(quitAllowed));\n     }\n```\n\n该方法会调用Looper构造函数同时实例化出MessageQueue和当前thread.\n\n```java\n    private Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    } \n\n    public static MessageQueue myQueue() {\n        return myLooper().mQueue;\n    }\n```\n\nprepare()方法中通过ThreadLocal对象实现Looper实例与线程的绑定。\n\n再看loop()方法\n\n```java\n    public static void loop() {\n        final Looper me = myLooper();\n        if (me == null) {\n            throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n        }\n        final MessageQueue queue = me.mQueue;\n\n        Binder.clearCallingIdentity();\n        final long ident = Binder.clearCallingIdentity();\n\n        for (;;) {\n            Message msg = queue.next(); // might block\n            if (msg == null) {\n               \n                return;\n            }\n\n            Printer logging = me.mLogging;\n            if (logging != null) {\n                logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +\n                        msg.callback + \": \" + msg.what);\n            }\n       //重点****\n            msg.target.dispatchMessage(msg);\n\n            if (logging != null) {\n                logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n            }\n\n            // identity of the thread wasn't corrupted.\n            final long newIdent = Binder.clearCallingIdentity();\n            if (ident != newIdent) {\n                Log.wtf(TAG, \"Thread identity changed from 0x\"\n                        + Long.toHexString(ident) + \" to 0x\"\n                        + Long.toHexString(newIdent) + \" while dispatching to \"\n                        + msg.target.getClass().getName() + \" \"\n                        + msg.callback + \" what=\" + msg.what);\n            }\n\n            msg.recycleUnchecked();\n        }\n    }\n```\n\n首先looper对象不能为空，就是说loop()方法调用必须在prepare()方法的后面。\n\nLooper一直在不断的从消息队列中通过MessageQueue的next方法获取Message，然后通过代码msg.target.dispatchMessage(msg)让该msg所绑定的Handler（Message.target）执行dispatchMessage方法以实现对Message的处理。 \n\nHandler的dispatchMessage的源码如下：\n\n```java\n     public void dispatchMessage(Message msg) {\n         if (msg.callback != null) {\n             handleCallback(msg);\n         } else {\n             if (mCallback != null) {\n                 if (mCallback.handleMessage(msg)) {\n                     return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n\n我们可以看到Handler提供了三种途径处理Message，而且处理有前后优先级之分：首先尝试让postXXX中传递的Runnable执行，其次尝试让Handler构造函数中传入的Callback的handleMessage方法处理，最后才是让Handler自身的handleMessage方法处理Message。\n\n### 六 如何在子线程中使用Handler\n\nHandler本质是从当前的线程中获取到Looper来监听和操作MessageQueue，当其他线程执行完成后回调当前线程。\n\n子线程需要先prepare（）才能获取到Looper的，是因为在子线程只是一个普通的线程，其ThreadLoacl中没有设置过Looper，所以会抛出异常，而在Looper的prepare（）方法中sThreadLocal.set(new Looper())是设置了Looper的。\n\n示例代码：\n\n定义一个类实现Runnable接口或继承Thread类（一般不继承）。\n\n```java\nclass Rub implements Runnable {  \n\n        public Handler myHandler;  \n        // 实现Runnable接口的线程体 \n        @Override  \n        public void run() {  \n\n         /*①、调用Looper的prepare()方法为当前线程创建Looper对象并，\n          创建Looper对象时，它的构造器会自动的创建相对应的MessageQueue*/\n            Looper.prepare();  \n\n            /*.②、创建Handler子类的实例，重写HandleMessage()方法，该方法处理除当前线程以外线程的消息*/\n             myHandler = new Handler() {  \n                @Override  \n                public void handleMessage(Message msg) {  \n                    String ms = \"\";  \n                    if (msg.what == 0x777) {  \n\n                    }  \n                }  \n\n            };  \n            //③、调用Looper的loop()方法来启动Looper让消息队列转动起来\n            Looper.loop();  \n        }\n    }\n```\n\n注意分成三步：\n\n- 调用Looper的prepare()方法为当前线程创建Looper对象，创建Looper对象时，它的构造器会创建与之配套的MessageQueue。 　\n- 有了Looper之后，创建Handler子类实例，重写HanderMessage()方法，该方法负责处理来自于其他线程的消息。\n- 调用Looper的looper()方法启动Looper。然后使用这个handler实例在任何其他线程中发送消息，最终处理消息的代码都会在你创建Handler实例的线程中运行。\n\n### 七 Handler总结\n\n- Handler：     \n发送和处理消息，它把消息发送给Looper管理的MessageQueue，并负责处理Looper分发给它的消息。\n      \n- Message：    \nHandler接收和处理的消息对象。\n\n- Looper：     \n每个线程只有一个Looper，它负责管理对应的MessageQueue，会不断地从MessageQueue取出消息，并将消息分给对应的Hanlder处理。主线程中，系统已经初始化了一个Looper对象，因此可以直接创建Handler即可，就可以通过Handler来发送消息、处理消息。若是在子线程，必须手动创建一个Looper对象，并启动它，调用Looper.prepare()方法。\n\n- prapare()：    \n保证每个线程最多只有一个Looper对象。\n\n- looper()：\n启动Looper，使用一个死循环不断取出MessageQueue中的消息，并将取出的消息分给对应的Handler进行处理。 　\n\n- MessageQueue：    \n由Looper负责管理，它采用先进先出的方式来管理Message。Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue想关联。Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。\n\n### 八 Android中另一个线程通信机制AsycTask\n\n##### 1.AsycTask简介\n\nAsycTask是Android中另一个处理异步任务的机制，我们上面说了可以用Handler来处理异步任务，但如果耗时的操作太多，那么我们需要开启太多的子线程，这就会给系统带来巨大的负担，随之也会带来性能方面的问题。在这种情况下我们就可以考虑使用类AsyncTask来异步执行任务，不需要子线程和handler，就可以完成异步操作和刷新UI。\n\nAsyncTask主要有二个部分：一个是与主线程的交互，另一个就是线程的管理调度。虽然可能多个AsyncTask的子类的实例，但是AsyncTask的内部Handler和ThreadPoolExecutor都是进程范围内共享的，其都是static的（所以AsycTask是串行的，不支持并发），也即属于类的，类的属性的作用范围是CLASSPATH，因为一个进程一个VM，所以是AsyncTask控制着进程范围内所有的子类实例。AsyncTask内部会创建一个进程作用域的线程池来管理要运行的任务，也就就是说当你调用了AsyncTask的execute()方法后，AsyncTask会把任务交给线程池，由线程池来管理创建Thread和运行Therad。\n\nAndroid的AsyncTask比Handler更轻量级一些（只是代码上轻量一些，而实际上要比handler更耗资源），适用于简单的异步处理。\n\n注意：不要随意使用AsyncTask,除非你必须要与UI线程交互.默认情况下使用Thread即可,要注意需要将线程优先级调低.AsyncTask适合处理短时间的操作,长时间的操作,比如下载一个很大的视频,这就需要你使用自己的线程来下载,不管是断点下载还是其它的.\n\n##### 2.AsycTask使用步骤\n\nAsyncTask对线程间的通讯做了包装，使后台线程和UI线程可以简易通讯。后台线程执行异步任务，将result告知UI线程。\n\n使用AsycTask分为两步：\n\n- 继承AsyncTask类实现自己的类    \n\n```java\npublic abstract class AsyncTask<Params, Progress, Result> {\n\n    /* Params: 输入参数，对应excute()方法中传递的参数。如果不需要传递参数，则直接设为void即可。\n\n    ** Progress：后台任务执行的百分比\n\n    ** Result：返回值类型，和doInBackground（）方法的返回值类型保持一致。*/\n}\n```\n\n- 复写方法\n\n最少要重写以下这两个方法：\n\n**a.**doInBackground(Params…)      \n在子线程（其他方法都在主线程执行）中执行比较耗时的操作，不能更新ＵＩ，可以在该方法中调用publishProgress(Progress…)来更新任务的进度。Progress方法是AsycTask中一个final方法只能调用不能重写。\n\n**b.**onPostExecute(Result)     \n使用在doInBackground 得到的结果处理操作UI， 在主线程执行，任务执行的结果作为此方法的参数返回。\n\n有时根据需求还要实现以下三个方法：\n\n**c.**onProgressUpdate(Progress…)     \n可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。\n\n**d.**onPreExecute()     \n这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。  \n\n**e.**onCancelled()    \n用户调用取消时，要做的操作\n\n##### 3.AsycTask使用示例\n\n按照上面的步骤定义自己的异步类：\n\n```java\npublic class MyTask extends AsyncTask<String, Integer, String> {  \n    //执行的第一个方法用于在执行后台任务前做一些UI操作  \n    @Override  \n    protected void onPreExecute() {  \n\n    }  \n\n    //第二个执行方法,在onPreExecute()后执行，用于后台任务,不可在此方法内修改UI\n    @Override  \n    protected String doInBackground(String... params) {  \n         //处理耗时操作\n        return \"后台任务执行完毕\";  \n    }  \n\n   /*这个函数在doInBackground调用publishProgress(int i)时触发，虽然调用时只有一个参数  \n    但是这里取到的是一个数组,所以要用progesss[0]来取值  \n    第n个参数就用progress[n]来取值   */\n    @Override  \n    protected void onProgressUpdate(Integer... progresses) {  \n        //\"loading...\" + progresses[0] + \"%\"\n        super.onProgressUpdate(progress);  \n    }  \n\n    /*doInBackground返回时触发，换句话说，就是doInBackground执行完后触发  \n    这里的result就是上面doInBackground执行后的返回值，所以这里是\"后台任务执行完毕\"  */\n    @Override  \n    protected void onPostExecute(String result) { \n\n    }  \n\n    //onCancelled方法用于在取消执行中的任务时更改UI  \n    @Override  \n    protected void onCancelled() {  \n\n    }  \n}\n```\n\n在主线程申明该类的对象，调用对象的execute（）函数开始执行。\n\n```java\nMyTask ｔ= new MyTask();\nt.execute();//这里没有参数\n```\n\n##### 4.使用AsyncTask需要注意的地方 \n\n- AsnycTask内部的Handler需要和主线程交互，所以AsyncTask的实例必须在UI线程中创建\n\n- AsyncTaskResult的doInBackground(mParams)方法执行异步任务运行在子线程中，其他方法运行在主线程中，可以操作UI组件。\n\n- 一个AsyncTask任务只能被执行一次。\n\n- 运行中可以随时调用AsnycTask对象的cancel(boolean)方法取消任务，如果成功，调用isCancelled()会返回true，并且不会执行 onPostExecute() 方法了，而是执行 onCancelled() 方法。\n\n- 对于想要立即开始执行的异步任务，要么直接使用Thread，要么单独创建线程池提供给AsyncTask。默认的AsyncTask不一定会立即执行你的任务，除非你提供给他一个单独的线程池。如果不与主线程交互，直接创建一个Thread就可以了。","source":"_posts/android基础之Handler与AsycTask.md","raw":"---\ntitle: android基础之Handler与AsycTask\ndate: 2017-02-27 14:47:53\ncategories: android\ntags:\n- android\n- java\n- Handler\n- AsycTask\n---\n\n### 一 概述\n\nHandler是Android中用于线程间通信的机制。\n\n当程序第一次启动的时候，Android会同时启动一条主线程（ Main Thread）来负责处理与UI相关的事件，我们叫做UI线程。Android的UI操作并不是线程安全的（出于性能优化考虑），意味着如果多个线程并发操作UI线程，可能导致线程安全问题。为了解决Android应用多线程问题—Android平台只允许UI线程修改Activity里的UI，这样如果在主线程中执行耗时操作就会导致UI阻塞，若超过5秒就会造成ANR。\n\n因此我们需要另开线程来处理这些耗时操作，而处理的结果我们可能需要传给主线程用于UI更新，这是就需要线程间的通信。Handler即是Android中用于线程间通信的机制，现在市场一些android的线程通信框架基本上都是基于Handler实现的，如下文将要介绍的已经置于android源码中AsycTask，和现在比较流行的EventBus。\n\n### 二 Handler的主要作用\n\n通过翻看的Handler的源码可知，Handler主要有两个作用。\n\n##### 1.线程延时\n\nHandler中内置了线程延时的方法：\n\n- final boolean postAtTime(Runnable r, long uptimeMillis)\n- final boolean postDelayed(Runnable r, long delayMillis)\n\n##### 2.线程通信\n\n主要步骤：\n\n- 在新启动的线程中发送消息     \n使用Handler对象的sendMessage()方法或者SendEmptyMessage()方法发送消息。   \n\n- 在主线程中获取处理消息   \n重写Handler类中处理消息的方法（void handleMessage(Message msg)），当新启动的线程发送消息时，消息发送到与之关联的MessageQueue。而Hanlder不断地从MessageQueue中获取并处理消息。\n\n### 三 Handler与UI线程通信示例\n\n- 首先要进行Handler 申明，复写handleMessage方法( 放在主线程中)\n\n```java\nprivate Handler handler = new Handler() {\n\n        @Override\n        public void handleMessage(Message msg) {\n            // TODO 接收消息并且去更新UI线程上的控件内容\n            if (msg.what == UPDATE) {\n                // 更新界面上的textview\n                tv.setText(String.valueOf(msg.obj));\n            }\n            super.handleMessage(msg);\n        }\n    };\n```\n\n- 子线程发送Message给ui线程表示自己任务已经执行完成，主线程可以做相应的操作了。\n\n```java\nnew Thread() {\n            @Override\n            public void run() {\n                // TODO 子线程中通过handler发送消息给handler接收，由handler去更新TextView的值\n                try {\n                       //do something\n\n                        Message msg = new Message();\n                        msg.what = UPDATE;                  \n                        msg.obj = \"更新后的值\" ;\n                        handler.sendMessage(msg);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }.start();\n```\n\n### 四 Handler原理分析\n\n##### 1.Handler的构造函数\n\n1. public　Handler() \n2. public　Handler(Callbackcallback)\n3. public　Handler(Looperlooper)\n4. public　Handler(Looperlooper, Callbackcallback) \n\n\n- 第1个和第2个构造函数都没有传递Looper，这两个构造函数都将通过调用Looper.myLooper()获取当前线程绑定的Looper对象，然后将该Looper对象保存到名为mLooper的成员字段中。 　   \n下面来看1,2个函数源码：\n\n```java\n    public Handler() {\n        this(null, false);\n    }\n\n    public Handler(Callback callback) {\n        this(callback, false);\n    }\n\n    //他们会调用Handler的内部构造方法\n\n    public Handler(Callback callback, boolean async) {\n        if (FIND_POTENTIAL_LEAKS) {\n      final Class<? extends Handler> klass = getClass();\n      if ((klass.isAnonymousClass() ||klass.isMemberClass()\n         || klass.isLocalClass()) &&\n                    (klass.getModifiers() & Modifier.STATIC) == 0) {\n                Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +\n                    klass.getCanonicalName());\n            }\n        }\n     /************************************\n        mLooper = Looper.myLooper();\n        if (mLooper == null) {\n            throw new RuntimeException(\n                \"Can't create handler inside thread that has not called Looper.prepare()\");\n        }\n        mQueue = mLooper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n```\n\n通过Looper.myLooper()获取了当前线程保存的Looper实例，又通过这个Looper实例获取了其中保存的MessageQueue（消息队列）。每个Handler 对应一个Looper对象，产生一个MessageQueue\n\n- 第3个和第4个构造函数传递了Looper对象，这两个构造函数会将该Looper保存到名为mLooper的成员字段中。 　   \n下面来看3、4个函数源码： \n\n```java\n    public Handler(Looper looper) {\n        this(looper, null, false);\n    }　\n\n    public Handler(Looper looper, Callback callback) {\n        this(looper, callback, false);\n    }\n   //他们会调用Handler的内部构造方法\n\n    public Handler(Looper looper, Callback callback, boolean async) {\n        mLooper = looper;\n        mQueue = looper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n```\n\n- 第2个和第4个构造函数还传递了Callback对象，Callback是Handler中的内部接口，需要实现其内部的handleMessage方法，Callback代码如下:\n\n```java\n     public interface Callback {\n         public boolean More ...handleMessage(Message msg);\n     }\n```\n\nHandler.Callback是用来处理Message的一种手段，如果没有传递该参数，那么就应该重写Handler的handleMessage方法，也就是说为了使得Handler能够处理Message，我们有两种办法： 　　 \n\n　\n1. 向Hanlder的构造函数传入一个Handler.Callback对象，并实现Handler.Callback的handleMessage方法  　    \n2. 无需向Hanlder的构造函数传入Handler.Callback对象，但是需要重写Handler本身的handleMessage方法 　\n\n也就是说无论哪种方式，我们都得通过某种方式实现handleMessage方法，这点与Java中对Thread的设计有异曲同工之处。\n\n##### Handler发送消息的几个方法的源码\n\n```java\n   public final boolean sendMessage(Message msg)\n    {\n        return sendMessageDelayed(msg, 0);\n    }\n\n   public final boolean sendEmptyMessageDelayed(int what, long delayMillis) {\n        Message msg = Message.obtain();\n        msg.what = what;\n        return sendMessageDelayed(msg, delayMillis);\n    }\n\n public final boolean sendMessageDelayed(Message msg, long delayMillis)\n    {\n        if (delayMillis < 0) {\n            delayMillis = 0;\n        }\n        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n    }\n\n public boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        if (queue == null) {\n            RuntimeException e = new RuntimeException(\n                    this + \" sendMessageAtTime() called with no mQueue\");\n            Log.w(\"Looper\", e.getMessage(), e);\n            return false;\n        }\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n\n```\n\n我们可以看出他们最后都调用了sendMessageAtTime（），然后返回了enqueueMessage方法，下面看一下此方法源码：\n\n```java\n    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n　　　　　　//把当前的handler作为msg的target属性\n        msg.target = this;\n        if (mAsynchronous) {\n            msg.setAsynchronous(true);\n        }\n        return queue.enqueueMessage(msg, uptimeMillis);\n    }\n```\n\n在该方法中有两件事需要注意： \n\n- msg.target = this   \n该代码将Message的target绑定为当前的Handler\n- queue.enqueueMessage   \n变量queue表示的是Handler所绑定的消息队列MessageQueue，通过调用queue.enqueueMessage(msg, uptimeMillis)我们将Message放入到消息队列中。\n\n### 五 Looper原理分析\n\n我们一般在主线程申明Handler，有时我们需要继承Thread类实现自己的线程功能，当我们在里面申明Handler的时候会报错。其原因是主线程中已经实现了两个重要的Looper方法，下面看一看ActivityThread.java中main方法的源码：\n\n```java\npublic static void main(String[] args) {\n            //......省略\n        Looper.prepareMainLooper();//>\n\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false);\n\n        if (sMainThreadHandler == null) {\n            sMainThreadHandler = thread.getHandler();\n        }\n\n        AsyncTask.init();\n\n        if (false) {\n            Looper.myLooper().setMessageLogging(new\n   LogPrinter(Log.DEBUG, \"ActivityThread\"));\n        }\n\n        Looper.loop();//>\n\n        throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n    }\n}\n```\n\n首先看prepare()方法\n\n```java\n     public static void prepare() {\n         prepare(true);\n     }\n \n     private static void prepare(boolean quitAllowed) {\n　　　　　//证了一个线程中只有一个Looper实例\n         if (sThreadLocal.get() != null) {\n             throw new RuntimeException(\"Only one Looper may be created per thread\");\n         }\n         sThreadLocal.set(new Looper(quitAllowed));\n     }\n```\n\n该方法会调用Looper构造函数同时实例化出MessageQueue和当前thread.\n\n```java\n    private Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    } \n\n    public static MessageQueue myQueue() {\n        return myLooper().mQueue;\n    }\n```\n\nprepare()方法中通过ThreadLocal对象实现Looper实例与线程的绑定。\n\n再看loop()方法\n\n```java\n    public static void loop() {\n        final Looper me = myLooper();\n        if (me == null) {\n            throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n        }\n        final MessageQueue queue = me.mQueue;\n\n        Binder.clearCallingIdentity();\n        final long ident = Binder.clearCallingIdentity();\n\n        for (;;) {\n            Message msg = queue.next(); // might block\n            if (msg == null) {\n               \n                return;\n            }\n\n            Printer logging = me.mLogging;\n            if (logging != null) {\n                logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +\n                        msg.callback + \": \" + msg.what);\n            }\n       //重点****\n            msg.target.dispatchMessage(msg);\n\n            if (logging != null) {\n                logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n            }\n\n            // identity of the thread wasn't corrupted.\n            final long newIdent = Binder.clearCallingIdentity();\n            if (ident != newIdent) {\n                Log.wtf(TAG, \"Thread identity changed from 0x\"\n                        + Long.toHexString(ident) + \" to 0x\"\n                        + Long.toHexString(newIdent) + \" while dispatching to \"\n                        + msg.target.getClass().getName() + \" \"\n                        + msg.callback + \" what=\" + msg.what);\n            }\n\n            msg.recycleUnchecked();\n        }\n    }\n```\n\n首先looper对象不能为空，就是说loop()方法调用必须在prepare()方法的后面。\n\nLooper一直在不断的从消息队列中通过MessageQueue的next方法获取Message，然后通过代码msg.target.dispatchMessage(msg)让该msg所绑定的Handler（Message.target）执行dispatchMessage方法以实现对Message的处理。 \n\nHandler的dispatchMessage的源码如下：\n\n```java\n     public void dispatchMessage(Message msg) {\n         if (msg.callback != null) {\n             handleCallback(msg);\n         } else {\n             if (mCallback != null) {\n                 if (mCallback.handleMessage(msg)) {\n                     return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n\n我们可以看到Handler提供了三种途径处理Message，而且处理有前后优先级之分：首先尝试让postXXX中传递的Runnable执行，其次尝试让Handler构造函数中传入的Callback的handleMessage方法处理，最后才是让Handler自身的handleMessage方法处理Message。\n\n### 六 如何在子线程中使用Handler\n\nHandler本质是从当前的线程中获取到Looper来监听和操作MessageQueue，当其他线程执行完成后回调当前线程。\n\n子线程需要先prepare（）才能获取到Looper的，是因为在子线程只是一个普通的线程，其ThreadLoacl中没有设置过Looper，所以会抛出异常，而在Looper的prepare（）方法中sThreadLocal.set(new Looper())是设置了Looper的。\n\n示例代码：\n\n定义一个类实现Runnable接口或继承Thread类（一般不继承）。\n\n```java\nclass Rub implements Runnable {  \n\n        public Handler myHandler;  \n        // 实现Runnable接口的线程体 \n        @Override  \n        public void run() {  \n\n         /*①、调用Looper的prepare()方法为当前线程创建Looper对象并，\n          创建Looper对象时，它的构造器会自动的创建相对应的MessageQueue*/\n            Looper.prepare();  \n\n            /*.②、创建Handler子类的实例，重写HandleMessage()方法，该方法处理除当前线程以外线程的消息*/\n             myHandler = new Handler() {  \n                @Override  \n                public void handleMessage(Message msg) {  \n                    String ms = \"\";  \n                    if (msg.what == 0x777) {  \n\n                    }  \n                }  \n\n            };  \n            //③、调用Looper的loop()方法来启动Looper让消息队列转动起来\n            Looper.loop();  \n        }\n    }\n```\n\n注意分成三步：\n\n- 调用Looper的prepare()方法为当前线程创建Looper对象，创建Looper对象时，它的构造器会创建与之配套的MessageQueue。 　\n- 有了Looper之后，创建Handler子类实例，重写HanderMessage()方法，该方法负责处理来自于其他线程的消息。\n- 调用Looper的looper()方法启动Looper。然后使用这个handler实例在任何其他线程中发送消息，最终处理消息的代码都会在你创建Handler实例的线程中运行。\n\n### 七 Handler总结\n\n- Handler：     \n发送和处理消息，它把消息发送给Looper管理的MessageQueue，并负责处理Looper分发给它的消息。\n      \n- Message：    \nHandler接收和处理的消息对象。\n\n- Looper：     \n每个线程只有一个Looper，它负责管理对应的MessageQueue，会不断地从MessageQueue取出消息，并将消息分给对应的Hanlder处理。主线程中，系统已经初始化了一个Looper对象，因此可以直接创建Handler即可，就可以通过Handler来发送消息、处理消息。若是在子线程，必须手动创建一个Looper对象，并启动它，调用Looper.prepare()方法。\n\n- prapare()：    \n保证每个线程最多只有一个Looper对象。\n\n- looper()：\n启动Looper，使用一个死循环不断取出MessageQueue中的消息，并将取出的消息分给对应的Handler进行处理。 　\n\n- MessageQueue：    \n由Looper负责管理，它采用先进先出的方式来管理Message。Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue想关联。Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。\n\n### 八 Android中另一个线程通信机制AsycTask\n\n##### 1.AsycTask简介\n\nAsycTask是Android中另一个处理异步任务的机制，我们上面说了可以用Handler来处理异步任务，但如果耗时的操作太多，那么我们需要开启太多的子线程，这就会给系统带来巨大的负担，随之也会带来性能方面的问题。在这种情况下我们就可以考虑使用类AsyncTask来异步执行任务，不需要子线程和handler，就可以完成异步操作和刷新UI。\n\nAsyncTask主要有二个部分：一个是与主线程的交互，另一个就是线程的管理调度。虽然可能多个AsyncTask的子类的实例，但是AsyncTask的内部Handler和ThreadPoolExecutor都是进程范围内共享的，其都是static的（所以AsycTask是串行的，不支持并发），也即属于类的，类的属性的作用范围是CLASSPATH，因为一个进程一个VM，所以是AsyncTask控制着进程范围内所有的子类实例。AsyncTask内部会创建一个进程作用域的线程池来管理要运行的任务，也就就是说当你调用了AsyncTask的execute()方法后，AsyncTask会把任务交给线程池，由线程池来管理创建Thread和运行Therad。\n\nAndroid的AsyncTask比Handler更轻量级一些（只是代码上轻量一些，而实际上要比handler更耗资源），适用于简单的异步处理。\n\n注意：不要随意使用AsyncTask,除非你必须要与UI线程交互.默认情况下使用Thread即可,要注意需要将线程优先级调低.AsyncTask适合处理短时间的操作,长时间的操作,比如下载一个很大的视频,这就需要你使用自己的线程来下载,不管是断点下载还是其它的.\n\n##### 2.AsycTask使用步骤\n\nAsyncTask对线程间的通讯做了包装，使后台线程和UI线程可以简易通讯。后台线程执行异步任务，将result告知UI线程。\n\n使用AsycTask分为两步：\n\n- 继承AsyncTask类实现自己的类    \n\n```java\npublic abstract class AsyncTask<Params, Progress, Result> {\n\n    /* Params: 输入参数，对应excute()方法中传递的参数。如果不需要传递参数，则直接设为void即可。\n\n    ** Progress：后台任务执行的百分比\n\n    ** Result：返回值类型，和doInBackground（）方法的返回值类型保持一致。*/\n}\n```\n\n- 复写方法\n\n最少要重写以下这两个方法：\n\n**a.**doInBackground(Params…)      \n在子线程（其他方法都在主线程执行）中执行比较耗时的操作，不能更新ＵＩ，可以在该方法中调用publishProgress(Progress…)来更新任务的进度。Progress方法是AsycTask中一个final方法只能调用不能重写。\n\n**b.**onPostExecute(Result)     \n使用在doInBackground 得到的结果处理操作UI， 在主线程执行，任务执行的结果作为此方法的参数返回。\n\n有时根据需求还要实现以下三个方法：\n\n**c.**onProgressUpdate(Progress…)     \n可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。\n\n**d.**onPreExecute()     \n这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。  \n\n**e.**onCancelled()    \n用户调用取消时，要做的操作\n\n##### 3.AsycTask使用示例\n\n按照上面的步骤定义自己的异步类：\n\n```java\npublic class MyTask extends AsyncTask<String, Integer, String> {  \n    //执行的第一个方法用于在执行后台任务前做一些UI操作  \n    @Override  \n    protected void onPreExecute() {  \n\n    }  \n\n    //第二个执行方法,在onPreExecute()后执行，用于后台任务,不可在此方法内修改UI\n    @Override  \n    protected String doInBackground(String... params) {  \n         //处理耗时操作\n        return \"后台任务执行完毕\";  \n    }  \n\n   /*这个函数在doInBackground调用publishProgress(int i)时触发，虽然调用时只有一个参数  \n    但是这里取到的是一个数组,所以要用progesss[0]来取值  \n    第n个参数就用progress[n]来取值   */\n    @Override  \n    protected void onProgressUpdate(Integer... progresses) {  \n        //\"loading...\" + progresses[0] + \"%\"\n        super.onProgressUpdate(progress);  \n    }  \n\n    /*doInBackground返回时触发，换句话说，就是doInBackground执行完后触发  \n    这里的result就是上面doInBackground执行后的返回值，所以这里是\"后台任务执行完毕\"  */\n    @Override  \n    protected void onPostExecute(String result) { \n\n    }  \n\n    //onCancelled方法用于在取消执行中的任务时更改UI  \n    @Override  \n    protected void onCancelled() {  \n\n    }  \n}\n```\n\n在主线程申明该类的对象，调用对象的execute（）函数开始执行。\n\n```java\nMyTask ｔ= new MyTask();\nt.execute();//这里没有参数\n```\n\n##### 4.使用AsyncTask需要注意的地方 \n\n- AsnycTask内部的Handler需要和主线程交互，所以AsyncTask的实例必须在UI线程中创建\n\n- AsyncTaskResult的doInBackground(mParams)方法执行异步任务运行在子线程中，其他方法运行在主线程中，可以操作UI组件。\n\n- 一个AsyncTask任务只能被执行一次。\n\n- 运行中可以随时调用AsnycTask对象的cancel(boolean)方法取消任务，如果成功，调用isCancelled()会返回true，并且不会执行 onPostExecute() 方法了，而是执行 onCancelled() 方法。\n\n- 对于想要立即开始执行的异步任务，要么直接使用Thread，要么单独创建线程池提供给AsyncTask。默认的AsyncTask不一定会立即执行你的任务，除非你提供给他一个单独的线程池。如果不与主线程交互，直接创建一个Thread就可以了。","slug":"android基础之Handler与AsycTask","published":1,"updated":"2017-03-09T12:47:42.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj02g6grz00057c02eghqhf9d","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Handler是Android中用于线程间通信的机制。</p>\n<p>当程序第一次启动的时候，Android会同时启动一条主线程（ Main Thread）来负责处理与UI相关的事件，我们叫做UI线程。Android的UI操作并不是线程安全的（出于性能优化考虑），意味着如果多个线程并发操作UI线程，可能导致线程安全问题。为了解决Android应用多线程问题—Android平台只允许UI线程修改Activity里的UI，这样如果在主线程中执行耗时操作就会导致UI阻塞，若超过5秒就会造成ANR。</p>\n<p>因此我们需要另开线程来处理这些耗时操作，而处理的结果我们可能需要传给主线程用于UI更新，这是就需要线程间的通信。Handler即是Android中用于线程间通信的机制，现在市场一些android的线程通信框架基本上都是基于Handler实现的，如下文将要介绍的已经置于android源码中AsycTask，和现在比较流行的EventBus。</p>\n<h3 id=\"二-Handler的主要作用\"><a href=\"#二-Handler的主要作用\" class=\"headerlink\" title=\"二 Handler的主要作用\"></a>二 Handler的主要作用</h3><p>通过翻看的Handler的源码可知，Handler主要有两个作用。</p>\n<h5 id=\"1-线程延时\"><a href=\"#1-线程延时\" class=\"headerlink\" title=\"1.线程延时\"></a>1.线程延时</h5><p>Handler中内置了线程延时的方法：</p>\n<ul>\n<li>final boolean postAtTime(Runnable r, long uptimeMillis)</li>\n<li>final boolean postDelayed(Runnable r, long delayMillis)</li>\n</ul>\n<h5 id=\"2-线程通信\"><a href=\"#2-线程通信\" class=\"headerlink\" title=\"2.线程通信\"></a>2.线程通信</h5><p>主要步骤：</p>\n<ul>\n<li><p>在新启动的线程中发送消息<br>使用Handler对象的sendMessage()方法或者SendEmptyMessage()方法发送消息。   </p>\n</li>\n<li><p>在主线程中获取处理消息<br>重写Handler类中处理消息的方法（void handleMessage(Message msg)），当新启动的线程发送消息时，消息发送到与之关联的MessageQueue。而Hanlder不断地从MessageQueue中获取并处理消息。</p>\n</li>\n</ul>\n<h3 id=\"三-Handler与UI线程通信示例\"><a href=\"#三-Handler与UI线程通信示例\" class=\"headerlink\" title=\"三 Handler与UI线程通信示例\"></a>三 Handler与UI线程通信示例</h3><ul>\n<li>首先要进行Handler 申明，复写handleMessage方法( 放在主线程中)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> Handler handler = <span class=\"keyword\">new</span> Handler() &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// TODO 接收消息并且去更新UI线程上的控件内容</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (msg.what == UPDATE) &#123;</div><div class=\"line\">                <span class=\"comment\">// 更新界面上的textview</span></div><div class=\"line\">                tv.setText(String.valueOf(msg.obj));</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">super</span>.handleMessage(msg);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<ul>\n<li>子线程发送Message给ui线程表示自己任务已经执行完成，主线程可以做相应的操作了。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Thread() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                <span class=\"comment\">// TODO 子线程中通过handler发送消息给handler接收，由handler去更新TextView的值</span></div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                       <span class=\"comment\">//do something</span></div><div class=\"line\"></div><div class=\"line\">                        Message msg = <span class=\"keyword\">new</span> Message();</div><div class=\"line\">                        msg.what = UPDATE;                  </div><div class=\"line\">                        msg.obj = <span class=\"string\">\"更新后的值\"</span> ;</div><div class=\"line\">                        handler.sendMessage(msg);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;.start();</div></pre></td></tr></table></figure>\n<h3 id=\"四-Handler原理分析\"><a href=\"#四-Handler原理分析\" class=\"headerlink\" title=\"四 Handler原理分析\"></a>四 Handler原理分析</h3><h5 id=\"1-Handler的构造函数\"><a href=\"#1-Handler的构造函数\" class=\"headerlink\" title=\"1.Handler的构造函数\"></a>1.Handler的构造函数</h5><ol>\n<li>public　Handler() </li>\n<li>public　Handler(Callbackcallback)</li>\n<li>public　Handler(Looperlooper)</li>\n<li>public　Handler(Looperlooper, Callbackcallback) </li>\n</ol>\n<ul>\n<li>第1个和第2个构造函数都没有传递Looper，这两个构造函数都将通过调用Looper.myLooper()获取当前线程绑定的Looper对象，然后将该Looper对象保存到名为mLooper的成员字段中。 　<br>下面来看1,2个函数源码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(callback, <span class=\"keyword\">false</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//他们会调用Handler的内部构造方法</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class=\"line\">  <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();</div><div class=\"line\">  <span class=\"keyword\">if</span> ((klass.isAnonymousClass() ||klass.isMemberClass()</div><div class=\"line\">     || klass.isLocalClass()) &amp;&amp;</div><div class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            Log.w(TAG, <span class=\"string\">\"The following Handler class should be static or leaks might occur: \"</span> +</div><div class=\"line\">                klass.getCanonicalName());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> <span class=\"comment\">/************************************</span></div><div class=\"line\">    mLooper = Looper.myLooper();</div><div class=\"line\">    if (mLooper == null) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">            \"Can't create handler inside thread that has not called Looper.prepare()\");</div><div class=\"line\">    &#125;</div><div class=\"line\">    mQueue = mLooper.mQueue;</div><div class=\"line\">    mCallback = callback;</div><div class=\"line\">    mAsynchronous = async;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过Looper.myLooper()获取了当前线程保存的Looper实例，又通过这个Looper实例获取了其中保存的MessageQueue（消息队列）。每个Handler 对应一个Looper对象，产生一个MessageQueue</p>\n<ul>\n<li>第3个和第4个构造函数传递了Looper对象，这两个构造函数会将该Looper保存到名为mLooper的成员字段中。 　<br>下面来看3、4个函数源码： </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Looper looper)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">this</span>(looper, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\"> &#125;　</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Looper looper, Callback callback)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">this</span>(looper, callback, <span class=\"keyword\">false</span>);</div><div class=\"line\"> &#125;</div><div class=\"line\"><span class=\"comment\">//他们会调用Handler的内部构造方法</span></div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Looper looper, Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</div><div class=\"line\">     mLooper = looper;</div><div class=\"line\">     mQueue = looper.mQueue;</div><div class=\"line\">     mCallback = callback;</div><div class=\"line\">     mAsynchronous = async;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第2个和第4个构造函数还传递了Callback对象，Callback是Handler中的内部接口，需要实现其内部的handleMessage方法，Callback代码如下:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callback</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> More ...handleMessage(Message msg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Handler.Callback是用来处理Message的一种手段，如果没有传递该参数，那么就应该重写Handler的handleMessage方法，也就是说为了使得Handler能够处理Message，我们有两种办法： 　　 </p>\n<p>　</p>\n<ol>\n<li>向Hanlder的构造函数传入一个Handler.Callback对象，并实现Handler.Callback的handleMessage方法  　    </li>\n<li>无需向Hanlder的构造函数传入Handler.Callback对象，但是需要重写Handler本身的handleMessage方法 　</li>\n</ol>\n<p>也就是说无论哪种方式，我们都得通过某种方式实现handleMessage方法，这点与Java中对Thread的设计有异曲同工之处。</p>\n<h5 id=\"Handler发送消息的几个方法的源码\"><a href=\"#Handler发送消息的几个方法的源码\" class=\"headerlink\" title=\"Handler发送消息的几个方法的源码\"></a>Handler发送消息的几个方法的源码</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessage</span><span class=\"params\">(Message msg)</span></span></div><div class=\"line\">   &#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> sendMessageDelayed(msg, <span class=\"number\">0</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendEmptyMessageDelayed</span><span class=\"params\">(<span class=\"keyword\">int</span> what, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</div><div class=\"line\">       Message msg = Message.obtain();</div><div class=\"line\">       msg.what = what;</div><div class=\"line\">       <span class=\"keyword\">return</span> sendMessageDelayed(msg, delayMillis);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageDelayed</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> delayMillis)</span></span></div><div class=\"line\">   &#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (delayMillis &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">           delayMillis = <span class=\"number\">0</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</div><div class=\"line\">       MessageQueue queue = mQueue;</div><div class=\"line\">       <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</div><div class=\"line\">                   <span class=\"keyword\">this</span> + <span class=\"string\">\" sendMessageAtTime() called with no mQueue\"</span>);</div><div class=\"line\">           Log.w(<span class=\"string\">\"Looper\"</span>, e.getMessage(), e);</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>我们可以看出他们最后都调用了sendMessageAtTime（），然后返回了enqueueMessage方法，下面看一下此方法源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(MessageQueue queue, Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</div><div class=\"line\">　　　　　　<span class=\"comment\">//把当前的handler作为msg的target属性</span></div><div class=\"line\">    msg.target = <span class=\"keyword\">this</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mAsynchronous) &#123;</div><div class=\"line\">        msg.setAsynchronous(<span class=\"keyword\">true</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在该方法中有两件事需要注意： </p>\n<ul>\n<li>msg.target = this<br>该代码将Message的target绑定为当前的Handler</li>\n<li>queue.enqueueMessage<br>变量queue表示的是Handler所绑定的消息队列MessageQueue，通过调用queue.enqueueMessage(msg, uptimeMillis)我们将Message放入到消息队列中。</li>\n</ul>\n<h3 id=\"五-Looper原理分析\"><a href=\"#五-Looper原理分析\" class=\"headerlink\" title=\"五 Looper原理分析\"></a>五 Looper原理分析</h3><p>我们一般在主线程申明Handler，有时我们需要继承Thread类实现自己的线程功能，当我们在里面申明Handler的时候会报错。其原因是主线程中已经实现了两个重要的Looper方法，下面看一看ActivityThread.java中main方法的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">//......省略</span></div><div class=\"line\">        Looper.prepareMainLooper();<span class=\"comment\">//&gt;</span></div><div class=\"line\"></div><div class=\"line\">        ActivityThread thread = <span class=\"keyword\">new</span> ActivityThread();</div><div class=\"line\">        thread.attach(<span class=\"keyword\">false</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (sMainThreadHandler == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            sMainThreadHandler = thread.getHandler();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        AsyncTask.init();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">false</span>) &#123;</div><div class=\"line\">            Looper.myLooper().setMessageLogging(<span class=\"keyword\">new</span></div><div class=\"line\">   LogPrinter(Log.DEBUG, <span class=\"string\">\"ActivityThread\"</span>));</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Looper.loop();<span class=\"comment\">//&gt;</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Main thread loop unexpectedly exited\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先看prepare()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    prepare(<span class=\"keyword\">true</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</div><div class=\"line\">　　　　　<span class=\"comment\">//证了一个线程中只有一个Looper实例</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>该方法会调用Looper构造函数同时实例化出MessageQueue和当前thread.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</div><div class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);</div><div class=\"line\">    mThread = Thread.currentThread();</div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> MessageQueue <span class=\"title\">myQueue</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> myLooper().mQueue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>prepare()方法中通过ThreadLocal对象实现Looper实例与线程的绑定。</p>\n<p>再看loop()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();</div><div class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</div><div class=\"line\"></div><div class=\"line\">    Binder.clearCallingIdentity();</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ident = Binder.clearCallingIdentity();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// might block</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           </div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Printer logging = me.mLogging;</div><div class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            logging.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt; Dispatching to \"</span> + msg.target + <span class=\"string\">\" \"</span> +</div><div class=\"line\">                    msg.callback + <span class=\"string\">\": \"</span> + msg.what);</div><div class=\"line\">        &#125;</div><div class=\"line\">   <span class=\"comment\">//重点****</span></div><div class=\"line\">        msg.target.dispatchMessage(msg);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            logging.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt; Finished to \"</span> + msg.target + <span class=\"string\">\" \"</span> + msg.callback);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// identity of the thread wasn't corrupted.</span></div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> newIdent = Binder.clearCallingIdentity();</div><div class=\"line\">        <span class=\"keyword\">if</span> (ident != newIdent) &#123;</div><div class=\"line\">            Log.wtf(TAG, <span class=\"string\">\"Thread identity changed from 0x\"</span></div><div class=\"line\">                    + Long.toHexString(ident) + <span class=\"string\">\" to 0x\"</span></div><div class=\"line\">                    + Long.toHexString(newIdent) + <span class=\"string\">\" while dispatching to \"</span></div><div class=\"line\">                    + msg.target.getClass().getName() + <span class=\"string\">\" \"</span></div><div class=\"line\">                    + msg.callback + <span class=\"string\">\" what=\"</span> + msg.what);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        msg.recycleUnchecked();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先looper对象不能为空，就是说loop()方法调用必须在prepare()方法的后面。</p>\n<p>Looper一直在不断的从消息队列中通过MessageQueue的next方法获取Message，然后通过代码msg.target.dispatchMessage(msg)让该msg所绑定的Handler（Message.target）执行dispatchMessage方法以实现对Message的处理。 </p>\n<p>Handler的dispatchMessage的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">         handleCallback(msg);</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">             <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class=\"line\">                 <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        handleMessage(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以看到Handler提供了三种途径处理Message，而且处理有前后优先级之分：首先尝试让postXXX中传递的Runnable执行，其次尝试让Handler构造函数中传入的Callback的handleMessage方法处理，最后才是让Handler自身的handleMessage方法处理Message。</p>\n<h3 id=\"六-如何在子线程中使用Handler\"><a href=\"#六-如何在子线程中使用Handler\" class=\"headerlink\" title=\"六 如何在子线程中使用Handler\"></a>六 如何在子线程中使用Handler</h3><p>Handler本质是从当前的线程中获取到Looper来监听和操作MessageQueue，当其他线程执行完成后回调当前线程。</p>\n<p>子线程需要先prepare（）才能获取到Looper的，是因为在子线程只是一个普通的线程，其ThreadLoacl中没有设置过Looper，所以会抛出异常，而在Looper的prepare（）方法中sThreadLocal.set(new Looper())是设置了Looper的。</p>\n<p>示例代码：</p>\n<p>定义一个类实现Runnable接口或继承Thread类（一般不继承）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rub</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">public</span> Handler myHandler;  </div><div class=\"line\">        <span class=\"comment\">// 实现Runnable接口的线程体 </span></div><div class=\"line\">        <span class=\"meta\">@Override</span>  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">         <span class=\"comment\">/*①、调用Looper的prepare()方法为当前线程创建Looper对象并，</span></div><div class=\"line\">          创建Looper对象时，它的构造器会自动的创建相对应的MessageQueue*/</div><div class=\"line\">            Looper.prepare();  </div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">/*.②、创建Handler子类的实例，重写HandleMessage()方法，该方法处理除当前线程以外线程的消息*/</span></div><div class=\"line\">             myHandler = <span class=\"keyword\">new</span> Handler() &#123;  </div><div class=\"line\">                <span class=\"meta\">@Override</span>  </div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;  </div><div class=\"line\">                    String ms = <span class=\"string\">\"\"</span>;  </div><div class=\"line\">                    <span class=\"keyword\">if</span> (msg.what == <span class=\"number\">0x777</span>) &#123;  </div><div class=\"line\"></div><div class=\"line\">                    &#125;  </div><div class=\"line\">                &#125;  </div><div class=\"line\"></div><div class=\"line\">            &#125;;  </div><div class=\"line\">            <span class=\"comment\">//③、调用Looper的loop()方法来启动Looper让消息队列转动起来</span></div><div class=\"line\">            Looper.loop();  </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>注意分成三步：</p>\n<ul>\n<li>调用Looper的prepare()方法为当前线程创建Looper对象，创建Looper对象时，它的构造器会创建与之配套的MessageQueue。 　</li>\n<li>有了Looper之后，创建Handler子类实例，重写HanderMessage()方法，该方法负责处理来自于其他线程的消息。</li>\n<li>调用Looper的looper()方法启动Looper。然后使用这个handler实例在任何其他线程中发送消息，最终处理消息的代码都会在你创建Handler实例的线程中运行。</li>\n</ul>\n<h3 id=\"七-Handler总结\"><a href=\"#七-Handler总结\" class=\"headerlink\" title=\"七 Handler总结\"></a>七 Handler总结</h3><ul>\n<li><p>Handler：<br>发送和处理消息，它把消息发送给Looper管理的MessageQueue，并负责处理Looper分发给它的消息。</p>\n</li>\n<li><p>Message：<br>Handler接收和处理的消息对象。</p>\n</li>\n<li><p>Looper：<br>每个线程只有一个Looper，它负责管理对应的MessageQueue，会不断地从MessageQueue取出消息，并将消息分给对应的Hanlder处理。主线程中，系统已经初始化了一个Looper对象，因此可以直接创建Handler即可，就可以通过Handler来发送消息、处理消息。若是在子线程，必须手动创建一个Looper对象，并启动它，调用Looper.prepare()方法。</p>\n</li>\n<li><p>prapare()：<br>保证每个线程最多只有一个Looper对象。</p>\n</li>\n<li><p>looper()：<br>启动Looper，使用一个死循环不断取出MessageQueue中的消息，并将取出的消息分给对应的Handler进行处理。 　</p>\n</li>\n<li><p>MessageQueue：<br>由Looper负责管理，它采用先进先出的方式来管理Message。Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue想关联。Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。</p>\n</li>\n</ul>\n<h3 id=\"八-Android中另一个线程通信机制AsycTask\"><a href=\"#八-Android中另一个线程通信机制AsycTask\" class=\"headerlink\" title=\"八 Android中另一个线程通信机制AsycTask\"></a>八 Android中另一个线程通信机制AsycTask</h3><h5 id=\"1-AsycTask简介\"><a href=\"#1-AsycTask简介\" class=\"headerlink\" title=\"1.AsycTask简介\"></a>1.AsycTask简介</h5><p>AsycTask是Android中另一个处理异步任务的机制，我们上面说了可以用Handler来处理异步任务，但如果耗时的操作太多，那么我们需要开启太多的子线程，这就会给系统带来巨大的负担，随之也会带来性能方面的问题。在这种情况下我们就可以考虑使用类AsyncTask来异步执行任务，不需要子线程和handler，就可以完成异步操作和刷新UI。</p>\n<p>AsyncTask主要有二个部分：一个是与主线程的交互，另一个就是线程的管理调度。虽然可能多个AsyncTask的子类的实例，但是AsyncTask的内部Handler和ThreadPoolExecutor都是进程范围内共享的，其都是static的（所以AsycTask是串行的，不支持并发），也即属于类的，类的属性的作用范围是CLASSPATH，因为一个进程一个VM，所以是AsyncTask控制着进程范围内所有的子类实例。AsyncTask内部会创建一个进程作用域的线程池来管理要运行的任务，也就就是说当你调用了AsyncTask的execute()方法后，AsyncTask会把任务交给线程池，由线程池来管理创建Thread和运行Therad。</p>\n<p>Android的AsyncTask比Handler更轻量级一些（只是代码上轻量一些，而实际上要比handler更耗资源），适用于简单的异步处理。</p>\n<p>注意：不要随意使用AsyncTask,除非你必须要与UI线程交互.默认情况下使用Thread即可,要注意需要将线程优先级调低.AsyncTask适合处理短时间的操作,长时间的操作,比如下载一个很大的视频,这就需要你使用自己的线程来下载,不管是断点下载还是其它的.</p>\n<h5 id=\"2-AsycTask使用步骤\"><a href=\"#2-AsycTask使用步骤\" class=\"headerlink\" title=\"2.AsycTask使用步骤\"></a>2.AsycTask使用步骤</h5><p>AsyncTask对线程间的通讯做了包装，使后台线程和UI线程可以简易通讯。后台线程执行异步任务，将result告知UI线程。</p>\n<p>使用AsycTask分为两步：</p>\n<ul>\n<li>继承AsyncTask类实现自己的类    </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncTask</span>&lt;<span class=\"title\">Params</span>, <span class=\"title\">Progress</span>, <span class=\"title\">Result</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/* Params: 输入参数，对应excute()方法中传递的参数。如果不需要传递参数，则直接设为void即可。</span></div><div class=\"line\"></div><div class=\"line\">    ** Progress：后台任务执行的百分比</div><div class=\"line\"></div><div class=\"line\">    ** Result：返回值类型，和doInBackground（）方法的返回值类型保持一致。*/</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>复写方法</li>\n</ul>\n<p>最少要重写以下这两个方法：</p>\n<p><strong>a.</strong>doInBackground(Params…)<br>在子线程（其他方法都在主线程执行）中执行比较耗时的操作，不能更新ＵＩ，可以在该方法中调用publishProgress(Progress…)来更新任务的进度。Progress方法是AsycTask中一个final方法只能调用不能重写。</p>\n<p><strong>b.</strong>onPostExecute(Result)<br>使用在doInBackground 得到的结果处理操作UI， 在主线程执行，任务执行的结果作为此方法的参数返回。</p>\n<p>有时根据需求还要实现以下三个方法：</p>\n<p><strong>c.</strong>onProgressUpdate(Progress…)<br>可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。</p>\n<p><strong>d.</strong>onPreExecute()<br>这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。  </p>\n<p><strong>e.</strong>onCancelled()<br>用户调用取消时，要做的操作</p>\n<h5 id=\"3-AsycTask使用示例\"><a href=\"#3-AsycTask使用示例\" class=\"headerlink\" title=\"3.AsycTask使用示例\"></a>3.AsycTask使用示例</h5><p>按照上面的步骤定义自己的异步类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">AsyncTask</span>&lt;<span class=\"title\">String</span>, <span class=\"title\">Integer</span>, <span class=\"title\">String</span>&gt; </span>&#123;  </div><div class=\"line\">    <span class=\"comment\">//执行的第一个方法用于在执行后台任务前做一些UI操作  </span></div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPreExecute</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//第二个执行方法,在onPreExecute()后执行，用于后台任务,不可在此方法内修改UI</span></div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">doInBackground</span><span class=\"params\">(String... params)</span> </span>&#123;  </div><div class=\"line\">         <span class=\"comment\">//处理耗时操作</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"后台任务执行完毕\"</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">/*这个函数在doInBackground调用publishProgress(int i)时触发，虽然调用时只有一个参数  </span></div><div class=\"line\">    但是这里取到的是一个数组,所以要用progesss[0]来取值  </div><div class=\"line\">    第n个参数就用progress[n]来取值   */</div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onProgressUpdate</span><span class=\"params\">(Integer... progresses)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">//\"loading...\" + progresses[0] + \"%\"</span></div><div class=\"line\">        <span class=\"keyword\">super</span>.onProgressUpdate(progress);  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/*doInBackground返回时触发，换句话说，就是doInBackground执行完后触发  </span></div><div class=\"line\">    这里的result就是上面doInBackground执行后的返回值，所以这里是\"后台任务执行完毕\"  */</div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPostExecute</span><span class=\"params\">(String result)</span> </span>&#123; </div><div class=\"line\"></div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//onCancelled方法用于在取消执行中的任务时更改UI  </span></div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在主线程申明该类的对象，调用对象的execute（）函数开始执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyTask ｔ= <span class=\"keyword\">new</span> MyTask();</div><div class=\"line\">t.execute();<span class=\"comment\">//这里没有参数</span></div></pre></td></tr></table></figure>\n<h5 id=\"4-使用AsyncTask需要注意的地方\"><a href=\"#4-使用AsyncTask需要注意的地方\" class=\"headerlink\" title=\"4.使用AsyncTask需要注意的地方\"></a>4.使用AsyncTask需要注意的地方</h5><ul>\n<li><p>AsnycTask内部的Handler需要和主线程交互，所以AsyncTask的实例必须在UI线程中创建</p>\n</li>\n<li><p>AsyncTaskResult的doInBackground(mParams)方法执行异步任务运行在子线程中，其他方法运行在主线程中，可以操作UI组件。</p>\n</li>\n<li><p>一个AsyncTask任务只能被执行一次。</p>\n</li>\n<li><p>运行中可以随时调用AsnycTask对象的cancel(boolean)方法取消任务，如果成功，调用isCancelled()会返回true，并且不会执行 onPostExecute() 方法了，而是执行 onCancelled() 方法。</p>\n</li>\n<li><p>对于想要立即开始执行的异步任务，要么直接使用Thread，要么单独创建线程池提供给AsyncTask。默认的AsyncTask不一定会立即执行你的任务，除非你提供给他一个单独的线程池。如果不与主线程交互，直接创建一个Thread就可以了。</p>\n</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Handler是Android中用于线程间通信的机制。</p>\n<p>当程序第一次启动的时候，Android会同时启动一条主线程（ Main Thread）来负责处理与UI相关的事件，我们叫做UI线程。Android的UI操作并不是线程安全的（出于性能优化考虑），意味着如果多个线程并发操作UI线程，可能导致线程安全问题。为了解决Android应用多线程问题—Android平台只允许UI线程修改Activity里的UI，这样如果在主线程中执行耗时操作就会导致UI阻塞，若超过5秒就会造成ANR。</p>\n<p>因此我们需要另开线程来处理这些耗时操作，而处理的结果我们可能需要传给主线程用于UI更新，这是就需要线程间的通信。Handler即是Android中用于线程间通信的机制，现在市场一些android的线程通信框架基本上都是基于Handler实现的，如下文将要介绍的已经置于android源码中AsycTask，和现在比较流行的EventBus。</p>\n<h3 id=\"二-Handler的主要作用\"><a href=\"#二-Handler的主要作用\" class=\"headerlink\" title=\"二 Handler的主要作用\"></a>二 Handler的主要作用</h3><p>通过翻看的Handler的源码可知，Handler主要有两个作用。</p>\n<h5 id=\"1-线程延时\"><a href=\"#1-线程延时\" class=\"headerlink\" title=\"1.线程延时\"></a>1.线程延时</h5><p>Handler中内置了线程延时的方法：</p>\n<ul>\n<li>final boolean postAtTime(Runnable r, long uptimeMillis)</li>\n<li>final boolean postDelayed(Runnable r, long delayMillis)</li>\n</ul>\n<h5 id=\"2-线程通信\"><a href=\"#2-线程通信\" class=\"headerlink\" title=\"2.线程通信\"></a>2.线程通信</h5><p>主要步骤：</p>\n<ul>\n<li><p>在新启动的线程中发送消息<br>使用Handler对象的sendMessage()方法或者SendEmptyMessage()方法发送消息。   </p>\n</li>\n<li><p>在主线程中获取处理消息<br>重写Handler类中处理消息的方法（void handleMessage(Message msg)），当新启动的线程发送消息时，消息发送到与之关联的MessageQueue。而Hanlder不断地从MessageQueue中获取并处理消息。</p>\n</li>\n</ul>\n<h3 id=\"三-Handler与UI线程通信示例\"><a href=\"#三-Handler与UI线程通信示例\" class=\"headerlink\" title=\"三 Handler与UI线程通信示例\"></a>三 Handler与UI线程通信示例</h3><ul>\n<li>首先要进行Handler 申明，复写handleMessage方法( 放在主线程中)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> Handler handler = <span class=\"keyword\">new</span> Handler() &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// TODO 接收消息并且去更新UI线程上的控件内容</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (msg.what == UPDATE) &#123;</div><div class=\"line\">                <span class=\"comment\">// 更新界面上的textview</span></div><div class=\"line\">                tv.setText(String.valueOf(msg.obj));</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">super</span>.handleMessage(msg);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<ul>\n<li>子线程发送Message给ui线程表示自己任务已经执行完成，主线程可以做相应的操作了。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Thread() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                <span class=\"comment\">// TODO 子线程中通过handler发送消息给handler接收，由handler去更新TextView的值</span></div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                       <span class=\"comment\">//do something</span></div><div class=\"line\"></div><div class=\"line\">                        Message msg = <span class=\"keyword\">new</span> Message();</div><div class=\"line\">                        msg.what = UPDATE;                  </div><div class=\"line\">                        msg.obj = <span class=\"string\">\"更新后的值\"</span> ;</div><div class=\"line\">                        handler.sendMessage(msg);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;.start();</div></pre></td></tr></table></figure>\n<h3 id=\"四-Handler原理分析\"><a href=\"#四-Handler原理分析\" class=\"headerlink\" title=\"四 Handler原理分析\"></a>四 Handler原理分析</h3><h5 id=\"1-Handler的构造函数\"><a href=\"#1-Handler的构造函数\" class=\"headerlink\" title=\"1.Handler的构造函数\"></a>1.Handler的构造函数</h5><ol>\n<li>public　Handler() </li>\n<li>public　Handler(Callbackcallback)</li>\n<li>public　Handler(Looperlooper)</li>\n<li>public　Handler(Looperlooper, Callbackcallback) </li>\n</ol>\n<ul>\n<li>第1个和第2个构造函数都没有传递Looper，这两个构造函数都将通过调用Looper.myLooper()获取当前线程绑定的Looper对象，然后将该Looper对象保存到名为mLooper的成员字段中。 　<br>下面来看1,2个函数源码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(callback, <span class=\"keyword\">false</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//他们会调用Handler的内部构造方法</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class=\"line\">  <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();</div><div class=\"line\">  <span class=\"keyword\">if</span> ((klass.isAnonymousClass() ||klass.isMemberClass()</div><div class=\"line\">     || klass.isLocalClass()) &amp;&amp;</div><div class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            Log.w(TAG, <span class=\"string\">\"The following Handler class should be static or leaks might occur: \"</span> +</div><div class=\"line\">                klass.getCanonicalName());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> <span class=\"comment\">/************************************</div><div class=\"line\">    mLooper = Looper.myLooper();</div><div class=\"line\">    if (mLooper == null) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">            \"Can't create handler inside thread that has not called Looper.prepare()\");</div><div class=\"line\">    &#125;</div><div class=\"line\">    mQueue = mLooper.mQueue;</div><div class=\"line\">    mCallback = callback;</div><div class=\"line\">    mAsynchronous = async;</div><div class=\"line\">&#125;</span></div></pre></td></tr></table></figure>\n<p>通过Looper.myLooper()获取了当前线程保存的Looper实例，又通过这个Looper实例获取了其中保存的MessageQueue（消息队列）。每个Handler 对应一个Looper对象，产生一个MessageQueue</p>\n<ul>\n<li>第3个和第4个构造函数传递了Looper对象，这两个构造函数会将该Looper保存到名为mLooper的成员字段中。 　<br>下面来看3、4个函数源码： </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Looper looper)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">this</span>(looper, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\"> &#125;　</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Looper looper, Callback callback)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">this</span>(looper, callback, <span class=\"keyword\">false</span>);</div><div class=\"line\"> &#125;</div><div class=\"line\"><span class=\"comment\">//他们会调用Handler的内部构造方法</span></div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Looper looper, Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</div><div class=\"line\">     mLooper = looper;</div><div class=\"line\">     mQueue = looper.mQueue;</div><div class=\"line\">     mCallback = callback;</div><div class=\"line\">     mAsynchronous = async;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第2个和第4个构造函数还传递了Callback对象，Callback是Handler中的内部接口，需要实现其内部的handleMessage方法，Callback代码如下:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callback</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> More ...handleMessage(Message msg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Handler.Callback是用来处理Message的一种手段，如果没有传递该参数，那么就应该重写Handler的handleMessage方法，也就是说为了使得Handler能够处理Message，我们有两种办法： 　　 </p>\n<p>　</p>\n<ol>\n<li>向Hanlder的构造函数传入一个Handler.Callback对象，并实现Handler.Callback的handleMessage方法  　    </li>\n<li>无需向Hanlder的构造函数传入Handler.Callback对象，但是需要重写Handler本身的handleMessage方法 　</li>\n</ol>\n<p>也就是说无论哪种方式，我们都得通过某种方式实现handleMessage方法，这点与Java中对Thread的设计有异曲同工之处。</p>\n<h5 id=\"Handler发送消息的几个方法的源码\"><a href=\"#Handler发送消息的几个方法的源码\" class=\"headerlink\" title=\"Handler发送消息的几个方法的源码\"></a>Handler发送消息的几个方法的源码</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessage</span><span class=\"params\">(Message msg)</span></div><div class=\"line\">   </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> sendMessageDelayed(msg, <span class=\"number\">0</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendEmptyMessageDelayed</span><span class=\"params\">(<span class=\"keyword\">int</span> what, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</div><div class=\"line\">       Message msg = Message.obtain();</div><div class=\"line\">       msg.what = what;</div><div class=\"line\">       <span class=\"keyword\">return</span> sendMessageDelayed(msg, delayMillis);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageDelayed</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> delayMillis)</span></div><div class=\"line\">   </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (delayMillis &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">           delayMillis = <span class=\"number\">0</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</div><div class=\"line\">       MessageQueue queue = mQueue;</div><div class=\"line\">       <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</div><div class=\"line\">                   <span class=\"keyword\">this</span> + <span class=\"string\">\" sendMessageAtTime() called with no mQueue\"</span>);</div><div class=\"line\">           Log.w(<span class=\"string\">\"Looper\"</span>, e.getMessage(), e);</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>我们可以看出他们最后都调用了sendMessageAtTime（），然后返回了enqueueMessage方法，下面看一下此方法源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(MessageQueue queue, Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</div><div class=\"line\">　　　　　　<span class=\"comment\">//把当前的handler作为msg的target属性</span></div><div class=\"line\">    msg.target = <span class=\"keyword\">this</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mAsynchronous) &#123;</div><div class=\"line\">        msg.setAsynchronous(<span class=\"keyword\">true</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在该方法中有两件事需要注意： </p>\n<ul>\n<li>msg.target = this<br>该代码将Message的target绑定为当前的Handler</li>\n<li>queue.enqueueMessage<br>变量queue表示的是Handler所绑定的消息队列MessageQueue，通过调用queue.enqueueMessage(msg, uptimeMillis)我们将Message放入到消息队列中。</li>\n</ul>\n<h3 id=\"五-Looper原理分析\"><a href=\"#五-Looper原理分析\" class=\"headerlink\" title=\"五 Looper原理分析\"></a>五 Looper原理分析</h3><p>我们一般在主线程申明Handler，有时我们需要继承Thread类实现自己的线程功能，当我们在里面申明Handler的时候会报错。其原因是主线程中已经实现了两个重要的Looper方法，下面看一看ActivityThread.java中main方法的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">//......省略</span></div><div class=\"line\">        Looper.prepareMainLooper();<span class=\"comment\">//&gt;</span></div><div class=\"line\"></div><div class=\"line\">        ActivityThread thread = <span class=\"keyword\">new</span> ActivityThread();</div><div class=\"line\">        thread.attach(<span class=\"keyword\">false</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (sMainThreadHandler == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            sMainThreadHandler = thread.getHandler();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        AsyncTask.init();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">false</span>) &#123;</div><div class=\"line\">            Looper.myLooper().setMessageLogging(<span class=\"keyword\">new</span></div><div class=\"line\">   LogPrinter(Log.DEBUG, <span class=\"string\">\"ActivityThread\"</span>));</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Looper.loop();<span class=\"comment\">//&gt;</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Main thread loop unexpectedly exited\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先看prepare()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    prepare(<span class=\"keyword\">true</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</div><div class=\"line\">　　　　　<span class=\"comment\">//证了一个线程中只有一个Looper实例</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>该方法会调用Looper构造函数同时实例化出MessageQueue和当前thread.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</div><div class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);</div><div class=\"line\">    mThread = Thread.currentThread();</div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> MessageQueue <span class=\"title\">myQueue</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> myLooper().mQueue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>prepare()方法中通过ThreadLocal对象实现Looper实例与线程的绑定。</p>\n<p>再看loop()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();</div><div class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</div><div class=\"line\"></div><div class=\"line\">    Binder.clearCallingIdentity();</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ident = Binder.clearCallingIdentity();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// might block</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           </div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Printer logging = me.mLogging;</div><div class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            logging.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt; Dispatching to \"</span> + msg.target + <span class=\"string\">\" \"</span> +</div><div class=\"line\">                    msg.callback + <span class=\"string\">\": \"</span> + msg.what);</div><div class=\"line\">        &#125;</div><div class=\"line\">   <span class=\"comment\">//重点****</span></div><div class=\"line\">        msg.target.dispatchMessage(msg);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            logging.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt; Finished to \"</span> + msg.target + <span class=\"string\">\" \"</span> + msg.callback);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// identity of the thread wasn't corrupted.</span></div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> newIdent = Binder.clearCallingIdentity();</div><div class=\"line\">        <span class=\"keyword\">if</span> (ident != newIdent) &#123;</div><div class=\"line\">            Log.wtf(TAG, <span class=\"string\">\"Thread identity changed from 0x\"</span></div><div class=\"line\">                    + Long.toHexString(ident) + <span class=\"string\">\" to 0x\"</span></div><div class=\"line\">                    + Long.toHexString(newIdent) + <span class=\"string\">\" while dispatching to \"</span></div><div class=\"line\">                    + msg.target.getClass().getName() + <span class=\"string\">\" \"</span></div><div class=\"line\">                    + msg.callback + <span class=\"string\">\" what=\"</span> + msg.what);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        msg.recycleUnchecked();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先looper对象不能为空，就是说loop()方法调用必须在prepare()方法的后面。</p>\n<p>Looper一直在不断的从消息队列中通过MessageQueue的next方法获取Message，然后通过代码msg.target.dispatchMessage(msg)让该msg所绑定的Handler（Message.target）执行dispatchMessage方法以实现对Message的处理。 </p>\n<p>Handler的dispatchMessage的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">         handleCallback(msg);</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">             <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class=\"line\">                 <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        handleMessage(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以看到Handler提供了三种途径处理Message，而且处理有前后优先级之分：首先尝试让postXXX中传递的Runnable执行，其次尝试让Handler构造函数中传入的Callback的handleMessage方法处理，最后才是让Handler自身的handleMessage方法处理Message。</p>\n<h3 id=\"六-如何在子线程中使用Handler\"><a href=\"#六-如何在子线程中使用Handler\" class=\"headerlink\" title=\"六 如何在子线程中使用Handler\"></a>六 如何在子线程中使用Handler</h3><p>Handler本质是从当前的线程中获取到Looper来监听和操作MessageQueue，当其他线程执行完成后回调当前线程。</p>\n<p>子线程需要先prepare（）才能获取到Looper的，是因为在子线程只是一个普通的线程，其ThreadLoacl中没有设置过Looper，所以会抛出异常，而在Looper的prepare（）方法中sThreadLocal.set(new Looper())是设置了Looper的。</p>\n<p>示例代码：</p>\n<p>定义一个类实现Runnable接口或继承Thread类（一般不继承）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rub</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">public</span> Handler myHandler;  </div><div class=\"line\">        <span class=\"comment\">// 实现Runnable接口的线程体 </span></div><div class=\"line\">        <span class=\"meta\">@Override</span>  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">         <span class=\"comment\">/*①、调用Looper的prepare()方法为当前线程创建Looper对象并，</div><div class=\"line\">          创建Looper对象时，它的构造器会自动的创建相对应的MessageQueue*/</span></div><div class=\"line\">            Looper.prepare();  </div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">/*.②、创建Handler子类的实例，重写HandleMessage()方法，该方法处理除当前线程以外线程的消息*/</span></div><div class=\"line\">             myHandler = <span class=\"keyword\">new</span> Handler() &#123;  </div><div class=\"line\">                <span class=\"meta\">@Override</span>  </div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;  </div><div class=\"line\">                    String ms = <span class=\"string\">\"\"</span>;  </div><div class=\"line\">                    <span class=\"keyword\">if</span> (msg.what == <span class=\"number\">0x777</span>) &#123;  </div><div class=\"line\"></div><div class=\"line\">                    &#125;  </div><div class=\"line\">                &#125;  </div><div class=\"line\"></div><div class=\"line\">            &#125;;  </div><div class=\"line\">            <span class=\"comment\">//③、调用Looper的loop()方法来启动Looper让消息队列转动起来</span></div><div class=\"line\">            Looper.loop();  </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>注意分成三步：</p>\n<ul>\n<li>调用Looper的prepare()方法为当前线程创建Looper对象，创建Looper对象时，它的构造器会创建与之配套的MessageQueue。 　</li>\n<li>有了Looper之后，创建Handler子类实例，重写HanderMessage()方法，该方法负责处理来自于其他线程的消息。</li>\n<li>调用Looper的looper()方法启动Looper。然后使用这个handler实例在任何其他线程中发送消息，最终处理消息的代码都会在你创建Handler实例的线程中运行。</li>\n</ul>\n<h3 id=\"七-Handler总结\"><a href=\"#七-Handler总结\" class=\"headerlink\" title=\"七 Handler总结\"></a>七 Handler总结</h3><ul>\n<li><p>Handler：<br>发送和处理消息，它把消息发送给Looper管理的MessageQueue，并负责处理Looper分发给它的消息。</p>\n</li>\n<li><p>Message：<br>Handler接收和处理的消息对象。</p>\n</li>\n<li><p>Looper：<br>每个线程只有一个Looper，它负责管理对应的MessageQueue，会不断地从MessageQueue取出消息，并将消息分给对应的Hanlder处理。主线程中，系统已经初始化了一个Looper对象，因此可以直接创建Handler即可，就可以通过Handler来发送消息、处理消息。若是在子线程，必须手动创建一个Looper对象，并启动它，调用Looper.prepare()方法。</p>\n</li>\n<li><p>prapare()：<br>保证每个线程最多只有一个Looper对象。</p>\n</li>\n<li><p>looper()：<br>启动Looper，使用一个死循环不断取出MessageQueue中的消息，并将取出的消息分给对应的Handler进行处理。 　</p>\n</li>\n<li><p>MessageQueue：<br>由Looper负责管理，它采用先进先出的方式来管理Message。Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue想关联。Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。</p>\n</li>\n</ul>\n<h3 id=\"八-Android中另一个线程通信机制AsycTask\"><a href=\"#八-Android中另一个线程通信机制AsycTask\" class=\"headerlink\" title=\"八 Android中另一个线程通信机制AsycTask\"></a>八 Android中另一个线程通信机制AsycTask</h3><h5 id=\"1-AsycTask简介\"><a href=\"#1-AsycTask简介\" class=\"headerlink\" title=\"1.AsycTask简介\"></a>1.AsycTask简介</h5><p>AsycTask是Android中另一个处理异步任务的机制，我们上面说了可以用Handler来处理异步任务，但如果耗时的操作太多，那么我们需要开启太多的子线程，这就会给系统带来巨大的负担，随之也会带来性能方面的问题。在这种情况下我们就可以考虑使用类AsyncTask来异步执行任务，不需要子线程和handler，就可以完成异步操作和刷新UI。</p>\n<p>AsyncTask主要有二个部分：一个是与主线程的交互，另一个就是线程的管理调度。虽然可能多个AsyncTask的子类的实例，但是AsyncTask的内部Handler和ThreadPoolExecutor都是进程范围内共享的，其都是static的（所以AsycTask是串行的，不支持并发），也即属于类的，类的属性的作用范围是CLASSPATH，因为一个进程一个VM，所以是AsyncTask控制着进程范围内所有的子类实例。AsyncTask内部会创建一个进程作用域的线程池来管理要运行的任务，也就就是说当你调用了AsyncTask的execute()方法后，AsyncTask会把任务交给线程池，由线程池来管理创建Thread和运行Therad。</p>\n<p>Android的AsyncTask比Handler更轻量级一些（只是代码上轻量一些，而实际上要比handler更耗资源），适用于简单的异步处理。</p>\n<p>注意：不要随意使用AsyncTask,除非你必须要与UI线程交互.默认情况下使用Thread即可,要注意需要将线程优先级调低.AsyncTask适合处理短时间的操作,长时间的操作,比如下载一个很大的视频,这就需要你使用自己的线程来下载,不管是断点下载还是其它的.</p>\n<h5 id=\"2-AsycTask使用步骤\"><a href=\"#2-AsycTask使用步骤\" class=\"headerlink\" title=\"2.AsycTask使用步骤\"></a>2.AsycTask使用步骤</h5><p>AsyncTask对线程间的通讯做了包装，使后台线程和UI线程可以简易通讯。后台线程执行异步任务，将result告知UI线程。</p>\n<p>使用AsycTask分为两步：</p>\n<ul>\n<li>继承AsyncTask类实现自己的类    </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncTask</span>&lt;<span class=\"title\">Params</span>, <span class=\"title\">Progress</span>, <span class=\"title\">Result</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/* Params: 输入参数，对应excute()方法中传递的参数。如果不需要传递参数，则直接设为void即可。</div><div class=\"line\"></div><div class=\"line\">    ** Progress：后台任务执行的百分比</div><div class=\"line\"></div><div class=\"line\">    ** Result：返回值类型，和doInBackground（）方法的返回值类型保持一致。*/</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>复写方法</li>\n</ul>\n<p>最少要重写以下这两个方法：</p>\n<p><strong>a.</strong>doInBackground(Params…)<br>在子线程（其他方法都在主线程执行）中执行比较耗时的操作，不能更新ＵＩ，可以在该方法中调用publishProgress(Progress…)来更新任务的进度。Progress方法是AsycTask中一个final方法只能调用不能重写。</p>\n<p><strong>b.</strong>onPostExecute(Result)<br>使用在doInBackground 得到的结果处理操作UI， 在主线程执行，任务执行的结果作为此方法的参数返回。</p>\n<p>有时根据需求还要实现以下三个方法：</p>\n<p><strong>c.</strong>onProgressUpdate(Progress…)<br>可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。</p>\n<p><strong>d.</strong>onPreExecute()<br>这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。  </p>\n<p><strong>e.</strong>onCancelled()<br>用户调用取消时，要做的操作</p>\n<h5 id=\"3-AsycTask使用示例\"><a href=\"#3-AsycTask使用示例\" class=\"headerlink\" title=\"3.AsycTask使用示例\"></a>3.AsycTask使用示例</h5><p>按照上面的步骤定义自己的异步类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">AsyncTask</span>&lt;<span class=\"title\">String</span>, <span class=\"title\">Integer</span>, <span class=\"title\">String</span>&gt; </span>&#123;  </div><div class=\"line\">    <span class=\"comment\">//执行的第一个方法用于在执行后台任务前做一些UI操作  </span></div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPreExecute</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//第二个执行方法,在onPreExecute()后执行，用于后台任务,不可在此方法内修改UI</span></div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">doInBackground</span><span class=\"params\">(String... params)</span> </span>&#123;  </div><div class=\"line\">         <span class=\"comment\">//处理耗时操作</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"后台任务执行完毕\"</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">/*这个函数在doInBackground调用publishProgress(int i)时触发，虽然调用时只有一个参数  </div><div class=\"line\">    但是这里取到的是一个数组,所以要用progesss[0]来取值  </div><div class=\"line\">    第n个参数就用progress[n]来取值   */</span></div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onProgressUpdate</span><span class=\"params\">(Integer... progresses)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">//\"loading...\" + progresses[0] + \"%\"</span></div><div class=\"line\">        <span class=\"keyword\">super</span>.onProgressUpdate(progress);  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/*doInBackground返回时触发，换句话说，就是doInBackground执行完后触发  </div><div class=\"line\">    这里的result就是上面doInBackground执行后的返回值，所以这里是\"后台任务执行完毕\"  */</span></div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPostExecute</span><span class=\"params\">(String result)</span> </span>&#123; </div><div class=\"line\"></div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//onCancelled方法用于在取消执行中的任务时更改UI  </span></div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在主线程申明该类的对象，调用对象的execute（）函数开始执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyTask ｔ= <span class=\"keyword\">new</span> MyTask();</div><div class=\"line\">t.execute();<span class=\"comment\">//这里没有参数</span></div></pre></td></tr></table></figure>\n<h5 id=\"4-使用AsyncTask需要注意的地方\"><a href=\"#4-使用AsyncTask需要注意的地方\" class=\"headerlink\" title=\"4.使用AsyncTask需要注意的地方\"></a>4.使用AsyncTask需要注意的地方</h5><ul>\n<li><p>AsnycTask内部的Handler需要和主线程交互，所以AsyncTask的实例必须在UI线程中创建</p>\n</li>\n<li><p>AsyncTaskResult的doInBackground(mParams)方法执行异步任务运行在子线程中，其他方法运行在主线程中，可以操作UI组件。</p>\n</li>\n<li><p>一个AsyncTask任务只能被执行一次。</p>\n</li>\n<li><p>运行中可以随时调用AsnycTask对象的cancel(boolean)方法取消任务，如果成功，调用isCancelled()会返回true，并且不会执行 onPostExecute() 方法了，而是执行 onCancelled() 方法。</p>\n</li>\n<li><p>对于想要立即开始执行的异步任务，要么直接使用Thread，要么单独创建线程池提供给AsyncTask。默认的AsyncTask不一定会立即执行你的任务，除非你提供给他一个单独的线程池。如果不与主线程交互，直接创建一个Thread就可以了。</p>\n</li>\n</ul>\n"},{"title":"android基础之Intents与Intent Filters","date":"2017-02-27T06:32:09.000Z","_content":"\n### 一 概述\n\nIntent是Android中组件之间传递消息的一种机制，这个组件可以是同一个应用程序的，也可以是不同的应用程序。Android四大组件中除了ContentProvider，其余三者皆可通过Intent来传递数据。而且Intent是一种运行时绑定机制。\n\nIntent在Android的三个组件中传递的机制是不同的：\n\n- 使用Context.startActivity() 或 Activity.startActivityForResult()，传入一个intent来启动一个activity。使用 Activity.setResult()，传入一个intent来从activity中返回结果。\n- 将intent对象传给Context.startService()来启动一个service或者传消息给一个运行的service。将intent对象传给 Context.bindService()来绑定一个service。\n- 将intent对象传给 Context.sendBroadcast()，Context.sendOrderedBroadcast()，或者Context.sendStickyBroadcast()等广播方法，则它们被传给 broadcast receiver。\n\n### 二 Intent的结构\n\nIntent主要包含以下属性：\n\n- component(组件)：目的组件    \nComponent属性明确指定Intent的目标组件的类名称。（属于直接Intent）。组件的名字通过函数setComponent()、setClass()、setClassName()设置，通过函数读取getComponent()。   \n\n- action（动作）：用来表现意图的行动  \nAction主要用来描述应用程序的组件，一个组件可以用于多个action，也可以多个组件拥有同一个action。\n\n\n- category（类别）：用来表现动作的类别     \ncategory通常和Action放在一起用的，用于描述这个action。一个action可以包含多个categoty，必须所有的categoty都匹配成功才算是与这个action匹配成功。如果一个action只有一个默认的categoty DEFAULT，则不需向Intent中添加categoty，系统会自动添加。addCategory() 放置一个intent里的类别，removeCategory()删除之前添加的，getCategories()获取当前所有的类别。      \n类别越多，动作越具体，意图越明确    \n\n\n- data（数据）：表示与动作要操纵的数据      \nData属性是Android要访问的数据，和action和Category声明方式相同，也是在<intent-filter>中。多个组件匹配成功显示优先级高的； 相同显示列表。Data是用一个uri对象来表示的，uri代表数据的地址，属于一种标识符。通常情况下，我们使用action+data属性的组合来描述一个意图：做什么    \n\n\n- type（数据类型）：对于data范例的描写     \n如果Intent对象中既包含Uri又包含Type，那么，在<intent-filter>中也必须二者都包含才能通过测试。Type属性用于明确指定Data属性的数据类型或MIME类型，但是通常来说，当Intent不指定Data属性时，Type属性才会起作用，否则Android系统将会根据Data属性值来分析数据的类型，所以无需指定Type属性。data和type属性一般只需要一个，通过setData方法会把type属性设置为null，相反设置setType方法会把data设置为null，如果想要两个属性同时设置，要使用Intent.setDataAndType()方法    \n\n\n- extras（扩展信息）：扩展信息     \n是其它所有附加信息的集合。以键值对的形式放入Intent中    \n\n\n- Flags（标志位）：期望这个意图的运行模式      \n用于指定Activity与task之间的关系。\n\n### 三 Intent发现组件的两种方式\n   \nIntent启动组件有两种方式：显示启动和隐式启动。\n\n上面Intent的Intent的7个属性中，只有component属于显示启动，action，category，data皆为隐式启动。\n\n##### 1.显示启动\n\n代码示例：\n\n```java\n    button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  //创建一个意图对象\n                  Intent intent = new Intent();\n                  //创建组件，通过组件来响应\n                  ComponentName component = new ComponentName(MainActivity.this, SecondActivity.class);\n                  intent.setComponent(component);                \n                  startActivity(intent);                \n             }\n         });\n```\n\n如果写的简单一点，监听事件onClick()方法里可以这样写：\n\n```java\n      Intent intent = new Intent();\n      //setClass函数的第一个参数是一个Context对象\n      //Context是一个类，Activity是Context类的子类，也就是说，所有的Activity对象，都可以向上转型为Context对象\n      //setClass函数的第二个参数是一个Class对象，在当前场景下，应该传入需要被启动的Activity类的class对象\n      intent.setClass(MainActivity.this, SecondActivity.class);\n      startActivity(intent);    \n```\n\n再简单一点，可以这样写：（当然，也是最常见的写法）\n\n```java\n                 Intent intent = new Intent(MainActivity.this,SecondActivity.class);\n                 startActivity(intent);\n```\n\n##### 2.隐式启动\n\n- action\n\n在Androidmanifest.xml中定义\n\n```java\n         <activity \n             android:name=\".SecondActivity\">\n             <intent-filter>\n                  <action android:name=\"com.example.smyh006intent01.MY_ACTION\"/>\n                  <category android:name=\"android.intent.category.DEFAULT\" />\n             </intent-filter>            \n         </activity>\n```\n\njava代码调用\n\n```java\n          button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  //启动另一个Activity，（通过action属性进行查找）\n                  Intent intent = new Intent();\n                  //设置动作（实际action属性就是一个字符串标记而已）\n                  intent.setAction(\"com.example.smyh006intent01.MY_ACTION\"); //方法：Intent android.content.Intent.setAction(String action)\n                  startActivity(intent);        \n              }\n         });\n```\n\n上面代码也可简写成\n\n```java\n         button1.setOnClickListener(new OnClickListener() {            \n             @Override\n             public void onClick(View v) {\n                 //启动另一个Activity，（通过action属性进行查找）\n                 Intent intent = new Intent(\"com.example.smyh006intent01.MY_ACTION\");//方法： android.content.Intent.Intent(String action)                \n                 startActivity(intent);        \n             }\n         });\n```\n\n- action+categoty\n\nAndroidmanifest.xml文件：\n\n```java\n         <activity\n             android:name=\".SecondActivity\">\n             <intent-filter>\n                  <action android:name=\"com.example.smyh006intent01.MY_ACTION\"/>\n                  <category android:name=\"android.intent.category.DEFAULT\" />\n                  <category android:name=\"com.example.smyh006intent01.MY_CATEGORY\" />\n             </intent-filter>            \n         </activity>\n```\n\njava文件中：\n\n```java\n         button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  //启动另一个Activity，（通过action属性进行查找）\n                  Intent intent = new Intent();\n                  //设置动作（实际action属性就是一个字符串标记而已）\n                  intent.setAction(\"com.example.smyh006intent01.MY_ACTION\"); //方法：Intent android.content.Intent.setAction(String action)\n                  intent.addCategory(\"com.example.smyh006intent01.MY_CATEGORY\");\n                  startActivity(intent);        \n             }\n         });\n```\n\n- action+data\n\n示例：打开指定网页\n\n```java\n         <activity \n             android:name=\".SecondActivity\">\n             <intent-filter>\n                  <action android:name=\"android.intent.action.VIEW\" />\n                  <category android:name=\"android.intent.category.DEFAULT\" />\n                  <data android:scheme=\"http\" android:host=\"www.baidu.com\"/>                 \n             </intent-filter>            \n         </activity>\n```\n\njava文件中：\n\n```java\n          button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  Intent intent = new Intent();\n                  intent.setAction(Intent.ACTION_VIEW);\n                  Uri data = Uri.parse(\"http://www.baidu.com\");\n                  intent.setData(data);                \n                  startActivity(intent);        \n              }\n         });\n```\n\n上面代码也可简写成：\n\n```java\n         button1.setOnClickListener(new OnClickListener() {            \n             @Override\n             public void onClick(View v) {\n                 Intent intent = new Intent(Intent.ACTION_VIEW);\n                 intent.setData(Uri.parse(\"http://www.baidu.com\"));                \n                 startActivity(intent);        \n             }\n         });\n```\n\n### 四 IntentFilter\n\nIntentFilter用于与Intent中的数据对比，来挑选出符合条件的组件。它分为静态注册（推荐）和动态注册两种方式。Intent与IntentFilter比较的步骤如下：\n\n1. 加载安装所有的IntentFilter到一个列表中\n2. 剔除所有action匹配失败的IntentFilter\n3. 剔除URI数据匹配失败的IntentFilter\n4. 剔除category匹配失败的IntentFilter\n5. 剩下的IntentFilter是否为0。是，查找失败，抛出异常；否将剩下的IntentFilter按优先级排列，返回优先级最高的IntentFilter\n\n代码示例：\n\n静态注册\n\n```java\n<receiver android:name=\".MyBroadCastReceiver\">  \n            <!-- android:priority属性是设置此接收者的优先级（从-1000到1000） -->\n            <intent-filter android:priority=\"20\">\n            <actionandroid:name=\"android.provider.Telephony.SMS_RECEIVED\"/>  \n            </intent-filter>  \n</receiver>\n```\n\n动态注册\n\n```java\nIntentFilter intentFilter = new IntentFilter(\"android.provider.Telephony.SMS_RECEIVED\");\n```\n\n\n### 五 总结","source":"_posts/android基础之Intents与Intent-Filters.md","raw":"---\ntitle: android基础之Intents与Intent Filters\ndate: 2017-02-27 14:32:09\ncategories: android\ntags:\n- android\n- java\n- Intent\n- IntentFilter\n---\n\n### 一 概述\n\nIntent是Android中组件之间传递消息的一种机制，这个组件可以是同一个应用程序的，也可以是不同的应用程序。Android四大组件中除了ContentProvider，其余三者皆可通过Intent来传递数据。而且Intent是一种运行时绑定机制。\n\nIntent在Android的三个组件中传递的机制是不同的：\n\n- 使用Context.startActivity() 或 Activity.startActivityForResult()，传入一个intent来启动一个activity。使用 Activity.setResult()，传入一个intent来从activity中返回结果。\n- 将intent对象传给Context.startService()来启动一个service或者传消息给一个运行的service。将intent对象传给 Context.bindService()来绑定一个service。\n- 将intent对象传给 Context.sendBroadcast()，Context.sendOrderedBroadcast()，或者Context.sendStickyBroadcast()等广播方法，则它们被传给 broadcast receiver。\n\n### 二 Intent的结构\n\nIntent主要包含以下属性：\n\n- component(组件)：目的组件    \nComponent属性明确指定Intent的目标组件的类名称。（属于直接Intent）。组件的名字通过函数setComponent()、setClass()、setClassName()设置，通过函数读取getComponent()。   \n\n- action（动作）：用来表现意图的行动  \nAction主要用来描述应用程序的组件，一个组件可以用于多个action，也可以多个组件拥有同一个action。\n\n\n- category（类别）：用来表现动作的类别     \ncategory通常和Action放在一起用的，用于描述这个action。一个action可以包含多个categoty，必须所有的categoty都匹配成功才算是与这个action匹配成功。如果一个action只有一个默认的categoty DEFAULT，则不需向Intent中添加categoty，系统会自动添加。addCategory() 放置一个intent里的类别，removeCategory()删除之前添加的，getCategories()获取当前所有的类别。      \n类别越多，动作越具体，意图越明确    \n\n\n- data（数据）：表示与动作要操纵的数据      \nData属性是Android要访问的数据，和action和Category声明方式相同，也是在<intent-filter>中。多个组件匹配成功显示优先级高的； 相同显示列表。Data是用一个uri对象来表示的，uri代表数据的地址，属于一种标识符。通常情况下，我们使用action+data属性的组合来描述一个意图：做什么    \n\n\n- type（数据类型）：对于data范例的描写     \n如果Intent对象中既包含Uri又包含Type，那么，在<intent-filter>中也必须二者都包含才能通过测试。Type属性用于明确指定Data属性的数据类型或MIME类型，但是通常来说，当Intent不指定Data属性时，Type属性才会起作用，否则Android系统将会根据Data属性值来分析数据的类型，所以无需指定Type属性。data和type属性一般只需要一个，通过setData方法会把type属性设置为null，相反设置setType方法会把data设置为null，如果想要两个属性同时设置，要使用Intent.setDataAndType()方法    \n\n\n- extras（扩展信息）：扩展信息     \n是其它所有附加信息的集合。以键值对的形式放入Intent中    \n\n\n- Flags（标志位）：期望这个意图的运行模式      \n用于指定Activity与task之间的关系。\n\n### 三 Intent发现组件的两种方式\n   \nIntent启动组件有两种方式：显示启动和隐式启动。\n\n上面Intent的Intent的7个属性中，只有component属于显示启动，action，category，data皆为隐式启动。\n\n##### 1.显示启动\n\n代码示例：\n\n```java\n    button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  //创建一个意图对象\n                  Intent intent = new Intent();\n                  //创建组件，通过组件来响应\n                  ComponentName component = new ComponentName(MainActivity.this, SecondActivity.class);\n                  intent.setComponent(component);                \n                  startActivity(intent);                \n             }\n         });\n```\n\n如果写的简单一点，监听事件onClick()方法里可以这样写：\n\n```java\n      Intent intent = new Intent();\n      //setClass函数的第一个参数是一个Context对象\n      //Context是一个类，Activity是Context类的子类，也就是说，所有的Activity对象，都可以向上转型为Context对象\n      //setClass函数的第二个参数是一个Class对象，在当前场景下，应该传入需要被启动的Activity类的class对象\n      intent.setClass(MainActivity.this, SecondActivity.class);\n      startActivity(intent);    \n```\n\n再简单一点，可以这样写：（当然，也是最常见的写法）\n\n```java\n                 Intent intent = new Intent(MainActivity.this,SecondActivity.class);\n                 startActivity(intent);\n```\n\n##### 2.隐式启动\n\n- action\n\n在Androidmanifest.xml中定义\n\n```java\n         <activity \n             android:name=\".SecondActivity\">\n             <intent-filter>\n                  <action android:name=\"com.example.smyh006intent01.MY_ACTION\"/>\n                  <category android:name=\"android.intent.category.DEFAULT\" />\n             </intent-filter>            \n         </activity>\n```\n\njava代码调用\n\n```java\n          button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  //启动另一个Activity，（通过action属性进行查找）\n                  Intent intent = new Intent();\n                  //设置动作（实际action属性就是一个字符串标记而已）\n                  intent.setAction(\"com.example.smyh006intent01.MY_ACTION\"); //方法：Intent android.content.Intent.setAction(String action)\n                  startActivity(intent);        \n              }\n         });\n```\n\n上面代码也可简写成\n\n```java\n         button1.setOnClickListener(new OnClickListener() {            \n             @Override\n             public void onClick(View v) {\n                 //启动另一个Activity，（通过action属性进行查找）\n                 Intent intent = new Intent(\"com.example.smyh006intent01.MY_ACTION\");//方法： android.content.Intent.Intent(String action)                \n                 startActivity(intent);        \n             }\n         });\n```\n\n- action+categoty\n\nAndroidmanifest.xml文件：\n\n```java\n         <activity\n             android:name=\".SecondActivity\">\n             <intent-filter>\n                  <action android:name=\"com.example.smyh006intent01.MY_ACTION\"/>\n                  <category android:name=\"android.intent.category.DEFAULT\" />\n                  <category android:name=\"com.example.smyh006intent01.MY_CATEGORY\" />\n             </intent-filter>            \n         </activity>\n```\n\njava文件中：\n\n```java\n         button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  //启动另一个Activity，（通过action属性进行查找）\n                  Intent intent = new Intent();\n                  //设置动作（实际action属性就是一个字符串标记而已）\n                  intent.setAction(\"com.example.smyh006intent01.MY_ACTION\"); //方法：Intent android.content.Intent.setAction(String action)\n                  intent.addCategory(\"com.example.smyh006intent01.MY_CATEGORY\");\n                  startActivity(intent);        \n             }\n         });\n```\n\n- action+data\n\n示例：打开指定网页\n\n```java\n         <activity \n             android:name=\".SecondActivity\">\n             <intent-filter>\n                  <action android:name=\"android.intent.action.VIEW\" />\n                  <category android:name=\"android.intent.category.DEFAULT\" />\n                  <data android:scheme=\"http\" android:host=\"www.baidu.com\"/>                 \n             </intent-filter>            \n         </activity>\n```\n\njava文件中：\n\n```java\n          button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  Intent intent = new Intent();\n                  intent.setAction(Intent.ACTION_VIEW);\n                  Uri data = Uri.parse(\"http://www.baidu.com\");\n                  intent.setData(data);                \n                  startActivity(intent);        \n              }\n         });\n```\n\n上面代码也可简写成：\n\n```java\n         button1.setOnClickListener(new OnClickListener() {            \n             @Override\n             public void onClick(View v) {\n                 Intent intent = new Intent(Intent.ACTION_VIEW);\n                 intent.setData(Uri.parse(\"http://www.baidu.com\"));                \n                 startActivity(intent);        \n             }\n         });\n```\n\n### 四 IntentFilter\n\nIntentFilter用于与Intent中的数据对比，来挑选出符合条件的组件。它分为静态注册（推荐）和动态注册两种方式。Intent与IntentFilter比较的步骤如下：\n\n1. 加载安装所有的IntentFilter到一个列表中\n2. 剔除所有action匹配失败的IntentFilter\n3. 剔除URI数据匹配失败的IntentFilter\n4. 剔除category匹配失败的IntentFilter\n5. 剩下的IntentFilter是否为0。是，查找失败，抛出异常；否将剩下的IntentFilter按优先级排列，返回优先级最高的IntentFilter\n\n代码示例：\n\n静态注册\n\n```java\n<receiver android:name=\".MyBroadCastReceiver\">  \n            <!-- android:priority属性是设置此接收者的优先级（从-1000到1000） -->\n            <intent-filter android:priority=\"20\">\n            <actionandroid:name=\"android.provider.Telephony.SMS_RECEIVED\"/>  \n            </intent-filter>  \n</receiver>\n```\n\n动态注册\n\n```java\nIntentFilter intentFilter = new IntentFilter(\"android.provider.Telephony.SMS_RECEIVED\");\n```\n\n\n### 五 总结","slug":"android基础之Intents与Intent-Filters","published":1,"updated":"2017-03-09T12:47:42.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj02g6grz00067c025w0rdm6h","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Intent是Android中组件之间传递消息的一种机制，这个组件可以是同一个应用程序的，也可以是不同的应用程序。Android四大组件中除了ContentProvider，其余三者皆可通过Intent来传递数据。而且Intent是一种运行时绑定机制。</p>\n<p>Intent在Android的三个组件中传递的机制是不同的：</p>\n<ul>\n<li>使用Context.startActivity() 或 Activity.startActivityForResult()，传入一个intent来启动一个activity。使用 Activity.setResult()，传入一个intent来从activity中返回结果。</li>\n<li>将intent对象传给Context.startService()来启动一个service或者传消息给一个运行的service。将intent对象传给 Context.bindService()来绑定一个service。</li>\n<li>将intent对象传给 Context.sendBroadcast()，Context.sendOrderedBroadcast()，或者Context.sendStickyBroadcast()等广播方法，则它们被传给 broadcast receiver。</li>\n</ul>\n<h3 id=\"二-Intent的结构\"><a href=\"#二-Intent的结构\" class=\"headerlink\" title=\"二 Intent的结构\"></a>二 Intent的结构</h3><p>Intent主要包含以下属性：</p>\n<ul>\n<li><p>component(组件)：目的组件<br>Component属性明确指定Intent的目标组件的类名称。（属于直接Intent）。组件的名字通过函数setComponent()、setClass()、setClassName()设置，通过函数读取getComponent()。   </p>\n</li>\n<li><p>action（动作）：用来表现意图的行动<br>Action主要用来描述应用程序的组件，一个组件可以用于多个action，也可以多个组件拥有同一个action。</p>\n</li>\n</ul>\n<ul>\n<li>category（类别）：用来表现动作的类别<br>category通常和Action放在一起用的，用于描述这个action。一个action可以包含多个categoty，必须所有的categoty都匹配成功才算是与这个action匹配成功。如果一个action只有一个默认的categoty DEFAULT，则不需向Intent中添加categoty，系统会自动添加。addCategory() 放置一个intent里的类别，removeCategory()删除之前添加的，getCategories()获取当前所有的类别。<br>类别越多，动作越具体，意图越明确    </li>\n</ul>\n<ul>\n<li>data（数据）：表示与动作要操纵的数据<br>Data属性是Android要访问的数据，和action和Category声明方式相同，也是在<intent-filter>中。多个组件匹配成功显示优先级高的； 相同显示列表。Data是用一个uri对象来表示的，uri代表数据的地址，属于一种标识符。通常情况下，我们使用action+data属性的组合来描述一个意图：做什么    </intent-filter></li>\n</ul>\n<ul>\n<li>type（数据类型）：对于data范例的描写<br>如果Intent对象中既包含Uri又包含Type，那么，在<intent-filter>中也必须二者都包含才能通过测试。Type属性用于明确指定Data属性的数据类型或MIME类型，但是通常来说，当Intent不指定Data属性时，Type属性才会起作用，否则Android系统将会根据Data属性值来分析数据的类型，所以无需指定Type属性。data和type属性一般只需要一个，通过setData方法会把type属性设置为null，相反设置setType方法会把data设置为null，如果想要两个属性同时设置，要使用Intent.setDataAndType()方法    </intent-filter></li>\n</ul>\n<ul>\n<li>extras（扩展信息）：扩展信息<br>是其它所有附加信息的集合。以键值对的形式放入Intent中    </li>\n</ul>\n<ul>\n<li>Flags（标志位）：期望这个意图的运行模式<br>用于指定Activity与task之间的关系。</li>\n</ul>\n<h3 id=\"三-Intent发现组件的两种方式\"><a href=\"#三-Intent发现组件的两种方式\" class=\"headerlink\" title=\"三 Intent发现组件的两种方式\"></a>三 Intent发现组件的两种方式</h3><p>Intent启动组件有两种方式：显示启动和隐式启动。</p>\n<p>上面Intent的Intent的7个属性中，只有component属于显示启动，action，category，data皆为隐式启动。</p>\n<h5 id=\"1-显示启动\"><a href=\"#1-显示启动\" class=\"headerlink\" title=\"1.显示启动\"></a>1.显示启动</h5><p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">          <span class=\"meta\">@Override</span></div><div class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">              <span class=\"comment\">//创建一个意图对象</span></div><div class=\"line\">              Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">              <span class=\"comment\">//创建组件，通过组件来响应</span></div><div class=\"line\">              ComponentName component = <span class=\"keyword\">new</span> ComponentName(MainActivity.<span class=\"keyword\">this</span>, SecondActivity.class);</div><div class=\"line\">              intent.setComponent(component);                </div><div class=\"line\">              startActivity(intent);                </div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;);</div></pre></td></tr></table></figure>\n<p>如果写的简单一点，监听事件onClick()方法里可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\"><span class=\"comment\">//setClass函数的第一个参数是一个Context对象</span></div><div class=\"line\"><span class=\"comment\">//Context是一个类，Activity是Context类的子类，也就是说，所有的Activity对象，都可以向上转型为Context对象</span></div><div class=\"line\"><span class=\"comment\">//setClass函数的第二个参数是一个Class对象，在当前场景下，应该传入需要被启动的Activity类的class对象</span></div><div class=\"line\">intent.setClass(MainActivity.<span class=\"keyword\">this</span>, SecondActivity.class);</div><div class=\"line\">startActivity(intent);</div></pre></td></tr></table></figure>\n<p>再简单一点，可以这样写：（当然，也是最常见的写法）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(MainActivity.<span class=\"keyword\">this</span>,SecondActivity.class);</div><div class=\"line\">startActivity(intent);</div></pre></td></tr></table></figure>\n<h5 id=\"2-隐式启动\"><a href=\"#2-隐式启动\" class=\"headerlink\" title=\"2.隐式启动\"></a>2.隐式启动</h5><ul>\n<li>action</li>\n</ul>\n<p>在Androidmanifest.xml中定义</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;activity </div><div class=\"line\">    android:name=\".SecondActivity\"&gt;</div><div class=\"line\">    &lt;intent-filter&gt;</div><div class=\"line\">         &lt;action android:name=\"com.example.smyh006intent01.MY_ACTION\"/&gt;</div><div class=\"line\">         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</div><div class=\"line\">    &lt;/intent-filter&gt;            </div><div class=\"line\">&lt;/activity&gt;</div></pre></td></tr></table></figure>\n<p>java代码调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">         <span class=\"comment\">//启动另一个Activity，（通过action属性进行查找）</span></div><div class=\"line\">         Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">         <span class=\"comment\">//设置动作（实际action属性就是一个字符串标记而已）</span></div><div class=\"line\">         intent.setAction(<span class=\"string\">\"com.example.smyh006intent01.MY_ACTION\"</span>); <span class=\"comment\">//方法：Intent android.content.Intent.setAction(String action)</span></div><div class=\"line\">         startActivity(intent);        </div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>上面代码也可简写成</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//启动另一个Activity，（通过action属性进行查找）</span></div><div class=\"line\">        Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"string\">\"com.example.smyh006intent01.MY_ACTION\"</span>);<span class=\"comment\">//方法： android.content.Intent.Intent(String action)                </span></div><div class=\"line\">        startActivity(intent);        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>action+categoty</li>\n</ul>\n<p>Androidmanifest.xml文件：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;activity</div><div class=\"line\">    android:name=\".SecondActivity\"&gt;</div><div class=\"line\">    &lt;intent-filter&gt;</div><div class=\"line\">         &lt;action android:name=\"com.example.smyh006intent01.MY_ACTION\"/&gt;</div><div class=\"line\">         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</div><div class=\"line\">         &lt;category android:name=\"com.example.smyh006intent01.MY_CATEGORY\" /&gt;</div><div class=\"line\">    &lt;/intent-filter&gt;            </div><div class=\"line\">&lt;/activity&gt;</div></pre></td></tr></table></figure>\n<p>java文件中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">         <span class=\"comment\">//启动另一个Activity，（通过action属性进行查找）</span></div><div class=\"line\">         Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">         <span class=\"comment\">//设置动作（实际action属性就是一个字符串标记而已）</span></div><div class=\"line\">         intent.setAction(<span class=\"string\">\"com.example.smyh006intent01.MY_ACTION\"</span>); <span class=\"comment\">//方法：Intent android.content.Intent.setAction(String action)</span></div><div class=\"line\">         intent.addCategory(<span class=\"string\">\"com.example.smyh006intent01.MY_CATEGORY\"</span>);</div><div class=\"line\">         startActivity(intent);        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>action+data</li>\n</ul>\n<p>示例：打开指定网页</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;activity </div><div class=\"line\">    android:name=\".SecondActivity\"&gt;</div><div class=\"line\">    &lt;intent-filter&gt;</div><div class=\"line\">         &lt;action android:name=\"android.intent.action.VIEW\" /&gt;</div><div class=\"line\">         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</div><div class=\"line\">         &lt;data android:scheme=\"http\" android:host=\"www.baidu.com\"/&gt;                 </div><div class=\"line\">    &lt;/intent-filter&gt;            </div><div class=\"line\">&lt;/activity&gt;</div></pre></td></tr></table></figure>\n<p>java文件中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">         Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">         intent.setAction(Intent.ACTION_VIEW);</div><div class=\"line\">         Uri data = Uri.parse(<span class=\"string\">\"http://www.baidu.com\"</span>);</div><div class=\"line\">         intent.setData(data);                </div><div class=\"line\">         startActivity(intent);        </div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>上面代码也可简写成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">        Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_VIEW);</div><div class=\"line\">        intent.setData(Uri.parse(<span class=\"string\">\"http://www.baidu.com\"</span>));                </div><div class=\"line\">        startActivity(intent);        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"四-IntentFilter\"><a href=\"#四-IntentFilter\" class=\"headerlink\" title=\"四 IntentFilter\"></a>四 IntentFilter</h3><p>IntentFilter用于与Intent中的数据对比，来挑选出符合条件的组件。它分为静态注册（推荐）和动态注册两种方式。Intent与IntentFilter比较的步骤如下：</p>\n<ol>\n<li>加载安装所有的IntentFilter到一个列表中</li>\n<li>剔除所有action匹配失败的IntentFilter</li>\n<li>剔除URI数据匹配失败的IntentFilter</li>\n<li>剔除category匹配失败的IntentFilter</li>\n<li>剩下的IntentFilter是否为0。是，查找失败，抛出异常；否将剩下的IntentFilter按优先级排列，返回优先级最高的IntentFilter</li>\n</ol>\n<p>代码示例：</p>\n<p>静态注册</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;receiver android:name=\".MyBroadCastReceiver\"&gt;  </div><div class=\"line\">            &lt;!-- android:priority属性是设置此接收者的优先级（从-1000到1000） --&gt;</div><div class=\"line\">            &lt;intent-filter android:priority=\"20\"&gt;</div><div class=\"line\">            &lt;actionandroid:name=\"android.provider.Telephony.SMS_RECEIVED\"/&gt;  </div><div class=\"line\">            &lt;/intent-filter&gt;  </div><div class=\"line\">&lt;/receiver&gt;</div></pre></td></tr></table></figure>\n<p>动态注册</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">IntentFilter intentFilter = <span class=\"keyword\">new</span> IntentFilter(<span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span>);</div></pre></td></tr></table></figure>\n<h3 id=\"五-总结\"><a href=\"#五-总结\" class=\"headerlink\" title=\"五 总结\"></a>五 总结</h3>","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Intent是Android中组件之间传递消息的一种机制，这个组件可以是同一个应用程序的，也可以是不同的应用程序。Android四大组件中除了ContentProvider，其余三者皆可通过Intent来传递数据。而且Intent是一种运行时绑定机制。</p>\n<p>Intent在Android的三个组件中传递的机制是不同的：</p>\n<ul>\n<li>使用Context.startActivity() 或 Activity.startActivityForResult()，传入一个intent来启动一个activity。使用 Activity.setResult()，传入一个intent来从activity中返回结果。</li>\n<li>将intent对象传给Context.startService()来启动一个service或者传消息给一个运行的service。将intent对象传给 Context.bindService()来绑定一个service。</li>\n<li>将intent对象传给 Context.sendBroadcast()，Context.sendOrderedBroadcast()，或者Context.sendStickyBroadcast()等广播方法，则它们被传给 broadcast receiver。</li>\n</ul>\n<h3 id=\"二-Intent的结构\"><a href=\"#二-Intent的结构\" class=\"headerlink\" title=\"二 Intent的结构\"></a>二 Intent的结构</h3><p>Intent主要包含以下属性：</p>\n<ul>\n<li><p>component(组件)：目的组件<br>Component属性明确指定Intent的目标组件的类名称。（属于直接Intent）。组件的名字通过函数setComponent()、setClass()、setClassName()设置，通过函数读取getComponent()。   </p>\n</li>\n<li><p>action（动作）：用来表现意图的行动<br>Action主要用来描述应用程序的组件，一个组件可以用于多个action，也可以多个组件拥有同一个action。</p>\n</li>\n</ul>\n<ul>\n<li>category（类别）：用来表现动作的类别<br>category通常和Action放在一起用的，用于描述这个action。一个action可以包含多个categoty，必须所有的categoty都匹配成功才算是与这个action匹配成功。如果一个action只有一个默认的categoty DEFAULT，则不需向Intent中添加categoty，系统会自动添加。addCategory() 放置一个intent里的类别，removeCategory()删除之前添加的，getCategories()获取当前所有的类别。<br>类别越多，动作越具体，意图越明确    </li>\n</ul>\n<ul>\n<li>data（数据）：表示与动作要操纵的数据<br>Data属性是Android要访问的数据，和action和Category声明方式相同，也是在<intent-filter>中。多个组件匹配成功显示优先级高的； 相同显示列表。Data是用一个uri对象来表示的，uri代表数据的地址，属于一种标识符。通常情况下，我们使用action+data属性的组合来描述一个意图：做什么    </li>\n</ul>\n<ul>\n<li>type（数据类型）：对于data范例的描写<br>如果Intent对象中既包含Uri又包含Type，那么，在<intent-filter>中也必须二者都包含才能通过测试。Type属性用于明确指定Data属性的数据类型或MIME类型，但是通常来说，当Intent不指定Data属性时，Type属性才会起作用，否则Android系统将会根据Data属性值来分析数据的类型，所以无需指定Type属性。data和type属性一般只需要一个，通过setData方法会把type属性设置为null，相反设置setType方法会把data设置为null，如果想要两个属性同时设置，要使用Intent.setDataAndType()方法    </li>\n</ul>\n<ul>\n<li>extras（扩展信息）：扩展信息<br>是其它所有附加信息的集合。以键值对的形式放入Intent中    </li>\n</ul>\n<ul>\n<li>Flags（标志位）：期望这个意图的运行模式<br>用于指定Activity与task之间的关系。</li>\n</ul>\n<h3 id=\"三-Intent发现组件的两种方式\"><a href=\"#三-Intent发现组件的两种方式\" class=\"headerlink\" title=\"三 Intent发现组件的两种方式\"></a>三 Intent发现组件的两种方式</h3><p>Intent启动组件有两种方式：显示启动和隐式启动。</p>\n<p>上面Intent的Intent的7个属性中，只有component属于显示启动，action，category，data皆为隐式启动。</p>\n<h5 id=\"1-显示启动\"><a href=\"#1-显示启动\" class=\"headerlink\" title=\"1.显示启动\"></a>1.显示启动</h5><p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">          <span class=\"meta\">@Override</span></div><div class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">              <span class=\"comment\">//创建一个意图对象</span></div><div class=\"line\">              Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">              <span class=\"comment\">//创建组件，通过组件来响应</span></div><div class=\"line\">              ComponentName component = <span class=\"keyword\">new</span> ComponentName(MainActivity.<span class=\"keyword\">this</span>, SecondActivity.class);</div><div class=\"line\">              intent.setComponent(component);                </div><div class=\"line\">              startActivity(intent);                </div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;);</div></pre></td></tr></table></figure>\n<p>如果写的简单一点，监听事件onClick()方法里可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\"><span class=\"comment\">//setClass函数的第一个参数是一个Context对象</span></div><div class=\"line\"><span class=\"comment\">//Context是一个类，Activity是Context类的子类，也就是说，所有的Activity对象，都可以向上转型为Context对象</span></div><div class=\"line\"><span class=\"comment\">//setClass函数的第二个参数是一个Class对象，在当前场景下，应该传入需要被启动的Activity类的class对象</span></div><div class=\"line\">intent.setClass(MainActivity.<span class=\"keyword\">this</span>, SecondActivity.class);</div><div class=\"line\">startActivity(intent);</div></pre></td></tr></table></figure>\n<p>再简单一点，可以这样写：（当然，也是最常见的写法）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(MainActivity.<span class=\"keyword\">this</span>,SecondActivity.class);</div><div class=\"line\">startActivity(intent);</div></pre></td></tr></table></figure>\n<h5 id=\"2-隐式启动\"><a href=\"#2-隐式启动\" class=\"headerlink\" title=\"2.隐式启动\"></a>2.隐式启动</h5><ul>\n<li>action</li>\n</ul>\n<p>在Androidmanifest.xml中定义</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;activity </div><div class=\"line\">    android:name=\".SecondActivity\"&gt;</div><div class=\"line\">    &lt;intent-filter&gt;</div><div class=\"line\">         &lt;action android:name=\"com.example.smyh006intent01.MY_ACTION\"/&gt;</div><div class=\"line\">         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</div><div class=\"line\">    &lt;/intent-filter&gt;            </div><div class=\"line\">&lt;/activity&gt;</div></pre></td></tr></table></figure>\n<p>java代码调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">         <span class=\"comment\">//启动另一个Activity，（通过action属性进行查找）</span></div><div class=\"line\">         Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">         <span class=\"comment\">//设置动作（实际action属性就是一个字符串标记而已）</span></div><div class=\"line\">         intent.setAction(<span class=\"string\">\"com.example.smyh006intent01.MY_ACTION\"</span>); <span class=\"comment\">//方法：Intent android.content.Intent.setAction(String action)</span></div><div class=\"line\">         startActivity(intent);        </div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>上面代码也可简写成</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//启动另一个Activity，（通过action属性进行查找）</span></div><div class=\"line\">        Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"string\">\"com.example.smyh006intent01.MY_ACTION\"</span>);<span class=\"comment\">//方法： android.content.Intent.Intent(String action)                </span></div><div class=\"line\">        startActivity(intent);        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>action+categoty</li>\n</ul>\n<p>Androidmanifest.xml文件：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;activity</div><div class=\"line\">    android:name=\".SecondActivity\"&gt;</div><div class=\"line\">    &lt;intent-filter&gt;</div><div class=\"line\">         &lt;action android:name=\"com.example.smyh006intent01.MY_ACTION\"/&gt;</div><div class=\"line\">         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</div><div class=\"line\">         &lt;category android:name=\"com.example.smyh006intent01.MY_CATEGORY\" /&gt;</div><div class=\"line\">    &lt;/intent-filter&gt;            </div><div class=\"line\">&lt;/activity&gt;</div></pre></td></tr></table></figure>\n<p>java文件中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">         <span class=\"comment\">//启动另一个Activity，（通过action属性进行查找）</span></div><div class=\"line\">         Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">         <span class=\"comment\">//设置动作（实际action属性就是一个字符串标记而已）</span></div><div class=\"line\">         intent.setAction(<span class=\"string\">\"com.example.smyh006intent01.MY_ACTION\"</span>); <span class=\"comment\">//方法：Intent android.content.Intent.setAction(String action)</span></div><div class=\"line\">         intent.addCategory(<span class=\"string\">\"com.example.smyh006intent01.MY_CATEGORY\"</span>);</div><div class=\"line\">         startActivity(intent);        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>action+data</li>\n</ul>\n<p>示例：打开指定网页</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;activity </div><div class=\"line\">    android:name=\".SecondActivity\"&gt;</div><div class=\"line\">    &lt;intent-filter&gt;</div><div class=\"line\">         &lt;action android:name=\"android.intent.action.VIEW\" /&gt;</div><div class=\"line\">         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</div><div class=\"line\">         &lt;data android:scheme=\"http\" android:host=\"www.baidu.com\"/&gt;                 </div><div class=\"line\">    &lt;/intent-filter&gt;            </div><div class=\"line\">&lt;/activity&gt;</div></pre></td></tr></table></figure>\n<p>java文件中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">         Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">         intent.setAction(Intent.ACTION_VIEW);</div><div class=\"line\">         Uri data = Uri.parse(<span class=\"string\">\"http://www.baidu.com\"</span>);</div><div class=\"line\">         intent.setData(data);                </div><div class=\"line\">         startActivity(intent);        </div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>上面代码也可简写成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">        Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_VIEW);</div><div class=\"line\">        intent.setData(Uri.parse(<span class=\"string\">\"http://www.baidu.com\"</span>));                </div><div class=\"line\">        startActivity(intent);        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"四-IntentFilter\"><a href=\"#四-IntentFilter\" class=\"headerlink\" title=\"四 IntentFilter\"></a>四 IntentFilter</h3><p>IntentFilter用于与Intent中的数据对比，来挑选出符合条件的组件。它分为静态注册（推荐）和动态注册两种方式。Intent与IntentFilter比较的步骤如下：</p>\n<ol>\n<li>加载安装所有的IntentFilter到一个列表中</li>\n<li>剔除所有action匹配失败的IntentFilter</li>\n<li>剔除URI数据匹配失败的IntentFilter</li>\n<li>剔除category匹配失败的IntentFilter</li>\n<li>剩下的IntentFilter是否为0。是，查找失败，抛出异常；否将剩下的IntentFilter按优先级排列，返回优先级最高的IntentFilter</li>\n</ol>\n<p>代码示例：</p>\n<p>静态注册</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;receiver android:name=\".MyBroadCastReceiver\"&gt;  </div><div class=\"line\">            &lt;!-- android:priority属性是设置此接收者的优先级（从-1000到1000） --&gt;</div><div class=\"line\">            &lt;intent-filter android:priority=\"20\"&gt;</div><div class=\"line\">            &lt;actionandroid:name=\"android.provider.Telephony.SMS_RECEIVED\"/&gt;  </div><div class=\"line\">            &lt;/intent-filter&gt;  </div><div class=\"line\">&lt;/receiver&gt;</div></pre></td></tr></table></figure>\n<p>动态注册</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">IntentFilter intentFilter = <span class=\"keyword\">new</span> IntentFilter(<span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span>);</div></pre></td></tr></table></figure>\n<h3 id=\"五-总结\"><a href=\"#五-总结\" class=\"headerlink\" title=\"五 总结\"></a>五 总结</h3>"},{"title":"android基础之SQLite","date":"2017-02-28T10:03:32.000Z","_content":"\n### 一 概述\n\nSQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的SQL数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。从Android1.5开始，Android就自带SQLite数据库了。\n\n### 二 特性\n\n1. ACID事务 　\n2. 零配置 – 无需安装和管理配置 \n3. 储存在单一磁盘文件中的一个完整的数据库\n4. 数据库文件可以在不同字节顺序的机器间自由的共享\n5. 支持数据库大小至2TB\n6. 足够小, 大致3万行C代码, 250K\n7. 比一些流行的数据库在大部分普通数据库操作要快\n8. 简单, 轻松的API\n9. 包含TCL绑定, 同时通过Wrapper支持其他语言的绑定\n10. 良好注释的源代码, 并且有着90%以上的测试覆盖率  \n11. 独立: 没有额外依赖\n12. Source完全的Open, 你可以用于任何用途, 包括出售它\n13. 支持多种开发语言，C，PHP，Perl，Java，ASP.NET，Python　　\n\n### 在Android中使用SQLite\n\nActivites 可以通过 Content Provider 或者 Service 访问一个数据库。\n\n##### 1.创建数据库\n\nAndroid 不自动提供数据库。在 Android 应用程序中使用 SQLite，必须自己创建数据库，然后创建表、索引，填充数据。Android 提供了 SQLiteOpenHelper 帮助你创建一个数据库，你只要继承 SQLiteOpenHelper 类根据开发应用程序的需要，封装创建和更新数据库使用的逻辑就行了。　 \n\nSQLiteOpenHelper 的子类，至少需要实现三个方法：\n\n```java\npublic class DatabaseHelper extends SQLiteOpenHelper {\n\n    /**\n     * @param context  上下文环境（例如，一个 Activity）\n     * @param name   数据库名字\n     * @param factory  一个可选的游标工厂（通常是 Null）\n     * @param version  数据库模型版本的整数\n     * \n     * 会调用父类 SQLiteOpenHelper的构造函数\n     */ \n    public DatabaseHelper(Context context, String name, CursorFactory factory, int version) {\n        super(context, name, factory, version);\n\n    }\n\n    /**\n     *  在数据库第一次创建的时候会调用这个方法\n     *  \n     *根据需要对传入的SQLiteDatabase 对象填充表和初始化数据。\n     */\n    @Override\n    public void onCreate(SQLiteDatabase db) {\n\n    }\n\n    /**\n     * 当数据库需要修改的时候（两个数据库版本不同），Android系统会主动的调用这个方法。\n     * 一般我们在这个方法里边删除数据库表，并建立新的数据库表.\n     */\n    @Override\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n        //三个参数，一个 SQLiteDatabase 对象，一个旧的版本号和一个新的版本号\n\n    }\n\n    @Override\n    public void onOpen(SQLiteDatabase db) {\n        // 每次成功打开数据库后首先被执行\n        super.onOpen(db);\n    }\n}\n```\n\n继承SQLiteOpenHelper之后就拥有了以下两个方法：\n\n- getReadableDatabase() 　创建或者打开一个查询数据库\n- getWritableDatabase()　创建或者打开一个可写数据库\n\n创建一个数据库代码示例：\n\n```java\nDatabaseHelper database = new DatabaseHelper(context);//传入一个上下文参数\nSQLiteDatabase db = null;\ndb = database.getWritableDatabase();\n```\n\n上面这段代码会返回一个 SQLiteDatabase 类的实例，使用这个对象，你就可以查询或者修改数据库。SQLiteDatabase类为我们提供了很多种方法，而较常用的方法如下：\n\n删除数据行\n\n```java\n(int) delete(String table,String whereClause,String[] whereArgs)\n```\n\n添加数据行\n\n```java\n(long) insert(String table,String nullColumnHack,ContentValues values)\n```\n\n更新数据行\n\n```java\n(int) update(String table, ContentValues values, String whereClause, String[] whereArgs)\n```\n\n执行一个SQL语句，可以是一个select或其他的sql语句(没有返回值的sql语句)\n\n```java\n(void) execSQL(String sql)\n```\n\n关闭数据库\n\n```java\n(void) close()\n```\n\n查询指定的数据表返回一个带游标的数据集。\n\n```java\n/*各参数说明： table：表名称 colums：列名称数组 selection：条件子句，相当于where selectionArgs：条件//*语句的参数数组 groupBy：分组 having：分组条件 orderBy：排序类 limit：分页查询的限制 Cursor：返回值，相*当于结果集ResultSet*/\n(Cursor) query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit)\n```\n\n运行一个预置的SQL语句，返回带游标的数据集（与上面的语句最大的区别就是防止SQL注入）\n\n```java\n(Cursor) rawQuery(String sql, String[] selectionArgs)\n```\n\n当你完成了对数据库的操作（例如你的 Activity 已经关闭），需要调用 SQLiteDatabase 的 Close() 方法来释放掉数据库连接。\n\n##### 2.创建表和索引\n\n为了创建表和索引，需要调用 SQLiteDatabase 的 execSQL() 方法来执行 DDL 语句。如果没有异常，这个方法没有返回值。 　　\n\n例如，你可以执行如下代码：\n\n```java\n db.execSQL(\"CREATE TABLE user(_id INTEGER PRIMARY KEY   \n        AUTOINCREMENT, username TEXT, password TEXT);\");\n```\n\n这条语句会创建一个名为 user的表，表有一个列名为 _id，并且是主键，这列的值是会自动增长的整数。另外还有两列：username( 字符 ) 和 password( 字符 )。 SQLite 会自动为主键列创建索引。 　　\n\n通常情况下，第一次创建数据库时创建了表和索引。要 删除表和索引，需要使用 execSQL() 方法调用 DROP INDEX 和 DROP TABLE 语句。\n\n##### 3.添加数据\n\n有两种方法可以给表添加数据。\n\na. 可以使用 execSQL() 方法执行 INSERT, UPDATE, DELETE 等语句来更新表的数据。execSQL() 方法适用于所有不返回结果的 SQL 语句。例如：\n\n```java\nString sql = \"insert into user(username,password) values ('finch','123456');//插入操作的SQL语句\ndb.execSQL(sql);//执行SQL语句\n```\n\nb. 使用 SQLiteDatabase 对象的 insert()。\n\n```java\nContentValues cv = new ContentValues();\ncv.put(\"username\",\"finch\");//添加用户名\ncv.put(\"password\",\"123456\"); //添加密码\ndb.insert(\"user\",null,cv);//执行插入操作\n```\n\n##### 4.更新数据\n\na. 使用execSQL方式的实现\n\n```java\nString sql = \"update [user] set password = '654321' where username=\"finch\";//修改的SQL语句\ndb.execSQL(sql);//执行修改\n```\n\nb.使用SQLiteDatabase 对象的 update()方法。\n\n```java\nContentValues cv = new ContentValues();\ncv.put(\"password\",\"654321\");//添加要更改的字段及内容\nString whereClause = \"username=?\";//修改条件\nString[] whereArgs = {\"finch\"};//修改条件的参数\ndb.update(\"user\",cv,whereClause,whereArgs);//执行修改\n```\n\n该方法有四个参数：表名、列名和值的 ContentValues 对象、可选的 WHERE 条件、可选的填充 WHERE 语句的字符串，这些字符串会替换 WHERE 条件中的“？”标记，update() 根据条件，更新指定列的值。\n\n##### 5.删除数据\n\n使用execSQL方式的实现\n\n```java\nString sql = \"delete from user where username=\"finch\";//删除操作的SQL语句\ndb.execSQL(sql);//执行删除操作\n```\n\n使用SQLiteDatabase 对象的delete()方法\n\n```java\nString whereClause = \"username=?\";//删除的条件\nString[] whereArgs = {\"finch\"};//删除的条件参数\ndb.delete(\"user\",whereClause,whereArgs);//执行删除\n```\n\n##### 6.查询数据\n\n使用 rawQuery() 直接调用 SELECT 语句\n\n```java\nCursor c = db.rawQuery(\"select * from user where username=?\",new Stirng[]{\"finch\"});\n\nif(cursor.moveToFirst()) {\n    String password = c.getString(c.getColumnIndex(\"password\"));\n}\n```\n\n返回值是一个 cursor 对象，这个对象的方法可以迭代查询结果。 如果查询是动态的，使用这个方法就会非常复杂。例如，当你需要查询的列在程序编译的时候不能确定，这时候使用 query() 方法会方便很多。\n\n通过query实现查询\n\nquery() 方法用 SELECT 语句段构建查询。 　　SELECT 语句内容作为 query() 方法的参数，比如：要查询的表名，要获取的字段名，WHERE 条件，包含可选的位置参数，去替代 WHERE 条件中位置参数的值，GROUP BY 条件，HAVING 条件。 　　除了表名，其他参数可以是 null。所以代码可写成：\n\n```java\nCursor c = db.query(\"user\",null,null,null,null,null,null);//查询并获得游标\nif(c.moveToFirst()){//判断游标是否为空\n    for(int i=0;i<c.getCount();i++){　\nc.move(i);//移动到指定记录\nString username = c.getString(c.getColumnIndex(\"username\");\nString password = c.getString(c.getColumnIndex(\"password\"));\n    }\n}\n```\n\n##### 7.使用游标\n\n不管你如何执行查询，都会返回一个 Cursor，这是 Android 的 SQLite 数据库游标，使用游标，你可以：\n\n- 通过使用 getCount() 方法得到结果集中有多少记录；　\n- 通过 moveToFirst(), moveToNext(), 和 isAfterLast() 方法遍历所有记录；\n- 通过 getColumnNames() 得到字段名；\n- 通过 getColumnIndex() 转换成字段号；\n- 通过 getString()，getInt() 等方法得到给定字段当前记录的值；\n- 通过 requery() 方法重新执行查询得到游标；\n- 通过 close() 方法释放游标资源；\n\n例如，下面代码遍历 user表:\n\n```java\nCursor result=db.rawQuery(\"SELECT _id, username, password FROM user\"); \n    result.moveToFirst(); \n    while (!result.isAfterLast()) { \n        int id=result.getInt(0); \n        String name=result.getString(1); \n        String password =result.getString(2); \n        // do something useful with these \n        result.moveToNext(); \n      } \n      result.close();\n```\n\n### 总结\n\n\n","source":"_posts/android基础之SQLite.md","raw":"---\ntitle: android基础之SQLite\ndate: 2017-02-28 18:03:32\ncategories: android\ntags:\n- android\n- java\n- SQLite\n---\n\n### 一 概述\n\nSQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的SQL数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。从Android1.5开始，Android就自带SQLite数据库了。\n\n### 二 特性\n\n1. ACID事务 　\n2. 零配置 – 无需安装和管理配置 \n3. 储存在单一磁盘文件中的一个完整的数据库\n4. 数据库文件可以在不同字节顺序的机器间自由的共享\n5. 支持数据库大小至2TB\n6. 足够小, 大致3万行C代码, 250K\n7. 比一些流行的数据库在大部分普通数据库操作要快\n8. 简单, 轻松的API\n9. 包含TCL绑定, 同时通过Wrapper支持其他语言的绑定\n10. 良好注释的源代码, 并且有着90%以上的测试覆盖率  \n11. 独立: 没有额外依赖\n12. Source完全的Open, 你可以用于任何用途, 包括出售它\n13. 支持多种开发语言，C，PHP，Perl，Java，ASP.NET，Python　　\n\n### 在Android中使用SQLite\n\nActivites 可以通过 Content Provider 或者 Service 访问一个数据库。\n\n##### 1.创建数据库\n\nAndroid 不自动提供数据库。在 Android 应用程序中使用 SQLite，必须自己创建数据库，然后创建表、索引，填充数据。Android 提供了 SQLiteOpenHelper 帮助你创建一个数据库，你只要继承 SQLiteOpenHelper 类根据开发应用程序的需要，封装创建和更新数据库使用的逻辑就行了。　 \n\nSQLiteOpenHelper 的子类，至少需要实现三个方法：\n\n```java\npublic class DatabaseHelper extends SQLiteOpenHelper {\n\n    /**\n     * @param context  上下文环境（例如，一个 Activity）\n     * @param name   数据库名字\n     * @param factory  一个可选的游标工厂（通常是 Null）\n     * @param version  数据库模型版本的整数\n     * \n     * 会调用父类 SQLiteOpenHelper的构造函数\n     */ \n    public DatabaseHelper(Context context, String name, CursorFactory factory, int version) {\n        super(context, name, factory, version);\n\n    }\n\n    /**\n     *  在数据库第一次创建的时候会调用这个方法\n     *  \n     *根据需要对传入的SQLiteDatabase 对象填充表和初始化数据。\n     */\n    @Override\n    public void onCreate(SQLiteDatabase db) {\n\n    }\n\n    /**\n     * 当数据库需要修改的时候（两个数据库版本不同），Android系统会主动的调用这个方法。\n     * 一般我们在这个方法里边删除数据库表，并建立新的数据库表.\n     */\n    @Override\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n        //三个参数，一个 SQLiteDatabase 对象，一个旧的版本号和一个新的版本号\n\n    }\n\n    @Override\n    public void onOpen(SQLiteDatabase db) {\n        // 每次成功打开数据库后首先被执行\n        super.onOpen(db);\n    }\n}\n```\n\n继承SQLiteOpenHelper之后就拥有了以下两个方法：\n\n- getReadableDatabase() 　创建或者打开一个查询数据库\n- getWritableDatabase()　创建或者打开一个可写数据库\n\n创建一个数据库代码示例：\n\n```java\nDatabaseHelper database = new DatabaseHelper(context);//传入一个上下文参数\nSQLiteDatabase db = null;\ndb = database.getWritableDatabase();\n```\n\n上面这段代码会返回一个 SQLiteDatabase 类的实例，使用这个对象，你就可以查询或者修改数据库。SQLiteDatabase类为我们提供了很多种方法，而较常用的方法如下：\n\n删除数据行\n\n```java\n(int) delete(String table,String whereClause,String[] whereArgs)\n```\n\n添加数据行\n\n```java\n(long) insert(String table,String nullColumnHack,ContentValues values)\n```\n\n更新数据行\n\n```java\n(int) update(String table, ContentValues values, String whereClause, String[] whereArgs)\n```\n\n执行一个SQL语句，可以是一个select或其他的sql语句(没有返回值的sql语句)\n\n```java\n(void) execSQL(String sql)\n```\n\n关闭数据库\n\n```java\n(void) close()\n```\n\n查询指定的数据表返回一个带游标的数据集。\n\n```java\n/*各参数说明： table：表名称 colums：列名称数组 selection：条件子句，相当于where selectionArgs：条件//*语句的参数数组 groupBy：分组 having：分组条件 orderBy：排序类 limit：分页查询的限制 Cursor：返回值，相*当于结果集ResultSet*/\n(Cursor) query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit)\n```\n\n运行一个预置的SQL语句，返回带游标的数据集（与上面的语句最大的区别就是防止SQL注入）\n\n```java\n(Cursor) rawQuery(String sql, String[] selectionArgs)\n```\n\n当你完成了对数据库的操作（例如你的 Activity 已经关闭），需要调用 SQLiteDatabase 的 Close() 方法来释放掉数据库连接。\n\n##### 2.创建表和索引\n\n为了创建表和索引，需要调用 SQLiteDatabase 的 execSQL() 方法来执行 DDL 语句。如果没有异常，这个方法没有返回值。 　　\n\n例如，你可以执行如下代码：\n\n```java\n db.execSQL(\"CREATE TABLE user(_id INTEGER PRIMARY KEY   \n        AUTOINCREMENT, username TEXT, password TEXT);\");\n```\n\n这条语句会创建一个名为 user的表，表有一个列名为 _id，并且是主键，这列的值是会自动增长的整数。另外还有两列：username( 字符 ) 和 password( 字符 )。 SQLite 会自动为主键列创建索引。 　　\n\n通常情况下，第一次创建数据库时创建了表和索引。要 删除表和索引，需要使用 execSQL() 方法调用 DROP INDEX 和 DROP TABLE 语句。\n\n##### 3.添加数据\n\n有两种方法可以给表添加数据。\n\na. 可以使用 execSQL() 方法执行 INSERT, UPDATE, DELETE 等语句来更新表的数据。execSQL() 方法适用于所有不返回结果的 SQL 语句。例如：\n\n```java\nString sql = \"insert into user(username,password) values ('finch','123456');//插入操作的SQL语句\ndb.execSQL(sql);//执行SQL语句\n```\n\nb. 使用 SQLiteDatabase 对象的 insert()。\n\n```java\nContentValues cv = new ContentValues();\ncv.put(\"username\",\"finch\");//添加用户名\ncv.put(\"password\",\"123456\"); //添加密码\ndb.insert(\"user\",null,cv);//执行插入操作\n```\n\n##### 4.更新数据\n\na. 使用execSQL方式的实现\n\n```java\nString sql = \"update [user] set password = '654321' where username=\"finch\";//修改的SQL语句\ndb.execSQL(sql);//执行修改\n```\n\nb.使用SQLiteDatabase 对象的 update()方法。\n\n```java\nContentValues cv = new ContentValues();\ncv.put(\"password\",\"654321\");//添加要更改的字段及内容\nString whereClause = \"username=?\";//修改条件\nString[] whereArgs = {\"finch\"};//修改条件的参数\ndb.update(\"user\",cv,whereClause,whereArgs);//执行修改\n```\n\n该方法有四个参数：表名、列名和值的 ContentValues 对象、可选的 WHERE 条件、可选的填充 WHERE 语句的字符串，这些字符串会替换 WHERE 条件中的“？”标记，update() 根据条件，更新指定列的值。\n\n##### 5.删除数据\n\n使用execSQL方式的实现\n\n```java\nString sql = \"delete from user where username=\"finch\";//删除操作的SQL语句\ndb.execSQL(sql);//执行删除操作\n```\n\n使用SQLiteDatabase 对象的delete()方法\n\n```java\nString whereClause = \"username=?\";//删除的条件\nString[] whereArgs = {\"finch\"};//删除的条件参数\ndb.delete(\"user\",whereClause,whereArgs);//执行删除\n```\n\n##### 6.查询数据\n\n使用 rawQuery() 直接调用 SELECT 语句\n\n```java\nCursor c = db.rawQuery(\"select * from user where username=?\",new Stirng[]{\"finch\"});\n\nif(cursor.moveToFirst()) {\n    String password = c.getString(c.getColumnIndex(\"password\"));\n}\n```\n\n返回值是一个 cursor 对象，这个对象的方法可以迭代查询结果。 如果查询是动态的，使用这个方法就会非常复杂。例如，当你需要查询的列在程序编译的时候不能确定，这时候使用 query() 方法会方便很多。\n\n通过query实现查询\n\nquery() 方法用 SELECT 语句段构建查询。 　　SELECT 语句内容作为 query() 方法的参数，比如：要查询的表名，要获取的字段名，WHERE 条件，包含可选的位置参数，去替代 WHERE 条件中位置参数的值，GROUP BY 条件，HAVING 条件。 　　除了表名，其他参数可以是 null。所以代码可写成：\n\n```java\nCursor c = db.query(\"user\",null,null,null,null,null,null);//查询并获得游标\nif(c.moveToFirst()){//判断游标是否为空\n    for(int i=0;i<c.getCount();i++){　\nc.move(i);//移动到指定记录\nString username = c.getString(c.getColumnIndex(\"username\");\nString password = c.getString(c.getColumnIndex(\"password\"));\n    }\n}\n```\n\n##### 7.使用游标\n\n不管你如何执行查询，都会返回一个 Cursor，这是 Android 的 SQLite 数据库游标，使用游标，你可以：\n\n- 通过使用 getCount() 方法得到结果集中有多少记录；　\n- 通过 moveToFirst(), moveToNext(), 和 isAfterLast() 方法遍历所有记录；\n- 通过 getColumnNames() 得到字段名；\n- 通过 getColumnIndex() 转换成字段号；\n- 通过 getString()，getInt() 等方法得到给定字段当前记录的值；\n- 通过 requery() 方法重新执行查询得到游标；\n- 通过 close() 方法释放游标资源；\n\n例如，下面代码遍历 user表:\n\n```java\nCursor result=db.rawQuery(\"SELECT _id, username, password FROM user\"); \n    result.moveToFirst(); \n    while (!result.isAfterLast()) { \n        int id=result.getInt(0); \n        String name=result.getString(1); \n        String password =result.getString(2); \n        // do something useful with these \n        result.moveToNext(); \n      } \n      result.close();\n```\n\n### 总结\n\n\n","slug":"android基础之SQLite","published":1,"updated":"2017-03-09T12:47:42.069Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj02g6grz00097c02eaydiwl0","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的SQL数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。从Android1.5开始，Android就自带SQLite数据库了。</p>\n<h3 id=\"二-特性\"><a href=\"#二-特性\" class=\"headerlink\" title=\"二 特性\"></a>二 特性</h3><ol>\n<li>ACID事务 　</li>\n<li>零配置 – 无需安装和管理配置 </li>\n<li>储存在单一磁盘文件中的一个完整的数据库</li>\n<li>数据库文件可以在不同字节顺序的机器间自由的共享</li>\n<li>支持数据库大小至2TB</li>\n<li>足够小, 大致3万行C代码, 250K</li>\n<li>比一些流行的数据库在大部分普通数据库操作要快</li>\n<li>简单, 轻松的API</li>\n<li>包含TCL绑定, 同时通过Wrapper支持其他语言的绑定</li>\n<li>良好注释的源代码, 并且有着90%以上的测试覆盖率  </li>\n<li>独立: 没有额外依赖</li>\n<li>Source完全的Open, 你可以用于任何用途, 包括出售它</li>\n<li>支持多种开发语言，C，PHP，Perl，Java，ASP.NET，Python　　</li>\n</ol>\n<h3 id=\"在Android中使用SQLite\"><a href=\"#在Android中使用SQLite\" class=\"headerlink\" title=\"在Android中使用SQLite\"></a>在Android中使用SQLite</h3><p>Activites 可以通过 Content Provider 或者 Service 访问一个数据库。</p>\n<h5 id=\"1-创建数据库\"><a href=\"#1-创建数据库\" class=\"headerlink\" title=\"1.创建数据库\"></a>1.创建数据库</h5><p>Android 不自动提供数据库。在 Android 应用程序中使用 SQLite，必须自己创建数据库，然后创建表、索引，填充数据。Android 提供了 SQLiteOpenHelper 帮助你创建一个数据库，你只要继承 SQLiteOpenHelper 类根据开发应用程序的需要，封装创建和更新数据库使用的逻辑就行了。　 </p>\n<p>SQLiteOpenHelper 的子类，至少需要实现三个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DatabaseHelper</span> <span class=\"keyword\">extends</span> <span class=\"title\">SQLiteOpenHelper</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * <span class=\"doctag\">@param</span> context  上下文环境（例如，一个 Activity）</div><div class=\"line\">     * <span class=\"doctag\">@param</span> name   数据库名字</div><div class=\"line\">     * <span class=\"doctag\">@param</span> factory  一个可选的游标工厂（通常是 Null）</div><div class=\"line\">     * <span class=\"doctag\">@param</span> version  数据库模型版本的整数</div><div class=\"line\">     * </div><div class=\"line\">     * 会调用父类 SQLiteOpenHelper的构造函数</div><div class=\"line\">     */ </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DatabaseHelper</span><span class=\"params\">(Context context, String name, CursorFactory factory, <span class=\"keyword\">int</span> version)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, name, factory, version);</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     *  在数据库第一次创建的时候会调用这个方法</div><div class=\"line\">     *  </div><div class=\"line\">     *根据需要对传入的SQLiteDatabase 对象填充表和初始化数据。</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(SQLiteDatabase db)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 当数据库需要修改的时候（两个数据库版本不同），Android系统会主动的调用这个方法。</div><div class=\"line\">     * 一般我们在这个方法里边删除数据库表，并建立新的数据库表.</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onUpgrade</span><span class=\"params\">(SQLiteDatabase db, <span class=\"keyword\">int</span> oldVersion, <span class=\"keyword\">int</span> newVersion)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//三个参数，一个 SQLiteDatabase 对象，一个旧的版本号和一个新的版本号</span></div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onOpen</span><span class=\"params\">(SQLiteDatabase db)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 每次成功打开数据库后首先被执行</span></div><div class=\"line\">        <span class=\"keyword\">super</span>.onOpen(db);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>继承SQLiteOpenHelper之后就拥有了以下两个方法：</p>\n<ul>\n<li>getReadableDatabase() 　创建或者打开一个查询数据库</li>\n<li>getWritableDatabase()　创建或者打开一个可写数据库</li>\n</ul>\n<p>创建一个数据库代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">DatabaseHelper database = <span class=\"keyword\">new</span> DatabaseHelper(context);<span class=\"comment\">//传入一个上下文参数</span></div><div class=\"line\">SQLiteDatabase db = <span class=\"keyword\">null</span>;</div><div class=\"line\">db = database.getWritableDatabase();</div></pre></td></tr></table></figure>\n<p>上面这段代码会返回一个 SQLiteDatabase 类的实例，使用这个对象，你就可以查询或者修改数据库。SQLiteDatabase类为我们提供了很多种方法，而较常用的方法如下：</p>\n<p>删除数据行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">int</span>) delete(String table,String whereClause,String[] whereArgs)</div></pre></td></tr></table></figure>\n<p>添加数据行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">long</span>) insert(String table,String nullColumnHack,ContentValues values)</div></pre></td></tr></table></figure>\n<p>更新数据行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">int</span>) update(String table, ContentValues values, String whereClause, String[] whereArgs)</div></pre></td></tr></table></figure>\n<p>执行一个SQL语句，可以是一个select或其他的sql语句(没有返回值的sql语句)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">void</span>) execSQL(String sql)</div></pre></td></tr></table></figure>\n<p>关闭数据库</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">void</span>) close()</div></pre></td></tr></table></figure>\n<p>查询指定的数据表返回一个带游标的数据集。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*各参数说明： table：表名称 colums：列名称数组 selection：条件子句，相当于where selectionArgs：条件//*语句的参数数组 groupBy：分组 having：分组条件 orderBy：排序类 limit：分页查询的限制 Cursor：返回值，相*当于结果集ResultSet*/</span></div><div class=\"line\">(Cursor) query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit)</div></pre></td></tr></table></figure>\n<p>运行一个预置的SQL语句，返回带游标的数据集（与上面的语句最大的区别就是防止SQL注入）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(Cursor) rawQuery(String sql, String[] selectionArgs)</div></pre></td></tr></table></figure>\n<p>当你完成了对数据库的操作（例如你的 Activity 已经关闭），需要调用 SQLiteDatabase 的 Close() 方法来释放掉数据库连接。</p>\n<h5 id=\"2-创建表和索引\"><a href=\"#2-创建表和索引\" class=\"headerlink\" title=\"2.创建表和索引\"></a>2.创建表和索引</h5><p>为了创建表和索引，需要调用 SQLiteDatabase 的 execSQL() 方法来执行 DDL 语句。如果没有异常，这个方法没有返回值。 　　</p>\n<p>例如，你可以执行如下代码：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">db.execSQL(\"CREATE TABLE user(_id INTEGER PRIMARY KEY   </div><div class=\"line\">       AUTOINCREMENT, username TEXT, password TEXT);\");</div></pre></td></tr></table></figure>\n<p>这条语句会创建一个名为 user的表，表有一个列名为 _id，并且是主键，这列的值是会自动增长的整数。另外还有两列：username( 字符 ) 和 password( 字符 )。 SQLite 会自动为主键列创建索引。 　　</p>\n<p>通常情况下，第一次创建数据库时创建了表和索引。要 删除表和索引，需要使用 execSQL() 方法调用 DROP INDEX 和 DROP TABLE 语句。</p>\n<h5 id=\"3-添加数据\"><a href=\"#3-添加数据\" class=\"headerlink\" title=\"3.添加数据\"></a>3.添加数据</h5><p>有两种方法可以给表添加数据。</p>\n<p>a. 可以使用 execSQL() 方法执行 INSERT, UPDATE, DELETE 等语句来更新表的数据。execSQL() 方法适用于所有不返回结果的 SQL 语句。例如：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">String sql = \"insert into user(username,password) values ('finch','123456');//插入操作的SQL语句</div><div class=\"line\">db.execSQL(sql);//执行SQL语句</div></pre></td></tr></table></figure>\n<p>b. 使用 SQLiteDatabase 对象的 insert()。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ContentValues cv = <span class=\"keyword\">new</span> ContentValues();</div><div class=\"line\">cv.put(<span class=\"string\">\"username\"</span>,<span class=\"string\">\"finch\"</span>);<span class=\"comment\">//添加用户名</span></div><div class=\"line\">cv.put(<span class=\"string\">\"password\"</span>,<span class=\"string\">\"123456\"</span>); <span class=\"comment\">//添加密码</span></div><div class=\"line\">db.insert(<span class=\"string\">\"user\"</span>,<span class=\"keyword\">null</span>,cv);<span class=\"comment\">//执行插入操作</span></div></pre></td></tr></table></figure>\n<h5 id=\"4-更新数据\"><a href=\"#4-更新数据\" class=\"headerlink\" title=\"4.更新数据\"></a>4.更新数据</h5><p>a. 使用execSQL方式的实现</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">String sql = \"update [user] set password = '654321' where username=\"finch\";//修改的SQL语句</div><div class=\"line\">db.execSQL(sql);//执行修改</div></pre></td></tr></table></figure>\n<p>b.使用SQLiteDatabase 对象的 update()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ContentValues cv = <span class=\"keyword\">new</span> ContentValues();</div><div class=\"line\">cv.put(<span class=\"string\">\"password\"</span>,<span class=\"string\">\"654321\"</span>);<span class=\"comment\">//添加要更改的字段及内容</span></div><div class=\"line\">String whereClause = <span class=\"string\">\"username=?\"</span>;<span class=\"comment\">//修改条件</span></div><div class=\"line\">String[] whereArgs = &#123;<span class=\"string\">\"finch\"</span>&#125;;<span class=\"comment\">//修改条件的参数</span></div><div class=\"line\">db.update(<span class=\"string\">\"user\"</span>,cv,whereClause,whereArgs);<span class=\"comment\">//执行修改</span></div></pre></td></tr></table></figure>\n<p>该方法有四个参数：表名、列名和值的 ContentValues 对象、可选的 WHERE 条件、可选的填充 WHERE 语句的字符串，这些字符串会替换 WHERE 条件中的“？”标记，update() 根据条件，更新指定列的值。</p>\n<h5 id=\"5-删除数据\"><a href=\"#5-删除数据\" class=\"headerlink\" title=\"5.删除数据\"></a>5.删除数据</h5><p>使用execSQL方式的实现</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">String sql = \"delete from user where username=\"finch\";//删除操作的SQL语句</div><div class=\"line\">db.execSQL(sql);//执行删除操作</div></pre></td></tr></table></figure>\n<p>使用SQLiteDatabase 对象的delete()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">String whereClause = <span class=\"string\">\"username=?\"</span>;<span class=\"comment\">//删除的条件</span></div><div class=\"line\">String[] whereArgs = &#123;<span class=\"string\">\"finch\"</span>&#125;;<span class=\"comment\">//删除的条件参数</span></div><div class=\"line\">db.delete(<span class=\"string\">\"user\"</span>,whereClause,whereArgs);<span class=\"comment\">//执行删除</span></div></pre></td></tr></table></figure>\n<h5 id=\"6-查询数据\"><a href=\"#6-查询数据\" class=\"headerlink\" title=\"6.查询数据\"></a>6.查询数据</h5><p>使用 rawQuery() 直接调用 SELECT 语句</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cursor c = db.rawQuery(<span class=\"string\">\"select * from user where username=?\"</span>,<span class=\"keyword\">new</span> Stirng[]&#123;<span class=\"string\">\"finch\"</span>&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span>(cursor.moveToFirst()) &#123;</div><div class=\"line\">    String password = c.getString(c.getColumnIndex(<span class=\"string\">\"password\"</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>返回值是一个 cursor 对象，这个对象的方法可以迭代查询结果。 如果查询是动态的，使用这个方法就会非常复杂。例如，当你需要查询的列在程序编译的时候不能确定，这时候使用 query() 方法会方便很多。</p>\n<p>通过query实现查询</p>\n<p>query() 方法用 SELECT 语句段构建查询。 　　SELECT 语句内容作为 query() 方法的参数，比如：要查询的表名，要获取的字段名，WHERE 条件，包含可选的位置参数，去替代 WHERE 条件中位置参数的值，GROUP BY 条件，HAVING 条件。 　　除了表名，其他参数可以是 null。所以代码可写成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cursor c = db.query(<span class=\"string\">\"user\"</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>);<span class=\"comment\">//查询并获得游标</span></div><div class=\"line\"><span class=\"keyword\">if</span>(c.moveToFirst())&#123;<span class=\"comment\">//判断游标是否为空</span></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;c.getCount();i++)&#123;　</div><div class=\"line\">c.move(i);<span class=\"comment\">//移动到指定记录</span></div><div class=\"line\">String username = c.getString(c.getColumnIndex(<span class=\"string\">\"username\"</span>);</div><div class=\"line\">String password = c.getString(c.getColumnIndex(<span class=\"string\">\"password\"</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"7-使用游标\"><a href=\"#7-使用游标\" class=\"headerlink\" title=\"7.使用游标\"></a>7.使用游标</h5><p>不管你如何执行查询，都会返回一个 Cursor，这是 Android 的 SQLite 数据库游标，使用游标，你可以：</p>\n<ul>\n<li>通过使用 getCount() 方法得到结果集中有多少记录；　</li>\n<li>通过 moveToFirst(), moveToNext(), 和 isAfterLast() 方法遍历所有记录；</li>\n<li>通过 getColumnNames() 得到字段名；</li>\n<li>通过 getColumnIndex() 转换成字段号；</li>\n<li>通过 getString()，getInt() 等方法得到给定字段当前记录的值；</li>\n<li>通过 requery() 方法重新执行查询得到游标；</li>\n<li>通过 close() 方法释放游标资源；</li>\n</ul>\n<p>例如，下面代码遍历 user表:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cursor result=db.rawQuery(<span class=\"string\">\"SELECT _id, username, password FROM user\"</span>); </div><div class=\"line\">    result.moveToFirst(); </div><div class=\"line\">    <span class=\"keyword\">while</span> (!result.isAfterLast()) &#123; </div><div class=\"line\">        <span class=\"keyword\">int</span> id=result.getInt(<span class=\"number\">0</span>); </div><div class=\"line\">        String name=result.getString(<span class=\"number\">1</span>); </div><div class=\"line\">        String password =result.getString(<span class=\"number\">2</span>); </div><div class=\"line\">        <span class=\"comment\">// do something useful with these </span></div><div class=\"line\">        result.moveToNext(); </div><div class=\"line\">      &#125; </div><div class=\"line\">      result.close();</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的SQL数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。从Android1.5开始，Android就自带SQLite数据库了。</p>\n<h3 id=\"二-特性\"><a href=\"#二-特性\" class=\"headerlink\" title=\"二 特性\"></a>二 特性</h3><ol>\n<li>ACID事务 　</li>\n<li>零配置 – 无需安装和管理配置 </li>\n<li>储存在单一磁盘文件中的一个完整的数据库</li>\n<li>数据库文件可以在不同字节顺序的机器间自由的共享</li>\n<li>支持数据库大小至2TB</li>\n<li>足够小, 大致3万行C代码, 250K</li>\n<li>比一些流行的数据库在大部分普通数据库操作要快</li>\n<li>简单, 轻松的API</li>\n<li>包含TCL绑定, 同时通过Wrapper支持其他语言的绑定</li>\n<li>良好注释的源代码, 并且有着90%以上的测试覆盖率  </li>\n<li>独立: 没有额外依赖</li>\n<li>Source完全的Open, 你可以用于任何用途, 包括出售它</li>\n<li>支持多种开发语言，C，PHP，Perl，Java，ASP.NET，Python　　</li>\n</ol>\n<h3 id=\"在Android中使用SQLite\"><a href=\"#在Android中使用SQLite\" class=\"headerlink\" title=\"在Android中使用SQLite\"></a>在Android中使用SQLite</h3><p>Activites 可以通过 Content Provider 或者 Service 访问一个数据库。</p>\n<h5 id=\"1-创建数据库\"><a href=\"#1-创建数据库\" class=\"headerlink\" title=\"1.创建数据库\"></a>1.创建数据库</h5><p>Android 不自动提供数据库。在 Android 应用程序中使用 SQLite，必须自己创建数据库，然后创建表、索引，填充数据。Android 提供了 SQLiteOpenHelper 帮助你创建一个数据库，你只要继承 SQLiteOpenHelper 类根据开发应用程序的需要，封装创建和更新数据库使用的逻辑就行了。　 </p>\n<p>SQLiteOpenHelper 的子类，至少需要实现三个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DatabaseHelper</span> <span class=\"keyword\">extends</span> <span class=\"title\">SQLiteOpenHelper</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * <span class=\"doctag\">@param</span> context  上下文环境（例如，一个 Activity）</div><div class=\"line\">     * <span class=\"doctag\">@param</span> name   数据库名字</div><div class=\"line\">     * <span class=\"doctag\">@param</span> factory  一个可选的游标工厂（通常是 Null）</div><div class=\"line\">     * <span class=\"doctag\">@param</span> version  数据库模型版本的整数</div><div class=\"line\">     * </div><div class=\"line\">     * 会调用父类 SQLiteOpenHelper的构造函数</div><div class=\"line\">     */</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DatabaseHelper</span><span class=\"params\">(Context context, String name, CursorFactory factory, <span class=\"keyword\">int</span> version)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, name, factory, version);</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     *  在数据库第一次创建的时候会调用这个方法</div><div class=\"line\">     *  </div><div class=\"line\">     *根据需要对传入的SQLiteDatabase 对象填充表和初始化数据。</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(SQLiteDatabase db)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 当数据库需要修改的时候（两个数据库版本不同），Android系统会主动的调用这个方法。</div><div class=\"line\">     * 一般我们在这个方法里边删除数据库表，并建立新的数据库表.</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onUpgrade</span><span class=\"params\">(SQLiteDatabase db, <span class=\"keyword\">int</span> oldVersion, <span class=\"keyword\">int</span> newVersion)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//三个参数，一个 SQLiteDatabase 对象，一个旧的版本号和一个新的版本号</span></div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onOpen</span><span class=\"params\">(SQLiteDatabase db)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 每次成功打开数据库后首先被执行</span></div><div class=\"line\">        <span class=\"keyword\">super</span>.onOpen(db);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>继承SQLiteOpenHelper之后就拥有了以下两个方法：</p>\n<ul>\n<li>getReadableDatabase() 　创建或者打开一个查询数据库</li>\n<li>getWritableDatabase()　创建或者打开一个可写数据库</li>\n</ul>\n<p>创建一个数据库代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">DatabaseHelper database = <span class=\"keyword\">new</span> DatabaseHelper(context);<span class=\"comment\">//传入一个上下文参数</span></div><div class=\"line\">SQLiteDatabase db = <span class=\"keyword\">null</span>;</div><div class=\"line\">db = database.getWritableDatabase();</div></pre></td></tr></table></figure>\n<p>上面这段代码会返回一个 SQLiteDatabase 类的实例，使用这个对象，你就可以查询或者修改数据库。SQLiteDatabase类为我们提供了很多种方法，而较常用的方法如下：</p>\n<p>删除数据行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">int</span>) delete(String table,String whereClause,String[] whereArgs)</div></pre></td></tr></table></figure>\n<p>添加数据行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">long</span>) insert(String table,String nullColumnHack,ContentValues values)</div></pre></td></tr></table></figure>\n<p>更新数据行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">int</span>) update(String table, ContentValues values, String whereClause, String[] whereArgs)</div></pre></td></tr></table></figure>\n<p>执行一个SQL语句，可以是一个select或其他的sql语句(没有返回值的sql语句)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">void</span>) execSQL(String sql)</div></pre></td></tr></table></figure>\n<p>关闭数据库</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">void</span>) close()</div></pre></td></tr></table></figure>\n<p>查询指定的数据表返回一个带游标的数据集。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*各参数说明： table：表名称 colums：列名称数组 selection：条件子句，相当于where selectionArgs：条件//*语句的参数数组 groupBy：分组 having：分组条件 orderBy：排序类 limit：分页查询的限制 Cursor：返回值，相*当于结果集ResultSet*/</span></div><div class=\"line\">(Cursor) query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit)</div></pre></td></tr></table></figure>\n<p>运行一个预置的SQL语句，返回带游标的数据集（与上面的语句最大的区别就是防止SQL注入）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(Cursor) rawQuery(String sql, String[] selectionArgs)</div></pre></td></tr></table></figure>\n<p>当你完成了对数据库的操作（例如你的 Activity 已经关闭），需要调用 SQLiteDatabase 的 Close() 方法来释放掉数据库连接。</p>\n<h5 id=\"2-创建表和索引\"><a href=\"#2-创建表和索引\" class=\"headerlink\" title=\"2.创建表和索引\"></a>2.创建表和索引</h5><p>为了创建表和索引，需要调用 SQLiteDatabase 的 execSQL() 方法来执行 DDL 语句。如果没有异常，这个方法没有返回值。 　　</p>\n<p>例如，你可以执行如下代码：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">db.execSQL(\"CREATE TABLE user(_id INTEGER PRIMARY KEY   </div><div class=\"line\">       AUTOINCREMENT, username TEXT, password TEXT);\");</div></pre></td></tr></table></figure>\n<p>这条语句会创建一个名为 user的表，表有一个列名为 _id，并且是主键，这列的值是会自动增长的整数。另外还有两列：username( 字符 ) 和 password( 字符 )。 SQLite 会自动为主键列创建索引。 　　</p>\n<p>通常情况下，第一次创建数据库时创建了表和索引。要 删除表和索引，需要使用 execSQL() 方法调用 DROP INDEX 和 DROP TABLE 语句。</p>\n<h5 id=\"3-添加数据\"><a href=\"#3-添加数据\" class=\"headerlink\" title=\"3.添加数据\"></a>3.添加数据</h5><p>有两种方法可以给表添加数据。</p>\n<p>a. 可以使用 execSQL() 方法执行 INSERT, UPDATE, DELETE 等语句来更新表的数据。execSQL() 方法适用于所有不返回结果的 SQL 语句。例如：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">String sql = \"insert into user(username,password) values ('finch','123456');//插入操作的SQL语句</div><div class=\"line\">db.execSQL(sql);//执行SQL语句</div></pre></td></tr></table></figure>\n<p>b. 使用 SQLiteDatabase 对象的 insert()。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ContentValues cv = <span class=\"keyword\">new</span> ContentValues();</div><div class=\"line\">cv.put(<span class=\"string\">\"username\"</span>,<span class=\"string\">\"finch\"</span>);<span class=\"comment\">//添加用户名</span></div><div class=\"line\">cv.put(<span class=\"string\">\"password\"</span>,<span class=\"string\">\"123456\"</span>); <span class=\"comment\">//添加密码</span></div><div class=\"line\">db.insert(<span class=\"string\">\"user\"</span>,<span class=\"keyword\">null</span>,cv);<span class=\"comment\">//执行插入操作</span></div></pre></td></tr></table></figure>\n<h5 id=\"4-更新数据\"><a href=\"#4-更新数据\" class=\"headerlink\" title=\"4.更新数据\"></a>4.更新数据</h5><p>a. 使用execSQL方式的实现</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">String sql = \"update [user] set password = '654321' where username=\"finch\";//修改的SQL语句</div><div class=\"line\">db.execSQL(sql);//执行修改</div></pre></td></tr></table></figure>\n<p>b.使用SQLiteDatabase 对象的 update()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ContentValues cv = <span class=\"keyword\">new</span> ContentValues();</div><div class=\"line\">cv.put(<span class=\"string\">\"password\"</span>,<span class=\"string\">\"654321\"</span>);<span class=\"comment\">//添加要更改的字段及内容</span></div><div class=\"line\">String whereClause = <span class=\"string\">\"username=?\"</span>;<span class=\"comment\">//修改条件</span></div><div class=\"line\">String[] whereArgs = &#123;<span class=\"string\">\"finch\"</span>&#125;;<span class=\"comment\">//修改条件的参数</span></div><div class=\"line\">db.update(<span class=\"string\">\"user\"</span>,cv,whereClause,whereArgs);<span class=\"comment\">//执行修改</span></div></pre></td></tr></table></figure>\n<p>该方法有四个参数：表名、列名和值的 ContentValues 对象、可选的 WHERE 条件、可选的填充 WHERE 语句的字符串，这些字符串会替换 WHERE 条件中的“？”标记，update() 根据条件，更新指定列的值。</p>\n<h5 id=\"5-删除数据\"><a href=\"#5-删除数据\" class=\"headerlink\" title=\"5.删除数据\"></a>5.删除数据</h5><p>使用execSQL方式的实现</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">String sql = \"delete from user where username=\"finch\";//删除操作的SQL语句</div><div class=\"line\">db.execSQL(sql);//执行删除操作</div></pre></td></tr></table></figure>\n<p>使用SQLiteDatabase 对象的delete()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">String whereClause = <span class=\"string\">\"username=?\"</span>;<span class=\"comment\">//删除的条件</span></div><div class=\"line\">String[] whereArgs = &#123;<span class=\"string\">\"finch\"</span>&#125;;<span class=\"comment\">//删除的条件参数</span></div><div class=\"line\">db.delete(<span class=\"string\">\"user\"</span>,whereClause,whereArgs);<span class=\"comment\">//执行删除</span></div></pre></td></tr></table></figure>\n<h5 id=\"6-查询数据\"><a href=\"#6-查询数据\" class=\"headerlink\" title=\"6.查询数据\"></a>6.查询数据</h5><p>使用 rawQuery() 直接调用 SELECT 语句</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cursor c = db.rawQuery(<span class=\"string\">\"select * from user where username=?\"</span>,<span class=\"keyword\">new</span> Stirng[]&#123;<span class=\"string\">\"finch\"</span>&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span>(cursor.moveToFirst()) &#123;</div><div class=\"line\">    String password = c.getString(c.getColumnIndex(<span class=\"string\">\"password\"</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>返回值是一个 cursor 对象，这个对象的方法可以迭代查询结果。 如果查询是动态的，使用这个方法就会非常复杂。例如，当你需要查询的列在程序编译的时候不能确定，这时候使用 query() 方法会方便很多。</p>\n<p>通过query实现查询</p>\n<p>query() 方法用 SELECT 语句段构建查询。 　　SELECT 语句内容作为 query() 方法的参数，比如：要查询的表名，要获取的字段名，WHERE 条件，包含可选的位置参数，去替代 WHERE 条件中位置参数的值，GROUP BY 条件，HAVING 条件。 　　除了表名，其他参数可以是 null。所以代码可写成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cursor c = db.query(<span class=\"string\">\"user\"</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>);<span class=\"comment\">//查询并获得游标</span></div><div class=\"line\"><span class=\"keyword\">if</span>(c.moveToFirst())&#123;<span class=\"comment\">//判断游标是否为空</span></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;c.getCount();i++)&#123;　</div><div class=\"line\">c.move(i);<span class=\"comment\">//移动到指定记录</span></div><div class=\"line\">String username = c.getString(c.getColumnIndex(<span class=\"string\">\"username\"</span>);</div><div class=\"line\">String password = c.getString(c.getColumnIndex(<span class=\"string\">\"password\"</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"7-使用游标\"><a href=\"#7-使用游标\" class=\"headerlink\" title=\"7.使用游标\"></a>7.使用游标</h5><p>不管你如何执行查询，都会返回一个 Cursor，这是 Android 的 SQLite 数据库游标，使用游标，你可以：</p>\n<ul>\n<li>通过使用 getCount() 方法得到结果集中有多少记录；　</li>\n<li>通过 moveToFirst(), moveToNext(), 和 isAfterLast() 方法遍历所有记录；</li>\n<li>通过 getColumnNames() 得到字段名；</li>\n<li>通过 getColumnIndex() 转换成字段号；</li>\n<li>通过 getString()，getInt() 等方法得到给定字段当前记录的值；</li>\n<li>通过 requery() 方法重新执行查询得到游标；</li>\n<li>通过 close() 方法释放游标资源；</li>\n</ul>\n<p>例如，下面代码遍历 user表:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cursor result=db.rawQuery(<span class=\"string\">\"SELECT _id, username, password FROM user\"</span>); </div><div class=\"line\">    result.moveToFirst(); </div><div class=\"line\">    <span class=\"keyword\">while</span> (!result.isAfterLast()) &#123; </div><div class=\"line\">        <span class=\"keyword\">int</span> id=result.getInt(<span class=\"number\">0</span>); </div><div class=\"line\">        String name=result.getString(<span class=\"number\">1</span>); </div><div class=\"line\">        String password =result.getString(<span class=\"number\">2</span>); </div><div class=\"line\">        <span class=\"comment\">// do something useful with these </span></div><div class=\"line\">        result.moveToNext(); </div><div class=\"line\">      &#125; </div><div class=\"line\">      result.close();</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>"},{"title":"android基础之activity","date":"2017-02-27T02:35:34.000Z","_content":"\n### 一 Activity简介   \nactivity是android四大组件之一，用于android app的界面显示。activity中包含一个window，window中则包含包含相应的view。\n\n### 二 Activity类的层次结构    \n继承的抽象类： ContextThemeWrapper\n实现的接口： ComponentCallbacks2 KeyEvent.Callback LayoutInflater.Factory2 View.OnCreateContextMenuListener Window.Callback      \n\n```java   \njava.lang.Object   \n\tandroid.content.Context\n\t\tandroid.content.ContextWrapper\n\t\t\tandroid.content.ContextThemeWrapper\n\t\t\t\tandroid.app.Activity\n```\n\n直接子类： AccountAuthenticatorActivity, ActivityGroup, AliasActivity, ExpandableListActivity, FragmentActivity, ListActivity, NativeActivity 　　　\n间接子类： ActionBarActivity, LauncherActivity, PreferenceActivity, TabActivity 　　　\n\n### 三 Activity的生命周期   　\nActivity在它的一生中有以下四种状态：  \n- running：此时Activity处于屏幕的前台并且拥有焦点，位于回退栈的顶部（回退栈将在下面介绍）。   \n- paused： 此时另一个Activity位于前台并拥有焦点，也就是说另一个Activity覆盖在本Activity的上面，但是这个Activity是透明的或者没有占据全屏，即从屏幕上还可以看到下面的Activity（比如弹出个红包）。一个paused的activity是完全存活的（Activity 对象仍然保留在内存里，它保持着所有的状态和成员信息，并且保持与window manager的联接），但在系统内存严重不足的情况下它能被杀死。    \n- stopped： 本Activity被其他Activity完全覆盖了，看不见了。一个stopped的activity也仍然是存活的（Activity 对象仍然保留在内存中，它保持着所有的状态和成员信息，但是不再与window manager联接了）。 但是，对于用户而言它已经不再可见了，并且当其它地方需要内存时它将会被杀死。    \n- killed： 当Activity处于paused或者stopped时，若内存不足，它将可能被干掉。当它被再次创建处于前台时，需要调用onCreate方法重新创建并恢复之前的状态    \n下面是activity的生命周期图：      \n{% asset_img activity生命周期图.png activity生命周期图 %}       \n由上图可以看出activity有三种不同的生命周期：　　\n- 完整生命周期： onCreate--onDestroy    \n- 可见生命周期： onResume到onPause之间循环    \n- 前台生命周期： onStart-onStop-onRestart三者之间循环    \nActivity中的回调方法    \n\n```java\npublic class ExampleActivity extends Activity {\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        // The activity is being created.\n    }\n    @Override\n    protected void onStart() {\n        super.onStart();\n        // The activity is about to become visible.\n    }\n    @Override\n    protected void onResume() {\n        super.onResume();\n        // The activity has become visible (it is now \"resumed\").\n    }\n    @Override\n    protected void onPause() {\n        super.onPause();\n        // Another activity is taking focus (this activity is about to be \"paused\").\n    }\n    @Override\n    protected void onStop() {\n        super.onStop();\n        // The activity is no longer visible (it is now \"stopped\")\n    }\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        // The activity is about to be destroyed.\n    }\n}\n```\n \nActivity回调方法汇总：       \n{% asset_img activity回调方法汇总.png activity回调方法汇总 %}       \n标为“之后可否被杀死？”的列指明了系统是否可以在这个方法返回之后的任意时刻杀掉这个activity的宿主进程， 而不再执行其它流程上的activity代码。 有三个方法是标为“可以”：（ onPause()、 onStop()、 和onDestroy()）。 因为onPause()是三个方法中的第一个， 一旦activity被创建， onPause() 就是进程可以被杀死之前最后一个能确保被调用的方法 ——如果系统在某种紧急情况下必须回收内存，则 onStop() 和onDestroy() 可能就不会被调用了。因此，你应该使用 onPause() 来把至关重要的需长期保存的数据写入存储器（比如用户所编辑的内容）。 不过，应该对必须通过 onPause() 方法进行保存的信息有所选择，因为该方法中所有的阻塞操作都会让切换到下一个activity的停滞，并使用户感觉到迟缓。\n\n“之后可否被杀死？”列中标为“否”的方法，在它们被调用时的那一刻起，就会保护本activity的宿主进程不被杀掉。 因此，只有在 onPause() 方法返回时至 onResume() 方法被调用时之间，activity才会被杀掉。直到 onPause() 再次被调用并返回时，activity都不会再次允许被杀死。\n\nNote:表1中标明的技术上不“可杀”的activity仍然有可能会被系统杀死——但那只有在没有任何资源的极端情况下才会发生。     \n\n### 四 保存Activity的状态    \n上一节中已简单提到，当一个activity被paused或者stopped时，activity的状态可以被保存。 的确如此，因为 Activity 对象在paused或者stopped时仍然被保留在内存之中——它所有的成员信息和当前状态都仍然存活。 这样用户在activity里所作的改动全都还保存着，所以当activity返回到前台时（当它“resume“），那些改动仍然有效。\n\n不过，如果系统是为了回收内存而销毁activity，则这个 Activity 对象就会被销毁，这样系统就无法简单地resume一下就能还原完整状态的activity。 如果用户要返回到这个activity的话，系统必须重新创建这个Activity 对象。可是用户并不知道系统是先销毁activity再重新创建了它的，所以，他很可能希望activity完全保持原样。 这种情况下，你可以保证activity状态的相关重要信息都由另一个回调方法保存下来了，此方法让你能保存activity状态的相关信息： onSaveInstanceState()。\n\n在activity变得很容易被销毁之前，系统会调用 onSaveInstanceState()方法。 调用时系统会传入一个Bundle对象， 你可以利用 putString() 之类的方法，以键值对的方式来把activity状态信息保存到该Bundle对象中。 然后，如果系统杀掉了你的application进程并且用户又返回到你的activity，系统就会重建activity并将这个 Bundle 传入onCreate() 和onRestoreInstanceState() 中，你就可以从 Bundle 中解析出已保存信息并恢复activity状态。如果没有储存状态信息，那么传入的 Bundle 将为null（当activity第一次被创建时就是如此）。     \n下图是Activity状态保存示意图：      \n{% asset_img Activity状态保存示意图.png activity状态保存示意图 %}  \n### 五 配置改动后的处理   \n设备的某些配置可能会在运行时发生变化（比如屏幕方向、键盘可用性以及语言）。 当发生这些变化时，Android会重建这个运行中的activity（系统会调用 onDestroy() ，然后再马上调用 onCreate() ）。这种设计有助于应用程序适用新的参数配置，通过把你预置的可替换资源（比如对应各种屏幕方向和尺寸的layout）自动重新装载进入应用程序的方式来实现。\n\n如果你采取了适当的设计，让activity能够正确地处理这些因为屏幕方向而引起的重启，并能如上所述地恢复activity状态， 那么你的应用程序将对生命周期中其它的意外事件更具适应能力。\n\n处理这类重启的最佳方式，就是利用 onSaveInstanceState() 和onRestoreInstanceState() （或者 onCreate() ）进行状态的保存和恢复，如上节所述。   \n\n### 六 Activity的启动方式   \nantivity的启动方式可以通过两种方式定义：     \n\n##### Androidmanifest文件       \nAndroidmanifest文件是android的清单文件，android的四大组件与相应权限皆需在这里设置。在这里你可以利用 <activity> 元素的 launchMode 属性来设定 activity 与 task 的关系。       \n可通过Androidmanifest文件设置的启动模式有：      \n- standard\n- singleTop\n- singleTask\n- singleInstance       \n\n##### Intent标志     \nIntent标志中有以下几种Activity的启动方式:       \n- FLAG_ACTIVITY_NEW_TASK\n- FLAG_ACTIVITY_SINGLE_TOP\n- FLAG_ACTIVITY_CLEAR_TOP       \n通过Intent标志的方式来启动Activity，优先级比manifest的高。    \n\n> **警告**： 大多数应用不应该改变 activity 和 task 默认的工作方式。 如果你确定有必要修改默认方式，请保持\n谨慎，并确保 activity 在启动和从其它 activity 用回退键返回时的可用性。 请确保对可能与用户预期的导航方式\n相冲突的地方进行测试。      \n\n### 七 启动Activity  \n要启动一个activity需要使用Intent，实际上android中组件之前的通信皆由Intent完成（如果你不了解Intent，请看我之后的博客[android基础之Intents与Intent-Filters.md](android基础之Intents与Intent-Filters.md \"android基础之Intents与Intent-Filters\")），而使用Intent启动activity有显示和隐式两种方式。   \n\n\n##### 显示启动      \n\n     \n```java\nIntent intent = new Intent(this, SignInActivity.class);\nstartActivity(intent);//显示启动一个叫SignInActivity的Activity    \n\n```   \n\n\n\n#####  隐式启动    \n要想隐式启动一个activity，你需要使用intent-filter来暴露你的activity。使用filter有java代码和xml文件两种方式，推荐使用第二种方式，你只需在Androidmanifest.xml文件中的activit元素中加入intent-filter属性，并声明一个action即可。但是如果你想使你的activity更独立，那么就不要为你的activity设置filter。那么什么时候使用这种方式呢？    \n如果，你的程序可能想要展示某些动作，例如发邮件，短信，微博，或者使用你activity中的数据。 这时候，你就不应该使用自己的activity来做这些工作。你应该调用系统中其他程序提供的响应功能。 这是intent真正体现其价值的地方。你可以创建一个描述了响应动作的intent,然后系统来为你挑选完成任务的程序。 如果有多个选择，系统会提示用户进行选择。例如你想让用户发邮件，你可以创建下面的intent：        \n\n\n```java\nIntent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_EMAIL, recipientArray);//recipientArray即你想发送过去的联系人信息\nstartActivity(intent);    \n\n```       \n\n##### 启动一个带返回结果的Activity    \n有时候，你想要启动一个activity,并从这个activty获得一个结果。 这时，要通过 startActivityForResult() (取代startActivity()) 来启动activity。 然后通过实现onActivityResult()回调方法来获得返回后的结果。 当这个后续的activity被关闭，它将发送一个 Intent 给 onActivityResult() 方法。     \n  \n例如，你可能想要取一个联系人的信息。下面介绍怎么创建intent并处理结果:         \n\n\n```java\nprivate void pickContact() {\n    // Create an intent to \"pick\" a contact, as defined by the content provider URI\n    Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);\n    startActivityForResult(intent, PICK_CONTACT_REQUEST);\n}\n\n@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    // If the request went well (OK) and the request was PICK_CONTACT_REQUEST\n    if (resultCode == Activity.RESULT_OK && requestCode == PICK_CONTACT_REQUEST) {\n        // Perform a query to the contact's content provider for the contact's name\n        Cursor cursor = getContentResolver().query(data.getData(),\n        new String[] {Contacts.DISPLAY_NAME}, null, null, null);\n        if (cursor.moveToFirst()) { // True if the cursor is not empty\n            int columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);\n            String name = cursor.getString(columnIndex);\n            // Do something with the selected contact's name...\n        }\n    }\n}       \n\n```      \n\n\n这个例子展示了使用onActivityResult() 来获取结果的基本方法。 第一步要判断请求是否被成功响应，通过判断resultCode 是不是RESULT_OK—， 然后判断这个响应是不是针对相应的请求— ，此时只要判断requestCode 和发送时提供的第二个参数 startActivityForResult() 是否相匹配。 最后，查询 Intent中的data信息。 (data 参数)。\n\n这个过程中，ContentResolver 开启了一个查询而不是content provider, 它返回一个 Cursor ，这将允许数据被读取。更多content provider相关信息，请阅读我之后的博客[android基础之Content-Providers.md](android基础之Content-Providers.md \"android基础之Content-Providers\")。     \n\n##### 关闭activity    \n你可以通过调用finish() 来终止activity。 你也可以调用finishActivity() 来终止你之前启动了的一个独立activity。    \n\n> **注意**: 多数情况下，你不应该明确地通过这些方式来关闭acitivity。 就像下面要讨论的activity的生命周期。系统会为你管理。所以你不必关闭他们。 调用这些方法将有悖于用户体验。它们仅用于你绝对不想让用户再返回这个activity的实例。   \n\n\n### 八 Task和back stack    \n一个app通常包含多个activity，android使用task来管理这些activity。当你在手机上没点开一个app，android即为这个app创建一个task，task中有一个back stack，你多点开的activity将依次入栈或者出栈，若你的activity调用别的应用的activity，它也会被压入本activity中。（activity与back stack的关系可阅读上文的activity的启动方式，它定义了activity在back stack中的存在方式）。    \n一个app即对应一个task，若你点开一个新的app，则该新app会进入前台，而之前的会被调入后台。当android的内存不足时，后台的task则可能被销毁。    \n\n其实，activity所处的task可以通过<activity>元素的taskAffinity属性指定，taskAffinity 属性是一个字符串值，必须与<manifest> 元素定义的包名称保证唯一性，因为系统把这个包名称用于标识应用的默认 task affinity值。但是，注意，一般情况下如无必要，不要去修改taskAffinity的值。    \n### 九 总结    \n到这里，android的activity相关的知识已经介绍的差不多了，但是这其中还有很多细节需要读者自己去发现。我所说的并不全面，有些地方可能还有谬误，万不可全信，这些仅仅是我个人的理解。其实博客的功能也只是让你对一个陌生的事物知道个大概，要想最终精通还需要多写多做。这些东西你只有自己经历了，研究了它才能成为你自己的东西，否则不过是镜花水月。   \n作为一个程序员最重要的是勤劳，最后以一句话与大家共勉：慈不掌兵，义不行贾，懒不撸码。\n   \n\n","source":"_posts/android基础之activity.md","raw":"---\ntitle: android基础之activity\ndate: 2017-02-27 10:35:34\ncategories: android\ntags:\n- java\n- android\n- activity\n---\n\n### 一 Activity简介   \nactivity是android四大组件之一，用于android app的界面显示。activity中包含一个window，window中则包含包含相应的view。\n\n### 二 Activity类的层次结构    \n继承的抽象类： ContextThemeWrapper\n实现的接口： ComponentCallbacks2 KeyEvent.Callback LayoutInflater.Factory2 View.OnCreateContextMenuListener Window.Callback      \n\n```java   \njava.lang.Object   \n\tandroid.content.Context\n\t\tandroid.content.ContextWrapper\n\t\t\tandroid.content.ContextThemeWrapper\n\t\t\t\tandroid.app.Activity\n```\n\n直接子类： AccountAuthenticatorActivity, ActivityGroup, AliasActivity, ExpandableListActivity, FragmentActivity, ListActivity, NativeActivity 　　　\n间接子类： ActionBarActivity, LauncherActivity, PreferenceActivity, TabActivity 　　　\n\n### 三 Activity的生命周期   　\nActivity在它的一生中有以下四种状态：  \n- running：此时Activity处于屏幕的前台并且拥有焦点，位于回退栈的顶部（回退栈将在下面介绍）。   \n- paused： 此时另一个Activity位于前台并拥有焦点，也就是说另一个Activity覆盖在本Activity的上面，但是这个Activity是透明的或者没有占据全屏，即从屏幕上还可以看到下面的Activity（比如弹出个红包）。一个paused的activity是完全存活的（Activity 对象仍然保留在内存里，它保持着所有的状态和成员信息，并且保持与window manager的联接），但在系统内存严重不足的情况下它能被杀死。    \n- stopped： 本Activity被其他Activity完全覆盖了，看不见了。一个stopped的activity也仍然是存活的（Activity 对象仍然保留在内存中，它保持着所有的状态和成员信息，但是不再与window manager联接了）。 但是，对于用户而言它已经不再可见了，并且当其它地方需要内存时它将会被杀死。    \n- killed： 当Activity处于paused或者stopped时，若内存不足，它将可能被干掉。当它被再次创建处于前台时，需要调用onCreate方法重新创建并恢复之前的状态    \n下面是activity的生命周期图：      \n{% asset_img activity生命周期图.png activity生命周期图 %}       \n由上图可以看出activity有三种不同的生命周期：　　\n- 完整生命周期： onCreate--onDestroy    \n- 可见生命周期： onResume到onPause之间循环    \n- 前台生命周期： onStart-onStop-onRestart三者之间循环    \nActivity中的回调方法    \n\n```java\npublic class ExampleActivity extends Activity {\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        // The activity is being created.\n    }\n    @Override\n    protected void onStart() {\n        super.onStart();\n        // The activity is about to become visible.\n    }\n    @Override\n    protected void onResume() {\n        super.onResume();\n        // The activity has become visible (it is now \"resumed\").\n    }\n    @Override\n    protected void onPause() {\n        super.onPause();\n        // Another activity is taking focus (this activity is about to be \"paused\").\n    }\n    @Override\n    protected void onStop() {\n        super.onStop();\n        // The activity is no longer visible (it is now \"stopped\")\n    }\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        // The activity is about to be destroyed.\n    }\n}\n```\n \nActivity回调方法汇总：       \n{% asset_img activity回调方法汇总.png activity回调方法汇总 %}       \n标为“之后可否被杀死？”的列指明了系统是否可以在这个方法返回之后的任意时刻杀掉这个activity的宿主进程， 而不再执行其它流程上的activity代码。 有三个方法是标为“可以”：（ onPause()、 onStop()、 和onDestroy()）。 因为onPause()是三个方法中的第一个， 一旦activity被创建， onPause() 就是进程可以被杀死之前最后一个能确保被调用的方法 ——如果系统在某种紧急情况下必须回收内存，则 onStop() 和onDestroy() 可能就不会被调用了。因此，你应该使用 onPause() 来把至关重要的需长期保存的数据写入存储器（比如用户所编辑的内容）。 不过，应该对必须通过 onPause() 方法进行保存的信息有所选择，因为该方法中所有的阻塞操作都会让切换到下一个activity的停滞，并使用户感觉到迟缓。\n\n“之后可否被杀死？”列中标为“否”的方法，在它们被调用时的那一刻起，就会保护本activity的宿主进程不被杀掉。 因此，只有在 onPause() 方法返回时至 onResume() 方法被调用时之间，activity才会被杀掉。直到 onPause() 再次被调用并返回时，activity都不会再次允许被杀死。\n\nNote:表1中标明的技术上不“可杀”的activity仍然有可能会被系统杀死——但那只有在没有任何资源的极端情况下才会发生。     \n\n### 四 保存Activity的状态    \n上一节中已简单提到，当一个activity被paused或者stopped时，activity的状态可以被保存。 的确如此，因为 Activity 对象在paused或者stopped时仍然被保留在内存之中——它所有的成员信息和当前状态都仍然存活。 这样用户在activity里所作的改动全都还保存着，所以当activity返回到前台时（当它“resume“），那些改动仍然有效。\n\n不过，如果系统是为了回收内存而销毁activity，则这个 Activity 对象就会被销毁，这样系统就无法简单地resume一下就能还原完整状态的activity。 如果用户要返回到这个activity的话，系统必须重新创建这个Activity 对象。可是用户并不知道系统是先销毁activity再重新创建了它的，所以，他很可能希望activity完全保持原样。 这种情况下，你可以保证activity状态的相关重要信息都由另一个回调方法保存下来了，此方法让你能保存activity状态的相关信息： onSaveInstanceState()。\n\n在activity变得很容易被销毁之前，系统会调用 onSaveInstanceState()方法。 调用时系统会传入一个Bundle对象， 你可以利用 putString() 之类的方法，以键值对的方式来把activity状态信息保存到该Bundle对象中。 然后，如果系统杀掉了你的application进程并且用户又返回到你的activity，系统就会重建activity并将这个 Bundle 传入onCreate() 和onRestoreInstanceState() 中，你就可以从 Bundle 中解析出已保存信息并恢复activity状态。如果没有储存状态信息，那么传入的 Bundle 将为null（当activity第一次被创建时就是如此）。     \n下图是Activity状态保存示意图：      \n{% asset_img Activity状态保存示意图.png activity状态保存示意图 %}  \n### 五 配置改动后的处理   \n设备的某些配置可能会在运行时发生变化（比如屏幕方向、键盘可用性以及语言）。 当发生这些变化时，Android会重建这个运行中的activity（系统会调用 onDestroy() ，然后再马上调用 onCreate() ）。这种设计有助于应用程序适用新的参数配置，通过把你预置的可替换资源（比如对应各种屏幕方向和尺寸的layout）自动重新装载进入应用程序的方式来实现。\n\n如果你采取了适当的设计，让activity能够正确地处理这些因为屏幕方向而引起的重启，并能如上所述地恢复activity状态， 那么你的应用程序将对生命周期中其它的意外事件更具适应能力。\n\n处理这类重启的最佳方式，就是利用 onSaveInstanceState() 和onRestoreInstanceState() （或者 onCreate() ）进行状态的保存和恢复，如上节所述。   \n\n### 六 Activity的启动方式   \nantivity的启动方式可以通过两种方式定义：     \n\n##### Androidmanifest文件       \nAndroidmanifest文件是android的清单文件，android的四大组件与相应权限皆需在这里设置。在这里你可以利用 <activity> 元素的 launchMode 属性来设定 activity 与 task 的关系。       \n可通过Androidmanifest文件设置的启动模式有：      \n- standard\n- singleTop\n- singleTask\n- singleInstance       \n\n##### Intent标志     \nIntent标志中有以下几种Activity的启动方式:       \n- FLAG_ACTIVITY_NEW_TASK\n- FLAG_ACTIVITY_SINGLE_TOP\n- FLAG_ACTIVITY_CLEAR_TOP       \n通过Intent标志的方式来启动Activity，优先级比manifest的高。    \n\n> **警告**： 大多数应用不应该改变 activity 和 task 默认的工作方式。 如果你确定有必要修改默认方式，请保持\n谨慎，并确保 activity 在启动和从其它 activity 用回退键返回时的可用性。 请确保对可能与用户预期的导航方式\n相冲突的地方进行测试。      \n\n### 七 启动Activity  \n要启动一个activity需要使用Intent，实际上android中组件之前的通信皆由Intent完成（如果你不了解Intent，请看我之后的博客[android基础之Intents与Intent-Filters.md](android基础之Intents与Intent-Filters.md \"android基础之Intents与Intent-Filters\")），而使用Intent启动activity有显示和隐式两种方式。   \n\n\n##### 显示启动      \n\n     \n```java\nIntent intent = new Intent(this, SignInActivity.class);\nstartActivity(intent);//显示启动一个叫SignInActivity的Activity    \n\n```   \n\n\n\n#####  隐式启动    \n要想隐式启动一个activity，你需要使用intent-filter来暴露你的activity。使用filter有java代码和xml文件两种方式，推荐使用第二种方式，你只需在Androidmanifest.xml文件中的activit元素中加入intent-filter属性，并声明一个action即可。但是如果你想使你的activity更独立，那么就不要为你的activity设置filter。那么什么时候使用这种方式呢？    \n如果，你的程序可能想要展示某些动作，例如发邮件，短信，微博，或者使用你activity中的数据。 这时候，你就不应该使用自己的activity来做这些工作。你应该调用系统中其他程序提供的响应功能。 这是intent真正体现其价值的地方。你可以创建一个描述了响应动作的intent,然后系统来为你挑选完成任务的程序。 如果有多个选择，系统会提示用户进行选择。例如你想让用户发邮件，你可以创建下面的intent：        \n\n\n```java\nIntent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_EMAIL, recipientArray);//recipientArray即你想发送过去的联系人信息\nstartActivity(intent);    \n\n```       \n\n##### 启动一个带返回结果的Activity    \n有时候，你想要启动一个activity,并从这个activty获得一个结果。 这时，要通过 startActivityForResult() (取代startActivity()) 来启动activity。 然后通过实现onActivityResult()回调方法来获得返回后的结果。 当这个后续的activity被关闭，它将发送一个 Intent 给 onActivityResult() 方法。     \n  \n例如，你可能想要取一个联系人的信息。下面介绍怎么创建intent并处理结果:         \n\n\n```java\nprivate void pickContact() {\n    // Create an intent to \"pick\" a contact, as defined by the content provider URI\n    Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);\n    startActivityForResult(intent, PICK_CONTACT_REQUEST);\n}\n\n@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    // If the request went well (OK) and the request was PICK_CONTACT_REQUEST\n    if (resultCode == Activity.RESULT_OK && requestCode == PICK_CONTACT_REQUEST) {\n        // Perform a query to the contact's content provider for the contact's name\n        Cursor cursor = getContentResolver().query(data.getData(),\n        new String[] {Contacts.DISPLAY_NAME}, null, null, null);\n        if (cursor.moveToFirst()) { // True if the cursor is not empty\n            int columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);\n            String name = cursor.getString(columnIndex);\n            // Do something with the selected contact's name...\n        }\n    }\n}       \n\n```      \n\n\n这个例子展示了使用onActivityResult() 来获取结果的基本方法。 第一步要判断请求是否被成功响应，通过判断resultCode 是不是RESULT_OK—， 然后判断这个响应是不是针对相应的请求— ，此时只要判断requestCode 和发送时提供的第二个参数 startActivityForResult() 是否相匹配。 最后，查询 Intent中的data信息。 (data 参数)。\n\n这个过程中，ContentResolver 开启了一个查询而不是content provider, 它返回一个 Cursor ，这将允许数据被读取。更多content provider相关信息，请阅读我之后的博客[android基础之Content-Providers.md](android基础之Content-Providers.md \"android基础之Content-Providers\")。     \n\n##### 关闭activity    \n你可以通过调用finish() 来终止activity。 你也可以调用finishActivity() 来终止你之前启动了的一个独立activity。    \n\n> **注意**: 多数情况下，你不应该明确地通过这些方式来关闭acitivity。 就像下面要讨论的activity的生命周期。系统会为你管理。所以你不必关闭他们。 调用这些方法将有悖于用户体验。它们仅用于你绝对不想让用户再返回这个activity的实例。   \n\n\n### 八 Task和back stack    \n一个app通常包含多个activity，android使用task来管理这些activity。当你在手机上没点开一个app，android即为这个app创建一个task，task中有一个back stack，你多点开的activity将依次入栈或者出栈，若你的activity调用别的应用的activity，它也会被压入本activity中。（activity与back stack的关系可阅读上文的activity的启动方式，它定义了activity在back stack中的存在方式）。    \n一个app即对应一个task，若你点开一个新的app，则该新app会进入前台，而之前的会被调入后台。当android的内存不足时，后台的task则可能被销毁。    \n\n其实，activity所处的task可以通过<activity>元素的taskAffinity属性指定，taskAffinity 属性是一个字符串值，必须与<manifest> 元素定义的包名称保证唯一性，因为系统把这个包名称用于标识应用的默认 task affinity值。但是，注意，一般情况下如无必要，不要去修改taskAffinity的值。    \n### 九 总结    \n到这里，android的activity相关的知识已经介绍的差不多了，但是这其中还有很多细节需要读者自己去发现。我所说的并不全面，有些地方可能还有谬误，万不可全信，这些仅仅是我个人的理解。其实博客的功能也只是让你对一个陌生的事物知道个大概，要想最终精通还需要多写多做。这些东西你只有自己经历了，研究了它才能成为你自己的东西，否则不过是镜花水月。   \n作为一个程序员最重要的是勤劳，最后以一句话与大家共勉：慈不掌兵，义不行贾，懒不撸码。\n   \n\n","slug":"android基础之activity","published":1,"updated":"2017-03-04T09:08:24.198Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj02g6gsi000b7c0211k1gz2w","content":"<h3 id=\"一-Activity简介\"><a href=\"#一-Activity简介\" class=\"headerlink\" title=\"一 Activity简介\"></a>一 Activity简介</h3><p>activity是android四大组件之一，用于android app的界面显示。activity中包含一个window，window中则包含包含相应的view。</p>\n<h3 id=\"二-Activity类的层次结构\"><a href=\"#二-Activity类的层次结构\" class=\"headerlink\" title=\"二 Activity类的层次结构\"></a>二 Activity类的层次结构</h3><p>继承的抽象类： ContextThemeWrapper<br>实现的接口： ComponentCallbacks2 KeyEvent.Callback LayoutInflater.Factory2 View.OnCreateContextMenuListener Window.Callback      </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.lang.Object   </div><div class=\"line\">\tandroid.content.Context</div><div class=\"line\">\t\tandroid.content.ContextWrapper</div><div class=\"line\">\t\t\tandroid.content.ContextThemeWrapper</div><div class=\"line\">\t\t\t\tandroid.app.Activity</div></pre></td></tr></table></figure>\n<p>直接子类： AccountAuthenticatorActivity, ActivityGroup, AliasActivity, ExpandableListActivity, FragmentActivity, ListActivity, NativeActivity 　　　<br>间接子类： ActionBarActivity, LauncherActivity, PreferenceActivity, TabActivity 　　　</p>\n<h3 id=\"三-Activity的生命周期\"><a href=\"#三-Activity的生命周期\" class=\"headerlink\" title=\"三 Activity的生命周期   　\"></a>三 Activity的生命周期   　</h3><p>Activity在它的一生中有以下四种状态：  </p>\n<ul>\n<li>running：此时Activity处于屏幕的前台并且拥有焦点，位于回退栈的顶部（回退栈将在下面介绍）。   </li>\n<li>paused： 此时另一个Activity位于前台并拥有焦点，也就是说另一个Activity覆盖在本Activity的上面，但是这个Activity是透明的或者没有占据全屏，即从屏幕上还可以看到下面的Activity（比如弹出个红包）。一个paused的activity是完全存活的（Activity 对象仍然保留在内存里，它保持着所有的状态和成员信息，并且保持与window manager的联接），但在系统内存严重不足的情况下它能被杀死。    </li>\n<li>stopped： 本Activity被其他Activity完全覆盖了，看不见了。一个stopped的activity也仍然是存活的（Activity 对象仍然保留在内存中，它保持着所有的状态和成员信息，但是不再与window manager联接了）。 但是，对于用户而言它已经不再可见了，并且当其它地方需要内存时它将会被杀死。    </li>\n<li>killed： 当Activity处于paused或者stopped时，若内存不足，它将可能被干掉。当它被再次创建处于前台时，需要调用onCreate方法重新创建并恢复之前的状态<br>下面是activity的生命周期图：      <img src=\"/2017/02/27/android基础之activity/activity生命周期图.png\" alt=\"activity生命周期图\" title=\"activity生命周期图\">       \n由上图可以看出activity有三种不同的生命周期：　　</li>\n<li>完整生命周期： onCreate–onDestroy    </li>\n<li>可见生命周期： onResume到onPause之间循环    </li>\n<li>前台生命周期： onStart-onStop-onRestart三者之间循环<br>Activity中的回调方法    </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        <span class=\"comment\">// The activity is being created.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onStart();</div><div class=\"line\">        <span class=\"comment\">// The activity is about to become visible.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onResume();</div><div class=\"line\">        <span class=\"comment\">// The activity has become visible (it is now \"resumed\").</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onPause();</div><div class=\"line\">        <span class=\"comment\">// Another activity is taking focus (this activity is about to be \"paused\").</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onStop();</div><div class=\"line\">        <span class=\"comment\">// The activity is no longer visible (it is now \"stopped\")</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</div><div class=\"line\">        <span class=\"comment\">// The activity is about to be destroyed.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Activity回调方法汇总：<br><img src=\"/2017/02/27/android基础之activity/activity回调方法汇总.png\" alt=\"activity回调方法汇总\" title=\"activity回调方法汇总\"><br>标为“之后可否被杀死？”的列指明了系统是否可以在这个方法返回之后的任意时刻杀掉这个activity的宿主进程， 而不再执行其它流程上的activity代码。 有三个方法是标为“可以”：（ onPause()、 onStop()、 和onDestroy()）。 因为onPause()是三个方法中的第一个， 一旦activity被创建， onPause() 就是进程可以被杀死之前最后一个能确保被调用的方法 ——如果系统在某种紧急情况下必须回收内存，则 onStop() 和onDestroy() 可能就不会被调用了。因此，你应该使用 onPause() 来把至关重要的需长期保存的数据写入存储器（比如用户所编辑的内容）。 不过，应该对必须通过 onPause() 方法进行保存的信息有所选择，因为该方法中所有的阻塞操作都会让切换到下一个activity的停滞，并使用户感觉到迟缓。</p>\n<p>“之后可否被杀死？”列中标为“否”的方法，在它们被调用时的那一刻起，就会保护本activity的宿主进程不被杀掉。 因此，只有在 onPause() 方法返回时至 onResume() 方法被调用时之间，activity才会被杀掉。直到 onPause() 再次被调用并返回时，activity都不会再次允许被杀死。</p>\n<p>Note:表1中标明的技术上不“可杀”的activity仍然有可能会被系统杀死——但那只有在没有任何资源的极端情况下才会发生。     </p>\n<h3 id=\"四-保存Activity的状态\"><a href=\"#四-保存Activity的状态\" class=\"headerlink\" title=\"四 保存Activity的状态\"></a>四 保存Activity的状态</h3><p>上一节中已简单提到，当一个activity被paused或者stopped时，activity的状态可以被保存。 的确如此，因为 Activity 对象在paused或者stopped时仍然被保留在内存之中——它所有的成员信息和当前状态都仍然存活。 这样用户在activity里所作的改动全都还保存着，所以当activity返回到前台时（当它“resume“），那些改动仍然有效。</p>\n<p>不过，如果系统是为了回收内存而销毁activity，则这个 Activity 对象就会被销毁，这样系统就无法简单地resume一下就能还原完整状态的activity。 如果用户要返回到这个activity的话，系统必须重新创建这个Activity 对象。可是用户并不知道系统是先销毁activity再重新创建了它的，所以，他很可能希望activity完全保持原样。 这种情况下，你可以保证activity状态的相关重要信息都由另一个回调方法保存下来了，此方法让你能保存activity状态的相关信息： onSaveInstanceState()。</p>\n<p>在activity变得很容易被销毁之前，系统会调用 onSaveInstanceState()方法。 调用时系统会传入一个Bundle对象， 你可以利用 putString() 之类的方法，以键值对的方式来把activity状态信息保存到该Bundle对象中。 然后，如果系统杀掉了你的application进程并且用户又返回到你的activity，系统就会重建activity并将这个 Bundle 传入onCreate() 和onRestoreInstanceState() 中，你就可以从 Bundle 中解析出已保存信息并恢复activity状态。如果没有储存状态信息，那么传入的 Bundle 将为null（当activity第一次被创建时就是如此）。<br>下图是Activity状态保存示意图：<br><img src=\"/2017/02/27/android基础之activity/Activity状态保存示意图.png\" alt=\"activity状态保存示意图\" title=\"activity状态保存示意图\">  </p>\n<h3 id=\"五-配置改动后的处理\"><a href=\"#五-配置改动后的处理\" class=\"headerlink\" title=\"五 配置改动后的处理\"></a>五 配置改动后的处理</h3><p>设备的某些配置可能会在运行时发生变化（比如屏幕方向、键盘可用性以及语言）。 当发生这些变化时，Android会重建这个运行中的activity（系统会调用 onDestroy() ，然后再马上调用 onCreate() ）。这种设计有助于应用程序适用新的参数配置，通过把你预置的可替换资源（比如对应各种屏幕方向和尺寸的layout）自动重新装载进入应用程序的方式来实现。</p>\n<p>如果你采取了适当的设计，让activity能够正确地处理这些因为屏幕方向而引起的重启，并能如上所述地恢复activity状态， 那么你的应用程序将对生命周期中其它的意外事件更具适应能力。</p>\n<p>处理这类重启的最佳方式，就是利用 onSaveInstanceState() 和onRestoreInstanceState() （或者 onCreate() ）进行状态的保存和恢复，如上节所述。   </p>\n<h3 id=\"六-Activity的启动方式\"><a href=\"#六-Activity的启动方式\" class=\"headerlink\" title=\"六 Activity的启动方式\"></a>六 Activity的启动方式</h3><p>antivity的启动方式可以通过两种方式定义：     </p>\n<h5 id=\"Androidmanifest文件\"><a href=\"#Androidmanifest文件\" class=\"headerlink\" title=\"Androidmanifest文件\"></a>Androidmanifest文件</h5><p>Androidmanifest文件是android的清单文件，android的四大组件与相应权限皆需在这里设置。在这里你可以利用 <activity> 元素的 launchMode 属性来设定 activity 与 task 的关系。<br>可通过Androidmanifest文件设置的启动模式有：      </activity></p>\n<ul>\n<li>standard</li>\n<li>singleTop</li>\n<li>singleTask</li>\n<li>singleInstance       </li>\n</ul>\n<h5 id=\"Intent标志\"><a href=\"#Intent标志\" class=\"headerlink\" title=\"Intent标志\"></a>Intent标志</h5><p>Intent标志中有以下几种Activity的启动方式:       </p>\n<ul>\n<li>FLAG_ACTIVITY_NEW_TASK</li>\n<li>FLAG_ACTIVITY_SINGLE_TOP</li>\n<li>FLAG_ACTIVITY_CLEAR_TOP<br>通过Intent标志的方式来启动Activity，优先级比manifest的高。    </li>\n</ul>\n<blockquote>\n<p><strong>警告</strong>： 大多数应用不应该改变 activity 和 task 默认的工作方式。 如果你确定有必要修改默认方式，请保持<br>谨慎，并确保 activity 在启动和从其它 activity 用回退键返回时的可用性。 请确保对可能与用户预期的导航方式<br>相冲突的地方进行测试。      </p>\n</blockquote>\n<h3 id=\"七-启动Activity\"><a href=\"#七-启动Activity\" class=\"headerlink\" title=\"七 启动Activity\"></a>七 启动Activity</h3><p>要启动一个activity需要使用Intent，实际上android中组件之前的通信皆由Intent完成（如果你不了解Intent，请看我之后的博客<a href=\"android基础之Intents与Intent-Filters.md\" title=\"android基础之Intents与Intent-Filters\">android基础之Intents与Intent-Filters.md</a>），而使用Intent启动activity有显示和隐式两种方式。   </p>\n<h5 id=\"显示启动\"><a href=\"#显示启动\" class=\"headerlink\" title=\"显示启动\"></a>显示启动</h5><pre><code class=\"java\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, SignInActivity.class);\nstartActivity(intent);<span class=\"comment\">//显示启动一个叫SignInActivity的Activity</span>\n</code></pre>\n<h5 id=\"隐式启动\"><a href=\"#隐式启动\" class=\"headerlink\" title=\"隐式启动\"></a>隐式启动</h5><p>要想隐式启动一个activity，你需要使用intent-filter来暴露你的activity。使用filter有java代码和xml文件两种方式，推荐使用第二种方式，你只需在Androidmanifest.xml文件中的activit元素中加入intent-filter属性，并声明一个action即可。但是如果你想使你的activity更独立，那么就不要为你的activity设置filter。那么什么时候使用这种方式呢？<br>如果，你的程序可能想要展示某些动作，例如发邮件，短信，微博，或者使用你activity中的数据。 这时候，你就不应该使用自己的activity来做这些工作。你应该调用系统中其他程序提供的响应功能。 这是intent真正体现其价值的地方。你可以创建一个描述了响应动作的intent,然后系统来为你挑选完成任务的程序。 如果有多个选择，系统会提示用户进行选择。例如你想让用户发邮件，你可以创建下面的intent：        </p>\n<pre><code class=\"java\">Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_EMAIL, recipientArray);<span class=\"comment\">//recipientArray即你想发送过去的联系人信息</span>\nstartActivity(intent);\n</code></pre>\n<h5 id=\"启动一个带返回结果的Activity\"><a href=\"#启动一个带返回结果的Activity\" class=\"headerlink\" title=\"启动一个带返回结果的Activity\"></a>启动一个带返回结果的Activity</h5><p>有时候，你想要启动一个activity,并从这个activty获得一个结果。 这时，要通过 startActivityForResult() (取代startActivity()) 来启动activity。 然后通过实现onActivityResult()回调方法来获得返回后的结果。 当这个后续的activity被关闭，它将发送一个 Intent 给 onActivityResult() 方法。     </p>\n<p>例如，你可能想要取一个联系人的信息。下面介绍怎么创建intent并处理结果:         </p>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">pickContact</span><span class=\"params\">()</span> </span>{\n    <span class=\"comment\">// Create an intent to \"pick\" a contact, as defined by the content provider URI</span>\n    Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);\n    startActivityForResult(intent, PICK_CONTACT_REQUEST);\n}\n\n<span class=\"meta\">@Override</span>\n<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> resultCode, Intent data)</span> </span>{\n    <span class=\"comment\">// If the request went well (OK) and the request was PICK_CONTACT_REQUEST</span>\n    <span class=\"keyword\">if</span> (resultCode == Activity.RESULT_OK &amp;&amp; requestCode == PICK_CONTACT_REQUEST) {\n        <span class=\"comment\">// Perform a query to the contact's content provider for the contact's name</span>\n        Cursor cursor = getContentResolver().query(data.getData(),\n        <span class=\"keyword\">new</span> String[] {Contacts.DISPLAY_NAME}, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);\n        <span class=\"keyword\">if</span> (cursor.moveToFirst()) { <span class=\"comment\">// True if the cursor is not empty</span>\n            <span class=\"keyword\">int</span> columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);\n            String name = cursor.getString(columnIndex);\n            <span class=\"comment\">// Do something with the selected contact's name...</span>\n        }\n    }\n}\n</code></pre>\n<p>这个例子展示了使用onActivityResult() 来获取结果的基本方法。 第一步要判断请求是否被成功响应，通过判断resultCode 是不是RESULT_OK—， 然后判断这个响应是不是针对相应的请求— ，此时只要判断requestCode 和发送时提供的第二个参数 startActivityForResult() 是否相匹配。 最后，查询 Intent中的data信息。 (data 参数)。</p>\n<p>这个过程中，ContentResolver 开启了一个查询而不是content provider, 它返回一个 Cursor ，这将允许数据被读取。更多content provider相关信息，请阅读我之后的博客<a href=\"android基础之Content-Providers.md\" title=\"android基础之Content-Providers\">android基础之Content-Providers.md</a>。     </p>\n<h5 id=\"关闭activity\"><a href=\"#关闭activity\" class=\"headerlink\" title=\"关闭activity\"></a>关闭activity</h5><p>你可以通过调用finish() 来终止activity。 你也可以调用finishActivity() 来终止你之前启动了的一个独立activity。    </p>\n<blockquote>\n<p><strong>注意</strong>: 多数情况下，你不应该明确地通过这些方式来关闭acitivity。 就像下面要讨论的activity的生命周期。系统会为你管理。所以你不必关闭他们。 调用这些方法将有悖于用户体验。它们仅用于你绝对不想让用户再返回这个activity的实例。   </p>\n</blockquote>\n<h3 id=\"八-Task和back-stack\"><a href=\"#八-Task和back-stack\" class=\"headerlink\" title=\"八 Task和back stack\"></a>八 Task和back stack</h3><p>一个app通常包含多个activity，android使用task来管理这些activity。当你在手机上没点开一个app，android即为这个app创建一个task，task中有一个back stack，你多点开的activity将依次入栈或者出栈，若你的activity调用别的应用的activity，它也会被压入本activity中。（activity与back stack的关系可阅读上文的activity的启动方式，它定义了activity在back stack中的存在方式）。<br>一个app即对应一个task，若你点开一个新的app，则该新app会进入前台，而之前的会被调入后台。当android的内存不足时，后台的task则可能被销毁。    </p>\n<p>其实，activity所处的task可以通过<activity>元素的taskAffinity属性指定，taskAffinity 属性是一个字符串值，必须与<manifest> 元素定义的包名称保证唯一性，因为系统把这个包名称用于标识应用的默认 task affinity值。但是，注意，一般情况下如无必要，不要去修改taskAffinity的值。    </manifest></activity></p>\n<h3 id=\"九-总结\"><a href=\"#九-总结\" class=\"headerlink\" title=\"九 总结\"></a>九 总结</h3><p>到这里，android的activity相关的知识已经介绍的差不多了，但是这其中还有很多细节需要读者自己去发现。我所说的并不全面，有些地方可能还有谬误，万不可全信，这些仅仅是我个人的理解。其实博客的功能也只是让你对一个陌生的事物知道个大概，要想最终精通还需要多写多做。这些东西你只有自己经历了，研究了它才能成为你自己的东西，否则不过是镜花水月。<br>作为一个程序员最重要的是勤劳，最后以一句话与大家共勉：慈不掌兵，义不行贾，懒不撸码。</p>\n","excerpt":"","more":"<h3 id=\"一-Activity简介\"><a href=\"#一-Activity简介\" class=\"headerlink\" title=\"一 Activity简介\"></a>一 Activity简介</h3><p>activity是android四大组件之一，用于android app的界面显示。activity中包含一个window，window中则包含包含相应的view。</p>\n<h3 id=\"二-Activity类的层次结构\"><a href=\"#二-Activity类的层次结构\" class=\"headerlink\" title=\"二 Activity类的层次结构\"></a>二 Activity类的层次结构</h3><p>继承的抽象类： ContextThemeWrapper<br>实现的接口： ComponentCallbacks2 KeyEvent.Callback LayoutInflater.Factory2 View.OnCreateContextMenuListener Window.Callback      </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.lang.Object   </div><div class=\"line\">\tandroid.content.Context</div><div class=\"line\">\t\tandroid.content.ContextWrapper</div><div class=\"line\">\t\t\tandroid.content.ContextThemeWrapper</div><div class=\"line\">\t\t\t\tandroid.app.Activity</div></pre></td></tr></table></figure>\n<p>直接子类： AccountAuthenticatorActivity, ActivityGroup, AliasActivity, ExpandableListActivity, FragmentActivity, ListActivity, NativeActivity 　　　<br>间接子类： ActionBarActivity, LauncherActivity, PreferenceActivity, TabActivity 　　　</p>\n<h3 id=\"三-Activity的生命周期\"><a href=\"#三-Activity的生命周期\" class=\"headerlink\" title=\"三 Activity的生命周期   　\"></a>三 Activity的生命周期   　</h3><p>Activity在它的一生中有以下四种状态：  </p>\n<ul>\n<li>running：此时Activity处于屏幕的前台并且拥有焦点，位于回退栈的顶部（回退栈将在下面介绍）。   </li>\n<li>paused： 此时另一个Activity位于前台并拥有焦点，也就是说另一个Activity覆盖在本Activity的上面，但是这个Activity是透明的或者没有占据全屏，即从屏幕上还可以看到下面的Activity（比如弹出个红包）。一个paused的activity是完全存活的（Activity 对象仍然保留在内存里，它保持着所有的状态和成员信息，并且保持与window manager的联接），但在系统内存严重不足的情况下它能被杀死。    </li>\n<li>stopped： 本Activity被其他Activity完全覆盖了，看不见了。一个stopped的activity也仍然是存活的（Activity 对象仍然保留在内存中，它保持着所有的状态和成员信息，但是不再与window manager联接了）。 但是，对于用户而言它已经不再可见了，并且当其它地方需要内存时它将会被杀死。    </li>\n<li>killed： 当Activity处于paused或者stopped时，若内存不足，它将可能被干掉。当它被再次创建处于前台时，需要调用onCreate方法重新创建并恢复之前的状态<br>下面是activity的生命周期图：      <img src=\"/2017/02/27/android基础之activity/activity生命周期图.png\" alt=\"activity生命周期图\" title=\"activity生命周期图\">       \n由上图可以看出activity有三种不同的生命周期：　　</li>\n<li>完整生命周期： onCreate–onDestroy    </li>\n<li>可见生命周期： onResume到onPause之间循环    </li>\n<li>前台生命周期： onStart-onStop-onRestart三者之间循环<br>Activity中的回调方法    </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        <span class=\"comment\">// The activity is being created.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onStart();</div><div class=\"line\">        <span class=\"comment\">// The activity is about to become visible.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onResume();</div><div class=\"line\">        <span class=\"comment\">// The activity has become visible (it is now \"resumed\").</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onPause();</div><div class=\"line\">        <span class=\"comment\">// Another activity is taking focus (this activity is about to be \"paused\").</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onStop();</div><div class=\"line\">        <span class=\"comment\">// The activity is no longer visible (it is now \"stopped\")</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</div><div class=\"line\">        <span class=\"comment\">// The activity is about to be destroyed.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Activity回调方法汇总：<br><img src=\"/2017/02/27/android基础之activity/activity回调方法汇总.png\" alt=\"activity回调方法汇总\" title=\"activity回调方法汇总\"><br>标为“之后可否被杀死？”的列指明了系统是否可以在这个方法返回之后的任意时刻杀掉这个activity的宿主进程， 而不再执行其它流程上的activity代码。 有三个方法是标为“可以”：（ onPause()、 onStop()、 和onDestroy()）。 因为onPause()是三个方法中的第一个， 一旦activity被创建， onPause() 就是进程可以被杀死之前最后一个能确保被调用的方法 ——如果系统在某种紧急情况下必须回收内存，则 onStop() 和onDestroy() 可能就不会被调用了。因此，你应该使用 onPause() 来把至关重要的需长期保存的数据写入存储器（比如用户所编辑的内容）。 不过，应该对必须通过 onPause() 方法进行保存的信息有所选择，因为该方法中所有的阻塞操作都会让切换到下一个activity的停滞，并使用户感觉到迟缓。</p>\n<p>“之后可否被杀死？”列中标为“否”的方法，在它们被调用时的那一刻起，就会保护本activity的宿主进程不被杀掉。 因此，只有在 onPause() 方法返回时至 onResume() 方法被调用时之间，activity才会被杀掉。直到 onPause() 再次被调用并返回时，activity都不会再次允许被杀死。</p>\n<p>Note:表1中标明的技术上不“可杀”的activity仍然有可能会被系统杀死——但那只有在没有任何资源的极端情况下才会发生。     </p>\n<h3 id=\"四-保存Activity的状态\"><a href=\"#四-保存Activity的状态\" class=\"headerlink\" title=\"四 保存Activity的状态\"></a>四 保存Activity的状态</h3><p>上一节中已简单提到，当一个activity被paused或者stopped时，activity的状态可以被保存。 的确如此，因为 Activity 对象在paused或者stopped时仍然被保留在内存之中——它所有的成员信息和当前状态都仍然存活。 这样用户在activity里所作的改动全都还保存着，所以当activity返回到前台时（当它“resume“），那些改动仍然有效。</p>\n<p>不过，如果系统是为了回收内存而销毁activity，则这个 Activity 对象就会被销毁，这样系统就无法简单地resume一下就能还原完整状态的activity。 如果用户要返回到这个activity的话，系统必须重新创建这个Activity 对象。可是用户并不知道系统是先销毁activity再重新创建了它的，所以，他很可能希望activity完全保持原样。 这种情况下，你可以保证activity状态的相关重要信息都由另一个回调方法保存下来了，此方法让你能保存activity状态的相关信息： onSaveInstanceState()。</p>\n<p>在activity变得很容易被销毁之前，系统会调用 onSaveInstanceState()方法。 调用时系统会传入一个Bundle对象， 你可以利用 putString() 之类的方法，以键值对的方式来把activity状态信息保存到该Bundle对象中。 然后，如果系统杀掉了你的application进程并且用户又返回到你的activity，系统就会重建activity并将这个 Bundle 传入onCreate() 和onRestoreInstanceState() 中，你就可以从 Bundle 中解析出已保存信息并恢复activity状态。如果没有储存状态信息，那么传入的 Bundle 将为null（当activity第一次被创建时就是如此）。<br>下图是Activity状态保存示意图：<br><img src=\"/2017/02/27/android基础之activity/Activity状态保存示意图.png\" alt=\"activity状态保存示意图\" title=\"activity状态保存示意图\">  </p>\n<h3 id=\"五-配置改动后的处理\"><a href=\"#五-配置改动后的处理\" class=\"headerlink\" title=\"五 配置改动后的处理\"></a>五 配置改动后的处理</h3><p>设备的某些配置可能会在运行时发生变化（比如屏幕方向、键盘可用性以及语言）。 当发生这些变化时，Android会重建这个运行中的activity（系统会调用 onDestroy() ，然后再马上调用 onCreate() ）。这种设计有助于应用程序适用新的参数配置，通过把你预置的可替换资源（比如对应各种屏幕方向和尺寸的layout）自动重新装载进入应用程序的方式来实现。</p>\n<p>如果你采取了适当的设计，让activity能够正确地处理这些因为屏幕方向而引起的重启，并能如上所述地恢复activity状态， 那么你的应用程序将对生命周期中其它的意外事件更具适应能力。</p>\n<p>处理这类重启的最佳方式，就是利用 onSaveInstanceState() 和onRestoreInstanceState() （或者 onCreate() ）进行状态的保存和恢复，如上节所述。   </p>\n<h3 id=\"六-Activity的启动方式\"><a href=\"#六-Activity的启动方式\" class=\"headerlink\" title=\"六 Activity的启动方式\"></a>六 Activity的启动方式</h3><p>antivity的启动方式可以通过两种方式定义：     </p>\n<h5 id=\"Androidmanifest文件\"><a href=\"#Androidmanifest文件\" class=\"headerlink\" title=\"Androidmanifest文件\"></a>Androidmanifest文件</h5><p>Androidmanifest文件是android的清单文件，android的四大组件与相应权限皆需在这里设置。在这里你可以利用 <activity> 元素的 launchMode 属性来设定 activity 与 task 的关系。<br>可通过Androidmanifest文件设置的启动模式有：      </p>\n<ul>\n<li>standard</li>\n<li>singleTop</li>\n<li>singleTask</li>\n<li>singleInstance       </li>\n</ul>\n<h5 id=\"Intent标志\"><a href=\"#Intent标志\" class=\"headerlink\" title=\"Intent标志\"></a>Intent标志</h5><p>Intent标志中有以下几种Activity的启动方式:       </p>\n<ul>\n<li>FLAG_ACTIVITY_NEW_TASK</li>\n<li>FLAG_ACTIVITY_SINGLE_TOP</li>\n<li>FLAG_ACTIVITY_CLEAR_TOP<br>通过Intent标志的方式来启动Activity，优先级比manifest的高。    </li>\n</ul>\n<blockquote>\n<p><strong>警告</strong>： 大多数应用不应该改变 activity 和 task 默认的工作方式。 如果你确定有必要修改默认方式，请保持<br>谨慎，并确保 activity 在启动和从其它 activity 用回退键返回时的可用性。 请确保对可能与用户预期的导航方式<br>相冲突的地方进行测试。      </p>\n</blockquote>\n<h3 id=\"七-启动Activity\"><a href=\"#七-启动Activity\" class=\"headerlink\" title=\"七 启动Activity\"></a>七 启动Activity</h3><p>要启动一个activity需要使用Intent，实际上android中组件之前的通信皆由Intent完成（如果你不了解Intent，请看我之后的博客<a href=\"android基础之Intents与Intent-Filters.md\" title=\"android基础之Intents与Intent-Filters\">android基础之Intents与Intent-Filters.md</a>），而使用Intent启动activity有显示和隐式两种方式。   </p>\n<h5 id=\"显示启动\"><a href=\"#显示启动\" class=\"headerlink\" title=\"显示启动\"></a>显示启动</h5><pre><code class=\"java\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, SignInActivity.class);\nstartActivity(intent);<span class=\"comment\">//显示启动一个叫SignInActivity的Activity</span>\n</code></pre>\n<h5 id=\"隐式启动\"><a href=\"#隐式启动\" class=\"headerlink\" title=\"隐式启动\"></a>隐式启动</h5><p>要想隐式启动一个activity，你需要使用intent-filter来暴露你的activity。使用filter有java代码和xml文件两种方式，推荐使用第二种方式，你只需在Androidmanifest.xml文件中的activit元素中加入intent-filter属性，并声明一个action即可。但是如果你想使你的activity更独立，那么就不要为你的activity设置filter。那么什么时候使用这种方式呢？<br>如果，你的程序可能想要展示某些动作，例如发邮件，短信，微博，或者使用你activity中的数据。 这时候，你就不应该使用自己的activity来做这些工作。你应该调用系统中其他程序提供的响应功能。 这是intent真正体现其价值的地方。你可以创建一个描述了响应动作的intent,然后系统来为你挑选完成任务的程序。 如果有多个选择，系统会提示用户进行选择。例如你想让用户发邮件，你可以创建下面的intent：        </p>\n<pre><code class=\"java\">Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_EMAIL, recipientArray);<span class=\"comment\">//recipientArray即你想发送过去的联系人信息</span>\nstartActivity(intent);\n</code></pre>\n<h5 id=\"启动一个带返回结果的Activity\"><a href=\"#启动一个带返回结果的Activity\" class=\"headerlink\" title=\"启动一个带返回结果的Activity\"></a>启动一个带返回结果的Activity</h5><p>有时候，你想要启动一个activity,并从这个activty获得一个结果。 这时，要通过 startActivityForResult() (取代startActivity()) 来启动activity。 然后通过实现onActivityResult()回调方法来获得返回后的结果。 当这个后续的activity被关闭，它将发送一个 Intent 给 onActivityResult() 方法。     </p>\n<p>例如，你可能想要取一个联系人的信息。下面介绍怎么创建intent并处理结果:         </p>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">pickContact</span><span class=\"params\">()</span> </span>{\n    <span class=\"comment\">// Create an intent to \"pick\" a contact, as defined by the content provider URI</span>\n    Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);\n    startActivityForResult(intent, PICK_CONTACT_REQUEST);\n}\n\n<span class=\"meta\">@Override</span>\n<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> resultCode, Intent data)</span> </span>{\n    <span class=\"comment\">// If the request went well (OK) and the request was PICK_CONTACT_REQUEST</span>\n    <span class=\"keyword\">if</span> (resultCode == Activity.RESULT_OK &amp;&amp; requestCode == PICK_CONTACT_REQUEST) {\n        <span class=\"comment\">// Perform a query to the contact's content provider for the contact's name</span>\n        Cursor cursor = getContentResolver().query(data.getData(),\n        <span class=\"keyword\">new</span> String[] {Contacts.DISPLAY_NAME}, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);\n        <span class=\"keyword\">if</span> (cursor.moveToFirst()) { <span class=\"comment\">// True if the cursor is not empty</span>\n            <span class=\"keyword\">int</span> columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);\n            String name = cursor.getString(columnIndex);\n            <span class=\"comment\">// Do something with the selected contact's name...</span>\n        }\n    }\n}\n</code></pre>\n<p>这个例子展示了使用onActivityResult() 来获取结果的基本方法。 第一步要判断请求是否被成功响应，通过判断resultCode 是不是RESULT_OK—， 然后判断这个响应是不是针对相应的请求— ，此时只要判断requestCode 和发送时提供的第二个参数 startActivityForResult() 是否相匹配。 最后，查询 Intent中的data信息。 (data 参数)。</p>\n<p>这个过程中，ContentResolver 开启了一个查询而不是content provider, 它返回一个 Cursor ，这将允许数据被读取。更多content provider相关信息，请阅读我之后的博客<a href=\"android基础之Content-Providers.md\" title=\"android基础之Content-Providers\">android基础之Content-Providers.md</a>。     </p>\n<h5 id=\"关闭activity\"><a href=\"#关闭activity\" class=\"headerlink\" title=\"关闭activity\"></a>关闭activity</h5><p>你可以通过调用finish() 来终止activity。 你也可以调用finishActivity() 来终止你之前启动了的一个独立activity。    </p>\n<blockquote>\n<p><strong>注意</strong>: 多数情况下，你不应该明确地通过这些方式来关闭acitivity。 就像下面要讨论的activity的生命周期。系统会为你管理。所以你不必关闭他们。 调用这些方法将有悖于用户体验。它们仅用于你绝对不想让用户再返回这个activity的实例。   </p>\n</blockquote>\n<h3 id=\"八-Task和back-stack\"><a href=\"#八-Task和back-stack\" class=\"headerlink\" title=\"八 Task和back stack\"></a>八 Task和back stack</h3><p>一个app通常包含多个activity，android使用task来管理这些activity。当你在手机上没点开一个app，android即为这个app创建一个task，task中有一个back stack，你多点开的activity将依次入栈或者出栈，若你的activity调用别的应用的activity，它也会被压入本activity中。（activity与back stack的关系可阅读上文的activity的启动方式，它定义了activity在back stack中的存在方式）。<br>一个app即对应一个task，若你点开一个新的app，则该新app会进入前台，而之前的会被调入后台。当android的内存不足时，后台的task则可能被销毁。    </p>\n<p>其实，activity所处的task可以通过<activity>元素的taskAffinity属性指定，taskAffinity 属性是一个字符串值，必须与<manifest> 元素定义的包名称保证唯一性，因为系统把这个包名称用于标识应用的默认 task affinity值。但是，注意，一般情况下如无必要，不要去修改taskAffinity的值。    </p>\n<h3 id=\"九-总结\"><a href=\"#九-总结\" class=\"headerlink\" title=\"九 总结\"></a>九 总结</h3><p>到这里，android的activity相关的知识已经介绍的差不多了，但是这其中还有很多细节需要读者自己去发现。我所说的并不全面，有些地方可能还有谬误，万不可全信，这些仅仅是我个人的理解。其实博客的功能也只是让你对一个陌生的事物知道个大概，要想最终精通还需要多写多做。这些东西你只有自己经历了，研究了它才能成为你自己的东西，否则不过是镜花水月。<br>作为一个程序员最重要的是勤劳，最后以一句话与大家共勉：慈不掌兵，义不行贾，懒不撸码。</p>\n"},{"title":"android基础之Service","date":"2017-02-27T06:06:22.000Z","_content":"\n### 一 Service简介    \nService也是Android的四大组件之一，它并不提供用户界面，主要做一些即使该应用程序被调入后台也需要运行的事务。比如下载，音乐播放，执行文件I/O或者与content provider进行交互等。Service主要做的就是上面这些比较耗时的操作，但是由于Service也是运行在主线程中，因此最好在其中另开一个线程做这些耗时操作，否者可能会引起UI阻塞。       \n\n### 二 Service的两种启动方式     \nService有started和bound两种启动方式，当然也可以两种都启用。你可通过startService()启动服务后再通过bindService()将activity于Service绑定。     \n\n##### 1.startService()启动    \n通过startService()启动的Service，Service一旦启动即与它的调用者（通常是某个activity）不再关联，即使调用它的组件被销毁，它也能在后台一直运行下去。通常，该类服务执行单一的操作并且不会向调用者返回结果，比如它可以通过网络下载或上传文件。此类服务应该在其工作完成后通过重写stopSelf()使其自行终止，或者由其他组件调用stopService()来终止。       \n通过startService()启动的服务需要实现它的生命周期中onStartCommand()方法        \n\n\n\n##### 2.bindService()启动      \n通过bindService()启动的服务，该服务的生命周期将与启动它的组件相关联，即如果启动它的组件被销毁则该服务也会被销毁，或者通过调用unBindService()与服务解绑，解绑后服务被销毁。多个组件可以同时与一个服务绑定，当所有组件都与服务解绑后，该服务才会被销毁。    \nbind服务提供了一个客户端/服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至进行进程间通信（IPC）。       \n通过bindService()启动的服务需要实现Service中的onBind()方法。   \n\n\n\n\n### 三 Service的生命周期     \n两种Service的生命周期如下图：     \n{% asset_img Service生命周期图.png Service生命周期图 %}     \n其回调方法如下：     \n\n   \n```java       \npublic class ExampleService extends Service {\n    int mStartMode;       // indicates how to behave if the service is killed\n    IBinder mBinder;      // interface for clients that bind\n    boolean mAllowRebind; // indicates whether onRebind should be used\n\n    @Override\n    public void onCreate() {\n        // The service is being created\n    }\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        // The service is starting, due to a call to startService()\n        return mStartMode;\n    }\n    @Override\n    public IBinder onBind(Intent intent) {\n        // A client is binding to the service with bindService()\n        return mBinder;\n    }\n    @Override\n    public boolean onUnbind(Intent intent) {\n        // All clients have unbound with unbindService()\n        return mAllowRebind;\n    }\n    @Override\n    public void onRebind(Intent intent) {\n        // A client is binding to the service with bindService(),\n        // after onUnbind() has already been called\n    }\n    @Override\n    public void onDestroy() {\n        // The service is no longer used and is being destroyed\n    }\n}\n```         \n\n\n\n### 四 Service与线程的区别    \n- Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。     \n- Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。       \n其实谈Service和线程的区别毫无意义，它们本来就是毫无关联的两样东西，我觉得应该谈的是在什么情况下，什么地方使用线程更合适。   \n比如：如果你的线程主要用于对UI的更新，那么在Activity中新建即可。但是如果你的线程用于app和服务器之间的消息推送，你需要隔一段时间就要连接服务器做数据同步的话，那么就不能在Activity中新建线程。因为此时的线程在Activity被销毁时，它仍然需要运行。此时将面对一个问题，如果你是Activity中创建得线程，那么当该Activity被销毁时，你将失去该线程的实例。另一方面，你没办法在不同的Activity中对同一线程进行控制。这种情况你就需要在Service中创建它，一方面Service在Activity被销毁时仍然可以运行，另一方面其他的Activity重建后也可以通过与Service进行绑定获得Service的实例，进而控制该线程。\n\n### 五 保证Service不被杀死    \n- onStartCommand方法，返回START_STICKY   \n- 提升service优先级   \n- 提升service进程优先级,将其提升为前台服务    \n- onDestroy方法里重启service  \n- 监听系统广播判断Service状态    \n- 将APK安装到/system/app，变身系统级应用      \n\n\n### 六 IntentService    \n\n因为大多数started服务都不需要同时处理多个请求（这实际上是一个危险的多线程情况），所以最佳方式也许就是用IntentService类来实现你的服务。   \nIntentService将执行以下步骤：    　　\n- 创建一个缺省的工作（worker）线程，它独立于应用程序主线程来执行所有发送到onStartCommand()的intent。　　　\n- 创建一个工作队列，每次向你的onHandleIntent()传入一个intent，这样你就永远不必担心多线程问题了。　\n- 在处理完所有的启动请求后，终止服务，因此你就永远不需调用stopSelf()了。　　\n- 提供缺省的onBind()实现代码，它返回null。\n- 提供缺省的onStartCommand()实现代码，它把intent送入工作队列，稍后会再传给你的onHandleIntent()实现代码。　　　\n\n以上所有步骤将汇成一个结果：你要做的全部工作就是实现onHandleIntent()的代码，来完成客户端提交的任务。（当然你还需要为服务提供一小段构造方法。）       \n\n以下是个IntentService的实现例程：    \n\n```java    \n\npublic class HelloIntentService extends IntentService {\n\n  /** \n   * 构造方法是必需的，必须用工作线程名称作为参数\n   * 调用父类的[http://developer.android.com/reference/android/app/IntentService.html#IntentService(java.lang.String) IntentService(String)]构造方法。\n   */\n  public HelloIntentService() {\n      super(\"HelloIntentService\");\n  }\n\n  /**\n   * IntentService从缺省的工作线程中调用本方法，并用启动服务的intent作为参数。 \n   * 本方法返回后，IntentService将适时终止这个服务。\n   */\n  @Override\n  protected void onHandleIntent(Intent intent) {\n      // 通常我们会在这里执行一些工作，比如下载文件。\n      // 作为例子，我们只是睡5秒钟。\n      long endTime = System.currentTimeMillis() + 5*1000;\n      while (System.currentTimeMillis() < endTime) {\n          synchronized (this) {\n              try {\n                  wait(endTime - System.currentTimeMillis());\n              } catch (Exception e) {\n              }\n          }\n      }\n  }\n}  \n\n```    \n\n所有你需要做的就是：一个构造方法和一个onHandleIntent()方法的实现。\n\n如果你还决定重写其它的回调方法，比如onCreate()、onStartCommand()、onDestroy()， 请确保调用一下父类的实现代码，以便IntentService能正确处理工作线程的生命周期。\n\n比如说，onStartCommand()必须返回缺省实现代码的结果（缺省代码实现了如何获取传给onHandleIntent()的intent）：    \n\n```java  \n@Override\npublic int onStartCommand(Intent intent, int flags, int startId) {\n    Toast.makeText(this, \"service starting\", Toast.LENGTH_SHORT).show();\n    return super.onStartCommand(intent,flags,startId);\n}\n```   \n\n除了onHandleIntent()以外，唯一不需要调用父类实现代码的方法是onBind()（不过如果你的服务允许绑定，你还是需要实现它）。    \n\n\n### 七 扩展Service   \n\n如上节所述，利用IntentService来实现一个started服务非常简单。 不过，假如你的服务需要多线程运行（而不是通过一个工作队列来处理启动请求），那你可以扩展Service类来完成每个intent的处理。\n\n作为对照，以下例程实现了 Service 类，它执行的工作与上述使用IntentService的例子相同。确切地说，对于每一个启动请求，它都用一个工作线程来完成处理工作，并且每次只处理一个请求。    \n\n```java    \npublic class HelloService extends Service {\n  private Looper mServiceLooper;\n  private ServiceHandler mServiceHandler;\n\n  // 处理从线程接收的消息\n  private final class ServiceHandler extends Handler {\n      public ServiceHandler(Looper looper) {\n          super(looper);\n      }\n      @Override\n      public void handleMessage(Message msg) {\n          // 通常我们在这里执行一些工作，比如下载文件。\n          // 作为例子，我们只是睡个5秒钟。\n          long endTime = System.currentTimeMillis() + 5*1000;\n          while (System.currentTimeMillis() < endTime) {\n              synchronized (this) {\n                  try {\n                      wait(endTime - System.currentTimeMillis());\n                  } catch (Exception e) {\n                  }\n              }\n          }\n          // 根据startId终止服务，这样我们就不会在处理其它工作的过程中再来终止服务\n          stopSelf(msg.arg1);\n      }\n  }\n\n  @Override\n  public void onCreate() {\n    // 启动运行服务的线程。\n    // 请记住我们要创建一个单独的线程，因为服务通常运行于进程的主线程中，可我们不想阻塞主线程。\n    // 我们还要赋予它后台运行的优先级，以便计算密集的工作不会干扰我们的UI。\n    HandlerThread thread = new HandlerThread(\"ServiceStartArguments\",\n            Process.THREAD_PRIORITY_BACKGROUND);\n    thread.start();\n    \n    // 获得HandlerThread的Looper队列并用于Handler\n    mServiceLooper = thread.getLooper();\n    mServiceHandler = new ServiceHandler(mServiceLooper);\n  }\n\n  @Override\n  public int onStartCommand(Intent intent, int flags, int startId) {\n      Toast.makeText(this, \"service starting\", Toast.LENGTH_SHORT).show();\n\n      // 对于每一个启动请求，都发送一个消息来启动一个处理\n      // 同时传入启动ID，以便任务完成后我们知道该终止哪一个请求。\n      Message msg = mServiceHandler.obtainMessage();\n      msg.arg1 = startId;\n      mServiceHandler.sendMessage(msg);\n      \n      // 如果我们被杀死了，那从这里返回之后被重启\n      return START_STICKY;\n  }\n\n  @Override\n  public IBinder onBind(Intent intent) {\n      // 我们不支持绑定，所以返回null\n      return null;\n  }\n  \n  @Override\n  public void onDestroy() {\n    Toast.makeText(this, \"service done\", Toast.LENGTH_SHORT).show(); \n  }\n}\n```    \n\n如你所见，它要干的事情比用IntentService时多了很多。\n\n不过，因为是自行处理每个onStartCommand()调用，你可以同时处理多个请求。 本例中没有这么去实现，但只要你愿意，你就可以为每个请求创建一个新的线程，并立即运行它们（而不是等待前一个请求处理完毕）。\n\n请注意onStartCommand()方法必须返回一个整数。这个整数是描述系统在杀死服务之后应该如何继续运行（上一节中缺省的 IntentService 实现代码会替你处理这一点，当然那样你就无法修改这个处理过程）。onStartCommand()的返回值必须是以下常量之一：\n\n\n- START_NOT_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则不会重建服务了，除非还存在未发送的intent。 当服务不再是必需的，并且应用程序能够简单地重启那些未完成的工作时，这是避免服务运行的最安全的选项。 \n\n\n- START_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并调用onStartCommand()，但不会再次送入上一个intent， 而是用null intent来调用onStartCommand() 。除非还有启动服务的intent未发送完，那么这些剩下的intent会继续发送。 这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命。 \n\n\n- START_REDELIVER_INTENT: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并用上一个已送过的intent调用onStartCommand()。任何未发送完的intent也都会依次送入。这适用于那些需要立即恢复工作的活跃服务，比如下载文件。    ","source":"_posts/android基础之Service.md","raw":"---\ntitle: android基础之Service\ndate: 2017-02-27 14:06:22\ncategories: android\ntags:\n- android\n- java\n- service\n---\n\n### 一 Service简介    \nService也是Android的四大组件之一，它并不提供用户界面，主要做一些即使该应用程序被调入后台也需要运行的事务。比如下载，音乐播放，执行文件I/O或者与content provider进行交互等。Service主要做的就是上面这些比较耗时的操作，但是由于Service也是运行在主线程中，因此最好在其中另开一个线程做这些耗时操作，否者可能会引起UI阻塞。       \n\n### 二 Service的两种启动方式     \nService有started和bound两种启动方式，当然也可以两种都启用。你可通过startService()启动服务后再通过bindService()将activity于Service绑定。     \n\n##### 1.startService()启动    \n通过startService()启动的Service，Service一旦启动即与它的调用者（通常是某个activity）不再关联，即使调用它的组件被销毁，它也能在后台一直运行下去。通常，该类服务执行单一的操作并且不会向调用者返回结果，比如它可以通过网络下载或上传文件。此类服务应该在其工作完成后通过重写stopSelf()使其自行终止，或者由其他组件调用stopService()来终止。       \n通过startService()启动的服务需要实现它的生命周期中onStartCommand()方法        \n\n\n\n##### 2.bindService()启动      \n通过bindService()启动的服务，该服务的生命周期将与启动它的组件相关联，即如果启动它的组件被销毁则该服务也会被销毁，或者通过调用unBindService()与服务解绑，解绑后服务被销毁。多个组件可以同时与一个服务绑定，当所有组件都与服务解绑后，该服务才会被销毁。    \nbind服务提供了一个客户端/服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至进行进程间通信（IPC）。       \n通过bindService()启动的服务需要实现Service中的onBind()方法。   \n\n\n\n\n### 三 Service的生命周期     \n两种Service的生命周期如下图：     \n{% asset_img Service生命周期图.png Service生命周期图 %}     \n其回调方法如下：     \n\n   \n```java       \npublic class ExampleService extends Service {\n    int mStartMode;       // indicates how to behave if the service is killed\n    IBinder mBinder;      // interface for clients that bind\n    boolean mAllowRebind; // indicates whether onRebind should be used\n\n    @Override\n    public void onCreate() {\n        // The service is being created\n    }\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        // The service is starting, due to a call to startService()\n        return mStartMode;\n    }\n    @Override\n    public IBinder onBind(Intent intent) {\n        // A client is binding to the service with bindService()\n        return mBinder;\n    }\n    @Override\n    public boolean onUnbind(Intent intent) {\n        // All clients have unbound with unbindService()\n        return mAllowRebind;\n    }\n    @Override\n    public void onRebind(Intent intent) {\n        // A client is binding to the service with bindService(),\n        // after onUnbind() has already been called\n    }\n    @Override\n    public void onDestroy() {\n        // The service is no longer used and is being destroyed\n    }\n}\n```         \n\n\n\n### 四 Service与线程的区别    \n- Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。     \n- Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。       \n其实谈Service和线程的区别毫无意义，它们本来就是毫无关联的两样东西，我觉得应该谈的是在什么情况下，什么地方使用线程更合适。   \n比如：如果你的线程主要用于对UI的更新，那么在Activity中新建即可。但是如果你的线程用于app和服务器之间的消息推送，你需要隔一段时间就要连接服务器做数据同步的话，那么就不能在Activity中新建线程。因为此时的线程在Activity被销毁时，它仍然需要运行。此时将面对一个问题，如果你是Activity中创建得线程，那么当该Activity被销毁时，你将失去该线程的实例。另一方面，你没办法在不同的Activity中对同一线程进行控制。这种情况你就需要在Service中创建它，一方面Service在Activity被销毁时仍然可以运行，另一方面其他的Activity重建后也可以通过与Service进行绑定获得Service的实例，进而控制该线程。\n\n### 五 保证Service不被杀死    \n- onStartCommand方法，返回START_STICKY   \n- 提升service优先级   \n- 提升service进程优先级,将其提升为前台服务    \n- onDestroy方法里重启service  \n- 监听系统广播判断Service状态    \n- 将APK安装到/system/app，变身系统级应用      \n\n\n### 六 IntentService    \n\n因为大多数started服务都不需要同时处理多个请求（这实际上是一个危险的多线程情况），所以最佳方式也许就是用IntentService类来实现你的服务。   \nIntentService将执行以下步骤：    　　\n- 创建一个缺省的工作（worker）线程，它独立于应用程序主线程来执行所有发送到onStartCommand()的intent。　　　\n- 创建一个工作队列，每次向你的onHandleIntent()传入一个intent，这样你就永远不必担心多线程问题了。　\n- 在处理完所有的启动请求后，终止服务，因此你就永远不需调用stopSelf()了。　　\n- 提供缺省的onBind()实现代码，它返回null。\n- 提供缺省的onStartCommand()实现代码，它把intent送入工作队列，稍后会再传给你的onHandleIntent()实现代码。　　　\n\n以上所有步骤将汇成一个结果：你要做的全部工作就是实现onHandleIntent()的代码，来完成客户端提交的任务。（当然你还需要为服务提供一小段构造方法。）       \n\n以下是个IntentService的实现例程：    \n\n```java    \n\npublic class HelloIntentService extends IntentService {\n\n  /** \n   * 构造方法是必需的，必须用工作线程名称作为参数\n   * 调用父类的[http://developer.android.com/reference/android/app/IntentService.html#IntentService(java.lang.String) IntentService(String)]构造方法。\n   */\n  public HelloIntentService() {\n      super(\"HelloIntentService\");\n  }\n\n  /**\n   * IntentService从缺省的工作线程中调用本方法，并用启动服务的intent作为参数。 \n   * 本方法返回后，IntentService将适时终止这个服务。\n   */\n  @Override\n  protected void onHandleIntent(Intent intent) {\n      // 通常我们会在这里执行一些工作，比如下载文件。\n      // 作为例子，我们只是睡5秒钟。\n      long endTime = System.currentTimeMillis() + 5*1000;\n      while (System.currentTimeMillis() < endTime) {\n          synchronized (this) {\n              try {\n                  wait(endTime - System.currentTimeMillis());\n              } catch (Exception e) {\n              }\n          }\n      }\n  }\n}  \n\n```    \n\n所有你需要做的就是：一个构造方法和一个onHandleIntent()方法的实现。\n\n如果你还决定重写其它的回调方法，比如onCreate()、onStartCommand()、onDestroy()， 请确保调用一下父类的实现代码，以便IntentService能正确处理工作线程的生命周期。\n\n比如说，onStartCommand()必须返回缺省实现代码的结果（缺省代码实现了如何获取传给onHandleIntent()的intent）：    \n\n```java  \n@Override\npublic int onStartCommand(Intent intent, int flags, int startId) {\n    Toast.makeText(this, \"service starting\", Toast.LENGTH_SHORT).show();\n    return super.onStartCommand(intent,flags,startId);\n}\n```   \n\n除了onHandleIntent()以外，唯一不需要调用父类实现代码的方法是onBind()（不过如果你的服务允许绑定，你还是需要实现它）。    \n\n\n### 七 扩展Service   \n\n如上节所述，利用IntentService来实现一个started服务非常简单。 不过，假如你的服务需要多线程运行（而不是通过一个工作队列来处理启动请求），那你可以扩展Service类来完成每个intent的处理。\n\n作为对照，以下例程实现了 Service 类，它执行的工作与上述使用IntentService的例子相同。确切地说，对于每一个启动请求，它都用一个工作线程来完成处理工作，并且每次只处理一个请求。    \n\n```java    \npublic class HelloService extends Service {\n  private Looper mServiceLooper;\n  private ServiceHandler mServiceHandler;\n\n  // 处理从线程接收的消息\n  private final class ServiceHandler extends Handler {\n      public ServiceHandler(Looper looper) {\n          super(looper);\n      }\n      @Override\n      public void handleMessage(Message msg) {\n          // 通常我们在这里执行一些工作，比如下载文件。\n          // 作为例子，我们只是睡个5秒钟。\n          long endTime = System.currentTimeMillis() + 5*1000;\n          while (System.currentTimeMillis() < endTime) {\n              synchronized (this) {\n                  try {\n                      wait(endTime - System.currentTimeMillis());\n                  } catch (Exception e) {\n                  }\n              }\n          }\n          // 根据startId终止服务，这样我们就不会在处理其它工作的过程中再来终止服务\n          stopSelf(msg.arg1);\n      }\n  }\n\n  @Override\n  public void onCreate() {\n    // 启动运行服务的线程。\n    // 请记住我们要创建一个单独的线程，因为服务通常运行于进程的主线程中，可我们不想阻塞主线程。\n    // 我们还要赋予它后台运行的优先级，以便计算密集的工作不会干扰我们的UI。\n    HandlerThread thread = new HandlerThread(\"ServiceStartArguments\",\n            Process.THREAD_PRIORITY_BACKGROUND);\n    thread.start();\n    \n    // 获得HandlerThread的Looper队列并用于Handler\n    mServiceLooper = thread.getLooper();\n    mServiceHandler = new ServiceHandler(mServiceLooper);\n  }\n\n  @Override\n  public int onStartCommand(Intent intent, int flags, int startId) {\n      Toast.makeText(this, \"service starting\", Toast.LENGTH_SHORT).show();\n\n      // 对于每一个启动请求，都发送一个消息来启动一个处理\n      // 同时传入启动ID，以便任务完成后我们知道该终止哪一个请求。\n      Message msg = mServiceHandler.obtainMessage();\n      msg.arg1 = startId;\n      mServiceHandler.sendMessage(msg);\n      \n      // 如果我们被杀死了，那从这里返回之后被重启\n      return START_STICKY;\n  }\n\n  @Override\n  public IBinder onBind(Intent intent) {\n      // 我们不支持绑定，所以返回null\n      return null;\n  }\n  \n  @Override\n  public void onDestroy() {\n    Toast.makeText(this, \"service done\", Toast.LENGTH_SHORT).show(); \n  }\n}\n```    \n\n如你所见，它要干的事情比用IntentService时多了很多。\n\n不过，因为是自行处理每个onStartCommand()调用，你可以同时处理多个请求。 本例中没有这么去实现，但只要你愿意，你就可以为每个请求创建一个新的线程，并立即运行它们（而不是等待前一个请求处理完毕）。\n\n请注意onStartCommand()方法必须返回一个整数。这个整数是描述系统在杀死服务之后应该如何继续运行（上一节中缺省的 IntentService 实现代码会替你处理这一点，当然那样你就无法修改这个处理过程）。onStartCommand()的返回值必须是以下常量之一：\n\n\n- START_NOT_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则不会重建服务了，除非还存在未发送的intent。 当服务不再是必需的，并且应用程序能够简单地重启那些未完成的工作时，这是避免服务运行的最安全的选项。 \n\n\n- START_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并调用onStartCommand()，但不会再次送入上一个intent， 而是用null intent来调用onStartCommand() 。除非还有启动服务的intent未发送完，那么这些剩下的intent会继续发送。 这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命。 \n\n\n- START_REDELIVER_INTENT: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并用上一个已送过的intent调用onStartCommand()。任何未发送完的intent也都会依次送入。这适用于那些需要立即恢复工作的活跃服务，比如下载文件。    ","slug":"android基础之Service","published":1,"updated":"2017-03-07T13:20:33.443Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj02g6gsl000f7c02j5o3rqp9","content":"<h3 id=\"一-Service简介\"><a href=\"#一-Service简介\" class=\"headerlink\" title=\"一 Service简介\"></a>一 Service简介</h3><p>Service也是Android的四大组件之一，它并不提供用户界面，主要做一些即使该应用程序被调入后台也需要运行的事务。比如下载，音乐播放，执行文件I/O或者与content provider进行交互等。Service主要做的就是上面这些比较耗时的操作，但是由于Service也是运行在主线程中，因此最好在其中另开一个线程做这些耗时操作，否者可能会引起UI阻塞。       </p>\n<h3 id=\"二-Service的两种启动方式\"><a href=\"#二-Service的两种启动方式\" class=\"headerlink\" title=\"二 Service的两种启动方式\"></a>二 Service的两种启动方式</h3><p>Service有started和bound两种启动方式，当然也可以两种都启用。你可通过startService()启动服务后再通过bindService()将activity于Service绑定。     </p>\n<h5 id=\"1-startService-启动\"><a href=\"#1-startService-启动\" class=\"headerlink\" title=\"1.startService()启动\"></a>1.startService()启动</h5><p>通过startService()启动的Service，Service一旦启动即与它的调用者（通常是某个activity）不再关联，即使调用它的组件被销毁，它也能在后台一直运行下去。通常，该类服务执行单一的操作并且不会向调用者返回结果，比如它可以通过网络下载或上传文件。此类服务应该在其工作完成后通过重写stopSelf()使其自行终止，或者由其他组件调用stopService()来终止。<br>通过startService()启动的服务需要实现它的生命周期中onStartCommand()方法        </p>\n<h5 id=\"2-bindService-启动\"><a href=\"#2-bindService-启动\" class=\"headerlink\" title=\"2.bindService()启动\"></a>2.bindService()启动</h5><p>通过bindService()启动的服务，该服务的生命周期将与启动它的组件相关联，即如果启动它的组件被销毁则该服务也会被销毁，或者通过调用unBindService()与服务解绑，解绑后服务被销毁。多个组件可以同时与一个服务绑定，当所有组件都与服务解绑后，该服务才会被销毁。<br>bind服务提供了一个客户端/服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至进行进程间通信（IPC）。<br>通过bindService()启动的服务需要实现Service中的onBind()方法。   </p>\n<h3 id=\"三-Service的生命周期\"><a href=\"#三-Service的生命周期\" class=\"headerlink\" title=\"三 Service的生命周期\"></a>三 Service的生命周期</h3><p>两种Service的生命周期如下图：<br><img src=\"/2017/02/27/android基础之Service/Service生命周期图.png\" alt=\"Service生命周期图\" title=\"Service生命周期图\"><br>其回调方法如下：     </p>\n<pre><code class=\"java\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>{\n    <span class=\"keyword\">int</span> mStartMode;       <span class=\"comment\">// indicates how to behave if the service is killed</span>\n    IBinder mBinder;      <span class=\"comment\">// interface for clients that bind</span>\n    <span class=\"keyword\">boolean</span> mAllowRebind; <span class=\"comment\">// indicates whether onRebind should be used</span>\n\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>{\n        <span class=\"comment\">// The service is being created</span>\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>{\n        <span class=\"comment\">// The service is starting, due to a call to startService()</span>\n        <span class=\"keyword\">return</span> mStartMode;\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>{\n        <span class=\"comment\">// A client is binding to the service with bindService()</span>\n        <span class=\"keyword\">return</span> mBinder;\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onUnbind</span><span class=\"params\">(Intent intent)</span> </span>{\n        <span class=\"comment\">// All clients have unbound with unbindService()</span>\n        <span class=\"keyword\">return</span> mAllowRebind;\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRebind</span><span class=\"params\">(Intent intent)</span> </span>{\n        <span class=\"comment\">// A client is binding to the service with bindService(),</span>\n        <span class=\"comment\">// after onUnbind() has already been called</span>\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>{\n        <span class=\"comment\">// The service is no longer used and is being destroyed</span>\n    }\n}\n</code></pre>\n<h3 id=\"四-Service与线程的区别\"><a href=\"#四-Service与线程的区别\" class=\"headerlink\" title=\"四 Service与线程的区别\"></a>四 Service与线程的区别</h3><ul>\n<li>Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。     </li>\n<li>Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。<br>其实谈Service和线程的区别毫无意义，它们本来就是毫无关联的两样东西，我觉得应该谈的是在什么情况下，什么地方使用线程更合适。<br>比如：如果你的线程主要用于对UI的更新，那么在Activity中新建即可。但是如果你的线程用于app和服务器之间的消息推送，你需要隔一段时间就要连接服务器做数据同步的话，那么就不能在Activity中新建线程。因为此时的线程在Activity被销毁时，它仍然需要运行。此时将面对一个问题，如果你是Activity中创建得线程，那么当该Activity被销毁时，你将失去该线程的实例。另一方面，你没办法在不同的Activity中对同一线程进行控制。这种情况你就需要在Service中创建它，一方面Service在Activity被销毁时仍然可以运行，另一方面其他的Activity重建后也可以通过与Service进行绑定获得Service的实例，进而控制该线程。</li>\n</ul>\n<h3 id=\"五-保证Service不被杀死\"><a href=\"#五-保证Service不被杀死\" class=\"headerlink\" title=\"五 保证Service不被杀死\"></a>五 保证Service不被杀死</h3><ul>\n<li>onStartCommand方法，返回START_STICKY   </li>\n<li>提升service优先级   </li>\n<li>提升service进程优先级,将其提升为前台服务    </li>\n<li>onDestroy方法里重启service  </li>\n<li>监听系统广播判断Service状态    </li>\n<li>将APK安装到/system/app，变身系统级应用      </li>\n</ul>\n<h3 id=\"六-IntentService\"><a href=\"#六-IntentService\" class=\"headerlink\" title=\"六 IntentService\"></a>六 IntentService</h3><p>因为大多数started服务都不需要同时处理多个请求（这实际上是一个危险的多线程情况），所以最佳方式也许就是用IntentService类来实现你的服务。<br>IntentService将执行以下步骤：    　　</p>\n<ul>\n<li>创建一个缺省的工作（worker）线程，它独立于应用程序主线程来执行所有发送到onStartCommand()的intent。　　　</li>\n<li>创建一个工作队列，每次向你的onHandleIntent()传入一个intent，这样你就永远不必担心多线程问题了。　</li>\n<li>在处理完所有的启动请求后，终止服务，因此你就永远不需调用stopSelf()了。　　</li>\n<li>提供缺省的onBind()实现代码，它返回null。</li>\n<li>提供缺省的onStartCommand()实现代码，它把intent送入工作队列，稍后会再传给你的onHandleIntent()实现代码。　　　</li>\n</ul>\n<p>以上所有步骤将汇成一个结果：你要做的全部工作就是实现onHandleIntent()的代码，来完成客户端提交的任务。（当然你还需要为服务提供一小段构造方法。）       </p>\n<p>以下是个IntentService的实现例程：    </p>\n<pre><code class=\"java\">\n<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloIntentService</span> <span class=\"keyword\">extends</span> <span class=\"title\">IntentService</span> </span>{\n\n  <span class=\"comment\">/** \n   * 构造方法是必需的，必须用工作线程名称作为参数\n   * 调用父类的[http://developer.android.com/reference/android/app/IntentService.html#IntentService(java.lang.String) IntentService(String)]构造方法。\n   */</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HelloIntentService</span><span class=\"params\">()</span> </span>{\n      <span class=\"keyword\">super</span>(<span class=\"string\">\"HelloIntentService\"</span>);\n  }\n\n  <span class=\"comment\">/**\n   * IntentService从缺省的工作线程中调用本方法，并用启动服务的intent作为参数。 \n   * 本方法返回后，IntentService将适时终止这个服务。\n   */</span>\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onHandleIntent</span><span class=\"params\">(Intent intent)</span> </span>{\n      <span class=\"comment\">// 通常我们会在这里执行一些工作，比如下载文件。</span>\n      <span class=\"comment\">// 作为例子，我们只是睡5秒钟。</span>\n      <span class=\"keyword\">long</span> endTime = System.currentTimeMillis() + <span class=\"number\">5</span>*<span class=\"number\">1000</span>;\n      <span class=\"keyword\">while</span> (System.currentTimeMillis() &lt; endTime) {\n          <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) {\n              <span class=\"keyword\">try</span> {\n                  wait(endTime - System.currentTimeMillis());\n              } <span class=\"keyword\">catch</span> (Exception e) {\n              }\n          }\n      }\n  }\n}\n</code></pre>\n<p>所有你需要做的就是：一个构造方法和一个onHandleIntent()方法的实现。</p>\n<p>如果你还决定重写其它的回调方法，比如onCreate()、onStartCommand()、onDestroy()， 请确保调用一下父类的实现代码，以便IntentService能正确处理工作线程的生命周期。</p>\n<p>比如说，onStartCommand()必须返回缺省实现代码的结果（缺省代码实现了如何获取传给onHandleIntent()的intent）：    </p>\n<pre><code class=\"java\"><span class=\"meta\">@Override</span>\n<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>{\n    Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"service starting\"</span>, Toast.LENGTH_SHORT).show();\n    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onStartCommand(intent,flags,startId);\n}\n</code></pre>\n<p>除了onHandleIntent()以外，唯一不需要调用父类实现代码的方法是onBind()（不过如果你的服务允许绑定，你还是需要实现它）。    </p>\n<h3 id=\"七-扩展Service\"><a href=\"#七-扩展Service\" class=\"headerlink\" title=\"七 扩展Service\"></a>七 扩展Service</h3><p>如上节所述，利用IntentService来实现一个started服务非常简单。 不过，假如你的服务需要多线程运行（而不是通过一个工作队列来处理启动请求），那你可以扩展Service类来完成每个intent的处理。</p>\n<p>作为对照，以下例程实现了 Service 类，它执行的工作与上述使用IntentService的例子相同。确切地说，对于每一个启动请求，它都用一个工作线程来完成处理工作，并且每次只处理一个请求。    </p>\n<pre><code class=\"java\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>{\n  <span class=\"keyword\">private</span> Looper mServiceLooper;\n  <span class=\"keyword\">private</span> ServiceHandler mServiceHandler;\n\n  <span class=\"comment\">// 处理从线程接收的消息</span>\n  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>{\n      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServiceHandler</span><span class=\"params\">(Looper looper)</span> </span>{\n          <span class=\"keyword\">super</span>(looper);\n      }\n      <span class=\"meta\">@Override</span>\n      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>{\n          <span class=\"comment\">// 通常我们在这里执行一些工作，比如下载文件。</span>\n          <span class=\"comment\">// 作为例子，我们只是睡个5秒钟。</span>\n          <span class=\"keyword\">long</span> endTime = System.currentTimeMillis() + <span class=\"number\">5</span>*<span class=\"number\">1000</span>;\n          <span class=\"keyword\">while</span> (System.currentTimeMillis() &lt; endTime) {\n              <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) {\n                  <span class=\"keyword\">try</span> {\n                      wait(endTime - System.currentTimeMillis());\n                  } <span class=\"keyword\">catch</span> (Exception e) {\n                  }\n              }\n          }\n          <span class=\"comment\">// 根据startId终止服务，这样我们就不会在处理其它工作的过程中再来终止服务</span>\n          stopSelf(msg.arg1);\n      }\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>{\n    <span class=\"comment\">// 启动运行服务的线程。</span>\n    <span class=\"comment\">// 请记住我们要创建一个单独的线程，因为服务通常运行于进程的主线程中，可我们不想阻塞主线程。</span>\n    <span class=\"comment\">// 我们还要赋予它后台运行的优先级，以便计算密集的工作不会干扰我们的UI。</span>\n    HandlerThread thread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">\"ServiceStartArguments\"</span>,\n            Process.THREAD_PRIORITY_BACKGROUND);\n    thread.start();\n\n    <span class=\"comment\">// 获得HandlerThread的Looper队列并用于Handler</span>\n    mServiceLooper = thread.getLooper();\n    mServiceHandler = <span class=\"keyword\">new</span> ServiceHandler(mServiceLooper);\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>{\n      Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"service starting\"</span>, Toast.LENGTH_SHORT).show();\n\n      <span class=\"comment\">// 对于每一个启动请求，都发送一个消息来启动一个处理</span>\n      <span class=\"comment\">// 同时传入启动ID，以便任务完成后我们知道该终止哪一个请求。</span>\n      Message msg = mServiceHandler.obtainMessage();\n      msg.arg1 = startId;\n      mServiceHandler.sendMessage(msg);\n\n      <span class=\"comment\">// 如果我们被杀死了，那从这里返回之后被重启</span>\n      <span class=\"keyword\">return</span> START_STICKY;\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>{\n      <span class=\"comment\">// 我们不支持绑定，所以返回null</span>\n      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>{\n    Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"service done\"</span>, Toast.LENGTH_SHORT).show(); \n  }\n}\n</code></pre>\n<p>如你所见，它要干的事情比用IntentService时多了很多。</p>\n<p>不过，因为是自行处理每个onStartCommand()调用，你可以同时处理多个请求。 本例中没有这么去实现，但只要你愿意，你就可以为每个请求创建一个新的线程，并立即运行它们（而不是等待前一个请求处理完毕）。</p>\n<p>请注意onStartCommand()方法必须返回一个整数。这个整数是描述系统在杀死服务之后应该如何继续运行（上一节中缺省的 IntentService 实现代码会替你处理这一点，当然那样你就无法修改这个处理过程）。onStartCommand()的返回值必须是以下常量之一：</p>\n<ul>\n<li>START_NOT_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则不会重建服务了，除非还存在未发送的intent。 当服务不再是必需的，并且应用程序能够简单地重启那些未完成的工作时，这是避免服务运行的最安全的选项。 </li>\n</ul>\n<ul>\n<li>START_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并调用onStartCommand()，但不会再次送入上一个intent， 而是用null intent来调用onStartCommand() 。除非还有启动服务的intent未发送完，那么这些剩下的intent会继续发送。 这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命。 </li>\n</ul>\n<ul>\n<li>START_REDELIVER_INTENT: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并用上一个已送过的intent调用onStartCommand()。任何未发送完的intent也都会依次送入。这适用于那些需要立即恢复工作的活跃服务，比如下载文件。    </li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一-Service简介\"><a href=\"#一-Service简介\" class=\"headerlink\" title=\"一 Service简介\"></a>一 Service简介</h3><p>Service也是Android的四大组件之一，它并不提供用户界面，主要做一些即使该应用程序被调入后台也需要运行的事务。比如下载，音乐播放，执行文件I/O或者与content provider进行交互等。Service主要做的就是上面这些比较耗时的操作，但是由于Service也是运行在主线程中，因此最好在其中另开一个线程做这些耗时操作，否者可能会引起UI阻塞。       </p>\n<h3 id=\"二-Service的两种启动方式\"><a href=\"#二-Service的两种启动方式\" class=\"headerlink\" title=\"二 Service的两种启动方式\"></a>二 Service的两种启动方式</h3><p>Service有started和bound两种启动方式，当然也可以两种都启用。你可通过startService()启动服务后再通过bindService()将activity于Service绑定。     </p>\n<h5 id=\"1-startService-启动\"><a href=\"#1-startService-启动\" class=\"headerlink\" title=\"1.startService()启动\"></a>1.startService()启动</h5><p>通过startService()启动的Service，Service一旦启动即与它的调用者（通常是某个activity）不再关联，即使调用它的组件被销毁，它也能在后台一直运行下去。通常，该类服务执行单一的操作并且不会向调用者返回结果，比如它可以通过网络下载或上传文件。此类服务应该在其工作完成后通过重写stopSelf()使其自行终止，或者由其他组件调用stopService()来终止。<br>通过startService()启动的服务需要实现它的生命周期中onStartCommand()方法        </p>\n<h5 id=\"2-bindService-启动\"><a href=\"#2-bindService-启动\" class=\"headerlink\" title=\"2.bindService()启动\"></a>2.bindService()启动</h5><p>通过bindService()启动的服务，该服务的生命周期将与启动它的组件相关联，即如果启动它的组件被销毁则该服务也会被销毁，或者通过调用unBindService()与服务解绑，解绑后服务被销毁。多个组件可以同时与一个服务绑定，当所有组件都与服务解绑后，该服务才会被销毁。<br>bind服务提供了一个客户端/服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至进行进程间通信（IPC）。<br>通过bindService()启动的服务需要实现Service中的onBind()方法。   </p>\n<h3 id=\"三-Service的生命周期\"><a href=\"#三-Service的生命周期\" class=\"headerlink\" title=\"三 Service的生命周期\"></a>三 Service的生命周期</h3><p>两种Service的生命周期如下图：<br><img src=\"/2017/02/27/android基础之Service/Service生命周期图.png\" alt=\"Service生命周期图\" title=\"Service生命周期图\"><br>其回调方法如下：     </p>\n<pre><code class=\"java\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>{\n    <span class=\"keyword\">int</span> mStartMode;       <span class=\"comment\">// indicates how to behave if the service is killed</span>\n    IBinder mBinder;      <span class=\"comment\">// interface for clients that bind</span>\n    <span class=\"keyword\">boolean</span> mAllowRebind; <span class=\"comment\">// indicates whether onRebind should be used</span>\n\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>{\n        <span class=\"comment\">// The service is being created</span>\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>{\n        <span class=\"comment\">// The service is starting, due to a call to startService()</span>\n        <span class=\"keyword\">return</span> mStartMode;\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>{\n        <span class=\"comment\">// A client is binding to the service with bindService()</span>\n        <span class=\"keyword\">return</span> mBinder;\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onUnbind</span><span class=\"params\">(Intent intent)</span> </span>{\n        <span class=\"comment\">// All clients have unbound with unbindService()</span>\n        <span class=\"keyword\">return</span> mAllowRebind;\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRebind</span><span class=\"params\">(Intent intent)</span> </span>{\n        <span class=\"comment\">// A client is binding to the service with bindService(),</span>\n        <span class=\"comment\">// after onUnbind() has already been called</span>\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>{\n        <span class=\"comment\">// The service is no longer used and is being destroyed</span>\n    }\n}\n</code></pre>\n<h3 id=\"四-Service与线程的区别\"><a href=\"#四-Service与线程的区别\" class=\"headerlink\" title=\"四 Service与线程的区别\"></a>四 Service与线程的区别</h3><ul>\n<li>Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。     </li>\n<li>Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。<br>其实谈Service和线程的区别毫无意义，它们本来就是毫无关联的两样东西，我觉得应该谈的是在什么情况下，什么地方使用线程更合适。<br>比如：如果你的线程主要用于对UI的更新，那么在Activity中新建即可。但是如果你的线程用于app和服务器之间的消息推送，你需要隔一段时间就要连接服务器做数据同步的话，那么就不能在Activity中新建线程。因为此时的线程在Activity被销毁时，它仍然需要运行。此时将面对一个问题，如果你是Activity中创建得线程，那么当该Activity被销毁时，你将失去该线程的实例。另一方面，你没办法在不同的Activity中对同一线程进行控制。这种情况你就需要在Service中创建它，一方面Service在Activity被销毁时仍然可以运行，另一方面其他的Activity重建后也可以通过与Service进行绑定获得Service的实例，进而控制该线程。</li>\n</ul>\n<h3 id=\"五-保证Service不被杀死\"><a href=\"#五-保证Service不被杀死\" class=\"headerlink\" title=\"五 保证Service不被杀死\"></a>五 保证Service不被杀死</h3><ul>\n<li>onStartCommand方法，返回START_STICKY   </li>\n<li>提升service优先级   </li>\n<li>提升service进程优先级,将其提升为前台服务    </li>\n<li>onDestroy方法里重启service  </li>\n<li>监听系统广播判断Service状态    </li>\n<li>将APK安装到/system/app，变身系统级应用      </li>\n</ul>\n<h3 id=\"六-IntentService\"><a href=\"#六-IntentService\" class=\"headerlink\" title=\"六 IntentService\"></a>六 IntentService</h3><p>因为大多数started服务都不需要同时处理多个请求（这实际上是一个危险的多线程情况），所以最佳方式也许就是用IntentService类来实现你的服务。<br>IntentService将执行以下步骤：    　　</p>\n<ul>\n<li>创建一个缺省的工作（worker）线程，它独立于应用程序主线程来执行所有发送到onStartCommand()的intent。　　　</li>\n<li>创建一个工作队列，每次向你的onHandleIntent()传入一个intent，这样你就永远不必担心多线程问题了。　</li>\n<li>在处理完所有的启动请求后，终止服务，因此你就永远不需调用stopSelf()了。　　</li>\n<li>提供缺省的onBind()实现代码，它返回null。</li>\n<li>提供缺省的onStartCommand()实现代码，它把intent送入工作队列，稍后会再传给你的onHandleIntent()实现代码。　　　</li>\n</ul>\n<p>以上所有步骤将汇成一个结果：你要做的全部工作就是实现onHandleIntent()的代码，来完成客户端提交的任务。（当然你还需要为服务提供一小段构造方法。）       </p>\n<p>以下是个IntentService的实现例程：    </p>\n<pre><code class=\"java\">\n<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloIntentService</span> <span class=\"keyword\">extends</span> <span class=\"title\">IntentService</span> </span>{\n\n  <span class=\"comment\">/** \n   * 构造方法是必需的，必须用工作线程名称作为参数\n   * 调用父类的[http://developer.android.com/reference/android/app/IntentService.html#IntentService(java.lang.String) IntentService(String)]构造方法。\n   */</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HelloIntentService</span><span class=\"params\">()</span> </span>{\n      <span class=\"keyword\">super</span>(<span class=\"string\">\"HelloIntentService\"</span>);\n  }\n\n  <span class=\"comment\">/**\n   * IntentService从缺省的工作线程中调用本方法，并用启动服务的intent作为参数。 \n   * 本方法返回后，IntentService将适时终止这个服务。\n   */</span>\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onHandleIntent</span><span class=\"params\">(Intent intent)</span> </span>{\n      <span class=\"comment\">// 通常我们会在这里执行一些工作，比如下载文件。</span>\n      <span class=\"comment\">// 作为例子，我们只是睡5秒钟。</span>\n      <span class=\"keyword\">long</span> endTime = System.currentTimeMillis() + <span class=\"number\">5</span>*<span class=\"number\">1000</span>;\n      <span class=\"keyword\">while</span> (System.currentTimeMillis() &lt; endTime) {\n          <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) {\n              <span class=\"keyword\">try</span> {\n                  wait(endTime - System.currentTimeMillis());\n              } <span class=\"keyword\">catch</span> (Exception e) {\n              }\n          }\n      }\n  }\n}\n</code></pre>\n<p>所有你需要做的就是：一个构造方法和一个onHandleIntent()方法的实现。</p>\n<p>如果你还决定重写其它的回调方法，比如onCreate()、onStartCommand()、onDestroy()， 请确保调用一下父类的实现代码，以便IntentService能正确处理工作线程的生命周期。</p>\n<p>比如说，onStartCommand()必须返回缺省实现代码的结果（缺省代码实现了如何获取传给onHandleIntent()的intent）：    </p>\n<pre><code class=\"java\"><span class=\"meta\">@Override</span>\n<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>{\n    Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"service starting\"</span>, Toast.LENGTH_SHORT).show();\n    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onStartCommand(intent,flags,startId);\n}\n</code></pre>\n<p>除了onHandleIntent()以外，唯一不需要调用父类实现代码的方法是onBind()（不过如果你的服务允许绑定，你还是需要实现它）。    </p>\n<h3 id=\"七-扩展Service\"><a href=\"#七-扩展Service\" class=\"headerlink\" title=\"七 扩展Service\"></a>七 扩展Service</h3><p>如上节所述，利用IntentService来实现一个started服务非常简单。 不过，假如你的服务需要多线程运行（而不是通过一个工作队列来处理启动请求），那你可以扩展Service类来完成每个intent的处理。</p>\n<p>作为对照，以下例程实现了 Service 类，它执行的工作与上述使用IntentService的例子相同。确切地说，对于每一个启动请求，它都用一个工作线程来完成处理工作，并且每次只处理一个请求。    </p>\n<pre><code class=\"java\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>{\n  <span class=\"keyword\">private</span> Looper mServiceLooper;\n  <span class=\"keyword\">private</span> ServiceHandler mServiceHandler;\n\n  <span class=\"comment\">// 处理从线程接收的消息</span>\n  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>{\n      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServiceHandler</span><span class=\"params\">(Looper looper)</span> </span>{\n          <span class=\"keyword\">super</span>(looper);\n      }\n      <span class=\"meta\">@Override</span>\n      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>{\n          <span class=\"comment\">// 通常我们在这里执行一些工作，比如下载文件。</span>\n          <span class=\"comment\">// 作为例子，我们只是睡个5秒钟。</span>\n          <span class=\"keyword\">long</span> endTime = System.currentTimeMillis() + <span class=\"number\">5</span>*<span class=\"number\">1000</span>;\n          <span class=\"keyword\">while</span> (System.currentTimeMillis() &lt; endTime) {\n              <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) {\n                  <span class=\"keyword\">try</span> {\n                      wait(endTime - System.currentTimeMillis());\n                  } <span class=\"keyword\">catch</span> (Exception e) {\n                  }\n              }\n          }\n          <span class=\"comment\">// 根据startId终止服务，这样我们就不会在处理其它工作的过程中再来终止服务</span>\n          stopSelf(msg.arg1);\n      }\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>{\n    <span class=\"comment\">// 启动运行服务的线程。</span>\n    <span class=\"comment\">// 请记住我们要创建一个单独的线程，因为服务通常运行于进程的主线程中，可我们不想阻塞主线程。</span>\n    <span class=\"comment\">// 我们还要赋予它后台运行的优先级，以便计算密集的工作不会干扰我们的UI。</span>\n    HandlerThread thread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">\"ServiceStartArguments\"</span>,\n            Process.THREAD_PRIORITY_BACKGROUND);\n    thread.start();\n\n    <span class=\"comment\">// 获得HandlerThread的Looper队列并用于Handler</span>\n    mServiceLooper = thread.getLooper();\n    mServiceHandler = <span class=\"keyword\">new</span> ServiceHandler(mServiceLooper);\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>{\n      Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"service starting\"</span>, Toast.LENGTH_SHORT).show();\n\n      <span class=\"comment\">// 对于每一个启动请求，都发送一个消息来启动一个处理</span>\n      <span class=\"comment\">// 同时传入启动ID，以便任务完成后我们知道该终止哪一个请求。</span>\n      Message msg = mServiceHandler.obtainMessage();\n      msg.arg1 = startId;\n      mServiceHandler.sendMessage(msg);\n\n      <span class=\"comment\">// 如果我们被杀死了，那从这里返回之后被重启</span>\n      <span class=\"keyword\">return</span> START_STICKY;\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>{\n      <span class=\"comment\">// 我们不支持绑定，所以返回null</span>\n      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>{\n    Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"service done\"</span>, Toast.LENGTH_SHORT).show(); \n  }\n}\n</code></pre>\n<p>如你所见，它要干的事情比用IntentService时多了很多。</p>\n<p>不过，因为是自行处理每个onStartCommand()调用，你可以同时处理多个请求。 本例中没有这么去实现，但只要你愿意，你就可以为每个请求创建一个新的线程，并立即运行它们（而不是等待前一个请求处理完毕）。</p>\n<p>请注意onStartCommand()方法必须返回一个整数。这个整数是描述系统在杀死服务之后应该如何继续运行（上一节中缺省的 IntentService 实现代码会替你处理这一点，当然那样你就无法修改这个处理过程）。onStartCommand()的返回值必须是以下常量之一：</p>\n<ul>\n<li>START_NOT_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则不会重建服务了，除非还存在未发送的intent。 当服务不再是必需的，并且应用程序能够简单地重启那些未完成的工作时，这是避免服务运行的最安全的选项。 </li>\n</ul>\n<ul>\n<li>START_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并调用onStartCommand()，但不会再次送入上一个intent， 而是用null intent来调用onStartCommand() 。除非还有启动服务的intent未发送完，那么这些剩下的intent会继续发送。 这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命。 </li>\n</ul>\n<ul>\n<li>START_REDELIVER_INTENT: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并用上一个已送过的intent调用onStartCommand()。任何未发送完的intent也都会依次送入。这适用于那些需要立即恢复工作的活跃服务，比如下载文件。    </li>\n</ul>\n"},{"title":"android基础之事件分发机制","date":"2017-02-28T10:25:28.000Z","_content":"\n### 一 概述\n\n在android开发中会经常遇到滑动冲突（比如ScrollView或是SliddingMenu与ListView的嵌套）的问题，需要我们深入的了解android事件响应机制才能解决，事件响应机制已经是android开发者必不可少的知识。\n\n### 二 涉及到事件响应的常用方法构成\n\n用户在手指与屏幕接触过程中通过MotionEvent对象产生一系列事件，它有四种状态： \n\n- MotionEvent.ACTION_DOWN　：手指按下屏幕的瞬间（一切事件的开始）\n- MotionEvent.ACTION_MOVE　：手指在屏幕上移动\n- MotionEvent.ACTION_UP　：手指离开屏幕瞬间\n- MotionEvent.ACTION_CANCEL 　：取消手势，一般由程序产生，不会由用户产生\n\nAndroid中的事件onClick, onLongClick，onScroll, onFling等等，都是由许多个Touch事件构成的（一个ACTION_DOWN， n个ACTION_MOVE，1个ACTION_UP）。\n\nandroid 事件响应机制是先分发（先由外部的View接收，然后依次传递给其内层的最小View）再处理 （从最小View单元（事件源）开始依次向外层传递。）的形式实现的。\n\n复杂性表现在：可以控制每层事件是否继续传递（分发和拦截协同实现），以及事件的具体消费（事件分发也具有事件消费能力）。\n\n### 三 android事件处理涉及到的三个重要函数\n\n##### 1.事件分发：public boolean dispatchTouchEvent(MotionEvent ev)\n\n当有监听到事件时，首先由Activity进行捕获，进入事件分发处理流程。（因为activity没有事件拦截，View和ViewGroup有）会将事件传递给最外层View的dispatchTouchEvent(MotionEvent ev)方法，该方法对事件进行分发。 \n\n- return true ：表示该View内部消化掉了所有事件。\n\n- return false ：事件在本层不再继续进行分发，并交由上层控件的onTouchEvent方法进行消费（如果本层控件已经是Activity，那么事件将被系统消费或处理）。　\n\n- 如果事件分发返回系统默认的 super.dispatchTouchEvent(ev)，事件将分发给本层的事件拦截onInterceptTouchEvent 方法进行处理\n\n##### 2.事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)\n\n- return true ：表示将事件进行拦截，并将拦截到的事件交由本层控件 的 onTouchEvent 进行处理；\n\n- return false ：则表示不对事件进行拦截，事件得以成功分发到子View。并由子View的dispatchTouchEvent进行处理。　\n\n- 如果返回super.onInterceptTouchEvent(ev)，默认表示拦截该事件，并将事件传递给当前View的onTouchEvent方法，和return true一样。\n\n##### 3.事件响应：public boolean onTouchEvent(MotionEvent ev)\n\n在dispatchTouchEvent（事件分发）返回super.dispatchTouchEvent(ev)并且onInterceptTouchEvent（事件拦截返回true或super.onInterceptTouchEvent(ev)的情况下，那么事件会传递到onTouchEvent方法，该方法对事件进行响应。\n\n- 如果return true，表示onTouchEvent处理完事件后消费了此次事件。此时事件终结；\n\n- 如果return fasle，则表示不响应事件，那么该事件将会不断向上层View的onTouchEvent方法传递，直到某个View的onTouchEvent方法返回true，如果到了最顶层View还是返回false，那么认为该事件不消耗，则在同一个事件系列中，当前View无法再次接收到事件，该事件会交由Activity的onTouchEvent进行处理；　　\n\n- 如果return super.dispatchTouchEvent(ev)，则表示不响应事件，结果与return false一样。\n\n从以上过程中可以看出，dispatchTouchEvent无论返回true还是false，事件都不再进行分发，只有当其返回super.dispatchTouchEvent(ev)，才表明其具有向下层分发的愿望，但是是否能够分发成功，则需要经过事件拦截onInterceptTouchEvent的审核。事件是否向上传递处理是由onTouchEvent的返回值决定的。\n\n下面是Touch事件传递机制流程图：\n\n{% asset_img Touch事件分发机制流程图.png Touch事件分发机制流程图 %}\n\n### 四 View源码分析\n\nAndroid中ImageView、textView、Button等继承于View但没有重写的dispatchTouchEvent方法，所以都用的View的该方法进行事件分发。\n\n看View重要函数部分源码：\n\n```java\npublic boolean dispatchTouchEvent(MotionEvent event) {\n//返回true,表示该View内部消化掉了所有事件。返回false，表示View内部只处理了ACTION_DOWN事件，事件继续传递，向上级View(ViewGroup)传递。\n\n    if (mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED &&\n            mOnTouchListener.onTouch(this, event)) {\n  //此处的onTouch方式就是回调的我们注册OnTouchListener时重写的onTouch()方法\n        return true;\n    }\n    return onTouchEvent(event);\n}\n```\n\n首先进行三个条件的判断：\n\n- 查看是否给button设置了OnTouchListener()事件；\n- 控件是否Enable；（控件默认都是enable的）\n- button里面实现的OnTouchListener监听里的onTouch()方法是否返回true；\n\n如果条件都满足，则该事件被消耗掉，不再进入onTouchEvent中处理。否则将事件将交给onTouchEvent方法处理。\n\n```java\n public boolean onTouchEvent(MotionEvent event) {\n    ...\n\n   /＊ 当前onTouch的组件必须是可点击的比如Button，ImageButton等等，此处CLICKABLE为true，才会进入if方法，最后返回true。\n 如果是ImageView、TexitView这些默认为不可点击的View,此处CLICKABLE为false，最后返回false。当然会有特殊情况，如果给这些View设置了onClick监听器，此处CLICKABLE也将为true　　＊／\n\n    if (((viewFlags & CLICKABLE) == CLICKABLE ||  \n            (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_UP:\n                ...\n                            if (!post(mPerformClick)) {\n                                performClick();// 实际就是回调了我们注册的OnClickListener中重新的onClick()方法\n                            }\n                 ...\n                break;\n\n            case MotionEvent.ACTION_DOWN:\n               ...\n                break;\n\n            case MotionEvent.ACTION_CANCEL:\n                ...\n                break;\n\n            case MotionEvent.ACTION_MOVE:\n               ...\n                break;\n        }\n        return true;\n    }\n\n    return false;\n}\n```\n\n```java\npublic boolean performClick() {\n    ...\n ／／\n    if (li != null && li.mOnClickListener != null) {\n        ...\n        li.mOnClickListener.onClick(this);\n        return true;\n    }\n\n    return false;\n}\n\n public void setOnClickListener(OnClickListener l) {\n    if (!isClickable()) {\n        setClickable(true);\n    }\n    getListenerInfo().mOnClickListener = l;\n}\n```\n\n只有我们注册OnTouchListener时重写的 onTouch()方法中:\n\n- 返回false —> 执行onTouchEvent方法 —> 导致onClick()回调方法执行　\n- 返回true —> onTouchEvent方法不执行 —> 导致onClick()回调方法不会执行\n\n### 五 ViewGroup源码分析\n\nAndroid中诸如LinearLayout等的五大布局控件，都是继承自ViewGroup，而ViewGroup本身是继承自View，所以ViewGroup的事件处理机制对这些控件都有效。\n\n```java\npublic boolean dispatchTouchEvent(MotionEvent ev) {  \n       final int action = ev.getAction();  \n       final float xf = ev.getX();  \n       final float yf = ev.getY();  \n       final float scrolledXFloat = xf + mScrollX;  \n       final float scrolledYFloat = yf + mScrollY;  \n       final Rect frame = mTempRect;  \n\n       //这个值默认是false, 然后我们可以通过requestDisallowInterceptTouchEvent(boolean disallowIntercept)方法  \n       //来改变disallowIntercept的值  \n       boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;  \n\n       //这里是ACTION_DOWN的处理逻辑  \n       if (action == MotionEvent.ACTION_DOWN) {  \n        //清除mMotionTarget, 每次ACTION_DOWN都很设置mMotionTarget为null  \n           if (mMotionTarget != null) {  \n               mMotionTarget = null;  \n           }  \n\n           //disallowIntercept默认是false, 就看ViewGroup的onInterceptTouchEvent()方法  \n           if (disallowIntercept || !onInterceptTouchEvent(ev)) {  //第一点\n               ev.setAction(MotionEvent.ACTION_DOWN);  \n               final int scrolledXInt = (int) scrolledXFloat;  \n               final int scrolledYInt = (int) scrolledYFloat;  \n               final View[] children = mChildren;  \n               final int count = mChildrenCount;  \n               //遍历其子View  \n               for (int i = count - 1; i >= 0; i--) {  //第二点\n                   final View child = children[i];  \n\n                   //如果该子View是VISIBLE或者该子View正在执行动画, 表示该View才  \n                   //可以接受到Touch事件  \n                   if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE  \n                           || child.getAnimation() != null) {  \n                    //获取子View的位置范围  \n                       child.getHitRect(frame);  \n\n                       //如Touch到屏幕上的点在该子View上面  \n                       if (frame.contains(scrolledXInt, scrolledYInt)) {  \n                           // offset the event to the view's coordinate system  \n                           final float xc = scrolledXFloat - child.mLeft;  \n                           final float yc = scrolledYFloat - child.mTop;  \n                           ev.setLocation(xc, yc);  \n                           child.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  \n\n                           //调用该子View的dispatchTouchEvent()方法  \n                           if (child.dispatchTouchEvent(ev))  {  \n                               // 如果child.dispatchTouchEvent(ev)返回true表示  \n                            //该事件被消费了，设置mMotionTarget为该子View  \n                               mMotionTarget = child;  \n                               //直接返回true  \n                               return true;  \n                           }  \n                           // The event didn't get handled, try the next view.  \n                           // Don't reset the event's location, it's not  \n                           // necessary here.  \n                       }  \n                   }  \n               }  \n           }  \n       }  \n\n       //判断是否为ACTION_UP或者ACTION_CANCEL  \n       boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  \n               (action == MotionEvent.ACTION_CANCEL);  \n\n       if (isUpOrCancel) {  \n           //如果是ACTION_UP或者ACTION_CANCEL, 将disallowIntercept设置为默认的false  \n        //假如我们调用了requestDisallowInterceptTouchEvent()方法来设置disallowIntercept为true  \n        //当我们抬起手指或者取消Touch事件的时候要将disallowIntercept重置为false  \n        //所以说上面的disallowIntercept默认在我们每次ACTION_DOWN的时候都是false  \n           mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;  \n       }  \n\n       // The event wasn't an ACTION_DOWN, dispatch it to our target if  \n       // we have one.  \n       final View target = mMotionTarget;  \n       //mMotionTarget为null意味着没有找到消费Touch事件的View, 所以我们需要调用ViewGroup父类的  \n       //dispatchTouchEvent()方法，也就是View的dispatchTouchEvent()方法  \n       if (target == null) {  \n           // We don't have a target, this means we're handling the  \n           // event as a regular view.  \n           ev.setLocation(xf, yf);  \n           if ((mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {  \n               ev.setAction(MotionEvent.ACTION_CANCEL);  \n               mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  \n           }  \n           return super.dispatchTouchEvent(ev);  \n       }  \n\n       //这个if里面的代码ACTION_DOWN不会执行，只有ACTION_MOVE  \n       //ACTION_UP才会走到这里, 假如在ACTION_MOVE或者ACTION_UP拦截的  \n       //Touch事件, 将ACTION_CANCEL派发给target，然后直接返回true  \n       //表示消费了此Touch事件  \n       if (!disallowIntercept && onInterceptTouchEvent(ev)) {  \n           final float xc = scrolledXFloat - (float) target.mLeft;  \n           final float yc = scrolledYFloat - (float) target.mTop;  \n           mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  \n           ev.setAction(MotionEvent.ACTION_CANCEL);  \n           ev.setLocation(xc, yc);  \n\n           if (!target.dispatchTouchEvent(ev)) {  \n           }  \n           // clear the target  \n           mMotionTarget = null;  \n           // Don't dispatch this event to our own view, because we already  \n           // saw it when intercepting; we just want to give the following  \n           // event to the normal onTouchEvent().  \n           return true;  \n       }  \n\n       if (isUpOrCancel) {  \n           mMotionTarget = null;  \n       }  \n\n       // finally offset the event to the target's coordinate system and  \n       // dispatch the event.  \n       final float xc = scrolledXFloat - (float) target.mLeft;  \n       final float yc = scrolledYFloat - (float) target.mTop;  \n       ev.setLocation(xc, yc);  \n\n       if ((target.mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {  \n           ev.setAction(MotionEvent.ACTION_CANCEL);  \n           target.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  \n           mMotionTarget = null;  \n       }  \n\n       //如果没有拦截ACTION_MOVE, ACTION_DOWN的话，直接将Touch事件派发给target  \n       return target.dispatchTouchEvent(ev);  \n   }\n```\n\n- dispatchTouchEvent作用：决定事件是否由onInterceptTouchEvent来拦截处理。 返回super.dispatchTouchEvent时，由onInterceptTouchEvent来决定事件的流向 返回false时，会继续分发事件，自己内部只处理了ACTION_DOWN 返回true时，不会继续分发事件，自己内部处理了所有事件（ACTION_DOWN,ACTION_MOVE,ACTION_UP）\n\n- onInterceptTouchEvent作用：拦截事件，用来决定事件是否传向子View 返回true时，拦截后交给自己的onTouchEvent处理 返回false时，拦截后交给子View来处理\n\n- onTouchEvent作用：事件最终到达这个方法 返回true时，内部处理所有的事件，换句话说，后续事件将继续传递给该view的onTouchEvent()处理 返回false时，事件会向上传递，由onToucEvent来接受，如果最上面View中的onTouchEvent也返回false的话，那么事件就会消失\n\n### 六 总结\n\n- 如果ViewGroup找到了能够处理该事件的View，则直接交给子View处理，自己的onTouchEvent不会被触发；　\n\n- 可以通过复写onInterceptTouchEvent(ev)方法，拦截子View的事件（即return true），把事件交给自己处理，则会执行自己对应的onTouchEvent方法。\n\n- 子View可以通过调用getParent().requestDisallowInterceptTouchEvent(true); 阻止ViewGroup对其MOVE或者UP事件进行拦截；　　\n\n- 一个点击事件产生后，它的传递过程如下： Activity->Window->View。顶级View接收到事件之后，就会按相应规则去分发事件。如果一个View的onTouchEvent方法返回false，那么将会交给父容器的onTouchEvent方法进行处理，逐级往上，如果所有的View都不处理该事件，则交由Activity的onTouchEvent进行处理。　\n\n- 如果某一个View开始处理事件，如果他不消耗ACTION_DOWN事件（也就是onTouchEvent返回false），则同一事件序列比如接下来进行ACTION_MOVE，则不会再交给该View处理。\n\n- ViewGroup默认不拦截任何事件。　\n\n- 诸如TextView、ImageView这些不作为容器的View，一旦接受到事件，就调用onTouchEvent方法，它们本身没有onInterceptTouchEvent方法。正常情况下，它们都会消耗事件（返回true），除非它们是不可点击的（clickable和longClickable都为false），那么就会交由父容器的onTouchEvent处理。　\n\n- 点击事件分发过程如下 dispatchTouchEvent—->OnTouchListener的onTouch方法—->onTouchEvent-->OnClickListener的onClick方法。也就是说，我们平时调用的setOnClickListener，优先级是最低的，所以，onTouchEvent或OnTouchListener的onTouch方法如果返回true，则不响应onClick方法...\n\n{% asset_img android事件分发.png 一个据说很牛的图 %}\n\n","source":"_posts/android基础之事件分发机制.md","raw":"---\ntitle: android基础之事件分发机制\ndate: 2017-02-28 18:25:28\ncategories: android\ntags:\n- android\n- java\n- View\n- 事件分发\n---\n\n### 一 概述\n\n在android开发中会经常遇到滑动冲突（比如ScrollView或是SliddingMenu与ListView的嵌套）的问题，需要我们深入的了解android事件响应机制才能解决，事件响应机制已经是android开发者必不可少的知识。\n\n### 二 涉及到事件响应的常用方法构成\n\n用户在手指与屏幕接触过程中通过MotionEvent对象产生一系列事件，它有四种状态： \n\n- MotionEvent.ACTION_DOWN　：手指按下屏幕的瞬间（一切事件的开始）\n- MotionEvent.ACTION_MOVE　：手指在屏幕上移动\n- MotionEvent.ACTION_UP　：手指离开屏幕瞬间\n- MotionEvent.ACTION_CANCEL 　：取消手势，一般由程序产生，不会由用户产生\n\nAndroid中的事件onClick, onLongClick，onScroll, onFling等等，都是由许多个Touch事件构成的（一个ACTION_DOWN， n个ACTION_MOVE，1个ACTION_UP）。\n\nandroid 事件响应机制是先分发（先由外部的View接收，然后依次传递给其内层的最小View）再处理 （从最小View单元（事件源）开始依次向外层传递。）的形式实现的。\n\n复杂性表现在：可以控制每层事件是否继续传递（分发和拦截协同实现），以及事件的具体消费（事件分发也具有事件消费能力）。\n\n### 三 android事件处理涉及到的三个重要函数\n\n##### 1.事件分发：public boolean dispatchTouchEvent(MotionEvent ev)\n\n当有监听到事件时，首先由Activity进行捕获，进入事件分发处理流程。（因为activity没有事件拦截，View和ViewGroup有）会将事件传递给最外层View的dispatchTouchEvent(MotionEvent ev)方法，该方法对事件进行分发。 \n\n- return true ：表示该View内部消化掉了所有事件。\n\n- return false ：事件在本层不再继续进行分发，并交由上层控件的onTouchEvent方法进行消费（如果本层控件已经是Activity，那么事件将被系统消费或处理）。　\n\n- 如果事件分发返回系统默认的 super.dispatchTouchEvent(ev)，事件将分发给本层的事件拦截onInterceptTouchEvent 方法进行处理\n\n##### 2.事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)\n\n- return true ：表示将事件进行拦截，并将拦截到的事件交由本层控件 的 onTouchEvent 进行处理；\n\n- return false ：则表示不对事件进行拦截，事件得以成功分发到子View。并由子View的dispatchTouchEvent进行处理。　\n\n- 如果返回super.onInterceptTouchEvent(ev)，默认表示拦截该事件，并将事件传递给当前View的onTouchEvent方法，和return true一样。\n\n##### 3.事件响应：public boolean onTouchEvent(MotionEvent ev)\n\n在dispatchTouchEvent（事件分发）返回super.dispatchTouchEvent(ev)并且onInterceptTouchEvent（事件拦截返回true或super.onInterceptTouchEvent(ev)的情况下，那么事件会传递到onTouchEvent方法，该方法对事件进行响应。\n\n- 如果return true，表示onTouchEvent处理完事件后消费了此次事件。此时事件终结；\n\n- 如果return fasle，则表示不响应事件，那么该事件将会不断向上层View的onTouchEvent方法传递，直到某个View的onTouchEvent方法返回true，如果到了最顶层View还是返回false，那么认为该事件不消耗，则在同一个事件系列中，当前View无法再次接收到事件，该事件会交由Activity的onTouchEvent进行处理；　　\n\n- 如果return super.dispatchTouchEvent(ev)，则表示不响应事件，结果与return false一样。\n\n从以上过程中可以看出，dispatchTouchEvent无论返回true还是false，事件都不再进行分发，只有当其返回super.dispatchTouchEvent(ev)，才表明其具有向下层分发的愿望，但是是否能够分发成功，则需要经过事件拦截onInterceptTouchEvent的审核。事件是否向上传递处理是由onTouchEvent的返回值决定的。\n\n下面是Touch事件传递机制流程图：\n\n{% asset_img Touch事件分发机制流程图.png Touch事件分发机制流程图 %}\n\n### 四 View源码分析\n\nAndroid中ImageView、textView、Button等继承于View但没有重写的dispatchTouchEvent方法，所以都用的View的该方法进行事件分发。\n\n看View重要函数部分源码：\n\n```java\npublic boolean dispatchTouchEvent(MotionEvent event) {\n//返回true,表示该View内部消化掉了所有事件。返回false，表示View内部只处理了ACTION_DOWN事件，事件继续传递，向上级View(ViewGroup)传递。\n\n    if (mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED &&\n            mOnTouchListener.onTouch(this, event)) {\n  //此处的onTouch方式就是回调的我们注册OnTouchListener时重写的onTouch()方法\n        return true;\n    }\n    return onTouchEvent(event);\n}\n```\n\n首先进行三个条件的判断：\n\n- 查看是否给button设置了OnTouchListener()事件；\n- 控件是否Enable；（控件默认都是enable的）\n- button里面实现的OnTouchListener监听里的onTouch()方法是否返回true；\n\n如果条件都满足，则该事件被消耗掉，不再进入onTouchEvent中处理。否则将事件将交给onTouchEvent方法处理。\n\n```java\n public boolean onTouchEvent(MotionEvent event) {\n    ...\n\n   /＊ 当前onTouch的组件必须是可点击的比如Button，ImageButton等等，此处CLICKABLE为true，才会进入if方法，最后返回true。\n 如果是ImageView、TexitView这些默认为不可点击的View,此处CLICKABLE为false，最后返回false。当然会有特殊情况，如果给这些View设置了onClick监听器，此处CLICKABLE也将为true　　＊／\n\n    if (((viewFlags & CLICKABLE) == CLICKABLE ||  \n            (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_UP:\n                ...\n                            if (!post(mPerformClick)) {\n                                performClick();// 实际就是回调了我们注册的OnClickListener中重新的onClick()方法\n                            }\n                 ...\n                break;\n\n            case MotionEvent.ACTION_DOWN:\n               ...\n                break;\n\n            case MotionEvent.ACTION_CANCEL:\n                ...\n                break;\n\n            case MotionEvent.ACTION_MOVE:\n               ...\n                break;\n        }\n        return true;\n    }\n\n    return false;\n}\n```\n\n```java\npublic boolean performClick() {\n    ...\n ／／\n    if (li != null && li.mOnClickListener != null) {\n        ...\n        li.mOnClickListener.onClick(this);\n        return true;\n    }\n\n    return false;\n}\n\n public void setOnClickListener(OnClickListener l) {\n    if (!isClickable()) {\n        setClickable(true);\n    }\n    getListenerInfo().mOnClickListener = l;\n}\n```\n\n只有我们注册OnTouchListener时重写的 onTouch()方法中:\n\n- 返回false —> 执行onTouchEvent方法 —> 导致onClick()回调方法执行　\n- 返回true —> onTouchEvent方法不执行 —> 导致onClick()回调方法不会执行\n\n### 五 ViewGroup源码分析\n\nAndroid中诸如LinearLayout等的五大布局控件，都是继承自ViewGroup，而ViewGroup本身是继承自View，所以ViewGroup的事件处理机制对这些控件都有效。\n\n```java\npublic boolean dispatchTouchEvent(MotionEvent ev) {  \n       final int action = ev.getAction();  \n       final float xf = ev.getX();  \n       final float yf = ev.getY();  \n       final float scrolledXFloat = xf + mScrollX;  \n       final float scrolledYFloat = yf + mScrollY;  \n       final Rect frame = mTempRect;  \n\n       //这个值默认是false, 然后我们可以通过requestDisallowInterceptTouchEvent(boolean disallowIntercept)方法  \n       //来改变disallowIntercept的值  \n       boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;  \n\n       //这里是ACTION_DOWN的处理逻辑  \n       if (action == MotionEvent.ACTION_DOWN) {  \n        //清除mMotionTarget, 每次ACTION_DOWN都很设置mMotionTarget为null  \n           if (mMotionTarget != null) {  \n               mMotionTarget = null;  \n           }  \n\n           //disallowIntercept默认是false, 就看ViewGroup的onInterceptTouchEvent()方法  \n           if (disallowIntercept || !onInterceptTouchEvent(ev)) {  //第一点\n               ev.setAction(MotionEvent.ACTION_DOWN);  \n               final int scrolledXInt = (int) scrolledXFloat;  \n               final int scrolledYInt = (int) scrolledYFloat;  \n               final View[] children = mChildren;  \n               final int count = mChildrenCount;  \n               //遍历其子View  \n               for (int i = count - 1; i >= 0; i--) {  //第二点\n                   final View child = children[i];  \n\n                   //如果该子View是VISIBLE或者该子View正在执行动画, 表示该View才  \n                   //可以接受到Touch事件  \n                   if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE  \n                           || child.getAnimation() != null) {  \n                    //获取子View的位置范围  \n                       child.getHitRect(frame);  \n\n                       //如Touch到屏幕上的点在该子View上面  \n                       if (frame.contains(scrolledXInt, scrolledYInt)) {  \n                           // offset the event to the view's coordinate system  \n                           final float xc = scrolledXFloat - child.mLeft;  \n                           final float yc = scrolledYFloat - child.mTop;  \n                           ev.setLocation(xc, yc);  \n                           child.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  \n\n                           //调用该子View的dispatchTouchEvent()方法  \n                           if (child.dispatchTouchEvent(ev))  {  \n                               // 如果child.dispatchTouchEvent(ev)返回true表示  \n                            //该事件被消费了，设置mMotionTarget为该子View  \n                               mMotionTarget = child;  \n                               //直接返回true  \n                               return true;  \n                           }  \n                           // The event didn't get handled, try the next view.  \n                           // Don't reset the event's location, it's not  \n                           // necessary here.  \n                       }  \n                   }  \n               }  \n           }  \n       }  \n\n       //判断是否为ACTION_UP或者ACTION_CANCEL  \n       boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  \n               (action == MotionEvent.ACTION_CANCEL);  \n\n       if (isUpOrCancel) {  \n           //如果是ACTION_UP或者ACTION_CANCEL, 将disallowIntercept设置为默认的false  \n        //假如我们调用了requestDisallowInterceptTouchEvent()方法来设置disallowIntercept为true  \n        //当我们抬起手指或者取消Touch事件的时候要将disallowIntercept重置为false  \n        //所以说上面的disallowIntercept默认在我们每次ACTION_DOWN的时候都是false  \n           mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;  \n       }  \n\n       // The event wasn't an ACTION_DOWN, dispatch it to our target if  \n       // we have one.  \n       final View target = mMotionTarget;  \n       //mMotionTarget为null意味着没有找到消费Touch事件的View, 所以我们需要调用ViewGroup父类的  \n       //dispatchTouchEvent()方法，也就是View的dispatchTouchEvent()方法  \n       if (target == null) {  \n           // We don't have a target, this means we're handling the  \n           // event as a regular view.  \n           ev.setLocation(xf, yf);  \n           if ((mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {  \n               ev.setAction(MotionEvent.ACTION_CANCEL);  \n               mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  \n           }  \n           return super.dispatchTouchEvent(ev);  \n       }  \n\n       //这个if里面的代码ACTION_DOWN不会执行，只有ACTION_MOVE  \n       //ACTION_UP才会走到这里, 假如在ACTION_MOVE或者ACTION_UP拦截的  \n       //Touch事件, 将ACTION_CANCEL派发给target，然后直接返回true  \n       //表示消费了此Touch事件  \n       if (!disallowIntercept && onInterceptTouchEvent(ev)) {  \n           final float xc = scrolledXFloat - (float) target.mLeft;  \n           final float yc = scrolledYFloat - (float) target.mTop;  \n           mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  \n           ev.setAction(MotionEvent.ACTION_CANCEL);  \n           ev.setLocation(xc, yc);  \n\n           if (!target.dispatchTouchEvent(ev)) {  \n           }  \n           // clear the target  \n           mMotionTarget = null;  \n           // Don't dispatch this event to our own view, because we already  \n           // saw it when intercepting; we just want to give the following  \n           // event to the normal onTouchEvent().  \n           return true;  \n       }  \n\n       if (isUpOrCancel) {  \n           mMotionTarget = null;  \n       }  \n\n       // finally offset the event to the target's coordinate system and  \n       // dispatch the event.  \n       final float xc = scrolledXFloat - (float) target.mLeft;  \n       final float yc = scrolledYFloat - (float) target.mTop;  \n       ev.setLocation(xc, yc);  \n\n       if ((target.mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {  \n           ev.setAction(MotionEvent.ACTION_CANCEL);  \n           target.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  \n           mMotionTarget = null;  \n       }  \n\n       //如果没有拦截ACTION_MOVE, ACTION_DOWN的话，直接将Touch事件派发给target  \n       return target.dispatchTouchEvent(ev);  \n   }\n```\n\n- dispatchTouchEvent作用：决定事件是否由onInterceptTouchEvent来拦截处理。 返回super.dispatchTouchEvent时，由onInterceptTouchEvent来决定事件的流向 返回false时，会继续分发事件，自己内部只处理了ACTION_DOWN 返回true时，不会继续分发事件，自己内部处理了所有事件（ACTION_DOWN,ACTION_MOVE,ACTION_UP）\n\n- onInterceptTouchEvent作用：拦截事件，用来决定事件是否传向子View 返回true时，拦截后交给自己的onTouchEvent处理 返回false时，拦截后交给子View来处理\n\n- onTouchEvent作用：事件最终到达这个方法 返回true时，内部处理所有的事件，换句话说，后续事件将继续传递给该view的onTouchEvent()处理 返回false时，事件会向上传递，由onToucEvent来接受，如果最上面View中的onTouchEvent也返回false的话，那么事件就会消失\n\n### 六 总结\n\n- 如果ViewGroup找到了能够处理该事件的View，则直接交给子View处理，自己的onTouchEvent不会被触发；　\n\n- 可以通过复写onInterceptTouchEvent(ev)方法，拦截子View的事件（即return true），把事件交给自己处理，则会执行自己对应的onTouchEvent方法。\n\n- 子View可以通过调用getParent().requestDisallowInterceptTouchEvent(true); 阻止ViewGroup对其MOVE或者UP事件进行拦截；　　\n\n- 一个点击事件产生后，它的传递过程如下： Activity->Window->View。顶级View接收到事件之后，就会按相应规则去分发事件。如果一个View的onTouchEvent方法返回false，那么将会交给父容器的onTouchEvent方法进行处理，逐级往上，如果所有的View都不处理该事件，则交由Activity的onTouchEvent进行处理。　\n\n- 如果某一个View开始处理事件，如果他不消耗ACTION_DOWN事件（也就是onTouchEvent返回false），则同一事件序列比如接下来进行ACTION_MOVE，则不会再交给该View处理。\n\n- ViewGroup默认不拦截任何事件。　\n\n- 诸如TextView、ImageView这些不作为容器的View，一旦接受到事件，就调用onTouchEvent方法，它们本身没有onInterceptTouchEvent方法。正常情况下，它们都会消耗事件（返回true），除非它们是不可点击的（clickable和longClickable都为false），那么就会交由父容器的onTouchEvent处理。　\n\n- 点击事件分发过程如下 dispatchTouchEvent—->OnTouchListener的onTouch方法—->onTouchEvent-->OnClickListener的onClick方法。也就是说，我们平时调用的setOnClickListener，优先级是最低的，所以，onTouchEvent或OnTouchListener的onTouch方法如果返回true，则不响应onClick方法...\n\n{% asset_img android事件分发.png 一个据说很牛的图 %}\n\n","slug":"android基础之事件分发机制","published":1,"updated":"2017-03-09T12:47:42.069Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj02g6gsm000h7c02nysj3x7v","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>在android开发中会经常遇到滑动冲突（比如ScrollView或是SliddingMenu与ListView的嵌套）的问题，需要我们深入的了解android事件响应机制才能解决，事件响应机制已经是android开发者必不可少的知识。</p>\n<h3 id=\"二-涉及到事件响应的常用方法构成\"><a href=\"#二-涉及到事件响应的常用方法构成\" class=\"headerlink\" title=\"二 涉及到事件响应的常用方法构成\"></a>二 涉及到事件响应的常用方法构成</h3><p>用户在手指与屏幕接触过程中通过MotionEvent对象产生一系列事件，它有四种状态： </p>\n<ul>\n<li>MotionEvent.ACTION_DOWN　：手指按下屏幕的瞬间（一切事件的开始）</li>\n<li>MotionEvent.ACTION_MOVE　：手指在屏幕上移动</li>\n<li>MotionEvent.ACTION_UP　：手指离开屏幕瞬间</li>\n<li>MotionEvent.ACTION_CANCEL 　：取消手势，一般由程序产生，不会由用户产生</li>\n</ul>\n<p>Android中的事件onClick, onLongClick，onScroll, onFling等等，都是由许多个Touch事件构成的（一个ACTION_DOWN， n个ACTION_MOVE，1个ACTION_UP）。</p>\n<p>android 事件响应机制是先分发（先由外部的View接收，然后依次传递给其内层的最小View）再处理 （从最小View单元（事件源）开始依次向外层传递。）的形式实现的。</p>\n<p>复杂性表现在：可以控制每层事件是否继续传递（分发和拦截协同实现），以及事件的具体消费（事件分发也具有事件消费能力）。</p>\n<h3 id=\"三-android事件处理涉及到的三个重要函数\"><a href=\"#三-android事件处理涉及到的三个重要函数\" class=\"headerlink\" title=\"三 android事件处理涉及到的三个重要函数\"></a>三 android事件处理涉及到的三个重要函数</h3><h5 id=\"1-事件分发：public-boolean-dispatchTouchEvent-MotionEvent-ev\"><a href=\"#1-事件分发：public-boolean-dispatchTouchEvent-MotionEvent-ev\" class=\"headerlink\" title=\"1.事件分发：public boolean dispatchTouchEvent(MotionEvent ev)\"></a>1.事件分发：public boolean dispatchTouchEvent(MotionEvent ev)</h5><p>当有监听到事件时，首先由Activity进行捕获，进入事件分发处理流程。（因为activity没有事件拦截，View和ViewGroup有）会将事件传递给最外层View的dispatchTouchEvent(MotionEvent ev)方法，该方法对事件进行分发。 </p>\n<ul>\n<li><p>return true ：表示该View内部消化掉了所有事件。</p>\n</li>\n<li><p>return false ：事件在本层不再继续进行分发，并交由上层控件的onTouchEvent方法进行消费（如果本层控件已经是Activity，那么事件将被系统消费或处理）。　</p>\n</li>\n<li><p>如果事件分发返回系统默认的 super.dispatchTouchEvent(ev)，事件将分发给本层的事件拦截onInterceptTouchEvent 方法进行处理</p>\n</li>\n</ul>\n<h5 id=\"2-事件拦截：public-boolean-onInterceptTouchEvent-MotionEvent-ev\"><a href=\"#2-事件拦截：public-boolean-onInterceptTouchEvent-MotionEvent-ev\" class=\"headerlink\" title=\"2.事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)\"></a>2.事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)</h5><ul>\n<li><p>return true ：表示将事件进行拦截，并将拦截到的事件交由本层控件 的 onTouchEvent 进行处理；</p>\n</li>\n<li><p>return false ：则表示不对事件进行拦截，事件得以成功分发到子View。并由子View的dispatchTouchEvent进行处理。　</p>\n</li>\n<li><p>如果返回super.onInterceptTouchEvent(ev)，默认表示拦截该事件，并将事件传递给当前View的onTouchEvent方法，和return true一样。</p>\n</li>\n</ul>\n<h5 id=\"3-事件响应：public-boolean-onTouchEvent-MotionEvent-ev\"><a href=\"#3-事件响应：public-boolean-onTouchEvent-MotionEvent-ev\" class=\"headerlink\" title=\"3.事件响应：public boolean onTouchEvent(MotionEvent ev)\"></a>3.事件响应：public boolean onTouchEvent(MotionEvent ev)</h5><p>在dispatchTouchEvent（事件分发）返回super.dispatchTouchEvent(ev)并且onInterceptTouchEvent（事件拦截返回true或super.onInterceptTouchEvent(ev)的情况下，那么事件会传递到onTouchEvent方法，该方法对事件进行响应。</p>\n<ul>\n<li><p>如果return true，表示onTouchEvent处理完事件后消费了此次事件。此时事件终结；</p>\n</li>\n<li><p>如果return fasle，则表示不响应事件，那么该事件将会不断向上层View的onTouchEvent方法传递，直到某个View的onTouchEvent方法返回true，如果到了最顶层View还是返回false，那么认为该事件不消耗，则在同一个事件系列中，当前View无法再次接收到事件，该事件会交由Activity的onTouchEvent进行处理；　　</p>\n</li>\n<li><p>如果return super.dispatchTouchEvent(ev)，则表示不响应事件，结果与return false一样。</p>\n</li>\n</ul>\n<p>从以上过程中可以看出，dispatchTouchEvent无论返回true还是false，事件都不再进行分发，只有当其返回super.dispatchTouchEvent(ev)，才表明其具有向下层分发的愿望，但是是否能够分发成功，则需要经过事件拦截onInterceptTouchEvent的审核。事件是否向上传递处理是由onTouchEvent的返回值决定的。</p>\n<p>下面是Touch事件传递机制流程图：</p>\n\n<h3 id=\"四-View源码分析\"><a href=\"#四-View源码分析\" class=\"headerlink\" title=\"四 View源码分析\"></a>四 View源码分析</h3><p>Android中ImageView、textView、Button等继承于View但没有重写的dispatchTouchEvent方法，所以都用的View的该方法进行事件分发。</p>\n<p>看View重要函数部分源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">//返回true,表示该View内部消化掉了所有事件。返回false，表示View内部只处理了ACTION_DOWN事件，事件继续传递，向上级View(ViewGroup)传递。</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (mOnTouchListener != <span class=\"keyword\">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;</div><div class=\"line\">            mOnTouchListener.onTouch(<span class=\"keyword\">this</span>, event)) &#123;</div><div class=\"line\">  <span class=\"comment\">//此处的onTouch方式就是回调的我们注册OnTouchListener时重写的onTouch()方法</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> onTouchEvent(event);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先进行三个条件的判断：</p>\n<ul>\n<li>查看是否给button设置了OnTouchListener()事件；</li>\n<li>控件是否Enable；（控件默认都是enable的）</li>\n<li>button里面实现的OnTouchListener监听里的onTouch()方法是否返回true；</li>\n</ul>\n<p>如果条件都满足，则该事件被消耗掉，不再进入onTouchEvent中处理。否则将事件将交给onTouchEvent方法处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\"></div><div class=\"line\">   /＊ 当前onTouch的组件必须是可点击的比如Button，ImageButton等等，此处CLICKABLE为<span class=\"keyword\">true</span>，才会进入<span class=\"keyword\">if</span>方法，最后返回<span class=\"keyword\">true</span>。</div><div class=\"line\"> 如果是ImageView、TexitView这些默认为不可点击的View,此处CLICKABLE为<span class=\"keyword\">false</span>，最后返回<span class=\"keyword\">false</span>。当然会有特殊情况，如果给这些View设置了onClick监听器，此处CLICKABLE也将为<span class=\"keyword\">true</span>　　＊／</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  </div><div class=\"line\">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (event.getAction()) &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_UP:</div><div class=\"line\">                ...</div><div class=\"line\">                            <span class=\"keyword\">if</span> (!post(mPerformClick)) &#123;</div><div class=\"line\">                                performClick();<span class=\"comment\">// 实际就是回调了我们注册的OnClickListener中重新的onClick()方法</span></div><div class=\"line\">                            &#125;</div><div class=\"line\">                 ...</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</div><div class=\"line\">               ...</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_CANCEL:</div><div class=\"line\">                ...</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE:</div><div class=\"line\">               ...</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">performClick</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\"> ／／</div><div class=\"line\">    <span class=\"keyword\">if</span> (li != <span class=\"keyword\">null</span> &amp;&amp; li.mOnClickListener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        ...</div><div class=\"line\">        li.mOnClickListener.onClick(<span class=\"keyword\">this</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOnClickListener</span><span class=\"params\">(OnClickListener l)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!isClickable()) &#123;</div><div class=\"line\">        setClickable(<span class=\"keyword\">true</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    getListenerInfo().mOnClickListener = l;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>只有我们注册OnTouchListener时重写的 onTouch()方法中:</p>\n<ul>\n<li>返回false —&gt; 执行onTouchEvent方法 —&gt; 导致onClick()回调方法执行　</li>\n<li>返回true —&gt; onTouchEvent方法不执行 —&gt; 导致onClick()回调方法不会执行</li>\n</ul>\n<h3 id=\"五-ViewGroup源码分析\"><a href=\"#五-ViewGroup源码分析\" class=\"headerlink\" title=\"五 ViewGroup源码分析\"></a>五 ViewGroup源码分析</h3><p>Android中诸如LinearLayout等的五大布局控件，都是继承自ViewGroup，而ViewGroup本身是继承自View，所以ViewGroup的事件处理机制对这些控件都有效。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> action = ev.getAction();  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> xf = ev.getX();  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> yf = ev.getY();  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> scrolledXFloat = xf + mScrollX;  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> scrolledYFloat = yf + mScrollY;  </div><div class=\"line\">       <span class=\"keyword\">final</span> Rect frame = mTempRect;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//这个值默认是false, 然后我们可以通过requestDisallowInterceptTouchEvent(boolean disallowIntercept)方法  </span></div><div class=\"line\">       <span class=\"comment\">//来改变disallowIntercept的值  </span></div><div class=\"line\">       <span class=\"keyword\">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class=\"number\">0</span>;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//这里是ACTION_DOWN的处理逻辑  </span></div><div class=\"line\">       <span class=\"keyword\">if</span> (action == MotionEvent.ACTION_DOWN) &#123;  </div><div class=\"line\">        <span class=\"comment\">//清除mMotionTarget, 每次ACTION_DOWN都很设置mMotionTarget为null  </span></div><div class=\"line\">           <span class=\"keyword\">if</span> (mMotionTarget != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">               mMotionTarget = <span class=\"keyword\">null</span>;  </div><div class=\"line\">           &#125;  </div><div class=\"line\"></div><div class=\"line\">           <span class=\"comment\">//disallowIntercept默认是false, 就看ViewGroup的onInterceptTouchEvent()方法  </span></div><div class=\"line\">           <span class=\"keyword\">if</span> (disallowIntercept || !onInterceptTouchEvent(ev)) &#123;  <span class=\"comment\">//第一点</span></div><div class=\"line\">               ev.setAction(MotionEvent.ACTION_DOWN);  </div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> scrolledXInt = (<span class=\"keyword\">int</span>) scrolledXFloat;  </div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> scrolledYInt = (<span class=\"keyword\">int</span>) scrolledYFloat;  </div><div class=\"line\">               <span class=\"keyword\">final</span> View[] children = mChildren;  </div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> count = mChildrenCount;  </div><div class=\"line\">               <span class=\"comment\">//遍历其子View  </span></div><div class=\"line\">               <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = count - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;  <span class=\"comment\">//第二点</span></div><div class=\"line\">                   <span class=\"keyword\">final</span> View child = children[i];  </div><div class=\"line\"></div><div class=\"line\">                   <span class=\"comment\">//如果该子View是VISIBLE或者该子View正在执行动画, 表示该View才  </span></div><div class=\"line\">                   <span class=\"comment\">//可以接受到Touch事件  </span></div><div class=\"line\">                   <span class=\"keyword\">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE  </div><div class=\"line\">                           || child.getAnimation() != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">                    <span class=\"comment\">//获取子View的位置范围  </span></div><div class=\"line\">                       child.getHitRect(frame);  </div><div class=\"line\"></div><div class=\"line\">                       <span class=\"comment\">//如Touch到屏幕上的点在该子View上面  </span></div><div class=\"line\">                       <span class=\"keyword\">if</span> (frame.contains(scrolledXInt, scrolledYInt)) &#123;  </div><div class=\"line\">                           <span class=\"comment\">// offset the event to the view's coordinate system  </span></div><div class=\"line\">                           <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> xc = scrolledXFloat - child.mLeft;  </div><div class=\"line\">                           <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> yc = scrolledYFloat - child.mTop;  </div><div class=\"line\">                           ev.setLocation(xc, yc);  </div><div class=\"line\">                           child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class=\"line\"></div><div class=\"line\">                           <span class=\"comment\">//调用该子View的dispatchTouchEvent()方法  </span></div><div class=\"line\">                           <span class=\"keyword\">if</span> (child.dispatchTouchEvent(ev))  &#123;  </div><div class=\"line\">                               <span class=\"comment\">// 如果child.dispatchTouchEvent(ev)返回true表示  </span></div><div class=\"line\">                            <span class=\"comment\">//该事件被消费了，设置mMotionTarget为该子View  </span></div><div class=\"line\">                               mMotionTarget = child;  </div><div class=\"line\">                               <span class=\"comment\">//直接返回true  </span></div><div class=\"line\">                               <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </div><div class=\"line\">                           &#125;  </div><div class=\"line\">                           <span class=\"comment\">// The event didn't get handled, try the next view.  </span></div><div class=\"line\">                           <span class=\"comment\">// Don't reset the event's location, it's not  </span></div><div class=\"line\">                           <span class=\"comment\">// necessary here.  </span></div><div class=\"line\">                       &#125;  </div><div class=\"line\">                   &#125;  </div><div class=\"line\">               &#125;  </div><div class=\"line\">           &#125;  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//判断是否为ACTION_UP或者ACTION_CANCEL  </span></div><div class=\"line\">       <span class=\"keyword\">boolean</span> isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  </div><div class=\"line\">               (action == MotionEvent.ACTION_CANCEL);  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (isUpOrCancel) &#123;  </div><div class=\"line\">           <span class=\"comment\">//如果是ACTION_UP或者ACTION_CANCEL, 将disallowIntercept设置为默认的false  </span></div><div class=\"line\">        <span class=\"comment\">//假如我们调用了requestDisallowInterceptTouchEvent()方法来设置disallowIntercept为true  </span></div><div class=\"line\">        <span class=\"comment\">//当我们抬起手指或者取消Touch事件的时候要将disallowIntercept重置为false  </span></div><div class=\"line\">        <span class=\"comment\">//所以说上面的disallowIntercept默认在我们每次ACTION_DOWN的时候都是false  </span></div><div class=\"line\">           mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">// The event wasn't an ACTION_DOWN, dispatch it to our target if  </span></div><div class=\"line\">       <span class=\"comment\">// we have one.  </span></div><div class=\"line\">       <span class=\"keyword\">final</span> View target = mMotionTarget;  </div><div class=\"line\">       <span class=\"comment\">//mMotionTarget为null意味着没有找到消费Touch事件的View, 所以我们需要调用ViewGroup父类的  </span></div><div class=\"line\">       <span class=\"comment\">//dispatchTouchEvent()方法，也就是View的dispatchTouchEvent()方法  </span></div><div class=\"line\">       <span class=\"keyword\">if</span> (target == <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">           <span class=\"comment\">// We don't have a target, this means we're handling the  </span></div><div class=\"line\">           <span class=\"comment\">// event as a regular view.  </span></div><div class=\"line\">           ev.setLocation(xf, yf);  </div><div class=\"line\">           <span class=\"keyword\">if</span> ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != <span class=\"number\">0</span>) &#123;  </div><div class=\"line\">               ev.setAction(MotionEvent.ACTION_CANCEL);  </div><div class=\"line\">               mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class=\"line\">           &#125;  </div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.dispatchTouchEvent(ev);  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//这个if里面的代码ACTION_DOWN不会执行，只有ACTION_MOVE  </span></div><div class=\"line\">       <span class=\"comment\">//ACTION_UP才会走到这里, 假如在ACTION_MOVE或者ACTION_UP拦截的  </span></div><div class=\"line\">       <span class=\"comment\">//Touch事件, 将ACTION_CANCEL派发给target，然后直接返回true  </span></div><div class=\"line\">       <span class=\"comment\">//表示消费了此Touch事件  </span></div><div class=\"line\">       <span class=\"keyword\">if</span> (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) &#123;  </div><div class=\"line\">           <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> xc = scrolledXFloat - (<span class=\"keyword\">float</span>) target.mLeft;  </div><div class=\"line\">           <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> yc = scrolledYFloat - (<span class=\"keyword\">float</span>) target.mTop;  </div><div class=\"line\">           mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class=\"line\">           ev.setAction(MotionEvent.ACTION_CANCEL);  </div><div class=\"line\">           ev.setLocation(xc, yc);  </div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">if</span> (!target.dispatchTouchEvent(ev)) &#123;  </div><div class=\"line\">           &#125;  </div><div class=\"line\">           <span class=\"comment\">// clear the target  </span></div><div class=\"line\">           mMotionTarget = <span class=\"keyword\">null</span>;  </div><div class=\"line\">           <span class=\"comment\">// Don't dispatch this event to our own view, because we already  </span></div><div class=\"line\">           <span class=\"comment\">// saw it when intercepting; we just want to give the following  </span></div><div class=\"line\">           <span class=\"comment\">// event to the normal onTouchEvent().  </span></div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (isUpOrCancel) &#123;  </div><div class=\"line\">           mMotionTarget = <span class=\"keyword\">null</span>;  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">// finally offset the event to the target's coordinate system and  </span></div><div class=\"line\">       <span class=\"comment\">// dispatch the event.  </span></div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> xc = scrolledXFloat - (<span class=\"keyword\">float</span>) target.mLeft;  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> yc = scrolledYFloat - (<span class=\"keyword\">float</span>) target.mTop;  </div><div class=\"line\">       ev.setLocation(xc, yc);  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> ((target.mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != <span class=\"number\">0</span>) &#123;  </div><div class=\"line\">           ev.setAction(MotionEvent.ACTION_CANCEL);  </div><div class=\"line\">           target.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class=\"line\">           mMotionTarget = <span class=\"keyword\">null</span>;  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//如果没有拦截ACTION_MOVE, ACTION_DOWN的话，直接将Touch事件派发给target  </span></div><div class=\"line\">       <span class=\"keyword\">return</span> target.dispatchTouchEvent(ev);  </div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>dispatchTouchEvent作用：决定事件是否由onInterceptTouchEvent来拦截处理。 返回super.dispatchTouchEvent时，由onInterceptTouchEvent来决定事件的流向 返回false时，会继续分发事件，自己内部只处理了ACTION_DOWN 返回true时，不会继续分发事件，自己内部处理了所有事件（ACTION_DOWN,ACTION_MOVE,ACTION_UP）</p>\n</li>\n<li><p>onInterceptTouchEvent作用：拦截事件，用来决定事件是否传向子View 返回true时，拦截后交给自己的onTouchEvent处理 返回false时，拦截后交给子View来处理</p>\n</li>\n<li><p>onTouchEvent作用：事件最终到达这个方法 返回true时，内部处理所有的事件，换句话说，后续事件将继续传递给该view的onTouchEvent()处理 返回false时，事件会向上传递，由onToucEvent来接受，如果最上面View中的onTouchEvent也返回false的话，那么事件就会消失</p>\n</li>\n</ul>\n<h3 id=\"六-总结\"><a href=\"#六-总结\" class=\"headerlink\" title=\"六 总结\"></a>六 总结</h3><ul>\n<li><p>如果ViewGroup找到了能够处理该事件的View，则直接交给子View处理，自己的onTouchEvent不会被触发；　</p>\n</li>\n<li><p>可以通过复写onInterceptTouchEvent(ev)方法，拦截子View的事件（即return true），把事件交给自己处理，则会执行自己对应的onTouchEvent方法。</p>\n</li>\n<li><p>子View可以通过调用getParent().requestDisallowInterceptTouchEvent(true); 阻止ViewGroup对其MOVE或者UP事件进行拦截；　　</p>\n</li>\n<li><p>一个点击事件产生后，它的传递过程如下： Activity-&gt;Window-&gt;View。顶级View接收到事件之后，就会按相应规则去分发事件。如果一个View的onTouchEvent方法返回false，那么将会交给父容器的onTouchEvent方法进行处理，逐级往上，如果所有的View都不处理该事件，则交由Activity的onTouchEvent进行处理。　</p>\n</li>\n<li><p>如果某一个View开始处理事件，如果他不消耗ACTION_DOWN事件（也就是onTouchEvent返回false），则同一事件序列比如接下来进行ACTION_MOVE，则不会再交给该View处理。</p>\n</li>\n<li><p>ViewGroup默认不拦截任何事件。　</p>\n</li>\n<li><p>诸如TextView、ImageView这些不作为容器的View，一旦接受到事件，就调用onTouchEvent方法，它们本身没有onInterceptTouchEvent方法。正常情况下，它们都会消耗事件（返回true），除非它们是不可点击的（clickable和longClickable都为false），那么就会交由父容器的onTouchEvent处理。　</p>\n</li>\n<li><p>点击事件分发过程如下 dispatchTouchEvent—-&gt;OnTouchListener的onTouch方法—-&gt;onTouchEvent–&gt;OnClickListener的onClick方法。也就是说，我们平时调用的setOnClickListener，优先级是最低的，所以，onTouchEvent或OnTouchListener的onTouch方法如果返回true，则不响应onClick方法…</p>\n</li>\n</ul>\n\n","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>在android开发中会经常遇到滑动冲突（比如ScrollView或是SliddingMenu与ListView的嵌套）的问题，需要我们深入的了解android事件响应机制才能解决，事件响应机制已经是android开发者必不可少的知识。</p>\n<h3 id=\"二-涉及到事件响应的常用方法构成\"><a href=\"#二-涉及到事件响应的常用方法构成\" class=\"headerlink\" title=\"二 涉及到事件响应的常用方法构成\"></a>二 涉及到事件响应的常用方法构成</h3><p>用户在手指与屏幕接触过程中通过MotionEvent对象产生一系列事件，它有四种状态： </p>\n<ul>\n<li>MotionEvent.ACTION_DOWN　：手指按下屏幕的瞬间（一切事件的开始）</li>\n<li>MotionEvent.ACTION_MOVE　：手指在屏幕上移动</li>\n<li>MotionEvent.ACTION_UP　：手指离开屏幕瞬间</li>\n<li>MotionEvent.ACTION_CANCEL 　：取消手势，一般由程序产生，不会由用户产生</li>\n</ul>\n<p>Android中的事件onClick, onLongClick，onScroll, onFling等等，都是由许多个Touch事件构成的（一个ACTION_DOWN， n个ACTION_MOVE，1个ACTION_UP）。</p>\n<p>android 事件响应机制是先分发（先由外部的View接收，然后依次传递给其内层的最小View）再处理 （从最小View单元（事件源）开始依次向外层传递。）的形式实现的。</p>\n<p>复杂性表现在：可以控制每层事件是否继续传递（分发和拦截协同实现），以及事件的具体消费（事件分发也具有事件消费能力）。</p>\n<h3 id=\"三-android事件处理涉及到的三个重要函数\"><a href=\"#三-android事件处理涉及到的三个重要函数\" class=\"headerlink\" title=\"三 android事件处理涉及到的三个重要函数\"></a>三 android事件处理涉及到的三个重要函数</h3><h5 id=\"1-事件分发：public-boolean-dispatchTouchEvent-MotionEvent-ev\"><a href=\"#1-事件分发：public-boolean-dispatchTouchEvent-MotionEvent-ev\" class=\"headerlink\" title=\"1.事件分发：public boolean dispatchTouchEvent(MotionEvent ev)\"></a>1.事件分发：public boolean dispatchTouchEvent(MotionEvent ev)</h5><p>当有监听到事件时，首先由Activity进行捕获，进入事件分发处理流程。（因为activity没有事件拦截，View和ViewGroup有）会将事件传递给最外层View的dispatchTouchEvent(MotionEvent ev)方法，该方法对事件进行分发。 </p>\n<ul>\n<li><p>return true ：表示该View内部消化掉了所有事件。</p>\n</li>\n<li><p>return false ：事件在本层不再继续进行分发，并交由上层控件的onTouchEvent方法进行消费（如果本层控件已经是Activity，那么事件将被系统消费或处理）。　</p>\n</li>\n<li><p>如果事件分发返回系统默认的 super.dispatchTouchEvent(ev)，事件将分发给本层的事件拦截onInterceptTouchEvent 方法进行处理</p>\n</li>\n</ul>\n<h5 id=\"2-事件拦截：public-boolean-onInterceptTouchEvent-MotionEvent-ev\"><a href=\"#2-事件拦截：public-boolean-onInterceptTouchEvent-MotionEvent-ev\" class=\"headerlink\" title=\"2.事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)\"></a>2.事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)</h5><ul>\n<li><p>return true ：表示将事件进行拦截，并将拦截到的事件交由本层控件 的 onTouchEvent 进行处理；</p>\n</li>\n<li><p>return false ：则表示不对事件进行拦截，事件得以成功分发到子View。并由子View的dispatchTouchEvent进行处理。　</p>\n</li>\n<li><p>如果返回super.onInterceptTouchEvent(ev)，默认表示拦截该事件，并将事件传递给当前View的onTouchEvent方法，和return true一样。</p>\n</li>\n</ul>\n<h5 id=\"3-事件响应：public-boolean-onTouchEvent-MotionEvent-ev\"><a href=\"#3-事件响应：public-boolean-onTouchEvent-MotionEvent-ev\" class=\"headerlink\" title=\"3.事件响应：public boolean onTouchEvent(MotionEvent ev)\"></a>3.事件响应：public boolean onTouchEvent(MotionEvent ev)</h5><p>在dispatchTouchEvent（事件分发）返回super.dispatchTouchEvent(ev)并且onInterceptTouchEvent（事件拦截返回true或super.onInterceptTouchEvent(ev)的情况下，那么事件会传递到onTouchEvent方法，该方法对事件进行响应。</p>\n<ul>\n<li><p>如果return true，表示onTouchEvent处理完事件后消费了此次事件。此时事件终结；</p>\n</li>\n<li><p>如果return fasle，则表示不响应事件，那么该事件将会不断向上层View的onTouchEvent方法传递，直到某个View的onTouchEvent方法返回true，如果到了最顶层View还是返回false，那么认为该事件不消耗，则在同一个事件系列中，当前View无法再次接收到事件，该事件会交由Activity的onTouchEvent进行处理；　　</p>\n</li>\n<li><p>如果return super.dispatchTouchEvent(ev)，则表示不响应事件，结果与return false一样。</p>\n</li>\n</ul>\n<p>从以上过程中可以看出，dispatchTouchEvent无论返回true还是false，事件都不再进行分发，只有当其返回super.dispatchTouchEvent(ev)，才表明其具有向下层分发的愿望，但是是否能够分发成功，则需要经过事件拦截onInterceptTouchEvent的审核。事件是否向上传递处理是由onTouchEvent的返回值决定的。</p>\n<p>下面是Touch事件传递机制流程图：</p>\n\n<h3 id=\"四-View源码分析\"><a href=\"#四-View源码分析\" class=\"headerlink\" title=\"四 View源码分析\"></a>四 View源码分析</h3><p>Android中ImageView、textView、Button等继承于View但没有重写的dispatchTouchEvent方法，所以都用的View的该方法进行事件分发。</p>\n<p>看View重要函数部分源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">//返回true,表示该View内部消化掉了所有事件。返回false，表示View内部只处理了ACTION_DOWN事件，事件继续传递，向上级View(ViewGroup)传递。</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (mOnTouchListener != <span class=\"keyword\">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;</div><div class=\"line\">            mOnTouchListener.onTouch(<span class=\"keyword\">this</span>, event)) &#123;</div><div class=\"line\">  <span class=\"comment\">//此处的onTouch方式就是回调的我们注册OnTouchListener时重写的onTouch()方法</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> onTouchEvent(event);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先进行三个条件的判断：</p>\n<ul>\n<li>查看是否给button设置了OnTouchListener()事件；</li>\n<li>控件是否Enable；（控件默认都是enable的）</li>\n<li>button里面实现的OnTouchListener监听里的onTouch()方法是否返回true；</li>\n</ul>\n<p>如果条件都满足，则该事件被消耗掉，不再进入onTouchEvent中处理。否则将事件将交给onTouchEvent方法处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\"></div><div class=\"line\">   /＊ 当前onTouch的组件必须是可点击的比如Button，ImageButton等等，此处CLICKABLE为<span class=\"keyword\">true</span>，才会进入<span class=\"keyword\">if</span>方法，最后返回<span class=\"keyword\">true</span>。</div><div class=\"line\"> 如果是ImageView、TexitView这些默认为不可点击的View,此处CLICKABLE为<span class=\"keyword\">false</span>，最后返回<span class=\"keyword\">false</span>。当然会有特殊情况，如果给这些View设置了onClick监听器，此处CLICKABLE也将为<span class=\"keyword\">true</span>　　＊／</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  </div><div class=\"line\">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (event.getAction()) &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_UP:</div><div class=\"line\">                ...</div><div class=\"line\">                            <span class=\"keyword\">if</span> (!post(mPerformClick)) &#123;</div><div class=\"line\">                                performClick();<span class=\"comment\">// 实际就是回调了我们注册的OnClickListener中重新的onClick()方法</span></div><div class=\"line\">                            &#125;</div><div class=\"line\">                 ...</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</div><div class=\"line\">               ...</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_CANCEL:</div><div class=\"line\">                ...</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE:</div><div class=\"line\">               ...</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">performClick</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\"> ／／</div><div class=\"line\">    <span class=\"keyword\">if</span> (li != <span class=\"keyword\">null</span> &amp;&amp; li.mOnClickListener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        ...</div><div class=\"line\">        li.mOnClickListener.onClick(<span class=\"keyword\">this</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOnClickListener</span><span class=\"params\">(OnClickListener l)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!isClickable()) &#123;</div><div class=\"line\">        setClickable(<span class=\"keyword\">true</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    getListenerInfo().mOnClickListener = l;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>只有我们注册OnTouchListener时重写的 onTouch()方法中:</p>\n<ul>\n<li>返回false —&gt; 执行onTouchEvent方法 —&gt; 导致onClick()回调方法执行　</li>\n<li>返回true —&gt; onTouchEvent方法不执行 —&gt; 导致onClick()回调方法不会执行</li>\n</ul>\n<h3 id=\"五-ViewGroup源码分析\"><a href=\"#五-ViewGroup源码分析\" class=\"headerlink\" title=\"五 ViewGroup源码分析\"></a>五 ViewGroup源码分析</h3><p>Android中诸如LinearLayout等的五大布局控件，都是继承自ViewGroup，而ViewGroup本身是继承自View，所以ViewGroup的事件处理机制对这些控件都有效。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> action = ev.getAction();  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> xf = ev.getX();  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> yf = ev.getY();  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> scrolledXFloat = xf + mScrollX;  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> scrolledYFloat = yf + mScrollY;  </div><div class=\"line\">       <span class=\"keyword\">final</span> Rect frame = mTempRect;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//这个值默认是false, 然后我们可以通过requestDisallowInterceptTouchEvent(boolean disallowIntercept)方法  </span></div><div class=\"line\">       <span class=\"comment\">//来改变disallowIntercept的值  </span></div><div class=\"line\">       <span class=\"keyword\">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class=\"number\">0</span>;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//这里是ACTION_DOWN的处理逻辑  </span></div><div class=\"line\">       <span class=\"keyword\">if</span> (action == MotionEvent.ACTION_DOWN) &#123;  </div><div class=\"line\">        <span class=\"comment\">//清除mMotionTarget, 每次ACTION_DOWN都很设置mMotionTarget为null  </span></div><div class=\"line\">           <span class=\"keyword\">if</span> (mMotionTarget != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">               mMotionTarget = <span class=\"keyword\">null</span>;  </div><div class=\"line\">           &#125;  </div><div class=\"line\"></div><div class=\"line\">           <span class=\"comment\">//disallowIntercept默认是false, 就看ViewGroup的onInterceptTouchEvent()方法  </span></div><div class=\"line\">           <span class=\"keyword\">if</span> (disallowIntercept || !onInterceptTouchEvent(ev)) &#123;  <span class=\"comment\">//第一点</span></div><div class=\"line\">               ev.setAction(MotionEvent.ACTION_DOWN);  </div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> scrolledXInt = (<span class=\"keyword\">int</span>) scrolledXFloat;  </div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> scrolledYInt = (<span class=\"keyword\">int</span>) scrolledYFloat;  </div><div class=\"line\">               <span class=\"keyword\">final</span> View[] children = mChildren;  </div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> count = mChildrenCount;  </div><div class=\"line\">               <span class=\"comment\">//遍历其子View  </span></div><div class=\"line\">               <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = count - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;  <span class=\"comment\">//第二点</span></div><div class=\"line\">                   <span class=\"keyword\">final</span> View child = children[i];  </div><div class=\"line\"></div><div class=\"line\">                   <span class=\"comment\">//如果该子View是VISIBLE或者该子View正在执行动画, 表示该View才  </span></div><div class=\"line\">                   <span class=\"comment\">//可以接受到Touch事件  </span></div><div class=\"line\">                   <span class=\"keyword\">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE  </div><div class=\"line\">                           || child.getAnimation() != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">                    <span class=\"comment\">//获取子View的位置范围  </span></div><div class=\"line\">                       child.getHitRect(frame);  </div><div class=\"line\"></div><div class=\"line\">                       <span class=\"comment\">//如Touch到屏幕上的点在该子View上面  </span></div><div class=\"line\">                       <span class=\"keyword\">if</span> (frame.contains(scrolledXInt, scrolledYInt)) &#123;  </div><div class=\"line\">                           <span class=\"comment\">// offset the event to the view's coordinate system  </span></div><div class=\"line\">                           <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> xc = scrolledXFloat - child.mLeft;  </div><div class=\"line\">                           <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> yc = scrolledYFloat - child.mTop;  </div><div class=\"line\">                           ev.setLocation(xc, yc);  </div><div class=\"line\">                           child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class=\"line\"></div><div class=\"line\">                           <span class=\"comment\">//调用该子View的dispatchTouchEvent()方法  </span></div><div class=\"line\">                           <span class=\"keyword\">if</span> (child.dispatchTouchEvent(ev))  &#123;  </div><div class=\"line\">                               <span class=\"comment\">// 如果child.dispatchTouchEvent(ev)返回true表示  </span></div><div class=\"line\">                            <span class=\"comment\">//该事件被消费了，设置mMotionTarget为该子View  </span></div><div class=\"line\">                               mMotionTarget = child;  </div><div class=\"line\">                               <span class=\"comment\">//直接返回true  </span></div><div class=\"line\">                               <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </div><div class=\"line\">                           &#125;  </div><div class=\"line\">                           <span class=\"comment\">// The event didn't get handled, try the next view.  </span></div><div class=\"line\">                           <span class=\"comment\">// Don't reset the event's location, it's not  </span></div><div class=\"line\">                           <span class=\"comment\">// necessary here.  </span></div><div class=\"line\">                       &#125;  </div><div class=\"line\">                   &#125;  </div><div class=\"line\">               &#125;  </div><div class=\"line\">           &#125;  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//判断是否为ACTION_UP或者ACTION_CANCEL  </span></div><div class=\"line\">       <span class=\"keyword\">boolean</span> isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  </div><div class=\"line\">               (action == MotionEvent.ACTION_CANCEL);  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (isUpOrCancel) &#123;  </div><div class=\"line\">           <span class=\"comment\">//如果是ACTION_UP或者ACTION_CANCEL, 将disallowIntercept设置为默认的false  </span></div><div class=\"line\">        <span class=\"comment\">//假如我们调用了requestDisallowInterceptTouchEvent()方法来设置disallowIntercept为true  </span></div><div class=\"line\">        <span class=\"comment\">//当我们抬起手指或者取消Touch事件的时候要将disallowIntercept重置为false  </span></div><div class=\"line\">        <span class=\"comment\">//所以说上面的disallowIntercept默认在我们每次ACTION_DOWN的时候都是false  </span></div><div class=\"line\">           mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">// The event wasn't an ACTION_DOWN, dispatch it to our target if  </span></div><div class=\"line\">       <span class=\"comment\">// we have one.  </span></div><div class=\"line\">       <span class=\"keyword\">final</span> View target = mMotionTarget;  </div><div class=\"line\">       <span class=\"comment\">//mMotionTarget为null意味着没有找到消费Touch事件的View, 所以我们需要调用ViewGroup父类的  </span></div><div class=\"line\">       <span class=\"comment\">//dispatchTouchEvent()方法，也就是View的dispatchTouchEvent()方法  </span></div><div class=\"line\">       <span class=\"keyword\">if</span> (target == <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">           <span class=\"comment\">// We don't have a target, this means we're handling the  </span></div><div class=\"line\">           <span class=\"comment\">// event as a regular view.  </span></div><div class=\"line\">           ev.setLocation(xf, yf);  </div><div class=\"line\">           <span class=\"keyword\">if</span> ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != <span class=\"number\">0</span>) &#123;  </div><div class=\"line\">               ev.setAction(MotionEvent.ACTION_CANCEL);  </div><div class=\"line\">               mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class=\"line\">           &#125;  </div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.dispatchTouchEvent(ev);  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//这个if里面的代码ACTION_DOWN不会执行，只有ACTION_MOVE  </span></div><div class=\"line\">       <span class=\"comment\">//ACTION_UP才会走到这里, 假如在ACTION_MOVE或者ACTION_UP拦截的  </span></div><div class=\"line\">       <span class=\"comment\">//Touch事件, 将ACTION_CANCEL派发给target，然后直接返回true  </span></div><div class=\"line\">       <span class=\"comment\">//表示消费了此Touch事件  </span></div><div class=\"line\">       <span class=\"keyword\">if</span> (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) &#123;  </div><div class=\"line\">           <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> xc = scrolledXFloat - (<span class=\"keyword\">float</span>) target.mLeft;  </div><div class=\"line\">           <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> yc = scrolledYFloat - (<span class=\"keyword\">float</span>) target.mTop;  </div><div class=\"line\">           mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class=\"line\">           ev.setAction(MotionEvent.ACTION_CANCEL);  </div><div class=\"line\">           ev.setLocation(xc, yc);  </div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">if</span> (!target.dispatchTouchEvent(ev)) &#123;  </div><div class=\"line\">           &#125;  </div><div class=\"line\">           <span class=\"comment\">// clear the target  </span></div><div class=\"line\">           mMotionTarget = <span class=\"keyword\">null</span>;  </div><div class=\"line\">           <span class=\"comment\">// Don't dispatch this event to our own view, because we already  </span></div><div class=\"line\">           <span class=\"comment\">// saw it when intercepting; we just want to give the following  </span></div><div class=\"line\">           <span class=\"comment\">// event to the normal onTouchEvent().  </span></div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (isUpOrCancel) &#123;  </div><div class=\"line\">           mMotionTarget = <span class=\"keyword\">null</span>;  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">// finally offset the event to the target's coordinate system and  </span></div><div class=\"line\">       <span class=\"comment\">// dispatch the event.  </span></div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> xc = scrolledXFloat - (<span class=\"keyword\">float</span>) target.mLeft;  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> yc = scrolledYFloat - (<span class=\"keyword\">float</span>) target.mTop;  </div><div class=\"line\">       ev.setLocation(xc, yc);  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> ((target.mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != <span class=\"number\">0</span>) &#123;  </div><div class=\"line\">           ev.setAction(MotionEvent.ACTION_CANCEL);  </div><div class=\"line\">           target.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class=\"line\">           mMotionTarget = <span class=\"keyword\">null</span>;  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//如果没有拦截ACTION_MOVE, ACTION_DOWN的话，直接将Touch事件派发给target  </span></div><div class=\"line\">       <span class=\"keyword\">return</span> target.dispatchTouchEvent(ev);  </div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>dispatchTouchEvent作用：决定事件是否由onInterceptTouchEvent来拦截处理。 返回super.dispatchTouchEvent时，由onInterceptTouchEvent来决定事件的流向 返回false时，会继续分发事件，自己内部只处理了ACTION_DOWN 返回true时，不会继续分发事件，自己内部处理了所有事件（ACTION_DOWN,ACTION_MOVE,ACTION_UP）</p>\n</li>\n<li><p>onInterceptTouchEvent作用：拦截事件，用来决定事件是否传向子View 返回true时，拦截后交给自己的onTouchEvent处理 返回false时，拦截后交给子View来处理</p>\n</li>\n<li><p>onTouchEvent作用：事件最终到达这个方法 返回true时，内部处理所有的事件，换句话说，后续事件将继续传递给该view的onTouchEvent()处理 返回false时，事件会向上传递，由onToucEvent来接受，如果最上面View中的onTouchEvent也返回false的话，那么事件就会消失</p>\n</li>\n</ul>\n<h3 id=\"六-总结\"><a href=\"#六-总结\" class=\"headerlink\" title=\"六 总结\"></a>六 总结</h3><ul>\n<li><p>如果ViewGroup找到了能够处理该事件的View，则直接交给子View处理，自己的onTouchEvent不会被触发；　</p>\n</li>\n<li><p>可以通过复写onInterceptTouchEvent(ev)方法，拦截子View的事件（即return true），把事件交给自己处理，则会执行自己对应的onTouchEvent方法。</p>\n</li>\n<li><p>子View可以通过调用getParent().requestDisallowInterceptTouchEvent(true); 阻止ViewGroup对其MOVE或者UP事件进行拦截；　　</p>\n</li>\n<li><p>一个点击事件产生后，它的传递过程如下： Activity-&gt;Window-&gt;View。顶级View接收到事件之后，就会按相应规则去分发事件。如果一个View的onTouchEvent方法返回false，那么将会交给父容器的onTouchEvent方法进行处理，逐级往上，如果所有的View都不处理该事件，则交由Activity的onTouchEvent进行处理。　</p>\n</li>\n<li><p>如果某一个View开始处理事件，如果他不消耗ACTION_DOWN事件（也就是onTouchEvent返回false），则同一事件序列比如接下来进行ACTION_MOVE，则不会再交给该View处理。</p>\n</li>\n<li><p>ViewGroup默认不拦截任何事件。　</p>\n</li>\n<li><p>诸如TextView、ImageView这些不作为容器的View，一旦接受到事件，就调用onTouchEvent方法，它们本身没有onInterceptTouchEvent方法。正常情况下，它们都会消耗事件（返回true），除非它们是不可点击的（clickable和longClickable都为false），那么就会交由父容器的onTouchEvent处理。　</p>\n</li>\n<li><p>点击事件分发过程如下 dispatchTouchEvent—-&gt;OnTouchListener的onTouch方法—-&gt;onTouchEvent–&gt;OnClickListener的onClick方法。也就是说，我们平时调用的setOnClickListener，优先级是最低的，所以，onTouchEvent或OnTouchListener的onTouch方法如果返回true，则不响应onClick方法…</p>\n</li>\n</ul>\n\n"},{"title":"android基础之loaders","date":"2017-02-27T06:39:21.000Z","_content":"\n### 一 概述\n\nLoaders从Android3.0开始引进（Loaders被翻译为装载器，它是一个异步加载数据的框架），它能在Activity或Fragment中异步加载数据；装载器具有如下特性：\n\n- 它们对每个Activity和Fragment都有效\n- 它们支持数据的异步加载\n- 它们监视数据源的改变，并在数据源改变时传送新的结果\n- 当由于配置改变而被重新创建后，它们会自动重连到上一个装载器的游标，所以不必重新查询数据\n\n### 二 loader使用相关简介\n\n##### LoaderManager\n\n一个和Activity或Fragment关联抽象类，管理一个或多个装载器的实例，它帮助应用管理那些与Activity或Fragment生命周期相关的长时间运行的操作。最常见的方式是与一个CursorLoader一起使用，你也可以实现自己的装载器以加载其它类型的数据。 每个Activity或Fragment只有一个LoaderManager，但是一个LoaderManager可以拥有多个装载器。\n\n##### Loader\n\n一个执行异步数据加载的抽象类，它是加载器的基类。你可以使用典型的CursorLoader，但是你也可以实现你自己的子类。一旦装载器被激活，它们应该监视它们的数据源并且在数据改变时传送新的结果。\n\n##### AsyncTaskLoader\n\n一个使用AsyncTask来执行异步加载工作的抽象类。继承于Loader\n\n##### CursorLoader\n\n一个AsyncTaskLoader的子类，它查询ContentResolver然后返回一个Cursor。这个装载器类的实现遵循查询游标数据源的标准，它的游标查询是通过AsyncTaskLoader在后台线程中执行，从而不会阻塞UI线程。使用这个装载器是从ContentProvider异步加载数据的最好方式。\n\n##### LoaderManager.LoaderCallbacks\n\n一个用于客户端与LoaderManager交互的回调接口。主要有三个回调方法：onCreateLoader()，onLoadFinished()，onLoaderReset()。\n\n\n### 三 使用Loader\n\n一个使用加载器的典型的应用包含以下几个组件：\n\n- 一个Activity或Fragment；\n-  一个LoaderManager的实例；\n-  一个依靠ContentProvider加载数据的CursorLoader；当然，你也可以继承Loader或AsyncTaskLoader实现你自己的装载器来从其它数据源加载数据；\n- 一个LoaderManager.LoaderCallbacks的实现，这是你创建新的装载器以及管理已有装载器的地方；\n-  一个用于展示装载器的返回数据的方式，例如使用一个SimpleCursorAdapter；\n-  一个数据源，例如ContentProvider（使用CursorLoader加载数据）。\n\n代码示例：\n\n\n\n\n\n### 四 总结\n\n\n\n\n","source":"_posts/android基础之loaders.md","raw":"---\ntitle: android基础之loaders\ndate: 2017-02-27 14:39:21\ncategories: android\ntags:\n- android\n- java\n- loader\n---\n\n### 一 概述\n\nLoaders从Android3.0开始引进（Loaders被翻译为装载器，它是一个异步加载数据的框架），它能在Activity或Fragment中异步加载数据；装载器具有如下特性：\n\n- 它们对每个Activity和Fragment都有效\n- 它们支持数据的异步加载\n- 它们监视数据源的改变，并在数据源改变时传送新的结果\n- 当由于配置改变而被重新创建后，它们会自动重连到上一个装载器的游标，所以不必重新查询数据\n\n### 二 loader使用相关简介\n\n##### LoaderManager\n\n一个和Activity或Fragment关联抽象类，管理一个或多个装载器的实例，它帮助应用管理那些与Activity或Fragment生命周期相关的长时间运行的操作。最常见的方式是与一个CursorLoader一起使用，你也可以实现自己的装载器以加载其它类型的数据。 每个Activity或Fragment只有一个LoaderManager，但是一个LoaderManager可以拥有多个装载器。\n\n##### Loader\n\n一个执行异步数据加载的抽象类，它是加载器的基类。你可以使用典型的CursorLoader，但是你也可以实现你自己的子类。一旦装载器被激活，它们应该监视它们的数据源并且在数据改变时传送新的结果。\n\n##### AsyncTaskLoader\n\n一个使用AsyncTask来执行异步加载工作的抽象类。继承于Loader\n\n##### CursorLoader\n\n一个AsyncTaskLoader的子类，它查询ContentResolver然后返回一个Cursor。这个装载器类的实现遵循查询游标数据源的标准，它的游标查询是通过AsyncTaskLoader在后台线程中执行，从而不会阻塞UI线程。使用这个装载器是从ContentProvider异步加载数据的最好方式。\n\n##### LoaderManager.LoaderCallbacks\n\n一个用于客户端与LoaderManager交互的回调接口。主要有三个回调方法：onCreateLoader()，onLoadFinished()，onLoaderReset()。\n\n\n### 三 使用Loader\n\n一个使用加载器的典型的应用包含以下几个组件：\n\n- 一个Activity或Fragment；\n-  一个LoaderManager的实例；\n-  一个依靠ContentProvider加载数据的CursorLoader；当然，你也可以继承Loader或AsyncTaskLoader实现你自己的装载器来从其它数据源加载数据；\n- 一个LoaderManager.LoaderCallbacks的实现，这是你创建新的装载器以及管理已有装载器的地方；\n-  一个用于展示装载器的返回数据的方式，例如使用一个SimpleCursorAdapter；\n-  一个数据源，例如ContentProvider（使用CursorLoader加载数据）。\n\n代码示例：\n\n\n\n\n\n### 四 总结\n\n\n\n\n","slug":"android基础之loaders","published":1,"updated":"2017-03-09T12:47:42.069Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj02g6gsm000k7c02bh0vzcni","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Loaders从Android3.0开始引进（Loaders被翻译为装载器，它是一个异步加载数据的框架），它能在Activity或Fragment中异步加载数据；装载器具有如下特性：</p>\n<ul>\n<li>它们对每个Activity和Fragment都有效</li>\n<li>它们支持数据的异步加载</li>\n<li>它们监视数据源的改变，并在数据源改变时传送新的结果</li>\n<li>当由于配置改变而被重新创建后，它们会自动重连到上一个装载器的游标，所以不必重新查询数据</li>\n</ul>\n<h3 id=\"二-loader使用相关简介\"><a href=\"#二-loader使用相关简介\" class=\"headerlink\" title=\"二 loader使用相关简介\"></a>二 loader使用相关简介</h3><h5 id=\"LoaderManager\"><a href=\"#LoaderManager\" class=\"headerlink\" title=\"LoaderManager\"></a>LoaderManager</h5><p>一个和Activity或Fragment关联抽象类，管理一个或多个装载器的实例，它帮助应用管理那些与Activity或Fragment生命周期相关的长时间运行的操作。最常见的方式是与一个CursorLoader一起使用，你也可以实现自己的装载器以加载其它类型的数据。 每个Activity或Fragment只有一个LoaderManager，但是一个LoaderManager可以拥有多个装载器。</p>\n<h5 id=\"Loader\"><a href=\"#Loader\" class=\"headerlink\" title=\"Loader\"></a>Loader</h5><p>一个执行异步数据加载的抽象类，它是加载器的基类。你可以使用典型的CursorLoader，但是你也可以实现你自己的子类。一旦装载器被激活，它们应该监视它们的数据源并且在数据改变时传送新的结果。</p>\n<h5 id=\"AsyncTaskLoader\"><a href=\"#AsyncTaskLoader\" class=\"headerlink\" title=\"AsyncTaskLoader\"></a>AsyncTaskLoader</h5><p>一个使用AsyncTask来执行异步加载工作的抽象类。继承于Loader</p>\n<h5 id=\"CursorLoader\"><a href=\"#CursorLoader\" class=\"headerlink\" title=\"CursorLoader\"></a>CursorLoader</h5><p>一个AsyncTaskLoader的子类，它查询ContentResolver然后返回一个Cursor。这个装载器类的实现遵循查询游标数据源的标准，它的游标查询是通过AsyncTaskLoader在后台线程中执行，从而不会阻塞UI线程。使用这个装载器是从ContentProvider异步加载数据的最好方式。</p>\n<h5 id=\"LoaderManager-LoaderCallbacks\"><a href=\"#LoaderManager-LoaderCallbacks\" class=\"headerlink\" title=\"LoaderManager.LoaderCallbacks\"></a>LoaderManager.LoaderCallbacks</h5><p>一个用于客户端与LoaderManager交互的回调接口。主要有三个回调方法：onCreateLoader()，onLoadFinished()，onLoaderReset()。</p>\n<h3 id=\"三-使用Loader\"><a href=\"#三-使用Loader\" class=\"headerlink\" title=\"三 使用Loader\"></a>三 使用Loader</h3><p>一个使用加载器的典型的应用包含以下几个组件：</p>\n<ul>\n<li>一个Activity或Fragment；</li>\n<li>一个LoaderManager的实例；</li>\n<li>一个依靠ContentProvider加载数据的CursorLoader；当然，你也可以继承Loader或AsyncTaskLoader实现你自己的装载器来从其它数据源加载数据；</li>\n<li>一个LoaderManager.LoaderCallbacks的实现，这是你创建新的装载器以及管理已有装载器的地方；</li>\n<li>一个用于展示装载器的返回数据的方式，例如使用一个SimpleCursorAdapter；</li>\n<li>一个数据源，例如ContentProvider（使用CursorLoader加载数据）。</li>\n</ul>\n<p>代码示例：</p>\n<h3 id=\"四-总结\"><a href=\"#四-总结\" class=\"headerlink\" title=\"四 总结\"></a>四 总结</h3>","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Loaders从Android3.0开始引进（Loaders被翻译为装载器，它是一个异步加载数据的框架），它能在Activity或Fragment中异步加载数据；装载器具有如下特性：</p>\n<ul>\n<li>它们对每个Activity和Fragment都有效</li>\n<li>它们支持数据的异步加载</li>\n<li>它们监视数据源的改变，并在数据源改变时传送新的结果</li>\n<li>当由于配置改变而被重新创建后，它们会自动重连到上一个装载器的游标，所以不必重新查询数据</li>\n</ul>\n<h3 id=\"二-loader使用相关简介\"><a href=\"#二-loader使用相关简介\" class=\"headerlink\" title=\"二 loader使用相关简介\"></a>二 loader使用相关简介</h3><h5 id=\"LoaderManager\"><a href=\"#LoaderManager\" class=\"headerlink\" title=\"LoaderManager\"></a>LoaderManager</h5><p>一个和Activity或Fragment关联抽象类，管理一个或多个装载器的实例，它帮助应用管理那些与Activity或Fragment生命周期相关的长时间运行的操作。最常见的方式是与一个CursorLoader一起使用，你也可以实现自己的装载器以加载其它类型的数据。 每个Activity或Fragment只有一个LoaderManager，但是一个LoaderManager可以拥有多个装载器。</p>\n<h5 id=\"Loader\"><a href=\"#Loader\" class=\"headerlink\" title=\"Loader\"></a>Loader</h5><p>一个执行异步数据加载的抽象类，它是加载器的基类。你可以使用典型的CursorLoader，但是你也可以实现你自己的子类。一旦装载器被激活，它们应该监视它们的数据源并且在数据改变时传送新的结果。</p>\n<h5 id=\"AsyncTaskLoader\"><a href=\"#AsyncTaskLoader\" class=\"headerlink\" title=\"AsyncTaskLoader\"></a>AsyncTaskLoader</h5><p>一个使用AsyncTask来执行异步加载工作的抽象类。继承于Loader</p>\n<h5 id=\"CursorLoader\"><a href=\"#CursorLoader\" class=\"headerlink\" title=\"CursorLoader\"></a>CursorLoader</h5><p>一个AsyncTaskLoader的子类，它查询ContentResolver然后返回一个Cursor。这个装载器类的实现遵循查询游标数据源的标准，它的游标查询是通过AsyncTaskLoader在后台线程中执行，从而不会阻塞UI线程。使用这个装载器是从ContentProvider异步加载数据的最好方式。</p>\n<h5 id=\"LoaderManager-LoaderCallbacks\"><a href=\"#LoaderManager-LoaderCallbacks\" class=\"headerlink\" title=\"LoaderManager.LoaderCallbacks\"></a>LoaderManager.LoaderCallbacks</h5><p>一个用于客户端与LoaderManager交互的回调接口。主要有三个回调方法：onCreateLoader()，onLoadFinished()，onLoaderReset()。</p>\n<h3 id=\"三-使用Loader\"><a href=\"#三-使用Loader\" class=\"headerlink\" title=\"三 使用Loader\"></a>三 使用Loader</h3><p>一个使用加载器的典型的应用包含以下几个组件：</p>\n<ul>\n<li>一个Activity或Fragment；</li>\n<li>一个LoaderManager的实例；</li>\n<li>一个依靠ContentProvider加载数据的CursorLoader；当然，你也可以继承Loader或AsyncTaskLoader实现你自己的装载器来从其它数据源加载数据；</li>\n<li>一个LoaderManager.LoaderCallbacks的实现，这是你创建新的装载器以及管理已有装载器的地方；</li>\n<li>一个用于展示装载器的返回数据的方式，例如使用一个SimpleCursorAdapter；</li>\n<li>一个数据源，例如ContentProvider（使用CursorLoader加载数据）。</li>\n</ul>\n<p>代码示例：</p>\n<h3 id=\"四-总结\"><a href=\"#四-总结\" class=\"headerlink\" title=\"四 总结\"></a>四 总结</h3>"},{"title":"android基础之数据存储","date":"2017-02-28T09:42:52.000Z","_content":"","source":"_posts/android基础之数据存储.md","raw":"---\ntitle: android基础之数据存储\ndate: 2017-02-28 17:42:52\ncategories:\ntags:\n---\n","slug":"android基础之数据存储","published":1,"updated":"2017-03-04T09:08:24.210Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj02g6gsm000n7c0237grjdtb","content":"","excerpt":"","more":""},{"title":"android基础之消息推送","date":"2017-03-01T06:28:10.000Z","_content":"","source":"_posts/android基础之消息推送.md","raw":"---\ntitle: android基础之消息推送\ndate: 2017-03-01 14:28:10\ncategories:\ntags:\n---\n","slug":"android基础之消息推送","published":1,"updated":"2017-03-04T09:08:24.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj02g6gsm000r7c025jd2kkr7","content":"","excerpt":"","more":""},{"title":"android基础之自定义View与ViewGroup","date":"2017-02-28T08:02:37.000Z","_content":"","source":"_posts/android基础之自定义View与ViewGroup.md","raw":"---\ntitle: android基础之自定义View与ViewGroup\ndate: 2017-02-28 16:02:37\ncategories:\ntags:\n---\n","slug":"android基础之自定义View与ViewGroup","published":1,"updated":"2017-03-04T09:08:24.217Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj02g6gsm000u7c026hnmneha","content":"","excerpt":"","more":""},{"title":"android基础之缓存","date":"2017-02-28T09:10:22.000Z","_content":"\n### 一 概述\n\n移动开发本质上就是手机和服务器之间进行通信，需要从服务端获取数据。反复通过网络获取数据是比较耗时的，特别是访问比较多的时候，会极大影响了性能，Android中可通过缓存机制来减少频繁的网络操作，减少流量、提升性能。android中缓存分为一级缓存，二级缓存和图片的三级缓存(就是网络)。\n\nAndroid缓存分为内存缓存（一级缓存）和文件缓存（二级缓存）。在早期，各大图片缓存框架流行之前，常用的内存缓存方式是软引用（SoftReference）和弱引用（WeakReference），如大部分的使用方式：HashMap<String url, SoftReference<Drawable>> imageCache;这种形式。从Android 2.3（Level 9）开始，垃圾回收器更倾向于回收SoftReference或WeakReference对象，这使得SoftReference和WeakReference变得不是那么实用有效。同时，到了Android 3.0（Level 11）之后，图片数据Bitmap被放置到了内存的堆区域，而堆区域的内存是由GC管理的，开发者也就不需要进行图片资源的释放工作，但这也使得图片数据的释放无法预知，增加了造成OOM的可能。因此，在Android3.1以后，Android推出了LruCache这个内存缓存类和DiskLruCache这个磁盘缓存类。\n\n当Android端需要获得数据时比如获取网络中的图片，我们首先从内存中查找（按键查找），内存中没有的再从磁盘文件或sqlite中去查找，若磁盘中也没有才通过网络获取（图片的3级缓存策略）；当获得来自网络的数据，就以key-value对的方式先缓存到内存（一级缓存），同时缓存到文件或sqlite中（二级缓存）。注意：内存缓存会造成堆内存泄露，所有一级缓存通常要严格控制缓存的大小，一般控制在系统内存的1/4。\n\n### 二 内存缓存（一级缓存）\n\nandroid中使用LruCache做内存缓存。在介绍这个类之前先了解一下LRU算法。\n\n##### 1.LRU算法\nLRU，全称Least Rencetly Used，即最近最少使用，是一种非常常用的置换算法，也即淘汰最长时间未使用的对象。LRU在操作系统中的页面置换算法中广泛使用，我们的内存或缓存空间是有限的，当新加入一个对象时，造成我们的缓存空间不足了，此时就需要根据某种算法对缓存中原有数据进行淘汰货删除，而LRU选择的是将最长时间未使用的对象进行淘汰。\n\n##### 2.LruCache实现原理\n\n根据LRU算法的思想，要实现LRU最核心的是要有一种数据结构能够基于访问顺序来保存缓存中的对象，这样我们就能够很方便的知道哪个对象是最近访问的，哪个对象是最长时间未访问的。LruCache选择的是LinkedHashMap这个数据结构，LinkedHashMap是一个双向循环链表，在构造LinkedHashMap时，通过一个boolean值来指定LinkedHashMap中保存数据的方式，LinkedHashMap的一个构造方法如下：\n\n```java\n    /* \n         * 初始化LinkedHashMap \n         * 第一个参数：initialCapacity，初始大小 \n         * 第二个参数：loadFactor，负载因子=0.75f \n         * 第三个参数：accessOrder=true，基于访问顺序；accessOrder=false，基于插入顺序 \n         */  \n        public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) {  \n            super(initialCapacity, loadFactor);  \n            init();  \n            this.accessOrder = accessOrder;  \n        }  \n```\n\n显然，在LruCache中选择的是accessOrder = true；此时，当accessOrder 设置为 true时，每当我们更新（即调用put方法）或访问（即调用get方法）map中的结点时，LinkedHashMap内部都会将这个结点移动到链表的尾部，因此，在链表的尾部是最近刚刚使用的结点，在链表的头部是是最近最少使用的结点，当我们的缓存空间不足时，就应该持续把链表头部结点移除掉，直到有剩余空间放置新结点。\n可以看到，LinkedHashMap完成了LruCache中的核心功能，那LruCache中剩下要做的就是定义缓存空间总容量，当前保存数据已使用的容量，对外提供put、get方法。\n\n##### 3.LruCache源码分析\n\n在了解了LruCache的核心原理之后，就可以开始分析LruCache的源码了。\n\n####### 3.1关键字段\n\n根据上面的分析，首先要有总容量、已使用容量、linkedHashMap这几个关键字段，LruCache中提供了下面三个关键字段：\n\n```java\n    //核心数据结构  \n        private final LinkedHashMap<K, V> map;  \n        // 当前缓存数据所占的大小  \n        private int size;  \n        //缓存空间总容量  \n        private int maxSize;  \n```\n\n要注意的是size字段，因为map中可以存放各种类型的数据，这些数据的大小测量方式也是不一样的，比如Bitmap类型的数据和String类型的数据计算他们的大小方式肯定不同，因此，LruCache中在计算放入数据大小的方法sizeOf中，只是简单的返回了1，需要我们重写这个方法，自己去定义数据的测量方式。因此，我们在使用LruCache的时候，经常会看到这种方式： \n\n```java\n    private static final int CACHE_SIZE = 4 * 1024 * 1024;//4Mib  \n        LruCache<String,Bitmap> bitmapCache = new LruCache<String,Bitmap>(CACHE_SIZE){  \n            @Override  \n            protected int sizeOf(String key, Bitmap value) {  \n                return value.getByteCount();//自定义Bitmap数据大小的计算方式  \n            }  \n        };  \n```\n\n####### 3.2 构造方法  \n\n```java\n\tpublic LruCache(int maxSize) {\n\t    if (maxSize <= 0) {\n\t        throw new IllegalArgumentException(\"maxSize <= 0\");\n\t    }\n\t    this.maxSize = maxSize;\n\t    this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n\t}\n```\n\nLruCache只有一个唯一的构造方法，在构造方法中，给定了缓存空间的总大小，初始化了LinkedHashMap核心数据结构，在LinkedHashMap中的第三个参数指定为true，也就设置了accessOrder=true，表示这个LinkedHashMap将是基于数据的访问顺序进行排序。\n\n\n####### 3.3 sizeOf()和safeSizeOf()方法测量数据类型大小\n\n根据上面的解释，由于各种数据类型大小测量的标准不统一，具体测量的方法应该由使用者来实现，如上面给出的一个在实现LruCache时重写sizeOf的一种常用实现方式。通过多态的性质，再具体调用sizeOf时会调用我们重写的方法进行测量，LruCache对sizeOf()的调用进行一层封装，如下： \n\n```java\n\tprivate int safeSizeOf(K key, V value) {\n\t    int result = sizeOf(key, value);\n\t    if (result < 0) {\n\t        throw new IllegalStateException(\"Negative size: \" + key + \"=\" + value);\n\t    }\n\t    return result;\n\t} \n```\n\n里面其实就是调用sizeOf()方法，返回sizeOf计算的大小。\n上面就是LruCache的基本内容，下面就需要提供LruCache的核心功能了。\n\n####### 3.4 put方法缓存数据   \n\n首先看一下它的源码实现：    \n\n```java\n/**\n   * 给对应key缓存value，并且将该value移动到链表的尾部。\n   */\npublic final V put(K key, V value) {\n    if (key == null || value == null) {\n        throw new NullPointerException(\"key == null || value == null\");\n    }\n\n      V previous;\n      synchronized (this) {\n        // 记录 put 的次数\n        putCount++;\n        // 通过键值对，计算出要保存对象value的大小，并更新当前缓存大小\n        size += safeSizeOf(key, value);\n        /*\n         * 如果 之前存在key，用新的value覆盖原来的数据， 并返回 之前key 的value\n         * 记录在 previous\n         */\n        previous = map.put(key, value);\n        // 如果之前存在key，并且之前的value不为null\n        if (previous != null) {\n            // 计算出 之前value的大小，因为前面size已经加上了新的value数据的大小，此时，需要再次更新size，减去原来value的大小\n            size -= safeSizeOf(key, previous);\n        }\n      }\n\n    // 如果之前存在key，并且之前的value不为null\n    if (previous != null) {\n        /*\n         * previous值被剔除了，此次添加的 value 已经作为key的 新值\n         * 告诉 自定义 的 entryRemoved 方法\n         */\n        entryRemoved(false, key, previous, value);\n    }\n    //裁剪缓存容量（在当前缓存数据大小超过了总容量maxSize时，才会真正去执行LRU）\n    trimToSize(maxSize);\n      return previous;\n}\n```\n\n可以看到，put()方法主要有以下几步：   \n1）key和value判空，说明LruCache中不允许key和value为null；   \n2）通过safeSizeOf()获取要加入对象数据的大小，并更新当前缓存数据的大小；   \n3）将新的对象数据放入到缓存中，即调用LinkedHashMap的put方法，如果原来存在该key时，直接替换掉原来的value值，并返回之前的value值，得到之前value的大小，更新当前缓存数据的size大小；如果原来不存在该key，则直接加入缓存即可；   \n4）清理缓存空间\n\n####### 3.5 trimToSize()清理缓存空间    \n当我们加入一个数据时（put），为了保证当前数据的缓存所占大小没有超过我们指定的总大小，通过调用trimToSize()来对缓存空间进行管理控制。\n\n```java\npublic void trimToSize(int maxSize) {\n    /*\n     * 循环进行LRU，直到当前所占容量大小没有超过指定的总容量大小\n     */\n    while (true) {\n        K key;\n        V value;\n        synchronized (this) {\n            // 一些异常情况的处理\n            if (size < 0 || (map.isEmpty() && size != 0)) {\n                throw new IllegalStateException(\n                        getClass().getName() + \".sizeOf() is reporting inconsistent results!\");\n            }\n            // 首先判断当前缓存数据大小是否超过了指定的缓存空间总大小。如果没有超过，即缓存中还可以存入数据，直接跳出循环，清理完毕\n            if (size <= maxSize || map.isEmpty()) {\n                break;\n            }\n            /**\n             * 执行到这，表示当前缓存数据已超过了总容量，需要执行LRU，即将最近最少使用的数据清除掉，直到数据所占缓存空间没有超标;\n             * 根据前面的原理分析，知道，在链表中，链表的头结点是最近最少使用的数据，因此，最先清除掉链表前面的结点\n             */\n            Map.Entry<K, V> toEvict = map.entrySet().iterator().next();\n            key = toEvict.getKey();\n            value = toEvict.getValue();\n            map.remove(key);\n            // 移除掉后，更新当前数据缓存的大小\n            size -= safeSizeOf(key, value);\n            // 更新移除的结点数量\n            evictionCount++;\n        }\n        /*\n         * 通知某个结点被移除，类似于回调\n         */\n        entryRemoved(true, key, value, null);\n    }\n}\n```\n\ntrimToSize()方法的作用就是为了保证当前数据的缓存大小不能超过我们指定的缓存总大小，如果超过了，就会开始移除最近最少使用的数据，直到size符合要求。trimToSize()方法在put()的时候一定会调用，在get()的时候有可能会调用。\n\n\n####### 3.6 get方法获取缓存数据   \n\n```java\n/**\n * 根据key查询缓存，如果该key对应的value存在于缓存，直接返回value；\n* 访问到这个结点时，LinkHashMap会将它移动到双向循环链表的的尾部。\n* 如果如果没有缓存的值，则返回null。（如果开发者重写了create()的话，返回创建的value）\n*/\npublic final V get(K key) {\n    if (key == null) {\n        throw new NullPointerException(\"key == null\");\n    }\n\n    V mapValue;\n    synchronized (this) {\n        // LinkHashMap 如果设置按照访问顺序的话，这里每次get都会重整数据顺序\n        mapValue = map.get(key);\n        // 计算 命中次数\n        if (mapValue != null) {\n            hitCount++;\n            return mapValue;\n        }\n        // 计算 丢失次数\n        missCount++;\n    }\n\n    /*\n     * 官方解释：\n     * 尝试创建一个值，这可能需要很长时间，并且Map可能在create()返回的值时有所不同。如果在create()执行的时\n     * 候，用这个key执行了put方法，那么此时就发生了冲突，我们在Map中删除这个创建的值，释放被创建的值，保留put进去的值。\n     */\n    V createdValue = create(key);\n    if (createdValue == null) {\n        return null;\n    }\n\n    /***************************\n     * 不覆写create方法走不到下面 *\n     ***************************/\n    /*\n     * 正常情况走不到这里\n     * 走到这里的话 说明 实现了自定义的 create(K key) 逻辑\n     * 因为默认的 create(K key) 逻辑为null\n     */\n    synchronized (this) {\n        // 记录 create 的次数\n        createCount++;\n        // 将自定义create创建的值，放入LinkedHashMap中，如果key已经存在，会返回 之前相同key 的值\n        mapValue = map.put(key, createdValue);\n\n        // 如果之前存在相同key的value，即有冲突。\n        if (mapValue != null) {\n            /*\n             * 有冲突\n             * 所以 撤销 刚才的 操作\n             * 将 之前相同key 的值 重新放回去\n             */\n            map.put(key, mapValue);\n        } else {\n            // 拿到键值对，计算出在容量中的相对长度，然后加上\n            size += safeSizeOf(key, createdValue);\n        }\n    }\n\n    // 如果上面 判断出了 将要放入的值发生冲突\n    if (mapValue != null) {\n        /*\n         * 刚才create的值被删除了，原来的 之前相同key 的值被重新添加回去了\n         * 告诉 自定义 的 entryRemoved 方法\n         */\n        entryRemoved(false, key, createdValue, mapValue);\n        return mapValue;\n    } else {\n        // 上面 进行了 size += 操作 所以这里要重整长度\n        trimToSize(maxSize);\n        return createdValue;\n    }\n}\n```\n\nget()方法的思路就是：   \n   1）先尝试从map缓存中获取value，即mapVaule = map.get(key);如果mapVaule != null，说明缓存中存在该对象，直接返回即可；   \n   2）如果mapVaule == null，说明缓存中不存在该对象，大多数情况下会直接返回null；但是如果我们重写了create()方法，在缓存没有该数据的时候自己去创建一个，则会继续往下走，中间可能会出现冲突，看注释；   \n   3）注意：在我们通过LinkedHashMap进行get(key)或put(key,value)时都会对链表进行调整，即将刚刚访问get或加入put的结点放入到链表尾部。\n\n####### 3.7 entryRemoved()     \n\nentryRemoved的源码如下：\n\n```java\n/**\n * 1.当被回收或者删掉时调用。该方法当value被回收释放存储空间时被remove调用\n* 或者替换条目值时put调用，默认实现什么都没做。\n* 2.该方法没用同步调用，如果其他线程访问缓存时，该方法也会执行。\n* 3.evicted=true：如果该条目被删除空间 （表示 进行了trimToSize or remove）  evicted=false：put冲突后 或 get里成功create后\n* 导致\n* 4.newValue!=null，那么则被put()或get()调用。\n*/\nprotected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {\n}\n```\n\nentryRemoved方法是一个空方法，说明这个也是让开发者自己根据需求去重写的。entryRemoved()主要作用就是在结点数据value需要被删除或回收的时候，给开发者的回调。开发者就可以在这个方法里面实现一些自己的逻辑：   \n（1）可以进行资源的回收；     \n（2）可以实现二级内存缓存，可以进一步提高性能，    \n思路如下：重写LruCache的entryRemoved()函数，把删除掉的item，再次存入另外一个LinkedHashMap<String, SoftWeakReference<Bitmap>>中，这个数据结构当做二级缓存，每次获得图片的时候，先判断LruCache中是否缓存，没有的话，再判断这个二级缓存中是否有，如果都没有再从sdcard上获取。sdcard上也没有的话，就从网络服务器上拉取。entryRemoved()在LruCache中有四个地方进行了调用：put()、get()、trimToSize()、remove()中进行了调用。\n\n\n####### 3.8 LruCache的线程安全性 \n\nLruCache是线程安全的，因为在put、get、trimToSize、remove的方法中都加入synchronized进行同步控制。\n\n\n##### 4.LruCache代码示例\n\n使用步骤：\n- 在构造LruCache时提供一个总的缓存大小；\n- 重写sizeOf方法，对存入map的数据大小进行自定义测量；\n- 根据需要，决定是否要重写entryRemoved()方法；\n- 使用LruCache提供的put和get方法进行数据的缓存\n\n```java\nprivate LruCache<String, Bitmap> mMemoryCache;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    ...\n    // 获得虚拟机能提供的最大内存，超过这个大小会抛出OutOfMemory的异常\n    final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);\n\n    // 用１／８的内存大小作为内存缓存\n    final int cacheSize = maxMemory / 8;\n\n    mMemoryCache = new LruCache<String, Bitmap>(cacheSize) {\n        @Override\n        protected int sizeOf(String key, Bitmap bitmap) {\n            // 这里返回的不是item的个数，是cache的size（单位1024个字节）\n            return bitmap.getByteCount() / 1024;\n        }\n    };\n    ...\n}\n\npublic void addBitmapToMemoryCache(String key, Bitmap bitmap) {\n    if (getBitmapFromMemCache(key) == null) {\n        mMemoryCache.put(key, bitmap);\n    }\n}\n\npublic Bitmap getBitmapFromMemCache(String key) {\n    return mMemoryCache.get(key);\n}\n```\n\n当为ImageView加载一张图片时，会先在LruCache 中看看有没有缓存这张图片，如果有的话直接更新到ImageView中，如果没有的话，一个后台线程会被触发来加载这张图片。\n\n```java\npublic void loadBitmap(int resId, ImageView imageView) {\n    final String imageKey = String.valueOf(resId);\n\n    // 查看下内存缓存中是否缓存了这张图片\n    final Bitmap bitmap = getBitmapFromMemCache(imageKey);\n    if (bitmap != null) {\n        mImageView.setImageBitmap(bitmap);\n    } else {\n        mImageView.setImageResource(R.drawable.image_placeholder);\nBitmapWorkerTask task = new BitmapWorkerTask(mImageView);\n        task.execute(resId);\n    }\n}\n```\n\n在图片加载的Task中，需要把加载好的图片加入到内存缓存中。\n\n```java\nclass BitmapWorkerTask extends AsyncTask<Integer, Void, Bitmap> {\n    ...\n    // 在后台完成\n    @Override\n    protected Bitmap doInBackground(Integer... params) {\n        final Bitmap bitmap = decodeSampledBitmapFromResource(\n                getResources(), params[0], 100, 100));\n    addBitmapToMemoryCache(String.valueOf(params[0]), bitmap);\n        return bitmap;\n    }\n    ...\n}\n```\n##### 5.总结\n\n- LruCache 自身并没有释放内存，只是 LinkedHashMap中将数据移除了，如果数据还在别的地方被引用了，还是有泄漏问题，还需要手动释放内存；\n- 覆写 entryRemoved 方法能知道 LruCache 数据移除是是否发生了冲突（冲突是指在map.put()的时候，对应的key中是否存在原来的值），也可以去手动释放资源；\n\n\n### 三 磁盘缓存（二级缓存）\n\nLruCache是一种内存缓存策略，但是当存在大量图片的时候，我们指定的缓存内存空间可能很快就会用完，这个时候，LruCache就会频繁的进行trimToSize()操作，不断的将最近最少使用的数据移除，当再次需要该数据时，又得从网络上重新加载，这样就有可能造成OOM。为此，Google提供了一种磁盘缓存的解决方案——DiskLruCache（DiskLruCache并没有集成到Android源码中，在Android Doc的例子中有讲解）。\n\n##### 1. DiskLruCache实现原理\n\n我们可以先来直观看一下，使用了DiskLruCache缓存策略的APP，缓存目录中是什么样子，如下图：\n\n{% asset_img 文件缓存结果图.png 文件缓存结果图 %}\n\n可以看到，缓存目录中有一堆文件名很长的文件，这些文件就是我们缓存的一张张图片数据，在最后有一个文件名journal的文件，这个journal文件是DiskLruCache的一个日志文件，即保存着每张缓存图片的操作记录，journal文件正是实现DiskLruCache的核心。看到出现了journal文件，基本可以说明这个APP使用了DiskLruCache缓存策略。\n\n根据对LruCache的分析，要实现LRU，最重要的是要有一种数据结构能够基于访问顺序来保存缓存中的对象，LinkedHashMap是一种非常合适的数据结构，为此，DiskLruCache也选择了LinkedHashMap作为维护访问顺序的数据结构，但是，对于DiskLruCache来说，单单LinkedHashMap是不够的，因为我们不能像LruCache一样，直接将数据放置到LinkedHashMap的value中，也就是处于内存当中，在DiskLruCache中，数据是缓存到了本地文件，这里的LinkedHashMap中的value只是保存的是value的一些简要信息Entry，如唯一的文件名称、大小、是否可读等信息，如：\n\n```java\nprivate final class Entry {\n    private final String key;\n    /** Lengths of this entry's files. */\n    private final long[] lengths;\n    /** True if this entry has ever been published */\n    private boolean readable;\n    /** The ongoing edit or null if this entry is not being edited. */\n    private Editor currentEditor;\n    /** The sequence number of the most recently committed edit to this entry. */\n    private long sequenceNumber;\n    private Entry(String key) {\n        this.key = key;\n        this.lengths = new long[valueCount];\n    }\n    public String getLengths() throws IOException {\n        StringBuilder result = new StringBuilder();\n        for (long size : lengths) {\n            result.append(' ').append(size);\n    }\n    return result.toString();\n}\n\n    /**\n     * Set lengths using decimal numbers like \"10123\".\n     */\n    private void setLengths(String[] strings) throws IOException {\n        if (strings.length != valueCount) {\n            throw invalidLengths(strings);\n        }\n\n        try {\n            for (int i = 0; i < strings.length; i++) {\n                lengths[i] = Long.parseLong(strings[i]);\n            }\n        } catch (NumberFormatException e) {\n            throw invalidLengths(strings);\n        }\n    }\n\n    private IOException invalidLengths(String[] strings) throws IOException {\n        throw new IOException(\"unexpected journal line: \" + Arrays.toString(strings));\n    }\n\n    public File getCleanFile(int i) {\n        return new File(directory, key + \".\" + i);\n    }\n\n    public File getDirtyFile(int i) {\n        return new File(directory, key + \".\" + i + \".tmp\");\n    }\n}\n```\n\nDiskLruCache中对于LinkedHashMap定义如下：\n\n```java\nprivate final LinkedHashMap<String, Entry> lruEntries\n\t= new LinkedHashMap<String, Entry>(0, 0.75f, true);\n```\n\n在LruCache中，由于数据是直接缓存中内存中，map中数据的建立是在使用LruCache缓存的过程中逐步建立的，而对于DiskLruCache，由于数据是缓存在本地文件，相当于是持久保存下来的一个文件，即使程序退出文件还在，因此，map中数据的建立，除了在使用DiskLruCache过程中建立外，map还应该包括之前已经存在的缓存文件，因此，在获取DiskLruCache的实例时，DiskLruCache会去读取journal这个日志文件，根据这个日志文件中的信息，建立map的初始数据，同时，会根据journal这个日志文件，维护本地的缓存文件。构造DiskLruCache的方法如下：\n\n```java\npublic static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)\n    throws IOException {\n    if (maxSize <= 0) {\n        throw new IllegalArgumentException(\"maxSize <= 0\");\n    }\n    if (valueCount <= 0) {\n        throw new IllegalArgumentException(\"valueCount <= 0\");\n    }\n\n    // prefer to pick up where we left off\n    DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);\n    if (cache.journalFile.exists()) {\n    try {\n        cache.readJournal();\n        cache.processJournal();\n        cache.journalWriter = new BufferedWriter(new FileWriter(cache.journalFile, true),IO_BUFFER_SIZE);\n                return cache;\n        } catch (IOException journalIsCorrupt) {\n            //                System.logW(\"DiskLruCache \" + directory + \" is corrupt: \"\n            //                        + journalIsCorrupt.getMessage() + \", removing\");\n            cache.delete();\n        }\n   }\n\n    // create a new empty cache\n    directory.mkdirs();\n    cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);\n    cache.rebuildJournal();\n    return cache;\n}\n```\n\n其中，\ncache.readJournal();    \ncache.processJournal();\n正是去读取journal日志文件，建立起map中的初始数据，同时维护缓存文件。\n\n##### 2.journal日志文件\n\njournal日志文件到底保存了什么信息呢，一个标准的journal日志文件信息如下：\n\n```bash\n\nlibcore.io.DiskLruCache    //第一行，固定内容，声明\n1                                        //第二行，cache的版本号，恒为1\n1                                        //第三行，APP的版本号\n2                                        //第四行，一个key，可以存放多少条数据valueCount    \n                                           //第五行，空行分割行\nDIRTY 335c4c6028171cfddfbaae1a9c313c52\nCLEAN 335c4c6028171cfddfbaae1a9c313c52 3934\nREMOVE 335c4c6028171cfddfbaae1a9c313c52\nDIRTY 1ab96a171faeeee38496d8b330771a7a\nCLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234\nREAD 335c4c6028171cfddfbaae1a9c313c52\nREAD 3400330d1dfc7f3f7f4b8d4d803dfcf6\n```\n\n前五行称为journal日志文件的头，下面部分的每一行会以四种前缀之一开始：DIRTY、CLEAN、REMOVE、READ。\n\n以一个DIRTY前缀开始的，后面紧跟着缓存图片的key。以DIRTY这个这个前缀开头，意味着这是一条脏数据。每当我们调用一次DiskLruCache的edit()方法时，都会向journal文件中写入一条DIRTY记录，表示我们正准备写入一条缓存数据，但不知结果如何。然后调用commit()方法表示写入缓存成功，这时会向journal中写入一条CLEAN记录，意味着这条“脏”数据被“洗干净了”，调用abort()方法表示写入缓存失败，这时会向journal中写入一条REMOVE记录。也就是说，每一行DIRTY的key，后面都应该有一行对应的CLEAN或者REMOVE的记录，否则这条数据就是“脏”的，会被自动删除掉。\n\n在CLEAN前缀和key后面还有一个数值，代表的是该条缓存数据的大小。\n\n##### 3.DiskLruCache中的工作流程\n\n**1.**初始化：通过open()方法，获取DiskLruCache的实例，在open方法中通过readJournal(); 方法读取journal日志文件，根据journal日志文件信息建立map中的初始数据；然后再调用processJournal();方法对刚刚建立起的map数据进行分析，分析的工作，一个是计算当前有效缓存文件（即被CLEAN的）的大小，一个是清理无用缓存文件；\n\n**2.**数据缓存与获取缓存：上面的初始化工作完成后，我们就可以在程序中进行数据的缓存功能和获取缓存的功能了；缓存数据的操作是借助DiskLruCache.Editor这个类完成的，这个类也是不能new的，需要调用DiskLruCache的edit()方法来获取实例，如：public Editor edit(String key) throws IOException。在写入完成后，需要进行commit()。\n\n如下一个简单示例：\n\n```java\n    new Thread(new Runnable() {    \n        @Override    \n        public void run() {    \n            try {    \n                String imageUrl = \"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg\";    \n                String key = hashKeyForDisk(imageUrl);  //MD5对url进行加密，这个主要是为了获得统一的16位字符  \n                DiskLruCache.Editor editor = mDiskLruCache.edit(key);  //拿到Editor，往journal日志中写入DIRTY记录  \n                if (editor != null) {    \n                    OutputStream outputStream = editor.newOutputStream(0);    \n                    if (downloadUrlToStream(imageUrl, outputStream)) {  //downloadUrlToStream方法为下载图片的方法，并且将输出流放到outputStream  \n                        editor.commit();  //完成后记得commit()，成功后，再往journal日志中写入CLEAN记录  \n                    } else {    \n                        editor.abort();  //失败后，要remove缓存文件，往journal文件中写入REMOVE记录  \n                    }    \n                }    \n                mDiskLruCache.flush();  //将缓存操作同步到journal日志文件，不一定要在这里就调用  \n            } catch (IOException e) {    \n                e.printStackTrace();    \n            }    \n        }    \n    }).start();   \n```\n\n**注意**每次调用edit()时，会向journal日志文件写入DIRTY为前缀的一条记录；文件保存成功后，调用commit()时，也会向journal日志中写入一条CLEAN为前缀的一条记录，如果失败，需要调用abort()，abort()里面会向journal文件写入一条REMOVE为前缀的记录。\n\n获取缓存数据是通过get()方法实现的，如下一个简单示例：\n\n```java\ntry {    \n    String imageUrl = \"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg\";    \n    String key = hashKeyForDisk(imageUrl);  //MD5对url进行加密，这个主要是为了获得统一的16位字符  \n     //通过get拿到value的Snapshot，里面封装了输入流、key等信息，调用get会向journal文件写入READ为前缀的记录  \n    DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key);   \n    if (snapShot != null) {    \n        InputStream is = snapShot.getInputStream(0);    \n        Bitmap bitmap = BitmapFactory.decodeStream(is);    \n        mImage.setImageBitmap(bitmap);    \n    }    \n} catch (IOException e) {    \n    e.printStackTrace();    \n}\n```\n\n**3.**合适的地方进行flush()\n\n在上面进行数据缓存或获取缓存的时候，调用不同的方法会往journal中写入不同前缀的一行记录，记录写入是通过IO下的Writer写入的，要真正生效，还需要调用writer的flush()方法，而DiskLruCache中的flush()方法中封装了writer.flush()的操作，因此，我们只需要在合适地方调用DiskLruCache中的flush()方法即可。其作用也就是将操作记录同步到journal文件中，这是一个消耗效率的IO操作，我们不用每次一往journal中写数据后就调用flush，这样对效率影响较大，可以在Activity的onPause()中调用一下即可。\n\n##### 4.DiskLruCache总结\n\n- 我们可以在在UI线程中检测内存缓存，即主线程中可以直接使用LruCache；\n- 使用DiskLruCache时，由于缓存或获取都需要对本地文件进行操作，因此需要另开一个线程，在子线程中检测磁盘缓存、保存缓存数据，磁盘操作从来不应该在UI线程中实现；\n- LruCache内存缓存的核心是LinkedHashMap，而DiskLruCache的核心是LinkedHashMap和journal日志文件，相当于把journal看作是一块“内存”，LinkedHashMap的value只保存文件的简要信息，对缓存文件的所有操作都会记录在journal日志文件中。\n\n##### 5.DiskLruCache优化\n\nDiskLruCache是基于日志文件journal的，这就决定了每次对缓存文件的操作都需要进行日志文件的记录，我们可以不用journal文件，在第一次构造DiskLruCache的时候，直接从程序访问缓存目录下的缓存文件，并将每个缓存文件的访问时间作为初始值记录在map的value中，每次访问或保存缓存都更新相应key对应的缓存文件的访问时间，这样就避免了频繁的IO操作，这种情况下就需要使用单例模式对DiskLruCache进行构造了，下面要说的Acache轻量级的数据缓存类就是这种实现方式。\n\n### 四 一个轻量级缓存框架——ACache\n\nACache是一个轻量级的开源cache框架，实际上就是一个叫ACache的java类。已经在商业项目中使用，运行效果不错。\n\nACache类似于SharedPreferences，但是比SharedPreferences功能更加强大，SharedPreferences只能保存一些基本数据类型、Serializable、Bundle等数据。而Acache可以缓存如下数据：普通的字符串、JsonObject、JsonArray、Bitmap、Drawable、序列化的java对象，和 byte数据。\n\n主要特色：\n\n- 轻，轻到只有一个JAVA文件。\n- 可配置，可以配置缓存路径，缓存大小，缓存数量等。\n- 可以设置缓存超时时间，缓存超时自动失效，并被删除。\n- 支持多进程\n\n应用场景：\n\n- 替换SharePreference当做配置文件\n- 可以缓存网络请求数据，比如oschina的android客户端可以缓存http请求的新闻内容，缓存时间假设为1个小时，超时后自动失效，让客户端重新请求新的数据，减少客户端流量，同时减少服务器并发量。\n\n代码示例：\n\n```java\npublic class NewsListActivity extends Activity {\n  private List<News> list;\n  private ListView listView;\n  private LoadImageAdapter adapter;//适配器\n  private ACache acache;//缓存框架\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    // TODO Auto-generated method stub\n    super.onCreate(savedInstanceState);\n    super.setContentView(R.layout.load_img_listview_activity);\n    acache=ACache.get(this);//创建ACache组件\n    initView();//初始化界面，代码不贴了\n}\n\npublic void loadData(){\n   String cacheData=acache.getAsString(\"newsList\");//从缓存中取数据\n   if(cacheData!=null){//如果缓存中有，就不访问网络\n   List<News> newsList=gson.fromJson(cacheData, new TypeToken<List<News>>(){}.getType());//将json转为List\n      list.addAll(newsList);\n      adapter.notifyDataSetChanged();\n      return;\n   }\n   new Thread(new Runnable() {\n     @Override\n     public void run() {\n       // TODO Auto-generated method stub\n       SystemClock.sleep(2000);//模拟网络耗时\n       String json=request();//模拟从网络中获取json数据\n       acache.put(\"newslist\", json, 60*60*1);//将数据存入缓存中，有效时间设置为1小时\n       List<News> newsList=gson.fromJson(json, new TypeToken<List<News>>(){}.getType());\n       list.addAll(newsList);\n       handler.sendEmptyMessage(1);\n    }\n         \n  }).start();\n}\n    /**\n     * 模拟网络请求方法\n     * @return json数据\n     */\nprivate String request(){\n   News news=null;\n   for(int i=0;i<10;i++){\n       news=new News();\n       news.setId(i);\n       news.setImgUrl(\"course/img/face_\"+i+\".png\");\n       news.setTitle(\"新闻标题\"+i);\n       news.setSummary(\"测试\"+i);\n       list.add(news);\n   }\n   Gson gson=new Gson();\n   return gson.toJson(list);    \n}\n\nprivate Handler handler=new Handler()\n   @Override\n   public void handleMessage(Message msg) {\n       // TODO Auto-generated method stub\n       switch(msg.what){\n           case 1:\n             notify_layout.setVisibility(View.GONE);\n             adapter.notifyDataSetChanged();\n           break;\n       }\n   }\n}\n```\n\n\n  \n\n\n","source":"_posts/android基础之缓存.md","raw":"---\ntitle: android基础之缓存\ndate: 2017-02-28 17:10:22\ncategories: android\ntags:\n- android\n- java\n- 缓存\n---\n\n### 一 概述\n\n移动开发本质上就是手机和服务器之间进行通信，需要从服务端获取数据。反复通过网络获取数据是比较耗时的，特别是访问比较多的时候，会极大影响了性能，Android中可通过缓存机制来减少频繁的网络操作，减少流量、提升性能。android中缓存分为一级缓存，二级缓存和图片的三级缓存(就是网络)。\n\nAndroid缓存分为内存缓存（一级缓存）和文件缓存（二级缓存）。在早期，各大图片缓存框架流行之前，常用的内存缓存方式是软引用（SoftReference）和弱引用（WeakReference），如大部分的使用方式：HashMap<String url, SoftReference<Drawable>> imageCache;这种形式。从Android 2.3（Level 9）开始，垃圾回收器更倾向于回收SoftReference或WeakReference对象，这使得SoftReference和WeakReference变得不是那么实用有效。同时，到了Android 3.0（Level 11）之后，图片数据Bitmap被放置到了内存的堆区域，而堆区域的内存是由GC管理的，开发者也就不需要进行图片资源的释放工作，但这也使得图片数据的释放无法预知，增加了造成OOM的可能。因此，在Android3.1以后，Android推出了LruCache这个内存缓存类和DiskLruCache这个磁盘缓存类。\n\n当Android端需要获得数据时比如获取网络中的图片，我们首先从内存中查找（按键查找），内存中没有的再从磁盘文件或sqlite中去查找，若磁盘中也没有才通过网络获取（图片的3级缓存策略）；当获得来自网络的数据，就以key-value对的方式先缓存到内存（一级缓存），同时缓存到文件或sqlite中（二级缓存）。注意：内存缓存会造成堆内存泄露，所有一级缓存通常要严格控制缓存的大小，一般控制在系统内存的1/4。\n\n### 二 内存缓存（一级缓存）\n\nandroid中使用LruCache做内存缓存。在介绍这个类之前先了解一下LRU算法。\n\n##### 1.LRU算法\nLRU，全称Least Rencetly Used，即最近最少使用，是一种非常常用的置换算法，也即淘汰最长时间未使用的对象。LRU在操作系统中的页面置换算法中广泛使用，我们的内存或缓存空间是有限的，当新加入一个对象时，造成我们的缓存空间不足了，此时就需要根据某种算法对缓存中原有数据进行淘汰货删除，而LRU选择的是将最长时间未使用的对象进行淘汰。\n\n##### 2.LruCache实现原理\n\n根据LRU算法的思想，要实现LRU最核心的是要有一种数据结构能够基于访问顺序来保存缓存中的对象，这样我们就能够很方便的知道哪个对象是最近访问的，哪个对象是最长时间未访问的。LruCache选择的是LinkedHashMap这个数据结构，LinkedHashMap是一个双向循环链表，在构造LinkedHashMap时，通过一个boolean值来指定LinkedHashMap中保存数据的方式，LinkedHashMap的一个构造方法如下：\n\n```java\n    /* \n         * 初始化LinkedHashMap \n         * 第一个参数：initialCapacity，初始大小 \n         * 第二个参数：loadFactor，负载因子=0.75f \n         * 第三个参数：accessOrder=true，基于访问顺序；accessOrder=false，基于插入顺序 \n         */  \n        public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) {  \n            super(initialCapacity, loadFactor);  \n            init();  \n            this.accessOrder = accessOrder;  \n        }  \n```\n\n显然，在LruCache中选择的是accessOrder = true；此时，当accessOrder 设置为 true时，每当我们更新（即调用put方法）或访问（即调用get方法）map中的结点时，LinkedHashMap内部都会将这个结点移动到链表的尾部，因此，在链表的尾部是最近刚刚使用的结点，在链表的头部是是最近最少使用的结点，当我们的缓存空间不足时，就应该持续把链表头部结点移除掉，直到有剩余空间放置新结点。\n可以看到，LinkedHashMap完成了LruCache中的核心功能，那LruCache中剩下要做的就是定义缓存空间总容量，当前保存数据已使用的容量，对外提供put、get方法。\n\n##### 3.LruCache源码分析\n\n在了解了LruCache的核心原理之后，就可以开始分析LruCache的源码了。\n\n####### 3.1关键字段\n\n根据上面的分析，首先要有总容量、已使用容量、linkedHashMap这几个关键字段，LruCache中提供了下面三个关键字段：\n\n```java\n    //核心数据结构  \n        private final LinkedHashMap<K, V> map;  \n        // 当前缓存数据所占的大小  \n        private int size;  \n        //缓存空间总容量  \n        private int maxSize;  \n```\n\n要注意的是size字段，因为map中可以存放各种类型的数据，这些数据的大小测量方式也是不一样的，比如Bitmap类型的数据和String类型的数据计算他们的大小方式肯定不同，因此，LruCache中在计算放入数据大小的方法sizeOf中，只是简单的返回了1，需要我们重写这个方法，自己去定义数据的测量方式。因此，我们在使用LruCache的时候，经常会看到这种方式： \n\n```java\n    private static final int CACHE_SIZE = 4 * 1024 * 1024;//4Mib  \n        LruCache<String,Bitmap> bitmapCache = new LruCache<String,Bitmap>(CACHE_SIZE){  \n            @Override  \n            protected int sizeOf(String key, Bitmap value) {  \n                return value.getByteCount();//自定义Bitmap数据大小的计算方式  \n            }  \n        };  \n```\n\n####### 3.2 构造方法  \n\n```java\n\tpublic LruCache(int maxSize) {\n\t    if (maxSize <= 0) {\n\t        throw new IllegalArgumentException(\"maxSize <= 0\");\n\t    }\n\t    this.maxSize = maxSize;\n\t    this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n\t}\n```\n\nLruCache只有一个唯一的构造方法，在构造方法中，给定了缓存空间的总大小，初始化了LinkedHashMap核心数据结构，在LinkedHashMap中的第三个参数指定为true，也就设置了accessOrder=true，表示这个LinkedHashMap将是基于数据的访问顺序进行排序。\n\n\n####### 3.3 sizeOf()和safeSizeOf()方法测量数据类型大小\n\n根据上面的解释，由于各种数据类型大小测量的标准不统一，具体测量的方法应该由使用者来实现，如上面给出的一个在实现LruCache时重写sizeOf的一种常用实现方式。通过多态的性质，再具体调用sizeOf时会调用我们重写的方法进行测量，LruCache对sizeOf()的调用进行一层封装，如下： \n\n```java\n\tprivate int safeSizeOf(K key, V value) {\n\t    int result = sizeOf(key, value);\n\t    if (result < 0) {\n\t        throw new IllegalStateException(\"Negative size: \" + key + \"=\" + value);\n\t    }\n\t    return result;\n\t} \n```\n\n里面其实就是调用sizeOf()方法，返回sizeOf计算的大小。\n上面就是LruCache的基本内容，下面就需要提供LruCache的核心功能了。\n\n####### 3.4 put方法缓存数据   \n\n首先看一下它的源码实现：    \n\n```java\n/**\n   * 给对应key缓存value，并且将该value移动到链表的尾部。\n   */\npublic final V put(K key, V value) {\n    if (key == null || value == null) {\n        throw new NullPointerException(\"key == null || value == null\");\n    }\n\n      V previous;\n      synchronized (this) {\n        // 记录 put 的次数\n        putCount++;\n        // 通过键值对，计算出要保存对象value的大小，并更新当前缓存大小\n        size += safeSizeOf(key, value);\n        /*\n         * 如果 之前存在key，用新的value覆盖原来的数据， 并返回 之前key 的value\n         * 记录在 previous\n         */\n        previous = map.put(key, value);\n        // 如果之前存在key，并且之前的value不为null\n        if (previous != null) {\n            // 计算出 之前value的大小，因为前面size已经加上了新的value数据的大小，此时，需要再次更新size，减去原来value的大小\n            size -= safeSizeOf(key, previous);\n        }\n      }\n\n    // 如果之前存在key，并且之前的value不为null\n    if (previous != null) {\n        /*\n         * previous值被剔除了，此次添加的 value 已经作为key的 新值\n         * 告诉 自定义 的 entryRemoved 方法\n         */\n        entryRemoved(false, key, previous, value);\n    }\n    //裁剪缓存容量（在当前缓存数据大小超过了总容量maxSize时，才会真正去执行LRU）\n    trimToSize(maxSize);\n      return previous;\n}\n```\n\n可以看到，put()方法主要有以下几步：   \n1）key和value判空，说明LruCache中不允许key和value为null；   \n2）通过safeSizeOf()获取要加入对象数据的大小，并更新当前缓存数据的大小；   \n3）将新的对象数据放入到缓存中，即调用LinkedHashMap的put方法，如果原来存在该key时，直接替换掉原来的value值，并返回之前的value值，得到之前value的大小，更新当前缓存数据的size大小；如果原来不存在该key，则直接加入缓存即可；   \n4）清理缓存空间\n\n####### 3.5 trimToSize()清理缓存空间    \n当我们加入一个数据时（put），为了保证当前数据的缓存所占大小没有超过我们指定的总大小，通过调用trimToSize()来对缓存空间进行管理控制。\n\n```java\npublic void trimToSize(int maxSize) {\n    /*\n     * 循环进行LRU，直到当前所占容量大小没有超过指定的总容量大小\n     */\n    while (true) {\n        K key;\n        V value;\n        synchronized (this) {\n            // 一些异常情况的处理\n            if (size < 0 || (map.isEmpty() && size != 0)) {\n                throw new IllegalStateException(\n                        getClass().getName() + \".sizeOf() is reporting inconsistent results!\");\n            }\n            // 首先判断当前缓存数据大小是否超过了指定的缓存空间总大小。如果没有超过，即缓存中还可以存入数据，直接跳出循环，清理完毕\n            if (size <= maxSize || map.isEmpty()) {\n                break;\n            }\n            /**\n             * 执行到这，表示当前缓存数据已超过了总容量，需要执行LRU，即将最近最少使用的数据清除掉，直到数据所占缓存空间没有超标;\n             * 根据前面的原理分析，知道，在链表中，链表的头结点是最近最少使用的数据，因此，最先清除掉链表前面的结点\n             */\n            Map.Entry<K, V> toEvict = map.entrySet().iterator().next();\n            key = toEvict.getKey();\n            value = toEvict.getValue();\n            map.remove(key);\n            // 移除掉后，更新当前数据缓存的大小\n            size -= safeSizeOf(key, value);\n            // 更新移除的结点数量\n            evictionCount++;\n        }\n        /*\n         * 通知某个结点被移除，类似于回调\n         */\n        entryRemoved(true, key, value, null);\n    }\n}\n```\n\ntrimToSize()方法的作用就是为了保证当前数据的缓存大小不能超过我们指定的缓存总大小，如果超过了，就会开始移除最近最少使用的数据，直到size符合要求。trimToSize()方法在put()的时候一定会调用，在get()的时候有可能会调用。\n\n\n####### 3.6 get方法获取缓存数据   \n\n```java\n/**\n * 根据key查询缓存，如果该key对应的value存在于缓存，直接返回value；\n* 访问到这个结点时，LinkHashMap会将它移动到双向循环链表的的尾部。\n* 如果如果没有缓存的值，则返回null。（如果开发者重写了create()的话，返回创建的value）\n*/\npublic final V get(K key) {\n    if (key == null) {\n        throw new NullPointerException(\"key == null\");\n    }\n\n    V mapValue;\n    synchronized (this) {\n        // LinkHashMap 如果设置按照访问顺序的话，这里每次get都会重整数据顺序\n        mapValue = map.get(key);\n        // 计算 命中次数\n        if (mapValue != null) {\n            hitCount++;\n            return mapValue;\n        }\n        // 计算 丢失次数\n        missCount++;\n    }\n\n    /*\n     * 官方解释：\n     * 尝试创建一个值，这可能需要很长时间，并且Map可能在create()返回的值时有所不同。如果在create()执行的时\n     * 候，用这个key执行了put方法，那么此时就发生了冲突，我们在Map中删除这个创建的值，释放被创建的值，保留put进去的值。\n     */\n    V createdValue = create(key);\n    if (createdValue == null) {\n        return null;\n    }\n\n    /***************************\n     * 不覆写create方法走不到下面 *\n     ***************************/\n    /*\n     * 正常情况走不到这里\n     * 走到这里的话 说明 实现了自定义的 create(K key) 逻辑\n     * 因为默认的 create(K key) 逻辑为null\n     */\n    synchronized (this) {\n        // 记录 create 的次数\n        createCount++;\n        // 将自定义create创建的值，放入LinkedHashMap中，如果key已经存在，会返回 之前相同key 的值\n        mapValue = map.put(key, createdValue);\n\n        // 如果之前存在相同key的value，即有冲突。\n        if (mapValue != null) {\n            /*\n             * 有冲突\n             * 所以 撤销 刚才的 操作\n             * 将 之前相同key 的值 重新放回去\n             */\n            map.put(key, mapValue);\n        } else {\n            // 拿到键值对，计算出在容量中的相对长度，然后加上\n            size += safeSizeOf(key, createdValue);\n        }\n    }\n\n    // 如果上面 判断出了 将要放入的值发生冲突\n    if (mapValue != null) {\n        /*\n         * 刚才create的值被删除了，原来的 之前相同key 的值被重新添加回去了\n         * 告诉 自定义 的 entryRemoved 方法\n         */\n        entryRemoved(false, key, createdValue, mapValue);\n        return mapValue;\n    } else {\n        // 上面 进行了 size += 操作 所以这里要重整长度\n        trimToSize(maxSize);\n        return createdValue;\n    }\n}\n```\n\nget()方法的思路就是：   \n   1）先尝试从map缓存中获取value，即mapVaule = map.get(key);如果mapVaule != null，说明缓存中存在该对象，直接返回即可；   \n   2）如果mapVaule == null，说明缓存中不存在该对象，大多数情况下会直接返回null；但是如果我们重写了create()方法，在缓存没有该数据的时候自己去创建一个，则会继续往下走，中间可能会出现冲突，看注释；   \n   3）注意：在我们通过LinkedHashMap进行get(key)或put(key,value)时都会对链表进行调整，即将刚刚访问get或加入put的结点放入到链表尾部。\n\n####### 3.7 entryRemoved()     \n\nentryRemoved的源码如下：\n\n```java\n/**\n * 1.当被回收或者删掉时调用。该方法当value被回收释放存储空间时被remove调用\n* 或者替换条目值时put调用，默认实现什么都没做。\n* 2.该方法没用同步调用，如果其他线程访问缓存时，该方法也会执行。\n* 3.evicted=true：如果该条目被删除空间 （表示 进行了trimToSize or remove）  evicted=false：put冲突后 或 get里成功create后\n* 导致\n* 4.newValue!=null，那么则被put()或get()调用。\n*/\nprotected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {\n}\n```\n\nentryRemoved方法是一个空方法，说明这个也是让开发者自己根据需求去重写的。entryRemoved()主要作用就是在结点数据value需要被删除或回收的时候，给开发者的回调。开发者就可以在这个方法里面实现一些自己的逻辑：   \n（1）可以进行资源的回收；     \n（2）可以实现二级内存缓存，可以进一步提高性能，    \n思路如下：重写LruCache的entryRemoved()函数，把删除掉的item，再次存入另外一个LinkedHashMap<String, SoftWeakReference<Bitmap>>中，这个数据结构当做二级缓存，每次获得图片的时候，先判断LruCache中是否缓存，没有的话，再判断这个二级缓存中是否有，如果都没有再从sdcard上获取。sdcard上也没有的话，就从网络服务器上拉取。entryRemoved()在LruCache中有四个地方进行了调用：put()、get()、trimToSize()、remove()中进行了调用。\n\n\n####### 3.8 LruCache的线程安全性 \n\nLruCache是线程安全的，因为在put、get、trimToSize、remove的方法中都加入synchronized进行同步控制。\n\n\n##### 4.LruCache代码示例\n\n使用步骤：\n- 在构造LruCache时提供一个总的缓存大小；\n- 重写sizeOf方法，对存入map的数据大小进行自定义测量；\n- 根据需要，决定是否要重写entryRemoved()方法；\n- 使用LruCache提供的put和get方法进行数据的缓存\n\n```java\nprivate LruCache<String, Bitmap> mMemoryCache;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    ...\n    // 获得虚拟机能提供的最大内存，超过这个大小会抛出OutOfMemory的异常\n    final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);\n\n    // 用１／８的内存大小作为内存缓存\n    final int cacheSize = maxMemory / 8;\n\n    mMemoryCache = new LruCache<String, Bitmap>(cacheSize) {\n        @Override\n        protected int sizeOf(String key, Bitmap bitmap) {\n            // 这里返回的不是item的个数，是cache的size（单位1024个字节）\n            return bitmap.getByteCount() / 1024;\n        }\n    };\n    ...\n}\n\npublic void addBitmapToMemoryCache(String key, Bitmap bitmap) {\n    if (getBitmapFromMemCache(key) == null) {\n        mMemoryCache.put(key, bitmap);\n    }\n}\n\npublic Bitmap getBitmapFromMemCache(String key) {\n    return mMemoryCache.get(key);\n}\n```\n\n当为ImageView加载一张图片时，会先在LruCache 中看看有没有缓存这张图片，如果有的话直接更新到ImageView中，如果没有的话，一个后台线程会被触发来加载这张图片。\n\n```java\npublic void loadBitmap(int resId, ImageView imageView) {\n    final String imageKey = String.valueOf(resId);\n\n    // 查看下内存缓存中是否缓存了这张图片\n    final Bitmap bitmap = getBitmapFromMemCache(imageKey);\n    if (bitmap != null) {\n        mImageView.setImageBitmap(bitmap);\n    } else {\n        mImageView.setImageResource(R.drawable.image_placeholder);\nBitmapWorkerTask task = new BitmapWorkerTask(mImageView);\n        task.execute(resId);\n    }\n}\n```\n\n在图片加载的Task中，需要把加载好的图片加入到内存缓存中。\n\n```java\nclass BitmapWorkerTask extends AsyncTask<Integer, Void, Bitmap> {\n    ...\n    // 在后台完成\n    @Override\n    protected Bitmap doInBackground(Integer... params) {\n        final Bitmap bitmap = decodeSampledBitmapFromResource(\n                getResources(), params[0], 100, 100));\n    addBitmapToMemoryCache(String.valueOf(params[0]), bitmap);\n        return bitmap;\n    }\n    ...\n}\n```\n##### 5.总结\n\n- LruCache 自身并没有释放内存，只是 LinkedHashMap中将数据移除了，如果数据还在别的地方被引用了，还是有泄漏问题，还需要手动释放内存；\n- 覆写 entryRemoved 方法能知道 LruCache 数据移除是是否发生了冲突（冲突是指在map.put()的时候，对应的key中是否存在原来的值），也可以去手动释放资源；\n\n\n### 三 磁盘缓存（二级缓存）\n\nLruCache是一种内存缓存策略，但是当存在大量图片的时候，我们指定的缓存内存空间可能很快就会用完，这个时候，LruCache就会频繁的进行trimToSize()操作，不断的将最近最少使用的数据移除，当再次需要该数据时，又得从网络上重新加载，这样就有可能造成OOM。为此，Google提供了一种磁盘缓存的解决方案——DiskLruCache（DiskLruCache并没有集成到Android源码中，在Android Doc的例子中有讲解）。\n\n##### 1. DiskLruCache实现原理\n\n我们可以先来直观看一下，使用了DiskLruCache缓存策略的APP，缓存目录中是什么样子，如下图：\n\n{% asset_img 文件缓存结果图.png 文件缓存结果图 %}\n\n可以看到，缓存目录中有一堆文件名很长的文件，这些文件就是我们缓存的一张张图片数据，在最后有一个文件名journal的文件，这个journal文件是DiskLruCache的一个日志文件，即保存着每张缓存图片的操作记录，journal文件正是实现DiskLruCache的核心。看到出现了journal文件，基本可以说明这个APP使用了DiskLruCache缓存策略。\n\n根据对LruCache的分析，要实现LRU，最重要的是要有一种数据结构能够基于访问顺序来保存缓存中的对象，LinkedHashMap是一种非常合适的数据结构，为此，DiskLruCache也选择了LinkedHashMap作为维护访问顺序的数据结构，但是，对于DiskLruCache来说，单单LinkedHashMap是不够的，因为我们不能像LruCache一样，直接将数据放置到LinkedHashMap的value中，也就是处于内存当中，在DiskLruCache中，数据是缓存到了本地文件，这里的LinkedHashMap中的value只是保存的是value的一些简要信息Entry，如唯一的文件名称、大小、是否可读等信息，如：\n\n```java\nprivate final class Entry {\n    private final String key;\n    /** Lengths of this entry's files. */\n    private final long[] lengths;\n    /** True if this entry has ever been published */\n    private boolean readable;\n    /** The ongoing edit or null if this entry is not being edited. */\n    private Editor currentEditor;\n    /** The sequence number of the most recently committed edit to this entry. */\n    private long sequenceNumber;\n    private Entry(String key) {\n        this.key = key;\n        this.lengths = new long[valueCount];\n    }\n    public String getLengths() throws IOException {\n        StringBuilder result = new StringBuilder();\n        for (long size : lengths) {\n            result.append(' ').append(size);\n    }\n    return result.toString();\n}\n\n    /**\n     * Set lengths using decimal numbers like \"10123\".\n     */\n    private void setLengths(String[] strings) throws IOException {\n        if (strings.length != valueCount) {\n            throw invalidLengths(strings);\n        }\n\n        try {\n            for (int i = 0; i < strings.length; i++) {\n                lengths[i] = Long.parseLong(strings[i]);\n            }\n        } catch (NumberFormatException e) {\n            throw invalidLengths(strings);\n        }\n    }\n\n    private IOException invalidLengths(String[] strings) throws IOException {\n        throw new IOException(\"unexpected journal line: \" + Arrays.toString(strings));\n    }\n\n    public File getCleanFile(int i) {\n        return new File(directory, key + \".\" + i);\n    }\n\n    public File getDirtyFile(int i) {\n        return new File(directory, key + \".\" + i + \".tmp\");\n    }\n}\n```\n\nDiskLruCache中对于LinkedHashMap定义如下：\n\n```java\nprivate final LinkedHashMap<String, Entry> lruEntries\n\t= new LinkedHashMap<String, Entry>(0, 0.75f, true);\n```\n\n在LruCache中，由于数据是直接缓存中内存中，map中数据的建立是在使用LruCache缓存的过程中逐步建立的，而对于DiskLruCache，由于数据是缓存在本地文件，相当于是持久保存下来的一个文件，即使程序退出文件还在，因此，map中数据的建立，除了在使用DiskLruCache过程中建立外，map还应该包括之前已经存在的缓存文件，因此，在获取DiskLruCache的实例时，DiskLruCache会去读取journal这个日志文件，根据这个日志文件中的信息，建立map的初始数据，同时，会根据journal这个日志文件，维护本地的缓存文件。构造DiskLruCache的方法如下：\n\n```java\npublic static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)\n    throws IOException {\n    if (maxSize <= 0) {\n        throw new IllegalArgumentException(\"maxSize <= 0\");\n    }\n    if (valueCount <= 0) {\n        throw new IllegalArgumentException(\"valueCount <= 0\");\n    }\n\n    // prefer to pick up where we left off\n    DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);\n    if (cache.journalFile.exists()) {\n    try {\n        cache.readJournal();\n        cache.processJournal();\n        cache.journalWriter = new BufferedWriter(new FileWriter(cache.journalFile, true),IO_BUFFER_SIZE);\n                return cache;\n        } catch (IOException journalIsCorrupt) {\n            //                System.logW(\"DiskLruCache \" + directory + \" is corrupt: \"\n            //                        + journalIsCorrupt.getMessage() + \", removing\");\n            cache.delete();\n        }\n   }\n\n    // create a new empty cache\n    directory.mkdirs();\n    cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);\n    cache.rebuildJournal();\n    return cache;\n}\n```\n\n其中，\ncache.readJournal();    \ncache.processJournal();\n正是去读取journal日志文件，建立起map中的初始数据，同时维护缓存文件。\n\n##### 2.journal日志文件\n\njournal日志文件到底保存了什么信息呢，一个标准的journal日志文件信息如下：\n\n```bash\n\nlibcore.io.DiskLruCache    //第一行，固定内容，声明\n1                                        //第二行，cache的版本号，恒为1\n1                                        //第三行，APP的版本号\n2                                        //第四行，一个key，可以存放多少条数据valueCount    \n                                           //第五行，空行分割行\nDIRTY 335c4c6028171cfddfbaae1a9c313c52\nCLEAN 335c4c6028171cfddfbaae1a9c313c52 3934\nREMOVE 335c4c6028171cfddfbaae1a9c313c52\nDIRTY 1ab96a171faeeee38496d8b330771a7a\nCLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234\nREAD 335c4c6028171cfddfbaae1a9c313c52\nREAD 3400330d1dfc7f3f7f4b8d4d803dfcf6\n```\n\n前五行称为journal日志文件的头，下面部分的每一行会以四种前缀之一开始：DIRTY、CLEAN、REMOVE、READ。\n\n以一个DIRTY前缀开始的，后面紧跟着缓存图片的key。以DIRTY这个这个前缀开头，意味着这是一条脏数据。每当我们调用一次DiskLruCache的edit()方法时，都会向journal文件中写入一条DIRTY记录，表示我们正准备写入一条缓存数据，但不知结果如何。然后调用commit()方法表示写入缓存成功，这时会向journal中写入一条CLEAN记录，意味着这条“脏”数据被“洗干净了”，调用abort()方法表示写入缓存失败，这时会向journal中写入一条REMOVE记录。也就是说，每一行DIRTY的key，后面都应该有一行对应的CLEAN或者REMOVE的记录，否则这条数据就是“脏”的，会被自动删除掉。\n\n在CLEAN前缀和key后面还有一个数值，代表的是该条缓存数据的大小。\n\n##### 3.DiskLruCache中的工作流程\n\n**1.**初始化：通过open()方法，获取DiskLruCache的实例，在open方法中通过readJournal(); 方法读取journal日志文件，根据journal日志文件信息建立map中的初始数据；然后再调用processJournal();方法对刚刚建立起的map数据进行分析，分析的工作，一个是计算当前有效缓存文件（即被CLEAN的）的大小，一个是清理无用缓存文件；\n\n**2.**数据缓存与获取缓存：上面的初始化工作完成后，我们就可以在程序中进行数据的缓存功能和获取缓存的功能了；缓存数据的操作是借助DiskLruCache.Editor这个类完成的，这个类也是不能new的，需要调用DiskLruCache的edit()方法来获取实例，如：public Editor edit(String key) throws IOException。在写入完成后，需要进行commit()。\n\n如下一个简单示例：\n\n```java\n    new Thread(new Runnable() {    \n        @Override    \n        public void run() {    \n            try {    \n                String imageUrl = \"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg\";    \n                String key = hashKeyForDisk(imageUrl);  //MD5对url进行加密，这个主要是为了获得统一的16位字符  \n                DiskLruCache.Editor editor = mDiskLruCache.edit(key);  //拿到Editor，往journal日志中写入DIRTY记录  \n                if (editor != null) {    \n                    OutputStream outputStream = editor.newOutputStream(0);    \n                    if (downloadUrlToStream(imageUrl, outputStream)) {  //downloadUrlToStream方法为下载图片的方法，并且将输出流放到outputStream  \n                        editor.commit();  //完成后记得commit()，成功后，再往journal日志中写入CLEAN记录  \n                    } else {    \n                        editor.abort();  //失败后，要remove缓存文件，往journal文件中写入REMOVE记录  \n                    }    \n                }    \n                mDiskLruCache.flush();  //将缓存操作同步到journal日志文件，不一定要在这里就调用  \n            } catch (IOException e) {    \n                e.printStackTrace();    \n            }    \n        }    \n    }).start();   \n```\n\n**注意**每次调用edit()时，会向journal日志文件写入DIRTY为前缀的一条记录；文件保存成功后，调用commit()时，也会向journal日志中写入一条CLEAN为前缀的一条记录，如果失败，需要调用abort()，abort()里面会向journal文件写入一条REMOVE为前缀的记录。\n\n获取缓存数据是通过get()方法实现的，如下一个简单示例：\n\n```java\ntry {    \n    String imageUrl = \"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg\";    \n    String key = hashKeyForDisk(imageUrl);  //MD5对url进行加密，这个主要是为了获得统一的16位字符  \n     //通过get拿到value的Snapshot，里面封装了输入流、key等信息，调用get会向journal文件写入READ为前缀的记录  \n    DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key);   \n    if (snapShot != null) {    \n        InputStream is = snapShot.getInputStream(0);    \n        Bitmap bitmap = BitmapFactory.decodeStream(is);    \n        mImage.setImageBitmap(bitmap);    \n    }    \n} catch (IOException e) {    \n    e.printStackTrace();    \n}\n```\n\n**3.**合适的地方进行flush()\n\n在上面进行数据缓存或获取缓存的时候，调用不同的方法会往journal中写入不同前缀的一行记录，记录写入是通过IO下的Writer写入的，要真正生效，还需要调用writer的flush()方法，而DiskLruCache中的flush()方法中封装了writer.flush()的操作，因此，我们只需要在合适地方调用DiskLruCache中的flush()方法即可。其作用也就是将操作记录同步到journal文件中，这是一个消耗效率的IO操作，我们不用每次一往journal中写数据后就调用flush，这样对效率影响较大，可以在Activity的onPause()中调用一下即可。\n\n##### 4.DiskLruCache总结\n\n- 我们可以在在UI线程中检测内存缓存，即主线程中可以直接使用LruCache；\n- 使用DiskLruCache时，由于缓存或获取都需要对本地文件进行操作，因此需要另开一个线程，在子线程中检测磁盘缓存、保存缓存数据，磁盘操作从来不应该在UI线程中实现；\n- LruCache内存缓存的核心是LinkedHashMap，而DiskLruCache的核心是LinkedHashMap和journal日志文件，相当于把journal看作是一块“内存”，LinkedHashMap的value只保存文件的简要信息，对缓存文件的所有操作都会记录在journal日志文件中。\n\n##### 5.DiskLruCache优化\n\nDiskLruCache是基于日志文件journal的，这就决定了每次对缓存文件的操作都需要进行日志文件的记录，我们可以不用journal文件，在第一次构造DiskLruCache的时候，直接从程序访问缓存目录下的缓存文件，并将每个缓存文件的访问时间作为初始值记录在map的value中，每次访问或保存缓存都更新相应key对应的缓存文件的访问时间，这样就避免了频繁的IO操作，这种情况下就需要使用单例模式对DiskLruCache进行构造了，下面要说的Acache轻量级的数据缓存类就是这种实现方式。\n\n### 四 一个轻量级缓存框架——ACache\n\nACache是一个轻量级的开源cache框架，实际上就是一个叫ACache的java类。已经在商业项目中使用，运行效果不错。\n\nACache类似于SharedPreferences，但是比SharedPreferences功能更加强大，SharedPreferences只能保存一些基本数据类型、Serializable、Bundle等数据。而Acache可以缓存如下数据：普通的字符串、JsonObject、JsonArray、Bitmap、Drawable、序列化的java对象，和 byte数据。\n\n主要特色：\n\n- 轻，轻到只有一个JAVA文件。\n- 可配置，可以配置缓存路径，缓存大小，缓存数量等。\n- 可以设置缓存超时时间，缓存超时自动失效，并被删除。\n- 支持多进程\n\n应用场景：\n\n- 替换SharePreference当做配置文件\n- 可以缓存网络请求数据，比如oschina的android客户端可以缓存http请求的新闻内容，缓存时间假设为1个小时，超时后自动失效，让客户端重新请求新的数据，减少客户端流量，同时减少服务器并发量。\n\n代码示例：\n\n```java\npublic class NewsListActivity extends Activity {\n  private List<News> list;\n  private ListView listView;\n  private LoadImageAdapter adapter;//适配器\n  private ACache acache;//缓存框架\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    // TODO Auto-generated method stub\n    super.onCreate(savedInstanceState);\n    super.setContentView(R.layout.load_img_listview_activity);\n    acache=ACache.get(this);//创建ACache组件\n    initView();//初始化界面，代码不贴了\n}\n\npublic void loadData(){\n   String cacheData=acache.getAsString(\"newsList\");//从缓存中取数据\n   if(cacheData!=null){//如果缓存中有，就不访问网络\n   List<News> newsList=gson.fromJson(cacheData, new TypeToken<List<News>>(){}.getType());//将json转为List\n      list.addAll(newsList);\n      adapter.notifyDataSetChanged();\n      return;\n   }\n   new Thread(new Runnable() {\n     @Override\n     public void run() {\n       // TODO Auto-generated method stub\n       SystemClock.sleep(2000);//模拟网络耗时\n       String json=request();//模拟从网络中获取json数据\n       acache.put(\"newslist\", json, 60*60*1);//将数据存入缓存中，有效时间设置为1小时\n       List<News> newsList=gson.fromJson(json, new TypeToken<List<News>>(){}.getType());\n       list.addAll(newsList);\n       handler.sendEmptyMessage(1);\n    }\n         \n  }).start();\n}\n    /**\n     * 模拟网络请求方法\n     * @return json数据\n     */\nprivate String request(){\n   News news=null;\n   for(int i=0;i<10;i++){\n       news=new News();\n       news.setId(i);\n       news.setImgUrl(\"course/img/face_\"+i+\".png\");\n       news.setTitle(\"新闻标题\"+i);\n       news.setSummary(\"测试\"+i);\n       list.add(news);\n   }\n   Gson gson=new Gson();\n   return gson.toJson(list);    \n}\n\nprivate Handler handler=new Handler()\n   @Override\n   public void handleMessage(Message msg) {\n       // TODO Auto-generated method stub\n       switch(msg.what){\n           case 1:\n             notify_layout.setVisibility(View.GONE);\n             adapter.notifyDataSetChanged();\n           break;\n       }\n   }\n}\n```\n\n\n  \n\n\n","slug":"android基础之缓存","published":1,"updated":"2017-03-09T13:16:38.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj02g6gsm000x7c02i00z1ske","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>移动开发本质上就是手机和服务器之间进行通信，需要从服务端获取数据。反复通过网络获取数据是比较耗时的，特别是访问比较多的时候，会极大影响了性能，Android中可通过缓存机制来减少频繁的网络操作，减少流量、提升性能。android中缓存分为一级缓存，二级缓存和图片的三级缓存(就是网络)。</p>\n<p>Android缓存分为内存缓存（一级缓存）和文件缓存（二级缓存）。在早期，各大图片缓存框架流行之前，常用的内存缓存方式是软引用（SoftReference）和弱引用（WeakReference），如大部分的使用方式：HashMap<string url,=\"\" softreference<drawable=\"\">&gt; imageCache;这种形式。从Android 2.3（Level 9）开始，垃圾回收器更倾向于回收SoftReference或WeakReference对象，这使得SoftReference和WeakReference变得不是那么实用有效。同时，到了Android 3.0（Level 11）之后，图片数据Bitmap被放置到了内存的堆区域，而堆区域的内存是由GC管理的，开发者也就不需要进行图片资源的释放工作，但这也使得图片数据的释放无法预知，增加了造成OOM的可能。因此，在Android3.1以后，Android推出了LruCache这个内存缓存类和DiskLruCache这个磁盘缓存类。</string></p>\n<p>当Android端需要获得数据时比如获取网络中的图片，我们首先从内存中查找（按键查找），内存中没有的再从磁盘文件或sqlite中去查找，若磁盘中也没有才通过网络获取（图片的3级缓存策略）；当获得来自网络的数据，就以key-value对的方式先缓存到内存（一级缓存），同时缓存到文件或sqlite中（二级缓存）。注意：内存缓存会造成堆内存泄露，所有一级缓存通常要严格控制缓存的大小，一般控制在系统内存的1/4。</p>\n<h3 id=\"二-内存缓存（一级缓存）\"><a href=\"#二-内存缓存（一级缓存）\" class=\"headerlink\" title=\"二 内存缓存（一级缓存）\"></a>二 内存缓存（一级缓存）</h3><p>android中使用LruCache做内存缓存。在介绍这个类之前先了解一下LRU算法。</p>\n<h5 id=\"1-LRU算法\"><a href=\"#1-LRU算法\" class=\"headerlink\" title=\"1.LRU算法\"></a>1.LRU算法</h5><p>LRU，全称Least Rencetly Used，即最近最少使用，是一种非常常用的置换算法，也即淘汰最长时间未使用的对象。LRU在操作系统中的页面置换算法中广泛使用，我们的内存或缓存空间是有限的，当新加入一个对象时，造成我们的缓存空间不足了，此时就需要根据某种算法对缓存中原有数据进行淘汰货删除，而LRU选择的是将最长时间未使用的对象进行淘汰。</p>\n<h5 id=\"2-LruCache实现原理\"><a href=\"#2-LruCache实现原理\" class=\"headerlink\" title=\"2.LruCache实现原理\"></a>2.LruCache实现原理</h5><p>根据LRU算法的思想，要实现LRU最核心的是要有一种数据结构能够基于访问顺序来保存缓存中的对象，这样我们就能够很方便的知道哪个对象是最近访问的，哪个对象是最长时间未访问的。LruCache选择的是LinkedHashMap这个数据结构，LinkedHashMap是一个双向循环链表，在构造LinkedHashMap时，通过一个boolean值来指定LinkedHashMap中保存数据的方式，LinkedHashMap的一个构造方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* </span></div><div class=\"line\">     * 初始化LinkedHashMap </div><div class=\"line\">     * 第一个参数：initialCapacity，初始大小 </div><div class=\"line\">     * 第二个参数：loadFactor，负载因子=0.75f </div><div class=\"line\">     * 第三个参数：accessOrder=true，基于访问顺序；accessOrder=false，基于插入顺序 </div><div class=\"line\">     */  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">boolean</span> accessOrder)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">super</span>(initialCapacity, loadFactor);  </div><div class=\"line\">        init();  </div><div class=\"line\">        <span class=\"keyword\">this</span>.accessOrder = accessOrder;  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>显然，在LruCache中选择的是accessOrder = true；此时，当accessOrder 设置为 true时，每当我们更新（即调用put方法）或访问（即调用get方法）map中的结点时，LinkedHashMap内部都会将这个结点移动到链表的尾部，因此，在链表的尾部是最近刚刚使用的结点，在链表的头部是是最近最少使用的结点，当我们的缓存空间不足时，就应该持续把链表头部结点移除掉，直到有剩余空间放置新结点。<br>可以看到，LinkedHashMap完成了LruCache中的核心功能，那LruCache中剩下要做的就是定义缓存空间总容量，当前保存数据已使用的容量，对外提供put、get方法。</p>\n<h5 id=\"3-LruCache源码分析\"><a href=\"#3-LruCache源码分析\" class=\"headerlink\" title=\"3.LruCache源码分析\"></a>3.LruCache源码分析</h5><p>在了解了LruCache的核心原理之后，就可以开始分析LruCache的源码了。</p>\n<p>####### 3.1关键字段</p>\n<p>根据上面的分析，首先要有总容量、已使用容量、linkedHashMap这几个关键字段，LruCache中提供了下面三个关键字段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//核心数据结构  </span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LinkedHashMap&lt;K, V&gt; map;  </div><div class=\"line\">    <span class=\"comment\">// 当前缓存数据所占的大小  </span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;  </div><div class=\"line\">    <span class=\"comment\">//缓存空间总容量  </span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxSize;</div></pre></td></tr></table></figure>\n<p>要注意的是size字段，因为map中可以存放各种类型的数据，这些数据的大小测量方式也是不一样的，比如Bitmap类型的数据和String类型的数据计算他们的大小方式肯定不同，因此，LruCache中在计算放入数据大小的方法sizeOf中，只是简单的返回了1，需要我们重写这个方法，自己去定义数据的测量方式。因此，我们在使用LruCache的时候，经常会看到这种方式： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CACHE_SIZE = <span class=\"number\">4</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;<span class=\"comment\">//4Mib  </span></div><div class=\"line\">    LruCache&lt;String,Bitmap&gt; bitmapCache = <span class=\"keyword\">new</span> LruCache&lt;String,Bitmap&gt;(CACHE_SIZE)&#123;  </div><div class=\"line\">        <span class=\"meta\">@Override</span>  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(String key, Bitmap value)</span> </span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">return</span> value.getByteCount();<span class=\"comment\">//自定义Bitmap数据大小的计算方式  </span></div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<p>####### 3.2 构造方法  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LruCache</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (maxSize &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"maxSize &lt;= 0\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.maxSize = maxSize;</div><div class=\"line\">    <span class=\"keyword\">this</span>.map = <span class=\"keyword\">new</span> LinkedHashMap&lt;K, V&gt;(<span class=\"number\">0</span>, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>LruCache只有一个唯一的构造方法，在构造方法中，给定了缓存空间的总大小，初始化了LinkedHashMap核心数据结构，在LinkedHashMap中的第三个参数指定为true，也就设置了accessOrder=true，表示这个LinkedHashMap将是基于数据的访问顺序进行排序。</p>\n<p>####### 3.3 sizeOf()和safeSizeOf()方法测量数据类型大小</p>\n<p>根据上面的解释，由于各种数据类型大小测量的标准不统一，具体测量的方法应该由使用者来实现，如上面给出的一个在实现LruCache时重写sizeOf的一种常用实现方式。通过多态的性质，再具体调用sizeOf时会调用我们重写的方法进行测量，LruCache对sizeOf()的调用进行一层封装，如下： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">safeSizeOf</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> result = sizeOf(key, value);</div><div class=\"line\">    <span class=\"keyword\">if</span> (result &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Negative size: \"</span> + key + <span class=\"string\">\"=\"</span> + value);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>里面其实就是调用sizeOf()方法，返回sizeOf计算的大小。<br>上面就是LruCache的基本内容，下面就需要提供LruCache的核心功能了。</p>\n<p>####### 3.4 put方法缓存数据   </p>\n<p>首先看一下它的源码实现：    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">   * 给对应key缓存value，并且将该value移动到链表的尾部。</div><div class=\"line\">   */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null || value == null\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">      V previous;</div><div class=\"line\">      <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// 记录 put 的次数</span></div><div class=\"line\">        putCount++;</div><div class=\"line\">        <span class=\"comment\">// 通过键值对，计算出要保存对象value的大小，并更新当前缓存大小</span></div><div class=\"line\">        size += safeSizeOf(key, value);</div><div class=\"line\">        <span class=\"comment\">/*</span></div><div class=\"line\">         * 如果 之前存在key，用新的value覆盖原来的数据， 并返回 之前key 的value</div><div class=\"line\">         * 记录在 previous</div><div class=\"line\">         */</div><div class=\"line\">        previous = map.put(key, value);</div><div class=\"line\">        <span class=\"comment\">// 如果之前存在key，并且之前的value不为null</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// 计算出 之前value的大小，因为前面size已经加上了新的value数据的大小，此时，需要再次更新size，减去原来value的大小</span></div><div class=\"line\">            size -= safeSizeOf(key, previous);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 如果之前存在key，并且之前的value不为null</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">/*</span></div><div class=\"line\">         * previous值被剔除了，此次添加的 value 已经作为key的 新值</div><div class=\"line\">         * 告诉 自定义 的 entryRemoved 方法</div><div class=\"line\">         */</div><div class=\"line\">        entryRemoved(<span class=\"keyword\">false</span>, key, previous, value);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//裁剪缓存容量（在当前缓存数据大小超过了总容量maxSize时，才会真正去执行LRU）</span></div><div class=\"line\">    trimToSize(maxSize);</div><div class=\"line\">      <span class=\"keyword\">return</span> previous;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，put()方法主要有以下几步：<br>1）key和value判空，说明LruCache中不允许key和value为null；<br>2）通过safeSizeOf()获取要加入对象数据的大小，并更新当前缓存数据的大小；<br>3）将新的对象数据放入到缓存中，即调用LinkedHashMap的put方法，如果原来存在该key时，直接替换掉原来的value值，并返回之前的value值，得到之前value的大小，更新当前缓存数据的size大小；如果原来不存在该key，则直接加入缓存即可；<br>4）清理缓存空间</p>\n<p>####### 3.5 trimToSize()清理缓存空间<br>当我们加入一个数据时（put），为了保证当前数据的缓存所占大小没有超过我们指定的总大小，通过调用trimToSize()来对缓存空间进行管理控制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     * 循环进行LRU，直到当前所占容量大小没有超过指定的总容量大小</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">        K key;</div><div class=\"line\">        V value;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// 一些异常情况的处理</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">0</span> || (map.isEmpty() &amp;&amp; size != <span class=\"number\">0</span>)) &#123;</div><div class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</div><div class=\"line\">                        getClass().getName() + <span class=\"string\">\".sizeOf() is reporting inconsistent results!\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">// 首先判断当前缓存数据大小是否超过了指定的缓存空间总大小。如果没有超过，即缓存中还可以存入数据，直接跳出循环，清理完毕</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">/**</span></div><div class=\"line\">             * 执行到这，表示当前缓存数据已超过了总容量，需要执行LRU，即将最近最少使用的数据清除掉，直到数据所占缓存空间没有超标;</div><div class=\"line\">             * 根据前面的原理分析，知道，在链表中，链表的头结点是最近最少使用的数据，因此，最先清除掉链表前面的结点</div><div class=\"line\">             */</div><div class=\"line\">            Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</div><div class=\"line\">            key = toEvict.getKey();</div><div class=\"line\">            value = toEvict.getValue();</div><div class=\"line\">            map.remove(key);</div><div class=\"line\">            <span class=\"comment\">// 移除掉后，更新当前数据缓存的大小</span></div><div class=\"line\">            size -= safeSizeOf(key, value);</div><div class=\"line\">            <span class=\"comment\">// 更新移除的结点数量</span></div><div class=\"line\">            evictionCount++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">/*</span></div><div class=\"line\">         * 通知某个结点被移除，类似于回调</div><div class=\"line\">         */</div><div class=\"line\">        entryRemoved(<span class=\"keyword\">true</span>, key, value, <span class=\"keyword\">null</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>trimToSize()方法的作用就是为了保证当前数据的缓存大小不能超过我们指定的缓存总大小，如果超过了，就会开始移除最近最少使用的数据，直到size符合要求。trimToSize()方法在put()的时候一定会调用，在get()的时候有可能会调用。</p>\n<p>####### 3.6 get方法获取缓存数据   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 根据key查询缓存，如果该key对应的value存在于缓存，直接返回value；</div><div class=\"line\">* 访问到这个结点时，LinkHashMap会将它移动到双向循环链表的的尾部。</div><div class=\"line\">* 如果如果没有缓存的值，则返回null。（如果开发者重写了create()的话，返回创建的value）</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">get</span><span class=\"params\">(K key)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    V mapValue;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// LinkHashMap 如果设置按照访问顺序的话，这里每次get都会重整数据顺序</span></div><div class=\"line\">        mapValue = map.get(key);</div><div class=\"line\">        <span class=\"comment\">// 计算 命中次数</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            hitCount++;</div><div class=\"line\">            <span class=\"keyword\">return</span> mapValue;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 计算 丢失次数</span></div><div class=\"line\">        missCount++;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     * 官方解释：</div><div class=\"line\">     * 尝试创建一个值，这可能需要很长时间，并且Map可能在create()返回的值时有所不同。如果在create()执行的时</div><div class=\"line\">     * 候，用这个key执行了put方法，那么此时就发生了冲突，我们在Map中删除这个创建的值，释放被创建的值，保留put进去的值。</div><div class=\"line\">     */</div><div class=\"line\">    V createdValue = create(key);</div><div class=\"line\">    <span class=\"keyword\">if</span> (createdValue == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/***************************</span></div><div class=\"line\">     * 不覆写create方法走不到下面 *</div><div class=\"line\">     ***************************/</div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     * 正常情况走不到这里</div><div class=\"line\">     * 走到这里的话 说明 实现了自定义的 create(K key) 逻辑</div><div class=\"line\">     * 因为默认的 create(K key) 逻辑为null</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// 记录 create 的次数</span></div><div class=\"line\">        createCount++;</div><div class=\"line\">        <span class=\"comment\">// 将自定义create创建的值，放入LinkedHashMap中，如果key已经存在，会返回 之前相同key 的值</span></div><div class=\"line\">        mapValue = map.put(key, createdValue);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 如果之前存在相同key的value，即有冲突。</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">/*</span></div><div class=\"line\">             * 有冲突</div><div class=\"line\">             * 所以 撤销 刚才的 操作</div><div class=\"line\">             * 将 之前相同key 的值 重新放回去</div><div class=\"line\">             */</div><div class=\"line\">            map.put(key, mapValue);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// 拿到键值对，计算出在容量中的相对长度，然后加上</span></div><div class=\"line\">            size += safeSizeOf(key, createdValue);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 如果上面 判断出了 将要放入的值发生冲突</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">/*</span></div><div class=\"line\">         * 刚才create的值被删除了，原来的 之前相同key 的值被重新添加回去了</div><div class=\"line\">         * 告诉 自定义 的 entryRemoved 方法</div><div class=\"line\">         */</div><div class=\"line\">        entryRemoved(<span class=\"keyword\">false</span>, key, createdValue, mapValue);</div><div class=\"line\">        <span class=\"keyword\">return</span> mapValue;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// 上面 进行了 size += 操作 所以这里要重整长度</span></div><div class=\"line\">        trimToSize(maxSize);</div><div class=\"line\">        <span class=\"keyword\">return</span> createdValue;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>get()方法的思路就是：<br>   1）先尝试从map缓存中获取value，即mapVaule = map.get(key);如果mapVaule != null，说明缓存中存在该对象，直接返回即可；<br>   2）如果mapVaule == null，说明缓存中不存在该对象，大多数情况下会直接返回null；但是如果我们重写了create()方法，在缓存没有该数据的时候自己去创建一个，则会继续往下走，中间可能会出现冲突，看注释；<br>   3）注意：在我们通过LinkedHashMap进行get(key)或put(key,value)时都会对链表进行调整，即将刚刚访问get或加入put的结点放入到链表尾部。</p>\n<p>####### 3.7 entryRemoved()     </p>\n<p>entryRemoved的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 1.当被回收或者删掉时调用。该方法当value被回收释放存储空间时被remove调用</div><div class=\"line\">* 或者替换条目值时put调用，默认实现什么都没做。</div><div class=\"line\">* 2.该方法没用同步调用，如果其他线程访问缓存时，该方法也会执行。</div><div class=\"line\">* 3.evicted=true：如果该条目被删除空间 （表示 进行了trimToSize or remove）  evicted=false：put冲突后 或 get里成功create后</div><div class=\"line\">* 导致</div><div class=\"line\">* 4.newValue!=null，那么则被put()或get()调用。</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">entryRemoved</span><span class=\"params\">(<span class=\"keyword\">boolean</span> evicted, K key, V oldValue, V newValue)</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>entryRemoved方法是一个空方法，说明这个也是让开发者自己根据需求去重写的。entryRemoved()主要作用就是在结点数据value需要被删除或回收的时候，给开发者的回调。开发者就可以在这个方法里面实现一些自己的逻辑：<br>（1）可以进行资源的回收；<br>（2）可以实现二级内存缓存，可以进一步提高性能，<br>思路如下：重写LruCache的entryRemoved()函数，把删除掉的item，再次存入另外一个LinkedHashMap<string, softweakreference<bitmap=\"\">&gt;中，这个数据结构当做二级缓存，每次获得图片的时候，先判断LruCache中是否缓存，没有的话，再判断这个二级缓存中是否有，如果都没有再从sdcard上获取。sdcard上也没有的话，就从网络服务器上拉取。entryRemoved()在LruCache中有四个地方进行了调用：put()、get()、trimToSize()、remove()中进行了调用。</string,></p>\n<p>####### 3.8 LruCache的线程安全性 </p>\n<p>LruCache是线程安全的，因为在put、get、trimToSize、remove的方法中都加入synchronized进行同步控制。</p>\n<h5 id=\"4-LruCache代码示例\"><a href=\"#4-LruCache代码示例\" class=\"headerlink\" title=\"4.LruCache代码示例\"></a>4.LruCache代码示例</h5><p>使用步骤：</p>\n<ul>\n<li>在构造LruCache时提供一个总的缓存大小；</li>\n<li>重写sizeOf方法，对存入map的数据大小进行自定义测量；</li>\n<li>根据需要，决定是否要重写entryRemoved()方法；</li>\n<li>使用LruCache提供的put和get方法进行数据的缓存</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> LruCache&lt;String, Bitmap&gt; mMemoryCache;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"comment\">// 获得虚拟机能提供的最大内存，超过这个大小会抛出OutOfMemory的异常</span></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxMemory = (<span class=\"keyword\">int</span>) (Runtime.getRuntime().maxMemory() / <span class=\"number\">1024</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 用１／８的内存大小作为内存缓存</span></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> cacheSize = maxMemory / <span class=\"number\">8</span>;</div><div class=\"line\"></div><div class=\"line\">    mMemoryCache = <span class=\"keyword\">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(String key, Bitmap bitmap)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// 这里返回的不是item的个数，是cache的size（单位1024个字节）</span></div><div class=\"line\">            <span class=\"keyword\">return</span> bitmap.getByteCount() / <span class=\"number\">1024</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addBitmapToMemoryCache</span><span class=\"params\">(String key, Bitmap bitmap)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (getBitmapFromMemCache(key) == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        mMemoryCache.put(key, bitmap);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Bitmap <span class=\"title\">getBitmapFromMemCache</span><span class=\"params\">(String key)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> mMemoryCache.get(key);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当为ImageView加载一张图片时，会先在LruCache 中看看有没有缓存这张图片，如果有的话直接更新到ImageView中，如果没有的话，一个后台线程会被触发来加载这张图片。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadBitmap</span><span class=\"params\">(<span class=\"keyword\">int</span> resId, ImageView imageView)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> String imageKey = String.valueOf(resId);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 查看下内存缓存中是否缓存了这张图片</span></div><div class=\"line\">    <span class=\"keyword\">final</span> Bitmap bitmap = getBitmapFromMemCache(imageKey);</div><div class=\"line\">    <span class=\"keyword\">if</span> (bitmap != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        mImageView.setImageBitmap(bitmap);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mImageView.setImageResource(R.drawable.image_placeholder);</div><div class=\"line\">BitmapWorkerTask task = <span class=\"keyword\">new</span> BitmapWorkerTask(mImageView);</div><div class=\"line\">        task.execute(resId);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在图片加载的Task中，需要把加载好的图片加入到内存缓存中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BitmapWorkerTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">AsyncTask</span>&lt;<span class=\"title\">Integer</span>, <span class=\"title\">Void</span>, <span class=\"title\">Bitmap</span>&gt; </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"comment\">// 在后台完成</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Bitmap <span class=\"title\">doInBackground</span><span class=\"params\">(Integer... params)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> Bitmap bitmap = decodeSampledBitmapFromResource(</div><div class=\"line\">                getResources(), params[<span class=\"number\">0</span>], <span class=\"number\">100</span>, <span class=\"number\">100</span>));</div><div class=\"line\">    addBitmapToMemoryCache(String.valueOf(params[<span class=\"number\">0</span>]), bitmap);</div><div class=\"line\">        <span class=\"keyword\">return</span> bitmap;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5.总结\"></a>5.总结</h5><ul>\n<li>LruCache 自身并没有释放内存，只是 LinkedHashMap中将数据移除了，如果数据还在别的地方被引用了，还是有泄漏问题，还需要手动释放内存；</li>\n<li>覆写 entryRemoved 方法能知道 LruCache 数据移除是是否发生了冲突（冲突是指在map.put()的时候，对应的key中是否存在原来的值），也可以去手动释放资源；</li>\n</ul>\n<h3 id=\"三-磁盘缓存（二级缓存）\"><a href=\"#三-磁盘缓存（二级缓存）\" class=\"headerlink\" title=\"三 磁盘缓存（二级缓存）\"></a>三 磁盘缓存（二级缓存）</h3><p>LruCache是一种内存缓存策略，但是当存在大量图片的时候，我们指定的缓存内存空间可能很快就会用完，这个时候，LruCache就会频繁的进行trimToSize()操作，不断的将最近最少使用的数据移除，当再次需要该数据时，又得从网络上重新加载，这样就有可能造成OOM。为此，Google提供了一种磁盘缓存的解决方案——DiskLruCache（DiskLruCache并没有集成到Android源码中，在Android Doc的例子中有讲解）。</p>\n<h5 id=\"1-DiskLruCache实现原理\"><a href=\"#1-DiskLruCache实现原理\" class=\"headerlink\" title=\"1. DiskLruCache实现原理\"></a>1. DiskLruCache实现原理</h5><p>我们可以先来直观看一下，使用了DiskLruCache缓存策略的APP，缓存目录中是什么样子，如下图：</p>\n\n<p>可以看到，缓存目录中有一堆文件名很长的文件，这些文件就是我们缓存的一张张图片数据，在最后有一个文件名journal的文件，这个journal文件是DiskLruCache的一个日志文件，即保存着每张缓存图片的操作记录，journal文件正是实现DiskLruCache的核心。看到出现了journal文件，基本可以说明这个APP使用了DiskLruCache缓存策略。</p>\n<p>根据对LruCache的分析，要实现LRU，最重要的是要有一种数据结构能够基于访问顺序来保存缓存中的对象，LinkedHashMap是一种非常合适的数据结构，为此，DiskLruCache也选择了LinkedHashMap作为维护访问顺序的数据结构，但是，对于DiskLruCache来说，单单LinkedHashMap是不够的，因为我们不能像LruCache一样，直接将数据放置到LinkedHashMap的value中，也就是处于内存当中，在DiskLruCache中，数据是缓存到了本地文件，这里的LinkedHashMap中的value只是保存的是value的一些简要信息Entry，如唯一的文件名称、大小、是否可读等信息，如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String key;</div><div class=\"line\">    <span class=\"comment\">/** Lengths of this entry's files. */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span>[] lengths;</div><div class=\"line\">    <span class=\"comment\">/** True if this entry has ever been published */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> readable;</div><div class=\"line\">    <span class=\"comment\">/** The ongoing edit or null if this entry is not being edited. */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> Editor currentEditor;</div><div class=\"line\">    <span class=\"comment\">/** The sequence number of the most recently committed edit to this entry. */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> sequenceNumber;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Entry</span><span class=\"params\">(String key)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.key = key;</div><div class=\"line\">        <span class=\"keyword\">this</span>.lengths = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[valueCount];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getLengths</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">        StringBuilder result = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">long</span> size : lengths) &#123;</div><div class=\"line\">            result.append(<span class=\"string\">' '</span>).append(size);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result.toString();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Set lengths using decimal numbers like \"10123\".</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setLengths</span><span class=\"params\">(String[] strings)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (strings.length != valueCount) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> invalidLengths(strings);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strings.length; i++) &#123;</div><div class=\"line\">                lengths[i] = Long.parseLong(strings[i]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NumberFormatException e) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> invalidLengths(strings);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> IOException <span class=\"title\">invalidLengths</span><span class=\"params\">(String[] strings)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"unexpected journal line: \"</span> + Arrays.toString(strings));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> File <span class=\"title\">getCleanFile</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> File(directory, key + <span class=\"string\">\".\"</span> + i);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> File <span class=\"title\">getDirtyFile</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> File(directory, key + <span class=\"string\">\".\"</span> + i + <span class=\"string\">\".tmp\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>DiskLruCache中对于LinkedHashMap定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LinkedHashMap&lt;String, Entry&gt; lruEntries</div><div class=\"line\">\t= <span class=\"keyword\">new</span> LinkedHashMap&lt;String, Entry&gt;(<span class=\"number\">0</span>, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</div></pre></td></tr></table></figure>\n<p>在LruCache中，由于数据是直接缓存中内存中，map中数据的建立是在使用LruCache缓存的过程中逐步建立的，而对于DiskLruCache，由于数据是缓存在本地文件，相当于是持久保存下来的一个文件，即使程序退出文件还在，因此，map中数据的建立，除了在使用DiskLruCache过程中建立外，map还应该包括之前已经存在的缓存文件，因此，在获取DiskLruCache的实例时，DiskLruCache会去读取journal这个日志文件，根据这个日志文件中的信息，建立map的初始数据，同时，会根据journal这个日志文件，维护本地的缓存文件。构造DiskLruCache的方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> DiskLruCache <span class=\"title\">open</span><span class=\"params\">(File directory, <span class=\"keyword\">int</span> appVersion, <span class=\"keyword\">int</span> valueCount, <span class=\"keyword\">long</span> maxSize)</span></span></div><div class=\"line\">    <span class=\"keyword\">throws</span> IOException &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (maxSize &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"maxSize &lt;= 0\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (valueCount &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"valueCount &lt;= 0\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// prefer to pick up where we left off</span></div><div class=\"line\">    DiskLruCache cache = <span class=\"keyword\">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</div><div class=\"line\">    <span class=\"keyword\">if</span> (cache.journalFile.exists()) &#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        cache.readJournal();</div><div class=\"line\">        cache.processJournal();</div><div class=\"line\">        cache.journalWriter = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> FileWriter(cache.journalFile, <span class=\"keyword\">true</span>),IO_BUFFER_SIZE);</div><div class=\"line\">                <span class=\"keyword\">return</span> cache;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException journalIsCorrupt) &#123;</div><div class=\"line\">            <span class=\"comment\">//                System.logW(\"DiskLruCache \" + directory + \" is corrupt: \"</span></div><div class=\"line\">            <span class=\"comment\">//                        + journalIsCorrupt.getMessage() + \", removing\");</span></div><div class=\"line\">            cache.delete();</div><div class=\"line\">        &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// create a new empty cache</span></div><div class=\"line\">    directory.mkdirs();</div><div class=\"line\">    cache = <span class=\"keyword\">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</div><div class=\"line\">    cache.rebuildJournal();</div><div class=\"line\">    <span class=\"keyword\">return</span> cache;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，<br>cache.readJournal();<br>cache.processJournal();<br>正是去读取journal日志文件，建立起map中的初始数据，同时维护缓存文件。</p>\n<h5 id=\"2-journal日志文件\"><a href=\"#2-journal日志文件\" class=\"headerlink\" title=\"2.journal日志文件\"></a>2.journal日志文件</h5><p>journal日志文件到底保存了什么信息呢，一个标准的journal日志文件信息如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">libcore.io.DiskLruCache    //第一行，固定内容，声明</div><div class=\"line\">1                                        //第二行，cache的版本号，恒为1</div><div class=\"line\">1                                        //第三行，APP的版本号</div><div class=\"line\">2                                        //第四行，一个key，可以存放多少条数据valueCount    </div><div class=\"line\">                                           //第五行，空行分割行</div><div class=\"line\">DIRTY 335c4c6028171cfddfbaae1a9c313c52</div><div class=\"line\">CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934</div><div class=\"line\">REMOVE 335c4c6028171cfddfbaae1a9c313c52</div><div class=\"line\">DIRTY 1ab96a171faeeee38496d8b330771a7a</div><div class=\"line\">CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234</div><div class=\"line\">READ 335c4c6028171cfddfbaae1a9c313c52</div><div class=\"line\">READ 3400330d1dfc7f3f7f4b8d4d803dfcf6</div></pre></td></tr></table></figure>\n<p>前五行称为journal日志文件的头，下面部分的每一行会以四种前缀之一开始：DIRTY、CLEAN、REMOVE、READ。</p>\n<p>以一个DIRTY前缀开始的，后面紧跟着缓存图片的key。以DIRTY这个这个前缀开头，意味着这是一条脏数据。每当我们调用一次DiskLruCache的edit()方法时，都会向journal文件中写入一条DIRTY记录，表示我们正准备写入一条缓存数据，但不知结果如何。然后调用commit()方法表示写入缓存成功，这时会向journal中写入一条CLEAN记录，意味着这条“脏”数据被“洗干净了”，调用abort()方法表示写入缓存失败，这时会向journal中写入一条REMOVE记录。也就是说，每一行DIRTY的key，后面都应该有一行对应的CLEAN或者REMOVE的记录，否则这条数据就是“脏”的，会被自动删除掉。</p>\n<p>在CLEAN前缀和key后面还有一个数值，代表的是该条缓存数据的大小。</p>\n<h5 id=\"3-DiskLruCache中的工作流程\"><a href=\"#3-DiskLruCache中的工作流程\" class=\"headerlink\" title=\"3.DiskLruCache中的工作流程\"></a>3.DiskLruCache中的工作流程</h5><p><strong>1.</strong>初始化：通过open()方法，获取DiskLruCache的实例，在open方法中通过readJournal(); 方法读取journal日志文件，根据journal日志文件信息建立map中的初始数据；然后再调用processJournal();方法对刚刚建立起的map数据进行分析，分析的工作，一个是计算当前有效缓存文件（即被CLEAN的）的大小，一个是清理无用缓存文件；</p>\n<p><strong>2.</strong>数据缓存与获取缓存：上面的初始化工作完成后，我们就可以在程序中进行数据的缓存功能和获取缓存的功能了；缓存数据的操作是借助DiskLruCache.Editor这个类完成的，这个类也是不能new的，需要调用DiskLruCache的edit()方法来获取实例，如：public Editor edit(String key) throws IOException。在写入完成后，需要进行commit()。</p>\n<p>如下一个简单示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;    </div><div class=\"line\">    <span class=\"meta\">@Override</span>    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;    </div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;    </div><div class=\"line\">            String imageUrl = <span class=\"string\">\"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg\"</span>;    </div><div class=\"line\">            String key = hashKeyForDisk(imageUrl);  <span class=\"comment\">//MD5对url进行加密，这个主要是为了获得统一的16位字符  </span></div><div class=\"line\">            DiskLruCache.Editor editor = mDiskLruCache.edit(key);  <span class=\"comment\">//拿到Editor，往journal日志中写入DIRTY记录  </span></div><div class=\"line\">            <span class=\"keyword\">if</span> (editor != <span class=\"keyword\">null</span>) &#123;    </div><div class=\"line\">                OutputStream outputStream = editor.newOutputStream(<span class=\"number\">0</span>);    </div><div class=\"line\">                <span class=\"keyword\">if</span> (downloadUrlToStream(imageUrl, outputStream)) &#123;  <span class=\"comment\">//downloadUrlToStream方法为下载图片的方法，并且将输出流放到outputStream  </span></div><div class=\"line\">                    editor.commit();  <span class=\"comment\">//完成后记得commit()，成功后，再往journal日志中写入CLEAN记录  </span></div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;    </div><div class=\"line\">                    editor.abort();  <span class=\"comment\">//失败后，要remove缓存文件，往journal文件中写入REMOVE记录  </span></div><div class=\"line\">                &#125;    </div><div class=\"line\">            &#125;    </div><div class=\"line\">            mDiskLruCache.flush();  <span class=\"comment\">//将缓存操作同步到journal日志文件，不一定要在这里就调用  </span></div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;    </div><div class=\"line\">            e.printStackTrace();    </div><div class=\"line\">        &#125;    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;).start();</div></pre></td></tr></table></figure>\n<p><strong>注意</strong>每次调用edit()时，会向journal日志文件写入DIRTY为前缀的一条记录；文件保存成功后，调用commit()时，也会向journal日志中写入一条CLEAN为前缀的一条记录，如果失败，需要调用abort()，abort()里面会向journal文件写入一条REMOVE为前缀的记录。</p>\n<p>获取缓存数据是通过get()方法实现的，如下一个简单示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span> &#123;    </div><div class=\"line\">    String imageUrl = <span class=\"string\">\"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg\"</span>;    </div><div class=\"line\">    String key = hashKeyForDisk(imageUrl);  <span class=\"comment\">//MD5对url进行加密，这个主要是为了获得统一的16位字符  </span></div><div class=\"line\">     <span class=\"comment\">//通过get拿到value的Snapshot，里面封装了输入流、key等信息，调用get会向journal文件写入READ为前缀的记录  </span></div><div class=\"line\">    DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key);   </div><div class=\"line\">    <span class=\"keyword\">if</span> (snapShot != <span class=\"keyword\">null</span>) &#123;    </div><div class=\"line\">        InputStream is = snapShot.getInputStream(<span class=\"number\">0</span>);    </div><div class=\"line\">        Bitmap bitmap = BitmapFactory.decodeStream(is);    </div><div class=\"line\">        mImage.setImageBitmap(bitmap);    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;    </div><div class=\"line\">    e.printStackTrace();    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>3.</strong>合适的地方进行flush()</p>\n<p>在上面进行数据缓存或获取缓存的时候，调用不同的方法会往journal中写入不同前缀的一行记录，记录写入是通过IO下的Writer写入的，要真正生效，还需要调用writer的flush()方法，而DiskLruCache中的flush()方法中封装了writer.flush()的操作，因此，我们只需要在合适地方调用DiskLruCache中的flush()方法即可。其作用也就是将操作记录同步到journal文件中，这是一个消耗效率的IO操作，我们不用每次一往journal中写数据后就调用flush，这样对效率影响较大，可以在Activity的onPause()中调用一下即可。</p>\n<h5 id=\"4-DiskLruCache总结\"><a href=\"#4-DiskLruCache总结\" class=\"headerlink\" title=\"4.DiskLruCache总结\"></a>4.DiskLruCache总结</h5><ul>\n<li>我们可以在在UI线程中检测内存缓存，即主线程中可以直接使用LruCache；</li>\n<li>使用DiskLruCache时，由于缓存或获取都需要对本地文件进行操作，因此需要另开一个线程，在子线程中检测磁盘缓存、保存缓存数据，磁盘操作从来不应该在UI线程中实现；</li>\n<li>LruCache内存缓存的核心是LinkedHashMap，而DiskLruCache的核心是LinkedHashMap和journal日志文件，相当于把journal看作是一块“内存”，LinkedHashMap的value只保存文件的简要信息，对缓存文件的所有操作都会记录在journal日志文件中。</li>\n</ul>\n<h5 id=\"5-DiskLruCache优化\"><a href=\"#5-DiskLruCache优化\" class=\"headerlink\" title=\"5.DiskLruCache优化\"></a>5.DiskLruCache优化</h5><p>DiskLruCache是基于日志文件journal的，这就决定了每次对缓存文件的操作都需要进行日志文件的记录，我们可以不用journal文件，在第一次构造DiskLruCache的时候，直接从程序访问缓存目录下的缓存文件，并将每个缓存文件的访问时间作为初始值记录在map的value中，每次访问或保存缓存都更新相应key对应的缓存文件的访问时间，这样就避免了频繁的IO操作，这种情况下就需要使用单例模式对DiskLruCache进行构造了，下面要说的Acache轻量级的数据缓存类就是这种实现方式。</p>\n<h3 id=\"四-一个轻量级缓存框架——ACache\"><a href=\"#四-一个轻量级缓存框架——ACache\" class=\"headerlink\" title=\"四 一个轻量级缓存框架——ACache\"></a>四 一个轻量级缓存框架——ACache</h3><p>ACache是一个轻量级的开源cache框架，实际上就是一个叫ACache的java类。已经在商业项目中使用，运行效果不错。</p>\n<p>ACache类似于SharedPreferences，但是比SharedPreferences功能更加强大，SharedPreferences只能保存一些基本数据类型、Serializable、Bundle等数据。而Acache可以缓存如下数据：普通的字符串、JsonObject、JsonArray、Bitmap、Drawable、序列化的java对象，和 byte数据。</p>\n<p>主要特色：</p>\n<ul>\n<li>轻，轻到只有一个JAVA文件。</li>\n<li>可配置，可以配置缓存路径，缓存大小，缓存数量等。</li>\n<li>可以设置缓存超时时间，缓存超时自动失效，并被删除。</li>\n<li>支持多进程</li>\n</ul>\n<p>应用场景：</p>\n<ul>\n<li>替换SharePreference当做配置文件</li>\n<li>可以缓存网络请求数据，比如oschina的android客户端可以缓存http请求的新闻内容，缓存时间假设为1个小时，超时后自动失效，让客户端重新请求新的数据，减少客户端流量，同时减少服务器并发量。</li>\n</ul>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewsListActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> List&lt;News&gt; list;</div><div class=\"line\">  <span class=\"keyword\">private</span> ListView listView;</div><div class=\"line\">  <span class=\"keyword\">private</span> LoadImageAdapter adapter;<span class=\"comment\">//适配器</span></div><div class=\"line\">  <span class=\"keyword\">private</span> ACache acache;<span class=\"comment\">//缓存框架</span></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">    <span class=\"keyword\">super</span>.setContentView(R.layout.load_img_listview_activity);</div><div class=\"line\">    acache=ACache.get(<span class=\"keyword\">this</span>);<span class=\"comment\">//创建ACache组件</span></div><div class=\"line\">    initView();<span class=\"comment\">//初始化界面，代码不贴了</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadData</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">   String cacheData=acache.getAsString(<span class=\"string\">\"newsList\"</span>);<span class=\"comment\">//从缓存中取数据</span></div><div class=\"line\">   <span class=\"keyword\">if</span>(cacheData!=<span class=\"keyword\">null</span>)&#123;<span class=\"comment\">//如果缓存中有，就不访问网络</span></div><div class=\"line\">   List&lt;News&gt; newsList=gson.fromJson(cacheData, <span class=\"keyword\">new</span> TypeToken&lt;List&lt;News&gt;&gt;()&#123;&#125;.getType());<span class=\"comment\">//将json转为List</span></div><div class=\"line\">      list.addAll(newsList);</div><div class=\"line\">      adapter.notifyDataSetChanged();</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">       SystemClock.sleep(<span class=\"number\">2000</span>);<span class=\"comment\">//模拟网络耗时</span></div><div class=\"line\">       String json=request();<span class=\"comment\">//模拟从网络中获取json数据</span></div><div class=\"line\">       acache.put(<span class=\"string\">\"newslist\"</span>, json, <span class=\"number\">60</span>*<span class=\"number\">60</span>*<span class=\"number\">1</span>);<span class=\"comment\">//将数据存入缓存中，有效时间设置为1小时</span></div><div class=\"line\">       List&lt;News&gt; newsList=gson.fromJson(json, <span class=\"keyword\">new</span> TypeToken&lt;List&lt;News&gt;&gt;()&#123;&#125;.getType());</div><div class=\"line\">       list.addAll(newsList);</div><div class=\"line\">       handler.sendEmptyMessage(<span class=\"number\">1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">         </div><div class=\"line\">  &#125;).start();</div><div class=\"line\">&#125;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 模拟网络请求方法</div><div class=\"line\">     * <span class=\"doctag\">@return</span> json数据</div><div class=\"line\">     */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">request</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">   News news=<span class=\"keyword\">null</span>;</div><div class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</div><div class=\"line\">       news=<span class=\"keyword\">new</span> News();</div><div class=\"line\">       news.setId(i);</div><div class=\"line\">       news.setImgUrl(<span class=\"string\">\"course/img/face_\"</span>+i+<span class=\"string\">\".png\"</span>);</div><div class=\"line\">       news.setTitle(<span class=\"string\">\"新闻标题\"</span>+i);</div><div class=\"line\">       news.setSummary(<span class=\"string\">\"测试\"</span>+i);</div><div class=\"line\">       list.add(news);</div><div class=\"line\">   &#125;</div><div class=\"line\">   Gson gson=<span class=\"keyword\">new</span> Gson();</div><div class=\"line\">   <span class=\"keyword\">return</span> gson.toJson(list);    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> Handler handler=<span class=\"keyword\">new</span> Handler()</div><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">       <span class=\"keyword\">switch</span>(msg.what)&#123;</div><div class=\"line\">           <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</div><div class=\"line\">             notify_layout.setVisibility(View.GONE);</div><div class=\"line\">             adapter.notifyDataSetChanged();</div><div class=\"line\">           <span class=\"keyword\">break</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>移动开发本质上就是手机和服务器之间进行通信，需要从服务端获取数据。反复通过网络获取数据是比较耗时的，特别是访问比较多的时候，会极大影响了性能，Android中可通过缓存机制来减少频繁的网络操作，减少流量、提升性能。android中缓存分为一级缓存，二级缓存和图片的三级缓存(就是网络)。</p>\n<p>Android缓存分为内存缓存（一级缓存）和文件缓存（二级缓存）。在早期，各大图片缓存框架流行之前，常用的内存缓存方式是软引用（SoftReference）和弱引用（WeakReference），如大部分的使用方式：HashMap<String url, SoftReference<Drawable>&gt; imageCache;这种形式。从Android 2.3（Level 9）开始，垃圾回收器更倾向于回收SoftReference或WeakReference对象，这使得SoftReference和WeakReference变得不是那么实用有效。同时，到了Android 3.0（Level 11）之后，图片数据Bitmap被放置到了内存的堆区域，而堆区域的内存是由GC管理的，开发者也就不需要进行图片资源的释放工作，但这也使得图片数据的释放无法预知，增加了造成OOM的可能。因此，在Android3.1以后，Android推出了LruCache这个内存缓存类和DiskLruCache这个磁盘缓存类。</p>\n<p>当Android端需要获得数据时比如获取网络中的图片，我们首先从内存中查找（按键查找），内存中没有的再从磁盘文件或sqlite中去查找，若磁盘中也没有才通过网络获取（图片的3级缓存策略）；当获得来自网络的数据，就以key-value对的方式先缓存到内存（一级缓存），同时缓存到文件或sqlite中（二级缓存）。注意：内存缓存会造成堆内存泄露，所有一级缓存通常要严格控制缓存的大小，一般控制在系统内存的1/4。</p>\n<h3 id=\"二-内存缓存（一级缓存）\"><a href=\"#二-内存缓存（一级缓存）\" class=\"headerlink\" title=\"二 内存缓存（一级缓存）\"></a>二 内存缓存（一级缓存）</h3><p>android中使用LruCache做内存缓存。在介绍这个类之前先了解一下LRU算法。</p>\n<h5 id=\"1-LRU算法\"><a href=\"#1-LRU算法\" class=\"headerlink\" title=\"1.LRU算法\"></a>1.LRU算法</h5><p>LRU，全称Least Rencetly Used，即最近最少使用，是一种非常常用的置换算法，也即淘汰最长时间未使用的对象。LRU在操作系统中的页面置换算法中广泛使用，我们的内存或缓存空间是有限的，当新加入一个对象时，造成我们的缓存空间不足了，此时就需要根据某种算法对缓存中原有数据进行淘汰货删除，而LRU选择的是将最长时间未使用的对象进行淘汰。</p>\n<h5 id=\"2-LruCache实现原理\"><a href=\"#2-LruCache实现原理\" class=\"headerlink\" title=\"2.LruCache实现原理\"></a>2.LruCache实现原理</h5><p>根据LRU算法的思想，要实现LRU最核心的是要有一种数据结构能够基于访问顺序来保存缓存中的对象，这样我们就能够很方便的知道哪个对象是最近访问的，哪个对象是最长时间未访问的。LruCache选择的是LinkedHashMap这个数据结构，LinkedHashMap是一个双向循环链表，在构造LinkedHashMap时，通过一个boolean值来指定LinkedHashMap中保存数据的方式，LinkedHashMap的一个构造方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* </div><div class=\"line\">     * 初始化LinkedHashMap </div><div class=\"line\">     * 第一个参数：initialCapacity，初始大小 </div><div class=\"line\">     * 第二个参数：loadFactor，负载因子=0.75f </div><div class=\"line\">     * 第三个参数：accessOrder=true，基于访问顺序；accessOrder=false，基于插入顺序 </div><div class=\"line\">     */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">boolean</span> accessOrder)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">super</span>(initialCapacity, loadFactor);  </div><div class=\"line\">        init();  </div><div class=\"line\">        <span class=\"keyword\">this</span>.accessOrder = accessOrder;  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>显然，在LruCache中选择的是accessOrder = true；此时，当accessOrder 设置为 true时，每当我们更新（即调用put方法）或访问（即调用get方法）map中的结点时，LinkedHashMap内部都会将这个结点移动到链表的尾部，因此，在链表的尾部是最近刚刚使用的结点，在链表的头部是是最近最少使用的结点，当我们的缓存空间不足时，就应该持续把链表头部结点移除掉，直到有剩余空间放置新结点。<br>可以看到，LinkedHashMap完成了LruCache中的核心功能，那LruCache中剩下要做的就是定义缓存空间总容量，当前保存数据已使用的容量，对外提供put、get方法。</p>\n<h5 id=\"3-LruCache源码分析\"><a href=\"#3-LruCache源码分析\" class=\"headerlink\" title=\"3.LruCache源码分析\"></a>3.LruCache源码分析</h5><p>在了解了LruCache的核心原理之后，就可以开始分析LruCache的源码了。</p>\n<p>####### 3.1关键字段</p>\n<p>根据上面的分析，首先要有总容量、已使用容量、linkedHashMap这几个关键字段，LruCache中提供了下面三个关键字段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//核心数据结构  </span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LinkedHashMap&lt;K, V&gt; map;  </div><div class=\"line\">    <span class=\"comment\">// 当前缓存数据所占的大小  </span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;  </div><div class=\"line\">    <span class=\"comment\">//缓存空间总容量  </span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxSize;</div></pre></td></tr></table></figure>\n<p>要注意的是size字段，因为map中可以存放各种类型的数据，这些数据的大小测量方式也是不一样的，比如Bitmap类型的数据和String类型的数据计算他们的大小方式肯定不同，因此，LruCache中在计算放入数据大小的方法sizeOf中，只是简单的返回了1，需要我们重写这个方法，自己去定义数据的测量方式。因此，我们在使用LruCache的时候，经常会看到这种方式： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CACHE_SIZE = <span class=\"number\">4</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;<span class=\"comment\">//4Mib  </span></div><div class=\"line\">    LruCache&lt;String,Bitmap&gt; bitmapCache = <span class=\"keyword\">new</span> LruCache&lt;String,Bitmap&gt;(CACHE_SIZE)&#123;  </div><div class=\"line\">        <span class=\"meta\">@Override</span>  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(String key, Bitmap value)</span> </span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">return</span> value.getByteCount();<span class=\"comment\">//自定义Bitmap数据大小的计算方式  </span></div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<p>####### 3.2 构造方法  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LruCache</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (maxSize &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"maxSize &lt;= 0\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.maxSize = maxSize;</div><div class=\"line\">    <span class=\"keyword\">this</span>.map = <span class=\"keyword\">new</span> LinkedHashMap&lt;K, V&gt;(<span class=\"number\">0</span>, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>LruCache只有一个唯一的构造方法，在构造方法中，给定了缓存空间的总大小，初始化了LinkedHashMap核心数据结构，在LinkedHashMap中的第三个参数指定为true，也就设置了accessOrder=true，表示这个LinkedHashMap将是基于数据的访问顺序进行排序。</p>\n<p>####### 3.3 sizeOf()和safeSizeOf()方法测量数据类型大小</p>\n<p>根据上面的解释，由于各种数据类型大小测量的标准不统一，具体测量的方法应该由使用者来实现，如上面给出的一个在实现LruCache时重写sizeOf的一种常用实现方式。通过多态的性质，再具体调用sizeOf时会调用我们重写的方法进行测量，LruCache对sizeOf()的调用进行一层封装，如下： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">safeSizeOf</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> result = sizeOf(key, value);</div><div class=\"line\">    <span class=\"keyword\">if</span> (result &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Negative size: \"</span> + key + <span class=\"string\">\"=\"</span> + value);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>里面其实就是调用sizeOf()方法，返回sizeOf计算的大小。<br>上面就是LruCache的基本内容，下面就需要提供LruCache的核心功能了。</p>\n<p>####### 3.4 put方法缓存数据   </p>\n<p>首先看一下它的源码实现：    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">   * 给对应key缓存value，并且将该value移动到链表的尾部。</div><div class=\"line\">   */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null || value == null\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">      V previous;</div><div class=\"line\">      <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// 记录 put 的次数</span></div><div class=\"line\">        putCount++;</div><div class=\"line\">        <span class=\"comment\">// 通过键值对，计算出要保存对象value的大小，并更新当前缓存大小</span></div><div class=\"line\">        size += safeSizeOf(key, value);</div><div class=\"line\">        <span class=\"comment\">/*</div><div class=\"line\">         * 如果 之前存在key，用新的value覆盖原来的数据， 并返回 之前key 的value</div><div class=\"line\">         * 记录在 previous</div><div class=\"line\">         */</span></div><div class=\"line\">        previous = map.put(key, value);</div><div class=\"line\">        <span class=\"comment\">// 如果之前存在key，并且之前的value不为null</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// 计算出 之前value的大小，因为前面size已经加上了新的value数据的大小，此时，需要再次更新size，减去原来value的大小</span></div><div class=\"line\">            size -= safeSizeOf(key, previous);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 如果之前存在key，并且之前的value不为null</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">/*</div><div class=\"line\">         * previous值被剔除了，此次添加的 value 已经作为key的 新值</div><div class=\"line\">         * 告诉 自定义 的 entryRemoved 方法</div><div class=\"line\">         */</span></div><div class=\"line\">        entryRemoved(<span class=\"keyword\">false</span>, key, previous, value);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//裁剪缓存容量（在当前缓存数据大小超过了总容量maxSize时，才会真正去执行LRU）</span></div><div class=\"line\">    trimToSize(maxSize);</div><div class=\"line\">      <span class=\"keyword\">return</span> previous;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，put()方法主要有以下几步：<br>1）key和value判空，说明LruCache中不允许key和value为null；<br>2）通过safeSizeOf()获取要加入对象数据的大小，并更新当前缓存数据的大小；<br>3）将新的对象数据放入到缓存中，即调用LinkedHashMap的put方法，如果原来存在该key时，直接替换掉原来的value值，并返回之前的value值，得到之前value的大小，更新当前缓存数据的size大小；如果原来不存在该key，则直接加入缓存即可；<br>4）清理缓存空间</p>\n<p>####### 3.5 trimToSize()清理缓存空间<br>当我们加入一个数据时（put），为了保证当前数据的缓存所占大小没有超过我们指定的总大小，通过调用trimToSize()来对缓存空间进行管理控制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/*</div><div class=\"line\">     * 循环进行LRU，直到当前所占容量大小没有超过指定的总容量大小</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">        K key;</div><div class=\"line\">        V value;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// 一些异常情况的处理</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">0</span> || (map.isEmpty() &amp;&amp; size != <span class=\"number\">0</span>)) &#123;</div><div class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</div><div class=\"line\">                        getClass().getName() + <span class=\"string\">\".sizeOf() is reporting inconsistent results!\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">// 首先判断当前缓存数据大小是否超过了指定的缓存空间总大小。如果没有超过，即缓存中还可以存入数据，直接跳出循环，清理完毕</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">/**</div><div class=\"line\">             * 执行到这，表示当前缓存数据已超过了总容量，需要执行LRU，即将最近最少使用的数据清除掉，直到数据所占缓存空间没有超标;</div><div class=\"line\">             * 根据前面的原理分析，知道，在链表中，链表的头结点是最近最少使用的数据，因此，最先清除掉链表前面的结点</div><div class=\"line\">             */</span></div><div class=\"line\">            Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</div><div class=\"line\">            key = toEvict.getKey();</div><div class=\"line\">            value = toEvict.getValue();</div><div class=\"line\">            map.remove(key);</div><div class=\"line\">            <span class=\"comment\">// 移除掉后，更新当前数据缓存的大小</span></div><div class=\"line\">            size -= safeSizeOf(key, value);</div><div class=\"line\">            <span class=\"comment\">// 更新移除的结点数量</span></div><div class=\"line\">            evictionCount++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">/*</div><div class=\"line\">         * 通知某个结点被移除，类似于回调</div><div class=\"line\">         */</span></div><div class=\"line\">        entryRemoved(<span class=\"keyword\">true</span>, key, value, <span class=\"keyword\">null</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>trimToSize()方法的作用就是为了保证当前数据的缓存大小不能超过我们指定的缓存总大小，如果超过了，就会开始移除最近最少使用的数据，直到size符合要求。trimToSize()方法在put()的时候一定会调用，在get()的时候有可能会调用。</p>\n<p>####### 3.6 get方法获取缓存数据   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 根据key查询缓存，如果该key对应的value存在于缓存，直接返回value；</div><div class=\"line\">* 访问到这个结点时，LinkHashMap会将它移动到双向循环链表的的尾部。</div><div class=\"line\">* 如果如果没有缓存的值，则返回null。（如果开发者重写了create()的话，返回创建的value）</div><div class=\"line\">*/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">get</span><span class=\"params\">(K key)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    V mapValue;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// LinkHashMap 如果设置按照访问顺序的话，这里每次get都会重整数据顺序</span></div><div class=\"line\">        mapValue = map.get(key);</div><div class=\"line\">        <span class=\"comment\">// 计算 命中次数</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            hitCount++;</div><div class=\"line\">            <span class=\"keyword\">return</span> mapValue;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 计算 丢失次数</span></div><div class=\"line\">        missCount++;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/*</div><div class=\"line\">     * 官方解释：</div><div class=\"line\">     * 尝试创建一个值，这可能需要很长时间，并且Map可能在create()返回的值时有所不同。如果在create()执行的时</div><div class=\"line\">     * 候，用这个key执行了put方法，那么此时就发生了冲突，我们在Map中删除这个创建的值，释放被创建的值，保留put进去的值。</div><div class=\"line\">     */</span></div><div class=\"line\">    V createdValue = create(key);</div><div class=\"line\">    <span class=\"keyword\">if</span> (createdValue == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/***************************</div><div class=\"line\">     * 不覆写create方法走不到下面 *</div><div class=\"line\">     ***************************/</span></div><div class=\"line\">    <span class=\"comment\">/*</div><div class=\"line\">     * 正常情况走不到这里</div><div class=\"line\">     * 走到这里的话 说明 实现了自定义的 create(K key) 逻辑</div><div class=\"line\">     * 因为默认的 create(K key) 逻辑为null</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// 记录 create 的次数</span></div><div class=\"line\">        createCount++;</div><div class=\"line\">        <span class=\"comment\">// 将自定义create创建的值，放入LinkedHashMap中，如果key已经存在，会返回 之前相同key 的值</span></div><div class=\"line\">        mapValue = map.put(key, createdValue);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 如果之前存在相同key的value，即有冲突。</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">/*</div><div class=\"line\">             * 有冲突</div><div class=\"line\">             * 所以 撤销 刚才的 操作</div><div class=\"line\">             * 将 之前相同key 的值 重新放回去</div><div class=\"line\">             */</span></div><div class=\"line\">            map.put(key, mapValue);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// 拿到键值对，计算出在容量中的相对长度，然后加上</span></div><div class=\"line\">            size += safeSizeOf(key, createdValue);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 如果上面 判断出了 将要放入的值发生冲突</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">/*</div><div class=\"line\">         * 刚才create的值被删除了，原来的 之前相同key 的值被重新添加回去了</div><div class=\"line\">         * 告诉 自定义 的 entryRemoved 方法</div><div class=\"line\">         */</span></div><div class=\"line\">        entryRemoved(<span class=\"keyword\">false</span>, key, createdValue, mapValue);</div><div class=\"line\">        <span class=\"keyword\">return</span> mapValue;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// 上面 进行了 size += 操作 所以这里要重整长度</span></div><div class=\"line\">        trimToSize(maxSize);</div><div class=\"line\">        <span class=\"keyword\">return</span> createdValue;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>get()方法的思路就是：<br>   1）先尝试从map缓存中获取value，即mapVaule = map.get(key);如果mapVaule != null，说明缓存中存在该对象，直接返回即可；<br>   2）如果mapVaule == null，说明缓存中不存在该对象，大多数情况下会直接返回null；但是如果我们重写了create()方法，在缓存没有该数据的时候自己去创建一个，则会继续往下走，中间可能会出现冲突，看注释；<br>   3）注意：在我们通过LinkedHashMap进行get(key)或put(key,value)时都会对链表进行调整，即将刚刚访问get或加入put的结点放入到链表尾部。</p>\n<p>####### 3.7 entryRemoved()     </p>\n<p>entryRemoved的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 1.当被回收或者删掉时调用。该方法当value被回收释放存储空间时被remove调用</div><div class=\"line\">* 或者替换条目值时put调用，默认实现什么都没做。</div><div class=\"line\">* 2.该方法没用同步调用，如果其他线程访问缓存时，该方法也会执行。</div><div class=\"line\">* 3.evicted=true：如果该条目被删除空间 （表示 进行了trimToSize or remove）  evicted=false：put冲突后 或 get里成功create后</div><div class=\"line\">* 导致</div><div class=\"line\">* 4.newValue!=null，那么则被put()或get()调用。</div><div class=\"line\">*/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">entryRemoved</span><span class=\"params\">(<span class=\"keyword\">boolean</span> evicted, K key, V oldValue, V newValue)</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>entryRemoved方法是一个空方法，说明这个也是让开发者自己根据需求去重写的。entryRemoved()主要作用就是在结点数据value需要被删除或回收的时候，给开发者的回调。开发者就可以在这个方法里面实现一些自己的逻辑：<br>（1）可以进行资源的回收；<br>（2）可以实现二级内存缓存，可以进一步提高性能，<br>思路如下：重写LruCache的entryRemoved()函数，把删除掉的item，再次存入另外一个LinkedHashMap<String, SoftWeakReference<Bitmap>&gt;中，这个数据结构当做二级缓存，每次获得图片的时候，先判断LruCache中是否缓存，没有的话，再判断这个二级缓存中是否有，如果都没有再从sdcard上获取。sdcard上也没有的话，就从网络服务器上拉取。entryRemoved()在LruCache中有四个地方进行了调用：put()、get()、trimToSize()、remove()中进行了调用。</p>\n<p>####### 3.8 LruCache的线程安全性 </p>\n<p>LruCache是线程安全的，因为在put、get、trimToSize、remove的方法中都加入synchronized进行同步控制。</p>\n<h5 id=\"4-LruCache代码示例\"><a href=\"#4-LruCache代码示例\" class=\"headerlink\" title=\"4.LruCache代码示例\"></a>4.LruCache代码示例</h5><p>使用步骤：</p>\n<ul>\n<li>在构造LruCache时提供一个总的缓存大小；</li>\n<li>重写sizeOf方法，对存入map的数据大小进行自定义测量；</li>\n<li>根据需要，决定是否要重写entryRemoved()方法；</li>\n<li>使用LruCache提供的put和get方法进行数据的缓存</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> LruCache&lt;String, Bitmap&gt; mMemoryCache;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"comment\">// 获得虚拟机能提供的最大内存，超过这个大小会抛出OutOfMemory的异常</span></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxMemory = (<span class=\"keyword\">int</span>) (Runtime.getRuntime().maxMemory() / <span class=\"number\">1024</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 用１／８的内存大小作为内存缓存</span></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> cacheSize = maxMemory / <span class=\"number\">8</span>;</div><div class=\"line\"></div><div class=\"line\">    mMemoryCache = <span class=\"keyword\">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(String key, Bitmap bitmap)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// 这里返回的不是item的个数，是cache的size（单位1024个字节）</span></div><div class=\"line\">            <span class=\"keyword\">return</span> bitmap.getByteCount() / <span class=\"number\">1024</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addBitmapToMemoryCache</span><span class=\"params\">(String key, Bitmap bitmap)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (getBitmapFromMemCache(key) == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        mMemoryCache.put(key, bitmap);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Bitmap <span class=\"title\">getBitmapFromMemCache</span><span class=\"params\">(String key)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> mMemoryCache.get(key);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当为ImageView加载一张图片时，会先在LruCache 中看看有没有缓存这张图片，如果有的话直接更新到ImageView中，如果没有的话，一个后台线程会被触发来加载这张图片。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadBitmap</span><span class=\"params\">(<span class=\"keyword\">int</span> resId, ImageView imageView)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> String imageKey = String.valueOf(resId);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 查看下内存缓存中是否缓存了这张图片</span></div><div class=\"line\">    <span class=\"keyword\">final</span> Bitmap bitmap = getBitmapFromMemCache(imageKey);</div><div class=\"line\">    <span class=\"keyword\">if</span> (bitmap != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        mImageView.setImageBitmap(bitmap);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mImageView.setImageResource(R.drawable.image_placeholder);</div><div class=\"line\">BitmapWorkerTask task = <span class=\"keyword\">new</span> BitmapWorkerTask(mImageView);</div><div class=\"line\">        task.execute(resId);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在图片加载的Task中，需要把加载好的图片加入到内存缓存中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BitmapWorkerTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">AsyncTask</span>&lt;<span class=\"title\">Integer</span>, <span class=\"title\">Void</span>, <span class=\"title\">Bitmap</span>&gt; </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"comment\">// 在后台完成</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Bitmap <span class=\"title\">doInBackground</span><span class=\"params\">(Integer... params)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> Bitmap bitmap = decodeSampledBitmapFromResource(</div><div class=\"line\">                getResources(), params[<span class=\"number\">0</span>], <span class=\"number\">100</span>, <span class=\"number\">100</span>));</div><div class=\"line\">    addBitmapToMemoryCache(String.valueOf(params[<span class=\"number\">0</span>]), bitmap);</div><div class=\"line\">        <span class=\"keyword\">return</span> bitmap;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5.总结\"></a>5.总结</h5><ul>\n<li>LruCache 自身并没有释放内存，只是 LinkedHashMap中将数据移除了，如果数据还在别的地方被引用了，还是有泄漏问题，还需要手动释放内存；</li>\n<li>覆写 entryRemoved 方法能知道 LruCache 数据移除是是否发生了冲突（冲突是指在map.put()的时候，对应的key中是否存在原来的值），也可以去手动释放资源；</li>\n</ul>\n<h3 id=\"三-磁盘缓存（二级缓存）\"><a href=\"#三-磁盘缓存（二级缓存）\" class=\"headerlink\" title=\"三 磁盘缓存（二级缓存）\"></a>三 磁盘缓存（二级缓存）</h3><p>LruCache是一种内存缓存策略，但是当存在大量图片的时候，我们指定的缓存内存空间可能很快就会用完，这个时候，LruCache就会频繁的进行trimToSize()操作，不断的将最近最少使用的数据移除，当再次需要该数据时，又得从网络上重新加载，这样就有可能造成OOM。为此，Google提供了一种磁盘缓存的解决方案——DiskLruCache（DiskLruCache并没有集成到Android源码中，在Android Doc的例子中有讲解）。</p>\n<h5 id=\"1-DiskLruCache实现原理\"><a href=\"#1-DiskLruCache实现原理\" class=\"headerlink\" title=\"1. DiskLruCache实现原理\"></a>1. DiskLruCache实现原理</h5><p>我们可以先来直观看一下，使用了DiskLruCache缓存策略的APP，缓存目录中是什么样子，如下图：</p>\n\n<p>可以看到，缓存目录中有一堆文件名很长的文件，这些文件就是我们缓存的一张张图片数据，在最后有一个文件名journal的文件，这个journal文件是DiskLruCache的一个日志文件，即保存着每张缓存图片的操作记录，journal文件正是实现DiskLruCache的核心。看到出现了journal文件，基本可以说明这个APP使用了DiskLruCache缓存策略。</p>\n<p>根据对LruCache的分析，要实现LRU，最重要的是要有一种数据结构能够基于访问顺序来保存缓存中的对象，LinkedHashMap是一种非常合适的数据结构，为此，DiskLruCache也选择了LinkedHashMap作为维护访问顺序的数据结构，但是，对于DiskLruCache来说，单单LinkedHashMap是不够的，因为我们不能像LruCache一样，直接将数据放置到LinkedHashMap的value中，也就是处于内存当中，在DiskLruCache中，数据是缓存到了本地文件，这里的LinkedHashMap中的value只是保存的是value的一些简要信息Entry，如唯一的文件名称、大小、是否可读等信息，如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String key;</div><div class=\"line\">    <span class=\"comment\">/** Lengths of this entry's files. */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span>[] lengths;</div><div class=\"line\">    <span class=\"comment\">/** True if this entry has ever been published */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> readable;</div><div class=\"line\">    <span class=\"comment\">/** The ongoing edit or null if this entry is not being edited. */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> Editor currentEditor;</div><div class=\"line\">    <span class=\"comment\">/** The sequence number of the most recently committed edit to this entry. */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> sequenceNumber;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Entry</span><span class=\"params\">(String key)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.key = key;</div><div class=\"line\">        <span class=\"keyword\">this</span>.lengths = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[valueCount];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getLengths</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">        StringBuilder result = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">long</span> size : lengths) &#123;</div><div class=\"line\">            result.append(<span class=\"string\">' '</span>).append(size);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result.toString();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * Set lengths using decimal numbers like \"10123\".</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setLengths</span><span class=\"params\">(String[] strings)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (strings.length != valueCount) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> invalidLengths(strings);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strings.length; i++) &#123;</div><div class=\"line\">                lengths[i] = Long.parseLong(strings[i]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NumberFormatException e) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> invalidLengths(strings);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> IOException <span class=\"title\">invalidLengths</span><span class=\"params\">(String[] strings)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"unexpected journal line: \"</span> + Arrays.toString(strings));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> File <span class=\"title\">getCleanFile</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> File(directory, key + <span class=\"string\">\".\"</span> + i);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> File <span class=\"title\">getDirtyFile</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> File(directory, key + <span class=\"string\">\".\"</span> + i + <span class=\"string\">\".tmp\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>DiskLruCache中对于LinkedHashMap定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LinkedHashMap&lt;String, Entry&gt; lruEntries</div><div class=\"line\">\t= <span class=\"keyword\">new</span> LinkedHashMap&lt;String, Entry&gt;(<span class=\"number\">0</span>, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</div></pre></td></tr></table></figure>\n<p>在LruCache中，由于数据是直接缓存中内存中，map中数据的建立是在使用LruCache缓存的过程中逐步建立的，而对于DiskLruCache，由于数据是缓存在本地文件，相当于是持久保存下来的一个文件，即使程序退出文件还在，因此，map中数据的建立，除了在使用DiskLruCache过程中建立外，map还应该包括之前已经存在的缓存文件，因此，在获取DiskLruCache的实例时，DiskLruCache会去读取journal这个日志文件，根据这个日志文件中的信息，建立map的初始数据，同时，会根据journal这个日志文件，维护本地的缓存文件。构造DiskLruCache的方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> DiskLruCache <span class=\"title\">open</span><span class=\"params\">(File directory, <span class=\"keyword\">int</span> appVersion, <span class=\"keyword\">int</span> valueCount, <span class=\"keyword\">long</span> maxSize)</span></div><div class=\"line\">    <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (maxSize &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"maxSize &lt;= 0\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (valueCount &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"valueCount &lt;= 0\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// prefer to pick up where we left off</span></div><div class=\"line\">    DiskLruCache cache = <span class=\"keyword\">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</div><div class=\"line\">    <span class=\"keyword\">if</span> (cache.journalFile.exists()) &#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        cache.readJournal();</div><div class=\"line\">        cache.processJournal();</div><div class=\"line\">        cache.journalWriter = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> FileWriter(cache.journalFile, <span class=\"keyword\">true</span>),IO_BUFFER_SIZE);</div><div class=\"line\">                <span class=\"keyword\">return</span> cache;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException journalIsCorrupt) &#123;</div><div class=\"line\">            <span class=\"comment\">//                System.logW(\"DiskLruCache \" + directory + \" is corrupt: \"</span></div><div class=\"line\">            <span class=\"comment\">//                        + journalIsCorrupt.getMessage() + \", removing\");</span></div><div class=\"line\">            cache.delete();</div><div class=\"line\">        &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// create a new empty cache</span></div><div class=\"line\">    directory.mkdirs();</div><div class=\"line\">    cache = <span class=\"keyword\">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</div><div class=\"line\">    cache.rebuildJournal();</div><div class=\"line\">    <span class=\"keyword\">return</span> cache;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，<br>cache.readJournal();<br>cache.processJournal();<br>正是去读取journal日志文件，建立起map中的初始数据，同时维护缓存文件。</p>\n<h5 id=\"2-journal日志文件\"><a href=\"#2-journal日志文件\" class=\"headerlink\" title=\"2.journal日志文件\"></a>2.journal日志文件</h5><p>journal日志文件到底保存了什么信息呢，一个标准的journal日志文件信息如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">libcore.io.DiskLruCache    //第一行，固定内容，声明</div><div class=\"line\">1                                        //第二行，cache的版本号，恒为1</div><div class=\"line\">1                                        //第三行，APP的版本号</div><div class=\"line\">2                                        //第四行，一个key，可以存放多少条数据valueCount    </div><div class=\"line\">                                           //第五行，空行分割行</div><div class=\"line\">DIRTY 335c4c6028171cfddfbaae1a9c313c52</div><div class=\"line\">CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934</div><div class=\"line\">REMOVE 335c4c6028171cfddfbaae1a9c313c52</div><div class=\"line\">DIRTY 1ab96a171faeeee38496d8b330771a7a</div><div class=\"line\">CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234</div><div class=\"line\">READ 335c4c6028171cfddfbaae1a9c313c52</div><div class=\"line\">READ 3400330d1dfc7f3f7f4b8d4d803dfcf6</div></pre></td></tr></table></figure>\n<p>前五行称为journal日志文件的头，下面部分的每一行会以四种前缀之一开始：DIRTY、CLEAN、REMOVE、READ。</p>\n<p>以一个DIRTY前缀开始的，后面紧跟着缓存图片的key。以DIRTY这个这个前缀开头，意味着这是一条脏数据。每当我们调用一次DiskLruCache的edit()方法时，都会向journal文件中写入一条DIRTY记录，表示我们正准备写入一条缓存数据，但不知结果如何。然后调用commit()方法表示写入缓存成功，这时会向journal中写入一条CLEAN记录，意味着这条“脏”数据被“洗干净了”，调用abort()方法表示写入缓存失败，这时会向journal中写入一条REMOVE记录。也就是说，每一行DIRTY的key，后面都应该有一行对应的CLEAN或者REMOVE的记录，否则这条数据就是“脏”的，会被自动删除掉。</p>\n<p>在CLEAN前缀和key后面还有一个数值，代表的是该条缓存数据的大小。</p>\n<h5 id=\"3-DiskLruCache中的工作流程\"><a href=\"#3-DiskLruCache中的工作流程\" class=\"headerlink\" title=\"3.DiskLruCache中的工作流程\"></a>3.DiskLruCache中的工作流程</h5><p><strong>1.</strong>初始化：通过open()方法，获取DiskLruCache的实例，在open方法中通过readJournal(); 方法读取journal日志文件，根据journal日志文件信息建立map中的初始数据；然后再调用processJournal();方法对刚刚建立起的map数据进行分析，分析的工作，一个是计算当前有效缓存文件（即被CLEAN的）的大小，一个是清理无用缓存文件；</p>\n<p><strong>2.</strong>数据缓存与获取缓存：上面的初始化工作完成后，我们就可以在程序中进行数据的缓存功能和获取缓存的功能了；缓存数据的操作是借助DiskLruCache.Editor这个类完成的，这个类也是不能new的，需要调用DiskLruCache的edit()方法来获取实例，如：public Editor edit(String key) throws IOException。在写入完成后，需要进行commit()。</p>\n<p>如下一个简单示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;    </div><div class=\"line\">    <span class=\"meta\">@Override</span>    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;    </div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;    </div><div class=\"line\">            String imageUrl = <span class=\"string\">\"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg\"</span>;    </div><div class=\"line\">            String key = hashKeyForDisk(imageUrl);  <span class=\"comment\">//MD5对url进行加密，这个主要是为了获得统一的16位字符  </span></div><div class=\"line\">            DiskLruCache.Editor editor = mDiskLruCache.edit(key);  <span class=\"comment\">//拿到Editor，往journal日志中写入DIRTY记录  </span></div><div class=\"line\">            <span class=\"keyword\">if</span> (editor != <span class=\"keyword\">null</span>) &#123;    </div><div class=\"line\">                OutputStream outputStream = editor.newOutputStream(<span class=\"number\">0</span>);    </div><div class=\"line\">                <span class=\"keyword\">if</span> (downloadUrlToStream(imageUrl, outputStream)) &#123;  <span class=\"comment\">//downloadUrlToStream方法为下载图片的方法，并且将输出流放到outputStream  </span></div><div class=\"line\">                    editor.commit();  <span class=\"comment\">//完成后记得commit()，成功后，再往journal日志中写入CLEAN记录  </span></div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;    </div><div class=\"line\">                    editor.abort();  <span class=\"comment\">//失败后，要remove缓存文件，往journal文件中写入REMOVE记录  </span></div><div class=\"line\">                &#125;    </div><div class=\"line\">            &#125;    </div><div class=\"line\">            mDiskLruCache.flush();  <span class=\"comment\">//将缓存操作同步到journal日志文件，不一定要在这里就调用  </span></div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;    </div><div class=\"line\">            e.printStackTrace();    </div><div class=\"line\">        &#125;    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;).start();</div></pre></td></tr></table></figure>\n<p><strong>注意</strong>每次调用edit()时，会向journal日志文件写入DIRTY为前缀的一条记录；文件保存成功后，调用commit()时，也会向journal日志中写入一条CLEAN为前缀的一条记录，如果失败，需要调用abort()，abort()里面会向journal文件写入一条REMOVE为前缀的记录。</p>\n<p>获取缓存数据是通过get()方法实现的，如下一个简单示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span> &#123;    </div><div class=\"line\">    String imageUrl = <span class=\"string\">\"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg\"</span>;    </div><div class=\"line\">    String key = hashKeyForDisk(imageUrl);  <span class=\"comment\">//MD5对url进行加密，这个主要是为了获得统一的16位字符  </span></div><div class=\"line\">     <span class=\"comment\">//通过get拿到value的Snapshot，里面封装了输入流、key等信息，调用get会向journal文件写入READ为前缀的记录  </span></div><div class=\"line\">    DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key);   </div><div class=\"line\">    <span class=\"keyword\">if</span> (snapShot != <span class=\"keyword\">null</span>) &#123;    </div><div class=\"line\">        InputStream is = snapShot.getInputStream(<span class=\"number\">0</span>);    </div><div class=\"line\">        Bitmap bitmap = BitmapFactory.decodeStream(is);    </div><div class=\"line\">        mImage.setImageBitmap(bitmap);    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;    </div><div class=\"line\">    e.printStackTrace();    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>3.</strong>合适的地方进行flush()</p>\n<p>在上面进行数据缓存或获取缓存的时候，调用不同的方法会往journal中写入不同前缀的一行记录，记录写入是通过IO下的Writer写入的，要真正生效，还需要调用writer的flush()方法，而DiskLruCache中的flush()方法中封装了writer.flush()的操作，因此，我们只需要在合适地方调用DiskLruCache中的flush()方法即可。其作用也就是将操作记录同步到journal文件中，这是一个消耗效率的IO操作，我们不用每次一往journal中写数据后就调用flush，这样对效率影响较大，可以在Activity的onPause()中调用一下即可。</p>\n<h5 id=\"4-DiskLruCache总结\"><a href=\"#4-DiskLruCache总结\" class=\"headerlink\" title=\"4.DiskLruCache总结\"></a>4.DiskLruCache总结</h5><ul>\n<li>我们可以在在UI线程中检测内存缓存，即主线程中可以直接使用LruCache；</li>\n<li>使用DiskLruCache时，由于缓存或获取都需要对本地文件进行操作，因此需要另开一个线程，在子线程中检测磁盘缓存、保存缓存数据，磁盘操作从来不应该在UI线程中实现；</li>\n<li>LruCache内存缓存的核心是LinkedHashMap，而DiskLruCache的核心是LinkedHashMap和journal日志文件，相当于把journal看作是一块“内存”，LinkedHashMap的value只保存文件的简要信息，对缓存文件的所有操作都会记录在journal日志文件中。</li>\n</ul>\n<h5 id=\"5-DiskLruCache优化\"><a href=\"#5-DiskLruCache优化\" class=\"headerlink\" title=\"5.DiskLruCache优化\"></a>5.DiskLruCache优化</h5><p>DiskLruCache是基于日志文件journal的，这就决定了每次对缓存文件的操作都需要进行日志文件的记录，我们可以不用journal文件，在第一次构造DiskLruCache的时候，直接从程序访问缓存目录下的缓存文件，并将每个缓存文件的访问时间作为初始值记录在map的value中，每次访问或保存缓存都更新相应key对应的缓存文件的访问时间，这样就避免了频繁的IO操作，这种情况下就需要使用单例模式对DiskLruCache进行构造了，下面要说的Acache轻量级的数据缓存类就是这种实现方式。</p>\n<h3 id=\"四-一个轻量级缓存框架——ACache\"><a href=\"#四-一个轻量级缓存框架——ACache\" class=\"headerlink\" title=\"四 一个轻量级缓存框架——ACache\"></a>四 一个轻量级缓存框架——ACache</h3><p>ACache是一个轻量级的开源cache框架，实际上就是一个叫ACache的java类。已经在商业项目中使用，运行效果不错。</p>\n<p>ACache类似于SharedPreferences，但是比SharedPreferences功能更加强大，SharedPreferences只能保存一些基本数据类型、Serializable、Bundle等数据。而Acache可以缓存如下数据：普通的字符串、JsonObject、JsonArray、Bitmap、Drawable、序列化的java对象，和 byte数据。</p>\n<p>主要特色：</p>\n<ul>\n<li>轻，轻到只有一个JAVA文件。</li>\n<li>可配置，可以配置缓存路径，缓存大小，缓存数量等。</li>\n<li>可以设置缓存超时时间，缓存超时自动失效，并被删除。</li>\n<li>支持多进程</li>\n</ul>\n<p>应用场景：</p>\n<ul>\n<li>替换SharePreference当做配置文件</li>\n<li>可以缓存网络请求数据，比如oschina的android客户端可以缓存http请求的新闻内容，缓存时间假设为1个小时，超时后自动失效，让客户端重新请求新的数据，减少客户端流量，同时减少服务器并发量。</li>\n</ul>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewsListActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> List&lt;News&gt; list;</div><div class=\"line\">  <span class=\"keyword\">private</span> ListView listView;</div><div class=\"line\">  <span class=\"keyword\">private</span> LoadImageAdapter adapter;<span class=\"comment\">//适配器</span></div><div class=\"line\">  <span class=\"keyword\">private</span> ACache acache;<span class=\"comment\">//缓存框架</span></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">    <span class=\"keyword\">super</span>.setContentView(R.layout.load_img_listview_activity);</div><div class=\"line\">    acache=ACache.get(<span class=\"keyword\">this</span>);<span class=\"comment\">//创建ACache组件</span></div><div class=\"line\">    initView();<span class=\"comment\">//初始化界面，代码不贴了</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadData</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">   String cacheData=acache.getAsString(<span class=\"string\">\"newsList\"</span>);<span class=\"comment\">//从缓存中取数据</span></div><div class=\"line\">   <span class=\"keyword\">if</span>(cacheData!=<span class=\"keyword\">null</span>)&#123;<span class=\"comment\">//如果缓存中有，就不访问网络</span></div><div class=\"line\">   List&lt;News&gt; newsList=gson.fromJson(cacheData, <span class=\"keyword\">new</span> TypeToken&lt;List&lt;News&gt;&gt;()&#123;&#125;.getType());<span class=\"comment\">//将json转为List</span></div><div class=\"line\">      list.addAll(newsList);</div><div class=\"line\">      adapter.notifyDataSetChanged();</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">       SystemClock.sleep(<span class=\"number\">2000</span>);<span class=\"comment\">//模拟网络耗时</span></div><div class=\"line\">       String json=request();<span class=\"comment\">//模拟从网络中获取json数据</span></div><div class=\"line\">       acache.put(<span class=\"string\">\"newslist\"</span>, json, <span class=\"number\">60</span>*<span class=\"number\">60</span>*<span class=\"number\">1</span>);<span class=\"comment\">//将数据存入缓存中，有效时间设置为1小时</span></div><div class=\"line\">       List&lt;News&gt; newsList=gson.fromJson(json, <span class=\"keyword\">new</span> TypeToken&lt;List&lt;News&gt;&gt;()&#123;&#125;.getType());</div><div class=\"line\">       list.addAll(newsList);</div><div class=\"line\">       handler.sendEmptyMessage(<span class=\"number\">1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">         </div><div class=\"line\">  &#125;).start();</div><div class=\"line\">&#125;</div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 模拟网络请求方法</div><div class=\"line\">     * <span class=\"doctag\">@return</span> json数据</div><div class=\"line\">     */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">request</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">   News news=<span class=\"keyword\">null</span>;</div><div class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</div><div class=\"line\">       news=<span class=\"keyword\">new</span> News();</div><div class=\"line\">       news.setId(i);</div><div class=\"line\">       news.setImgUrl(<span class=\"string\">\"course/img/face_\"</span>+i+<span class=\"string\">\".png\"</span>);</div><div class=\"line\">       news.setTitle(<span class=\"string\">\"新闻标题\"</span>+i);</div><div class=\"line\">       news.setSummary(<span class=\"string\">\"测试\"</span>+i);</div><div class=\"line\">       list.add(news);</div><div class=\"line\">   &#125;</div><div class=\"line\">   Gson gson=<span class=\"keyword\">new</span> Gson();</div><div class=\"line\">   <span class=\"keyword\">return</span> gson.toJson(list);    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> Handler handler=<span class=\"keyword\">new</span> Handler()</div><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">       <span class=\"keyword\">switch</span>(msg.what)&#123;</div><div class=\"line\">           <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</div><div class=\"line\">             notify_layout.setVisibility(View.GONE);</div><div class=\"line\">             adapter.notifyDataSetChanged();</div><div class=\"line\">           <span class=\"keyword\">break</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"android基础之进程间通信","date":"2017-02-28T10:00:00.000Z","_content":"","source":"_posts/android基础之进程间通信.md","raw":"---\ntitle: android基础之进程间通信\ndate: 2017-02-28 18:00:00\ncategories:\ntags:\n---\n","slug":"android基础之进程间通信","published":1,"updated":"2017-03-04T09:08:24.219Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj02g6gsm000z7c02ih8qo3z0","content":"","excerpt":"","more":""},{"title":"hexo搭建博客指南（一）--建站","date":"2017-02-16T07:08:29.000Z","_content":"### 一 hexo简介   \n\n> hexo是一款快速，高效，简洁的博客框架。\n\n### 二 搭建博客   \n\n#### 2.1 安装环境\n\n&emsp;&emsp;hexo是基于node.js的，因此要想使用hexo，必须安装node环境，同时还需要git，用于将hexo部署到github上。所需软件：  \nnode.js &emsp;&emsp;下载链接：[http://nodejs.cn/download/](http://nodejs.cn/download/)  \ngit &emsp;&emsp;&emsp;&emsp;下载链接：[https://git-for-windows.github.io/](https://git-for-windows.github.io/)  \n\n\n下载后直接安装，完成后打开windows的cmd，输入以下命令：  \n\n``` bash\nnode -v    \nnpm -v \n```        \n\n当出现以下信息时，则说明安装成功。    \n   \n``` bash\nzhengrui-ds@ZHENGRUI-DS MINGW64 ~\n$ node -v\nv6.9.4\n\nzhengrui-ds@ZHENGRUI-DS MINGW64 ~\n$ npm -v\n3.10.10\n```\n\n\n#### 2.2 安装hexo    \n\n安装客户端   \n\n```bash\nnpm install -g hexo-cli    \n```   \n\n安装服务端  \n\n```bash\nnpm install hexo --save   \n```   \n\n新建一个用于装在hexo的文件夹，如hexo  \n切换到该文件夹，执行以下命令：   \n\n```bash\n hexo init  //初始化该文件夹  \n npm install  //安装相应的依赖包\n```    \n\n此时hexo搭建博客已基本完成。可执行以下命令来查看博客的初始效果：  \n\n```bash\n\thexo clean   //清空public文件夹下面的内容，该文件夹用于存放生成的网页文件。  \n\thexo g       //该命令用于产生相应的网页文件，在public文件夹下  \n\thexo s      //启动一个本地服务器，一般是http://localhost:4000，可查看生成的网页情况。\n```    \n\n**注意**：有时会存在4000端口被占用的情况，此时可以使用hexo s -p 端口号&emsp;来指定端口号。其实如果你有使用linux的经验，应该知道这些命令一般都可以在命令的后面加上-h或者--help来查看它的用法。hexo中的命令可以连写，如hexo g与hexo s可合写成hexo s -g  \n\n#### 2.3 将博客部署到github上  \n&emsp;&emsp;要想将博客部署到github上，你需要先有一个github账号，并且将你本地的git（计算机）与github关联起来。本文已认为你已经有了自己的github账号并已关联本地，如果没有请移步我的另一篇博客TODO  \n其次你需要了解一下hexo的配置文件_config.yml：  \n站点配置\n``` bash\n# Site\ntitle: ZHENGRUI'BLOG\nsubtitle: 今日之果，皆因曾经之因\ndescription:\nauthor: zhengrui\nlanguage: zh-CN\ntimezone:\n``` \n将博客部署到github上  \n``` bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: git@github.com:zhezaoyizhuding/zhezaoyizhuding.github.io.git\n  branch: master\n```  \n你需要执行以下命令，安装hexo的git插件  \n\n```bash\nnpm install hexo-deployer-git --save\n```    \n\n后面要加--save否则无法将依赖写入hexo的package.json中，执行以下命令即可将网站部署到github上。  \n\n```bash\nhexo d\n```  \n\n至此你一讲将博客部署到github上了，在浏览器输入https://你的github用户名.github.io即可访问。","source":"_posts/hexo搭建博客指南（一）-建站.md","raw":"---\ntitle: hexo搭建博客指南（一）--建站\ndate: 2017-02-16 15:08:29\ncategories: hexo\ntags:\n- hexo\n---\n### 一 hexo简介   \n\n> hexo是一款快速，高效，简洁的博客框架。\n\n### 二 搭建博客   \n\n#### 2.1 安装环境\n\n&emsp;&emsp;hexo是基于node.js的，因此要想使用hexo，必须安装node环境，同时还需要git，用于将hexo部署到github上。所需软件：  \nnode.js &emsp;&emsp;下载链接：[http://nodejs.cn/download/](http://nodejs.cn/download/)  \ngit &emsp;&emsp;&emsp;&emsp;下载链接：[https://git-for-windows.github.io/](https://git-for-windows.github.io/)  \n\n\n下载后直接安装，完成后打开windows的cmd，输入以下命令：  \n\n``` bash\nnode -v    \nnpm -v \n```        \n\n当出现以下信息时，则说明安装成功。    \n   \n``` bash\nzhengrui-ds@ZHENGRUI-DS MINGW64 ~\n$ node -v\nv6.9.4\n\nzhengrui-ds@ZHENGRUI-DS MINGW64 ~\n$ npm -v\n3.10.10\n```\n\n\n#### 2.2 安装hexo    \n\n安装客户端   \n\n```bash\nnpm install -g hexo-cli    \n```   \n\n安装服务端  \n\n```bash\nnpm install hexo --save   \n```   \n\n新建一个用于装在hexo的文件夹，如hexo  \n切换到该文件夹，执行以下命令：   \n\n```bash\n hexo init  //初始化该文件夹  \n npm install  //安装相应的依赖包\n```    \n\n此时hexo搭建博客已基本完成。可执行以下命令来查看博客的初始效果：  \n\n```bash\n\thexo clean   //清空public文件夹下面的内容，该文件夹用于存放生成的网页文件。  \n\thexo g       //该命令用于产生相应的网页文件，在public文件夹下  \n\thexo s      //启动一个本地服务器，一般是http://localhost:4000，可查看生成的网页情况。\n```    \n\n**注意**：有时会存在4000端口被占用的情况，此时可以使用hexo s -p 端口号&emsp;来指定端口号。其实如果你有使用linux的经验，应该知道这些命令一般都可以在命令的后面加上-h或者--help来查看它的用法。hexo中的命令可以连写，如hexo g与hexo s可合写成hexo s -g  \n\n#### 2.3 将博客部署到github上  \n&emsp;&emsp;要想将博客部署到github上，你需要先有一个github账号，并且将你本地的git（计算机）与github关联起来。本文已认为你已经有了自己的github账号并已关联本地，如果没有请移步我的另一篇博客TODO  \n其次你需要了解一下hexo的配置文件_config.yml：  \n站点配置\n``` bash\n# Site\ntitle: ZHENGRUI'BLOG\nsubtitle: 今日之果，皆因曾经之因\ndescription:\nauthor: zhengrui\nlanguage: zh-CN\ntimezone:\n``` \n将博客部署到github上  \n``` bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: git@github.com:zhezaoyizhuding/zhezaoyizhuding.github.io.git\n  branch: master\n```  \n你需要执行以下命令，安装hexo的git插件  \n\n```bash\nnpm install hexo-deployer-git --save\n```    \n\n后面要加--save否则无法将依赖写入hexo的package.json中，执行以下命令即可将网站部署到github上。  \n\n```bash\nhexo d\n```  \n\n至此你一讲将博客部署到github上了，在浏览器输入https://你的github用户名.github.io即可访问。","slug":"hexo搭建博客指南（一）-建站","published":1,"updated":"2017-03-04T09:08:24.222Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj02g6gsm00127c02rfukd2pi","content":"<h3 id=\"一-hexo简介\"><a href=\"#一-hexo简介\" class=\"headerlink\" title=\"一 hexo简介\"></a>一 hexo简介</h3><blockquote>\n<p>hexo是一款快速，高效，简洁的博客框架。</p>\n</blockquote>\n<h3 id=\"二-搭建博客\"><a href=\"#二-搭建博客\" class=\"headerlink\" title=\"二 搭建博客\"></a>二 搭建博客</h3><h4 id=\"2-1-安装环境\"><a href=\"#2-1-安装环境\" class=\"headerlink\" title=\"2.1 安装环境\"></a>2.1 安装环境</h4><p>&emsp;&emsp;hexo是基于node.js的，因此要想使用hexo，必须安装node环境，同时还需要git，用于将hexo部署到github上。所需软件：<br>node.js &emsp;&emsp;下载链接：<a href=\"http://nodejs.cn/download/\" target=\"_blank\" rel=\"external\">http://nodejs.cn/download/</a><br>git &emsp;&emsp;&emsp;&emsp;下载链接：<a href=\"https://git-for-windows.github.io/\" target=\"_blank\" rel=\"external\">https://git-for-windows.github.io/</a>  </p>\n<p>下载后直接安装，完成后打开windows的cmd，输入以下命令：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">node -v    </div><div class=\"line\">npm -v </div><div class=\"line\">```        </div><div class=\"line\"></div><div class=\"line\">当出现以下信息时，则说明安装成功。    </div><div class=\"line\">   </div><div class=\"line\">``` bash</div><div class=\"line\">zhengrui-ds@ZHENGRUI-DS MINGW64 ~</div><div class=\"line\">$ node -v</div><div class=\"line\">v6.9.4</div><div class=\"line\"></div><div class=\"line\">zhengrui-ds@ZHENGRUI-DS MINGW64 ~</div><div class=\"line\">$ npm -v</div><div class=\"line\">3.10.10</div></pre></td></tr></table></figure>\n<h4 id=\"2-2-安装hexo\"><a href=\"#2-2-安装hexo\" class=\"headerlink\" title=\"2.2 安装hexo\"></a>2.2 安装hexo</h4><p>安装客户端   </p>\n<pre><code class=\"bash\">npm install -g hexo-cli\n</code></pre>\n<p>安装服务端  </p>\n<pre><code class=\"bash\">npm install hexo --save\n</code></pre>\n<p>新建一个用于装在hexo的文件夹，如hexo<br>切换到该文件夹，执行以下命令：   </p>\n<pre><code class=\"bash\">hexo init  //初始化该文件夹  \nnpm install  //安装相应的依赖包\n</code></pre>\n<p>此时hexo搭建博客已基本完成。可执行以下命令来查看博客的初始效果：  </p>\n<pre><code class=\"bash\">hexo clean   //清空public文件夹下面的内容，该文件夹用于存放生成的网页文件。  \nhexo g       //该命令用于产生相应的网页文件，在public文件夹下  \nhexo s      //启动一个本地服务器，一般是http://localhost:4000，可查看生成的网页情况。\n</code></pre>\n<p><strong>注意</strong>：有时会存在4000端口被占用的情况，此时可以使用hexo s -p 端口号&emsp;来指定端口号。其实如果你有使用linux的经验，应该知道这些命令一般都可以在命令的后面加上-h或者–help来查看它的用法。hexo中的命令可以连写，如hexo g与hexo s可合写成hexo s -g  </p>\n<h4 id=\"2-3-将博客部署到github上\"><a href=\"#2-3-将博客部署到github上\" class=\"headerlink\" title=\"2.3 将博客部署到github上\"></a>2.3 将博客部署到github上</h4><p>&emsp;&emsp;要想将博客部署到github上，你需要先有一个github账号，并且将你本地的git（计算机）与github关联起来。本文已认为你已经有了自己的github账号并已关联本地，如果没有请移步我的另一篇博客TODO<br>其次你需要了解一下hexo的配置文件_config.yml：<br>站点配置</p>\n<pre><code class=\"bash\"><span class=\"comment\"># Site</span>\ntitle: ZHENGRUI<span class=\"string\">'BLOG\nsubtitle: 今日之果，皆因曾经之因\ndescription:\nauthor: zhengrui\nlanguage: zh-CN\ntimezone:</span>\n</code></pre>\n<p>将博客部署到github上  </p>\n<pre><code class=\"bash\"><span class=\"comment\"># Deployment</span>\n<span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span>\ndeploy:\n  <span class=\"built_in\">type</span>: git\n  repo: git@github.com:zhezaoyizhuding/zhezaoyizhuding.github.io.git\n  branch: master\n</code></pre>\n<p>你需要执行以下命令，安装hexo的git插件  </p>\n<pre><code class=\"bash\">npm install hexo-deployer-git --save\n</code></pre>\n<p>后面要加–save否则无法将依赖写入hexo的package.json中，执行以下命令即可将网站部署到github上。  </p>\n<pre><code class=\"bash\">hexo d\n</code></pre>\n<p>至此你一讲将博客部署到github上了，在浏览器输入<a href=\"https://你的github用户名.github.io即可访问。\" target=\"_blank\" rel=\"external\">https://你的github用户名.github.io即可访问。</a></p>\n","excerpt":"","more":"<h3 id=\"一-hexo简介\"><a href=\"#一-hexo简介\" class=\"headerlink\" title=\"一 hexo简介\"></a>一 hexo简介</h3><blockquote>\n<p>hexo是一款快速，高效，简洁的博客框架。</p>\n</blockquote>\n<h3 id=\"二-搭建博客\"><a href=\"#二-搭建博客\" class=\"headerlink\" title=\"二 搭建博客\"></a>二 搭建博客</h3><h4 id=\"2-1-安装环境\"><a href=\"#2-1-安装环境\" class=\"headerlink\" title=\"2.1 安装环境\"></a>2.1 安装环境</h4><p>&emsp;&emsp;hexo是基于node.js的，因此要想使用hexo，必须安装node环境，同时还需要git，用于将hexo部署到github上。所需软件：<br>node.js &emsp;&emsp;下载链接：<a href=\"http://nodejs.cn/download/\">http://nodejs.cn/download/</a><br>git &emsp;&emsp;&emsp;&emsp;下载链接：<a href=\"https://git-for-windows.github.io/\">https://git-for-windows.github.io/</a>  </p>\n<p>下载后直接安装，完成后打开windows的cmd，输入以下命令：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">node -v    </div><div class=\"line\">npm -v </div><div class=\"line\">```        </div><div class=\"line\"></div><div class=\"line\">当出现以下信息时，则说明安装成功。    </div><div class=\"line\">   </div><div class=\"line\">``` bash</div><div class=\"line\">zhengrui-ds@ZHENGRUI-DS MINGW64 ~</div><div class=\"line\">$ node -v</div><div class=\"line\">v6.9.4</div><div class=\"line\"></div><div class=\"line\">zhengrui-ds@ZHENGRUI-DS MINGW64 ~</div><div class=\"line\">$ npm -v</div><div class=\"line\">3.10.10</div></pre></td></tr></table></figure>\n<h4 id=\"2-2-安装hexo\"><a href=\"#2-2-安装hexo\" class=\"headerlink\" title=\"2.2 安装hexo\"></a>2.2 安装hexo</h4><p>安装客户端   </p>\n<pre><code class=\"bash\">npm install -g hexo-cli\n</code></pre>\n<p>安装服务端  </p>\n<pre><code class=\"bash\">npm install hexo --save\n</code></pre>\n<p>新建一个用于装在hexo的文件夹，如hexo<br>切换到该文件夹，执行以下命令：   </p>\n<pre><code class=\"bash\">hexo init  //初始化该文件夹  \nnpm install  //安装相应的依赖包\n</code></pre>\n<p>此时hexo搭建博客已基本完成。可执行以下命令来查看博客的初始效果：  </p>\n<pre><code class=\"bash\">hexo clean   //清空public文件夹下面的内容，该文件夹用于存放生成的网页文件。  \nhexo g       //该命令用于产生相应的网页文件，在public文件夹下  \nhexo s      //启动一个本地服务器，一般是http://localhost:4000，可查看生成的网页情况。\n</code></pre>\n<p><strong>注意</strong>：有时会存在4000端口被占用的情况，此时可以使用hexo s -p 端口号&emsp;来指定端口号。其实如果你有使用linux的经验，应该知道这些命令一般都可以在命令的后面加上-h或者–help来查看它的用法。hexo中的命令可以连写，如hexo g与hexo s可合写成hexo s -g  </p>\n<h4 id=\"2-3-将博客部署到github上\"><a href=\"#2-3-将博客部署到github上\" class=\"headerlink\" title=\"2.3 将博客部署到github上\"></a>2.3 将博客部署到github上</h4><p>&emsp;&emsp;要想将博客部署到github上，你需要先有一个github账号，并且将你本地的git（计算机）与github关联起来。本文已认为你已经有了自己的github账号并已关联本地，如果没有请移步我的另一篇博客TODO<br>其次你需要了解一下hexo的配置文件_config.yml：<br>站点配置</p>\n<pre><code class=\"bash\"><span class=\"comment\"># Site</span>\ntitle: ZHENGRUI<span class=\"string\">'BLOG\nsubtitle: 今日之果，皆因曾经之因\ndescription:\nauthor: zhengrui\nlanguage: zh-CN\ntimezone:</span>\n</code></pre>\n<p>将博客部署到github上  </p>\n<pre><code class=\"bash\"><span class=\"comment\"># Deployment</span>\n<span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span>\ndeploy:\n  <span class=\"built_in\">type</span>: git\n  repo: git@github.com:zhezaoyizhuding/zhezaoyizhuding.github.io.git\n  branch: master\n</code></pre>\n<p>你需要执行以下命令，安装hexo的git插件  </p>\n<pre><code class=\"bash\">npm install hexo-deployer-git --save\n</code></pre>\n<p>后面要加–save否则无法将依赖写入hexo的package.json中，执行以下命令即可将网站部署到github上。  </p>\n<pre><code class=\"bash\">hexo d\n</code></pre>\n<p>至此你一讲将博客部署到github上了，在浏览器输入<a href=\"https://你的github用户名.github.io即可访问。\">https://你的github用户名.github.io即可访问。</a></p>\n"},{"title":"hexo搭建博客指南（二）--主题配置","date":"2017-02-18T07:09:07.000Z","_content":"### 一 主题选择  \n\n&emsp;&emsp;由于hexo默认的主题并不让人满意，因此要想搭建一个让自己心仪的博客你还需要一款好看的主题。hexo的主题你可以冲一下两个网站中获取：  \n[https://github.com/hexojs/hexo/wiki/Themes](https://github.com/hexojs/hexo/wiki/Themes)  \n[https://hexo.io/zh-cn/docs/themes.html](https://hexo.io/zh-cn/docs/themes.html)  \n\n\n### 二 主题配置  \n\n#### 2.1 安装主题\n\n&emsp;&emsp;你可以选择自己心仪的主题，然后改一下hexo的配置文件_config.yml文件。  \n``` bash\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: hexo-theme-air\n``` \n你只需要将它改成你的主题名字  \n\n\n#### 2.2 配置主题  \n&emsp;&emsp;你需要了解一下hexo的主题配置文件_config.yml(注意与hexo根目录下的配置文件不是一个文件)的一些配置:\n``` bash\nmenu:\n  首页: /\n  项目: /项目/\n  职业生涯: /职业生涯/\n  随感: /随感/\n  归档: /archives\n  关于我: /about\n\nwidgets:\n- search\n- category\n- recent_posts\n- tagcloud\n\n```  \n##### **menu**\n&emsp;&emsp;下面的是你想要为你的网站划分的版块。前面是版块名称，后面是相应的路径。你可通过如下命令来新建新的版块页面：  \n``` bash\nhexo new page 版块名\n```  \nhexo会自动在source文件下建立相应的文件夹。   \n**注意：**这里有坑。  \n\n- 我曾新建完一个新的页面后却无法访问，究其原因是当我访问这个页面是浏览器的协议自动从https换成了http，结果找不到资源。原因未知，解决办法：将hexo中的东西都删掉，重搭。。。。。   \n- 又遇一坑，当我将我的版块页面所在的文件夹取名为中文时，我需要在主题配置文件中的menu下相应的版块路径后面多家一个“/”，否则报错，而英文的就不需要，原因未知。\n- 坑3，当使用md写博客时，网站默认quote是居中的，可通过修改主题下的source/css/_partial/article.styl文件中blockquote解决。  \n这些估计都是我选择的light主题中的坑。  \n\n##### **widget**  \n&emsp;&emsp;这下面的是一些网站侧边的一些小部件，比如我的网站右边的分类和标签云。你可以在你的主题下面的/layout/_widget下面找到你的主题支持哪些小部件，你只需要将这些部件名依照格式放在widget下即可显示在网站中。  \n\n##### **categories 和 tags**\n&emsp;&emsp;categories和tags是hexo内置的标签，你只需要在编写博客时加入以下配置：  \n``` bash\n---\ntitle: hexo搭建博客指南（二）--主题配置\ndate: 2017-02-18 15:09:07\ncategories: hexo\ntags:\n- hexo\n---\n``` \n即可在widget中的category和tag中显示你的分类与标签，categories一般用于文章分类，你也可用它来生成你的版块页；tags一般则是用于为搜索引擎提供你这篇博文的关键字。  \n\n### 三 总结\n\n&emsp;&emsp;文章到这里也差不多说完了，hexo的其他知识点你可以通过google搜索或者研究hexo的官方文档[https://hexo.io/zh-cn/docs/asset-folders.html](https://hexo.io/zh-cn/docs/asset-folders.html)来获得。下篇我将介绍hexo的相关插件使用。","source":"_posts/hexo搭建博客指南（二）-主题配置.md","raw":"---\ntitle: hexo搭建博客指南（二）--主题配置\ndate: 2017-02-18 15:09:07\ncategories: hexo\ntags:\n- hexo\n---\n### 一 主题选择  \n\n&emsp;&emsp;由于hexo默认的主题并不让人满意，因此要想搭建一个让自己心仪的博客你还需要一款好看的主题。hexo的主题你可以冲一下两个网站中获取：  \n[https://github.com/hexojs/hexo/wiki/Themes](https://github.com/hexojs/hexo/wiki/Themes)  \n[https://hexo.io/zh-cn/docs/themes.html](https://hexo.io/zh-cn/docs/themes.html)  \n\n\n### 二 主题配置  \n\n#### 2.1 安装主题\n\n&emsp;&emsp;你可以选择自己心仪的主题，然后改一下hexo的配置文件_config.yml文件。  \n``` bash\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: hexo-theme-air\n``` \n你只需要将它改成你的主题名字  \n\n\n#### 2.2 配置主题  \n&emsp;&emsp;你需要了解一下hexo的主题配置文件_config.yml(注意与hexo根目录下的配置文件不是一个文件)的一些配置:\n``` bash\nmenu:\n  首页: /\n  项目: /项目/\n  职业生涯: /职业生涯/\n  随感: /随感/\n  归档: /archives\n  关于我: /about\n\nwidgets:\n- search\n- category\n- recent_posts\n- tagcloud\n\n```  \n##### **menu**\n&emsp;&emsp;下面的是你想要为你的网站划分的版块。前面是版块名称，后面是相应的路径。你可通过如下命令来新建新的版块页面：  \n``` bash\nhexo new page 版块名\n```  \nhexo会自动在source文件下建立相应的文件夹。   \n**注意：**这里有坑。  \n\n- 我曾新建完一个新的页面后却无法访问，究其原因是当我访问这个页面是浏览器的协议自动从https换成了http，结果找不到资源。原因未知，解决办法：将hexo中的东西都删掉，重搭。。。。。   \n- 又遇一坑，当我将我的版块页面所在的文件夹取名为中文时，我需要在主题配置文件中的menu下相应的版块路径后面多家一个“/”，否则报错，而英文的就不需要，原因未知。\n- 坑3，当使用md写博客时，网站默认quote是居中的，可通过修改主题下的source/css/_partial/article.styl文件中blockquote解决。  \n这些估计都是我选择的light主题中的坑。  \n\n##### **widget**  \n&emsp;&emsp;这下面的是一些网站侧边的一些小部件，比如我的网站右边的分类和标签云。你可以在你的主题下面的/layout/_widget下面找到你的主题支持哪些小部件，你只需要将这些部件名依照格式放在widget下即可显示在网站中。  \n\n##### **categories 和 tags**\n&emsp;&emsp;categories和tags是hexo内置的标签，你只需要在编写博客时加入以下配置：  \n``` bash\n---\ntitle: hexo搭建博客指南（二）--主题配置\ndate: 2017-02-18 15:09:07\ncategories: hexo\ntags:\n- hexo\n---\n``` \n即可在widget中的category和tag中显示你的分类与标签，categories一般用于文章分类，你也可用它来生成你的版块页；tags一般则是用于为搜索引擎提供你这篇博文的关键字。  \n\n### 三 总结\n\n&emsp;&emsp;文章到这里也差不多说完了，hexo的其他知识点你可以通过google搜索或者研究hexo的官方文档[https://hexo.io/zh-cn/docs/asset-folders.html](https://hexo.io/zh-cn/docs/asset-folders.html)来获得。下篇我将介绍hexo的相关插件使用。","slug":"hexo搭建博客指南（二）-主题配置","published":1,"updated":"2017-03-04T09:08:24.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj02g6gt100157c02rfytaqcz","content":"<h3 id=\"一-主题选择\"><a href=\"#一-主题选择\" class=\"headerlink\" title=\"一 主题选择\"></a>一 主题选择</h3><p>&emsp;&emsp;由于hexo默认的主题并不让人满意，因此要想搭建一个让自己心仪的博客你还需要一款好看的主题。hexo的主题你可以冲一下两个网站中获取：<br><a href=\"https://github.com/hexojs/hexo/wiki/Themes\" target=\"_blank\" rel=\"external\">https://github.com/hexojs/hexo/wiki/Themes</a><br><a href=\"https://hexo.io/zh-cn/docs/themes.html\" target=\"_blank\" rel=\"external\">https://hexo.io/zh-cn/docs/themes.html</a>  </p>\n<h3 id=\"二-主题配置\"><a href=\"#二-主题配置\" class=\"headerlink\" title=\"二 主题配置\"></a>二 主题配置</h3><h4 id=\"2-1-安装主题\"><a href=\"#2-1-安装主题\" class=\"headerlink\" title=\"2.1 安装主题\"></a>2.1 安装主题</h4><p>&emsp;&emsp;你可以选择自己心仪的主题，然后改一下hexo的配置文件_config.yml文件。  </p>\n<pre><code class=\"bash\"><span class=\"comment\"># Extensions</span>\n<span class=\"comment\">## Plugins: https://hexo.io/plugins/</span>\n<span class=\"comment\">## Themes: https://hexo.io/themes/</span>\ntheme: hexo-theme-air\n</code></pre>\n<p>你只需要将它改成你的主题名字  </p>\n<h4 id=\"2-2-配置主题\"><a href=\"#2-2-配置主题\" class=\"headerlink\" title=\"2.2 配置主题\"></a>2.2 配置主题</h4><p>&emsp;&emsp;你需要了解一下hexo的主题配置文件_config.yml(注意与hexo根目录下的配置文件不是一个文件)的一些配置:</p>\n<pre><code class=\"bash\">menu:\n  首页: /\n  项目: /项目/\n  职业生涯: /职业生涯/\n  随感: /随感/\n  归档: /archives\n  关于我: /about\n\nwidgets:\n- search\n- category\n- recent_posts\n- tagcloud\n</code></pre>\n<h5 id=\"menu\"><a href=\"#menu\" class=\"headerlink\" title=\"menu\"></a><strong>menu</strong></h5><p>&emsp;&emsp;下面的是你想要为你的网站划分的版块。前面是版块名称，后面是相应的路径。你可通过如下命令来新建新的版块页面：  </p>\n<pre><code class=\"bash\">hexo new page 版块名\n</code></pre>\n<p>hexo会自动在source文件下建立相应的文件夹。<br><strong>注意：</strong>这里有坑。  </p>\n<ul>\n<li>我曾新建完一个新的页面后却无法访问，究其原因是当我访问这个页面是浏览器的协议自动从https换成了http，结果找不到资源。原因未知，解决办法：将hexo中的东西都删掉，重搭。。。。。   </li>\n<li>又遇一坑，当我将我的版块页面所在的文件夹取名为中文时，我需要在主题配置文件中的menu下相应的版块路径后面多家一个“/”，否则报错，而英文的就不需要，原因未知。</li>\n<li>坑3，当使用md写博客时，网站默认quote是居中的，可通过修改主题下的source/css/_partial/article.styl文件中blockquote解决。<br>这些估计都是我选择的light主题中的坑。  </li>\n</ul>\n<h5 id=\"widget\"><a href=\"#widget\" class=\"headerlink\" title=\"widget\"></a><strong>widget</strong></h5><p>&emsp;&emsp;这下面的是一些网站侧边的一些小部件，比如我的网站右边的分类和标签云。你可以在你的主题下面的/layout/_widget下面找到你的主题支持哪些小部件，你只需要将这些部件名依照格式放在widget下即可显示在网站中。  </p>\n<h5 id=\"categories-和-tags\"><a href=\"#categories-和-tags\" class=\"headerlink\" title=\"categories 和 tags\"></a><strong>categories 和 tags</strong></h5><p>&emsp;&emsp;categories和tags是hexo内置的标签，你只需要在编写博客时加入以下配置：  </p>\n<pre><code class=\"bash\">---\ntitle: hexo搭建博客指南（二）--主题配置\ndate: 2017-02-18 15:09:07\ncategories: hexo\ntags:\n- hexo\n---\n</code></pre>\n<p>即可在widget中的category和tag中显示你的分类与标签，categories一般用于文章分类，你也可用它来生成你的版块页；tags一般则是用于为搜索引擎提供你这篇博文的关键字。  </p>\n<h3 id=\"三-总结\"><a href=\"#三-总结\" class=\"headerlink\" title=\"三 总结\"></a>三 总结</h3><p>&emsp;&emsp;文章到这里也差不多说完了，hexo的其他知识点你可以通过google搜索或者研究hexo的官方文档<a href=\"https://hexo.io/zh-cn/docs/asset-folders.html\" target=\"_blank\" rel=\"external\">https://hexo.io/zh-cn/docs/asset-folders.html</a>来获得。下篇我将介绍hexo的相关插件使用。</p>\n","excerpt":"","more":"<h3 id=\"一-主题选择\"><a href=\"#一-主题选择\" class=\"headerlink\" title=\"一 主题选择\"></a>一 主题选择</h3><p>&emsp;&emsp;由于hexo默认的主题并不让人满意，因此要想搭建一个让自己心仪的博客你还需要一款好看的主题。hexo的主题你可以冲一下两个网站中获取：<br><a href=\"https://github.com/hexojs/hexo/wiki/Themes\">https://github.com/hexojs/hexo/wiki/Themes</a><br><a href=\"https://hexo.io/zh-cn/docs/themes.html\">https://hexo.io/zh-cn/docs/themes.html</a>  </p>\n<h3 id=\"二-主题配置\"><a href=\"#二-主题配置\" class=\"headerlink\" title=\"二 主题配置\"></a>二 主题配置</h3><h4 id=\"2-1-安装主题\"><a href=\"#2-1-安装主题\" class=\"headerlink\" title=\"2.1 安装主题\"></a>2.1 安装主题</h4><p>&emsp;&emsp;你可以选择自己心仪的主题，然后改一下hexo的配置文件_config.yml文件。  </p>\n<pre><code class=\"bash\"><span class=\"comment\"># Extensions</span>\n<span class=\"comment\">## Plugins: https://hexo.io/plugins/</span>\n<span class=\"comment\">## Themes: https://hexo.io/themes/</span>\ntheme: hexo-theme-air\n</code></pre>\n<p>你只需要将它改成你的主题名字  </p>\n<h4 id=\"2-2-配置主题\"><a href=\"#2-2-配置主题\" class=\"headerlink\" title=\"2.2 配置主题\"></a>2.2 配置主题</h4><p>&emsp;&emsp;你需要了解一下hexo的主题配置文件_config.yml(注意与hexo根目录下的配置文件不是一个文件)的一些配置:</p>\n<pre><code class=\"bash\">menu:\n  首页: /\n  项目: /项目/\n  职业生涯: /职业生涯/\n  随感: /随感/\n  归档: /archives\n  关于我: /about\n\nwidgets:\n- search\n- category\n- recent_posts\n- tagcloud\n</code></pre>\n<h5 id=\"menu\"><a href=\"#menu\" class=\"headerlink\" title=\"menu\"></a><strong>menu</strong></h5><p>&emsp;&emsp;下面的是你想要为你的网站划分的版块。前面是版块名称，后面是相应的路径。你可通过如下命令来新建新的版块页面：  </p>\n<pre><code class=\"bash\">hexo new page 版块名\n</code></pre>\n<p>hexo会自动在source文件下建立相应的文件夹。<br><strong>注意：</strong>这里有坑。  </p>\n<ul>\n<li>我曾新建完一个新的页面后却无法访问，究其原因是当我访问这个页面是浏览器的协议自动从https换成了http，结果找不到资源。原因未知，解决办法：将hexo中的东西都删掉，重搭。。。。。   </li>\n<li>又遇一坑，当我将我的版块页面所在的文件夹取名为中文时，我需要在主题配置文件中的menu下相应的版块路径后面多家一个“/”，否则报错，而英文的就不需要，原因未知。</li>\n<li>坑3，当使用md写博客时，网站默认quote是居中的，可通过修改主题下的source/css/_partial/article.styl文件中blockquote解决。<br>这些估计都是我选择的light主题中的坑。  </li>\n</ul>\n<h5 id=\"widget\"><a href=\"#widget\" class=\"headerlink\" title=\"widget\"></a><strong>widget</strong></h5><p>&emsp;&emsp;这下面的是一些网站侧边的一些小部件，比如我的网站右边的分类和标签云。你可以在你的主题下面的/layout/_widget下面找到你的主题支持哪些小部件，你只需要将这些部件名依照格式放在widget下即可显示在网站中。  </p>\n<h5 id=\"categories-和-tags\"><a href=\"#categories-和-tags\" class=\"headerlink\" title=\"categories 和 tags\"></a><strong>categories 和 tags</strong></h5><p>&emsp;&emsp;categories和tags是hexo内置的标签，你只需要在编写博客时加入以下配置：  </p>\n<pre><code class=\"bash\">---\ntitle: hexo搭建博客指南（二）--主题配置\ndate: 2017-02-18 15:09:07\ncategories: hexo\ntags:\n- hexo\n---\n</code></pre>\n<p>即可在widget中的category和tag中显示你的分类与标签，categories一般用于文章分类，你也可用它来生成你的版块页；tags一般则是用于为搜索引擎提供你这篇博文的关键字。  </p>\n<h3 id=\"三-总结\"><a href=\"#三-总结\" class=\"headerlink\" title=\"三 总结\"></a>三 总结</h3><p>&emsp;&emsp;文章到这里也差不多说完了，hexo的其他知识点你可以通过google搜索或者研究hexo的官方文档<a href=\"https://hexo.io/zh-cn/docs/asset-folders.html\">https://hexo.io/zh-cn/docs/asset-folders.html</a>来获得。下篇我将介绍hexo的相关插件使用。</p>\n"}],"PostAsset":[{"_id":"source/_posts/android基础之Service/Service生命周期图.png","post":"cj02g6gsl000f7c02j5o3rqp9","slug":"Service生命周期图.png","modified":1,"renderable":1},{"_id":"source/_posts/android基础之Fragments/Fragment与Activity生命周期对比.png","post":"cj02g6grz00047c02ahjlarri","slug":"Fragment与Activity生命周期对比.png","modified":1,"renderable":1},{"_id":"source/_posts/android基础之Fragments/Fragment显示图.png","post":"cj02g6grz00047c02ahjlarri","slug":"Fragment显示图.png","modified":1,"renderable":1},{"_id":"source/_posts/android基础之Fragments/Fragment生命周期图.png","post":"cj02g6grz00047c02ahjlarri","slug":"Fragment生命周期图.png","modified":1,"renderable":1},{"_id":"source/_posts/android基础之activity/Activity状态保存示意图.png","post":"cj02g6gsi000b7c0211k1gz2w","slug":"Activity状态保存示意图.png","modified":1,"renderable":1},{"_id":"source/_posts/android基础之activity/activity回调方法汇总.png","post":"cj02g6gsi000b7c0211k1gz2w","slug":"activity回调方法汇总.png","modified":1,"renderable":1},{"_id":"source/_posts/android基础之activity/activity生命周期图.png","post":"cj02g6gsi000b7c0211k1gz2w","slug":"activity生命周期图.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cj02g6grz00057c02eghqhf9d","category_id":"cj02g6grz00027c02xlure3bg","_id":"cj02g6gsi000a7c022oa19pyz"},{"post_id":"cj02g6grk00007c02sriciazn","category_id":"cj02g6grz00027c02xlure3bg","_id":"cj02g6gsk000e7c025kjr1bu5"},{"post_id":"cj02g6grz00067c025w0rdm6h","category_id":"cj02g6grz00027c02xlure3bg","_id":"cj02g6gsm000g7c024z325hfx"},{"post_id":"cj02g6grz00097c02eaydiwl0","category_id":"cj02g6grz00027c02xlure3bg","_id":"cj02g6gsm000j7c021wuhvq86"},{"post_id":"cj02g6grz00017c026ym2ojm9","category_id":"cj02g6grz00027c02xlure3bg","_id":"cj02g6gsm000m7c02h4hm29ah"},{"post_id":"cj02g6gsi000b7c0211k1gz2w","category_id":"cj02g6grz00027c02xlure3bg","_id":"cj02g6gsm000q7c02swinskn8"},{"post_id":"cj02g6gsl000f7c02j5o3rqp9","category_id":"cj02g6grz00027c02xlure3bg","_id":"cj02g6gsm000t7c02263a9tsx"},{"post_id":"cj02g6grz00047c02ahjlarri","category_id":"cj02g6grz00027c02xlure3bg","_id":"cj02g6gsm000w7c02t0xwm0lg"},{"post_id":"cj02g6gsm000h7c02nysj3x7v","category_id":"cj02g6grz00027c02xlure3bg","_id":"cj02g6gsm000y7c02rruq2ln4"},{"post_id":"cj02g6gsm000k7c02bh0vzcni","category_id":"cj02g6grz00027c02xlure3bg","_id":"cj02g6gsm00107c02wz5bwb1z"},{"post_id":"cj02g6gsm000x7c02i00z1ske","category_id":"cj02g6grz00027c02xlure3bg","_id":"cj02g6gt100147c02jimi9kng"},{"post_id":"cj02g6gsm00127c02rfukd2pi","category_id":"cj02g6gt100177c0242c1hm4t","_id":"cj02g6gt1001c7c02agjnrvi0"},{"post_id":"cj02g6gt100157c02rfytaqcz","category_id":"cj02g6gt100177c0242c1hm4t","_id":"cj02g6gt1001f7c02q3pmvpuy"}],"PostTag":[{"post_id":"cj02g6grk00007c02sriciazn","tag_id":"cj02g6grz00037c029mcrr6rv","_id":"cj02g6gsm000l7c02o0xhtui6"},{"post_id":"cj02g6grk00007c02sriciazn","tag_id":"cj02g6grz00087c025wbomn3o","_id":"cj02g6gsm000o7c02xozpgud3"},{"post_id":"cj02g6grk00007c02sriciazn","tag_id":"cj02g6gsk000d7c027973sln5","_id":"cj02g6gsm000s7c02r5syqtiz"},{"post_id":"cj02g6grz00017c026ym2ojm9","tag_id":"cj02g6grz00037c029mcrr6rv","_id":"cj02g6gt100137c023vfk1b1l"},{"post_id":"cj02g6grz00017c026ym2ojm9","tag_id":"cj02g6grz00087c025wbomn3o","_id":"cj02g6gt100167c02h7y70x90"},{"post_id":"cj02g6grz00017c026ym2ojm9","tag_id":"cj02g6gsm000v7c02p6xzpobd","_id":"cj02g6gt100197c02l5pdciqb"},{"post_id":"cj02g6grz00047c02ahjlarri","tag_id":"cj02g6grz00037c029mcrr6rv","_id":"cj02g6gt1001e7c027r8jeusz"},{"post_id":"cj02g6grz00047c02ahjlarri","tag_id":"cj02g6grz00087c025wbomn3o","_id":"cj02g6gt1001g7c02bq4drzdh"},{"post_id":"cj02g6grz00047c02ahjlarri","tag_id":"cj02g6gt1001a7c02teqxf7m1","_id":"cj02g6gt1001i7c02y7o57nsw"},{"post_id":"cj02g6grz00057c02eghqhf9d","tag_id":"cj02g6grz00037c029mcrr6rv","_id":"cj02g6gt1001l7c02czplcdwu"},{"post_id":"cj02g6grz00057c02eghqhf9d","tag_id":"cj02g6grz00087c025wbomn3o","_id":"cj02g6gt1001m7c02bp1wxeem"},{"post_id":"cj02g6grz00057c02eghqhf9d","tag_id":"cj02g6gt1001h7c02un015q5n","_id":"cj02g6gt1001o7c026xokvkmx"},{"post_id":"cj02g6grz00057c02eghqhf9d","tag_id":"cj02g6gt1001j7c02qf22fymf","_id":"cj02g6gt1001p7c022ed5enyc"},{"post_id":"cj02g6grz00067c025w0rdm6h","tag_id":"cj02g6grz00037c029mcrr6rv","_id":"cj02g6gt1001s7c023p28aeox"},{"post_id":"cj02g6grz00067c025w0rdm6h","tag_id":"cj02g6grz00087c025wbomn3o","_id":"cj02g6gt1001t7c029h169s9e"},{"post_id":"cj02g6grz00067c025w0rdm6h","tag_id":"cj02g6gt1001n7c02ihl42w6p","_id":"cj02g6gt1001v7c02sfr0q360"},{"post_id":"cj02g6grz00067c025w0rdm6h","tag_id":"cj02g6gt1001q7c02yecd1o2g","_id":"cj02g6gth001w7c02h1rchqk1"},{"post_id":"cj02g6grz00097c02eaydiwl0","tag_id":"cj02g6grz00037c029mcrr6rv","_id":"cj02g6gth001y7c02jbryyng7"},{"post_id":"cj02g6grz00097c02eaydiwl0","tag_id":"cj02g6grz00087c025wbomn3o","_id":"cj02g6gth001z7c02sa6o62zu"},{"post_id":"cj02g6grz00097c02eaydiwl0","tag_id":"cj02g6gt1001r7c02vlebze4t","_id":"cj02g6gth00217c02p0dg7mte"},{"post_id":"cj02g6gsi000b7c0211k1gz2w","tag_id":"cj02g6grz00087c025wbomn3o","_id":"cj02g6gth00227c02hp83g1gm"},{"post_id":"cj02g6gsi000b7c0211k1gz2w","tag_id":"cj02g6grz00037c029mcrr6rv","_id":"cj02g6gth00237c02w7f050mt"},{"post_id":"cj02g6gsi000b7c0211k1gz2w","tag_id":"cj02g6gt1001u7c02g33z30z8","_id":"cj02g6gth00257c02ddtgothu"},{"post_id":"cj02g6gsl000f7c02j5o3rqp9","tag_id":"cj02g6grz00037c029mcrr6rv","_id":"cj02g6gth00267c024s6dwce7"},{"post_id":"cj02g6gsl000f7c02j5o3rqp9","tag_id":"cj02g6grz00087c025wbomn3o","_id":"cj02g6gth00287c02ki55h4ac"},{"post_id":"cj02g6gsl000f7c02j5o3rqp9","tag_id":"cj02g6gth001x7c02h65ttgk9","_id":"cj02g6gth00297c02p2h5s4rw"},{"post_id":"cj02g6gsm000h7c02nysj3x7v","tag_id":"cj02g6grz00037c029mcrr6rv","_id":"cj02g6gth002b7c02p0d4vnir"},{"post_id":"cj02g6gsm000h7c02nysj3x7v","tag_id":"cj02g6grz00087c025wbomn3o","_id":"cj02g6gth002c7c02v363j78j"},{"post_id":"cj02g6gsm000h7c02nysj3x7v","tag_id":"cj02g6gth00207c02nzrnxh6t","_id":"cj02g6gth002e7c02jfxmiygq"},{"post_id":"cj02g6gsm000h7c02nysj3x7v","tag_id":"cj02g6gth00247c02m53jguin","_id":"cj02g6gth002f7c028f9evwov"},{"post_id":"cj02g6gsm000k7c02bh0vzcni","tag_id":"cj02g6grz00037c029mcrr6rv","_id":"cj02g6gth002g7c02vgcq1rhc"},{"post_id":"cj02g6gsm000k7c02bh0vzcni","tag_id":"cj02g6grz00087c025wbomn3o","_id":"cj02g6gth002i7c02lpnp17z5"},{"post_id":"cj02g6gsm000k7c02bh0vzcni","tag_id":"cj02g6gth00277c02txb8gpaz","_id":"cj02g6gth002j7c022z5l08g9"},{"post_id":"cj02g6gsm000x7c02i00z1ske","tag_id":"cj02g6grz00037c029mcrr6rv","_id":"cj02g6gth002k7c021wn9uo22"},{"post_id":"cj02g6gsm000x7c02i00z1ske","tag_id":"cj02g6grz00087c025wbomn3o","_id":"cj02g6gth002l7c02ve2zrssd"},{"post_id":"cj02g6gsm000x7c02i00z1ske","tag_id":"cj02g6gth002a7c02w9id9uvn","_id":"cj02g6gth002m7c02b6m901l3"},{"post_id":"cj02g6gsm00127c02rfukd2pi","tag_id":"cj02g6gth002d7c02g36tlm5e","_id":"cj02g6gth002n7c02yhnqybs6"},{"post_id":"cj02g6gt100157c02rfytaqcz","tag_id":"cj02g6gth002d7c02g36tlm5e","_id":"cj02g6gth002o7c029cysrasx"}],"Tag":[{"name":"android","_id":"cj02g6grz00037c029mcrr6rv"},{"name":"java","_id":"cj02g6grz00087c025wbomn3o"},{"name":"BroadcastReceiver","_id":"cj02g6gsk000d7c027973sln5"},{"name":"Content Provider","_id":"cj02g6gsm000v7c02p6xzpobd"},{"name":"Fragment","_id":"cj02g6gt1001a7c02teqxf7m1"},{"name":"Handler","_id":"cj02g6gt1001h7c02un015q5n"},{"name":"AsycTask","_id":"cj02g6gt1001j7c02qf22fymf"},{"name":"Intent","_id":"cj02g6gt1001n7c02ihl42w6p"},{"name":"IntentFilter","_id":"cj02g6gt1001q7c02yecd1o2g"},{"name":"SQLite","_id":"cj02g6gt1001r7c02vlebze4t"},{"name":"activity","_id":"cj02g6gt1001u7c02g33z30z8"},{"name":"service","_id":"cj02g6gth001x7c02h65ttgk9"},{"name":"View","_id":"cj02g6gth00207c02nzrnxh6t"},{"name":"事件分发","_id":"cj02g6gth00247c02m53jguin"},{"name":"loader","_id":"cj02g6gth00277c02txb8gpaz"},{"name":"缓存","_id":"cj02g6gth002a7c02w9id9uvn"},{"name":"hexo","_id":"cj02g6gth002d7c02g36tlm5e"}]}}
=======
{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[],"Cache":[],"Category":[],"Data":[],"Page":[],"Post":[],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}
>>>>>>> 8b940d99b72aba634875cdf4aa9c31eb4ee12190
