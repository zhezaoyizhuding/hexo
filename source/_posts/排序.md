---
title: 排序
date: 2017-04-10 12:14:01
categories: 数据结构与算法
tags:
- 排序
---

排序是基本的算法之一，也是在面试中被问的最多的问题。即将开始找工作，便趁此机会复习一下这些早已被忘却的知识（估计之后我还会忘记它）。

排序如果按照程序运行的地点，可将它分为内部排序和外部排序。内部排序即是数据都放在内存中，但是有时候我们的数据量很大内存无法容纳，就需要将数据放在磁盘中，然后分段放入内存中排序。

排序算法有稳定和不稳定之分。所谓稳定性即是当序列中有两个相同的数据时，排序前和排序后它俩的顺序不变，能实现这种情况的排序算法我们说他是稳定的。

#### 插入排序

##### 基本思想

插入排序的基本思想是将一个记录插入到已经排好序的序列中，它默认将第一个元素视为一个已经排好序的序列，后面的元素从后向前逐个扫描，插入到相应位置。时间复杂度O(n^2),空间复杂度O(1)。这种排序是稳定的。

##### 操作步骤

- 从第一个元素开始，该元素可以认为已经被排序
- 取出下一个元素，在已经排序的元素序列中从后向前扫描
- 如果被扫描的元素（已排序）大于新元素，将该元素后移一位
- 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
- 将新元素插入到该位置后
- 重复步骤2~5

##### 代码示例



#### 希尔排序

希尔排序也是插入排序的一种，又叫缩小增量排序。这种排序会设置一个增量（这个增量决定排序效率的高低），然后根据这个增量将整个序列分为若干个子序列，我们可以将这些子序列排成一个增量长的表，分别对每列进行排序，这叫做一趟。然后增量递减，像上述这样进行多趟排序，直到增量为1，此时的最后一趟排序即为直接插入排序。

例如有这样的一组数[49,38,65,97,76,13,27,**49**,55,04],我们以初始增量为5来进行多趟排序，如下：

第一趟：（增量为5）

49 38 65 97 76   
13 27 **49** 55 04

排序结果为:

13 27 **49** 55 04   
49 38 65 97 76

合成一列为：[13,27,**49**,55,04,49,38,65,97,76]

第二趟：（增量为4）

13 27 **49** 55   
04 49 38 65   
97 76

排序结果：

04 27 38 55
13 49 **49** 65
97 76

合成一列为：[04,27,38,55,13，49，**49**，65，97，76]

第三趟：（增量为3）

04 27 38
55 13 49
**49** 65 97
76

排序结果：

04 13 38
**49** 27 49
55 65 97
76

合成一列为：[04,13,38,**49**,27,49,55,65,97,76]

第四趟：（增量为2）

04 13
38 **49**
27 49
55 65
97 76

排序结果：

04 13
27 **49**
38 49
55 65
97 76

合成一列为：[04,13,27,**49**,38,49,55,65,97,76]

最后一趟，增量为1，即为直接插入排序。此时序列已基本有序，排序效率大大提高。

结果：[04,13,27,38，**49**,49,55,65,76,97]

从结果能看到，希尔排序为不稳定排序。它的排序效率有所选择的增量决定。

###### 代码示例


#### 简单选择排序

选择排序的思路很简单，即是扫描未排序的序列，然后将序列中最大（或者最小）的元素放在前面已经排好序的序列的末尾。时间复杂度O(n^2),空间复杂度O(1)。

##### 代码示例


#### 简单选择排序的改进--二元选择排序

简单选择排序每趟循环只能确定一个元素的位置，我们可以考虑每趟循环确定两个元素的位置（当前趟最大和最小），从而减少排序所需的循环次数，来提升效率。

##### 代码示例


#### 堆排序

堆排序也是选择排序的一种，但是其底层数据结构为树，效率比简单选择排序要高。其时间复杂度为O(nlog(n))。

堆是一棵完全二叉树，分为大顶堆和小顶堆。大顶堆即为根节点大于叶子节点的二叉树，小顶堆相反。堆排序即是每次将堆顶元素输出，剩余元素再建立一个堆，如此循环直到序列有序。



#### 冒泡排序

冒泡排序是交换排序的一种，和简单选择排序一样是最经典的排序算法，这两个也是笔者最先接触的两种排序算法。冒泡排序是依次比较相邻两个元素，大的下沉，小的上浮，就像气泡一样，因此叫做冒泡排序。它的时间复杂度和直接选择排序一样，都是O(n^2)。

##### 代码示例

#### 快速排序

快速排序也是一种交换排序，它被称为最快的排序算法。


#### 归并排序



#### 基数排序（桶排序/计数排序 ）





