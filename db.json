{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-alex/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/js/jquery.scrollLoading.js","path":"js/jquery.scrollLoading.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/logo.png","path":"css/images/logo.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/logo@2x.png","path":"css/images/logo@2x.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY.png","path":"css/images/logoDIY.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/preloader.gif","path":"css/images/preloader.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/preloader@2x.gif","path":"css/images/preloader@2x.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY@2x.png","path":"css/images/logoDIY@2x.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY1.png","path":"css/images/logoDIY1.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-alex/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1487823302797},{"_id":"themes/hexo-theme-alex/LICENSE","hash":"f0c7cd0dcb6f00b98393878068ff3e6bf5f321f1","modified":1487823302798},{"_id":"themes/hexo-theme-alex/_config.yml","hash":"1326fcd415c81b47652a6c7b702916dfdcfdbd62","modified":1487823698754},{"_id":"themes/hexo-theme-alex/package.json","hash":"d07f326588fef82f1d23ae3101c9ddfff34c132f","modified":1487823302807},{"_id":"themes/hexo-theme-alex/README.md","hash":"31e9ee4a08a89afc067733d6ac32302badbad95d","modified":1487823302798},{"_id":"source/_posts/android基础之BroadcastReceiver.md","hash":"3d91e2b86c7115562956bdca6180ae1f693f4ccc","modified":1488178111795},{"_id":"source/_posts/android基础之Content-Providers.md","hash":"21b74154616a65a43442a5be60042fb666d068cf","modified":1488177162736},{"_id":"source/_posts/android基础之Fragments.md","hash":"2d6db035b4744fed840d9024d79ac3fc082a25a0","modified":1488177091514},{"_id":"source/_posts/android基础之Handler与AsycTask.md","hash":"dba7e3aa538c1d8469595908d693866fbde7db09","modified":1488178073910},{"_id":"source/_posts/android基础之Intents与Intent-Filters.md","hash":"a65dde30f73f97ffa7d7c9eb471e79ebc01dd61e","modified":1488177129628},{"_id":"source/_posts/android基础之Service.md","hash":"0df8e68890208a35d4517438c6612297b7877d1c","modified":1488184508324},{"_id":"source/_posts/android基础之SQLite.md","hash":"317bbf7fda9ac549a091706a8e00da6125c7add7","modified":1488276212716},{"_id":"source/_posts/android基础之activity.md","hash":"1405f95c417a673696604ba969bd1018489ae4cb","modified":1488524433843},{"_id":"source/_posts/android基础之loaders.md","hash":"365d0bb94dbc63841f0efae38a40be71ce2c39af","modified":1488177562007},{"_id":"source/_posts/android基础之数据存储.md","hash":"8dd38b7ff4752b487123eda0b357a42a1e5c87b9","modified":1488274972277},{"_id":"source/_posts/android基础之消息推送.md","hash":"e5b0daec1280a70265aa492fec5d6c051336dbf2","modified":1488349690850},{"_id":"source/_posts/android基础之事件分发机制.md","hash":"875967b2b2c4e9d052a6e792c39860907ca29bca","modified":1488277528020},{"_id":"source/_posts/android基础之进程间通信.md","hash":"cbfc60b60fc51d0401e9ab44a42d3a07f6797ab3","modified":1488276000191},{"_id":"source/_posts/android基础之自定义View与ViewGroup.md","hash":"d937576cb8f13e24c071dd8b3681c73cd0bf71fc","modified":1488268957153},{"_id":"themes/hexo-theme-alex/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1487823302805},{"_id":"themes/hexo-theme-alex/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1487823302805},{"_id":"themes/hexo-theme-alex/layout/layout.ejs","hash":"6722d4980da4a8b6ae9ebee5fbb3df625d4cccc0","modified":1487823302805},{"_id":"source/_posts/android基础之缓存.md","hash":"73c19c5fd165c978b6ce8345fc4b49c7d55fc9f8","modified":1488273022046},{"_id":"themes/hexo-theme-alex/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1487823302807},{"_id":"themes/hexo-theme-alex/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1487823302805},{"_id":"themes/hexo-theme-alex/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1487823302807},{"_id":"themes/hexo-theme-alex/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1487823302806},{"_id":"themes/hexo-theme-alex/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1487823302808},{"_id":"source/_posts/hexo搭建博客指南（二）-主题配置.md","hash":"2c72a279f51933a4b954019e259e6ba9aae8129e","modified":1487847317467},{"_id":"themes/hexo-theme-alex/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1487823302799},{"_id":"source/_posts/hexo搭建博客指南（一）-建站.md","hash":"843c243de558b7a23e5e929337f739f7ab6ee5ba","modified":1487838852388},{"_id":"themes/hexo-theme-alex/layout/_partial/after-footer.ejs","hash":"473fd916d73a634865d776ff591860f4680f2a5a","modified":1487823302799},{"_id":"themes/hexo-theme-alex/layout/_partial/footer.ejs","hash":"f4c0fb5d3ac8f3ede1d1a668b362ebadc157c5a9","modified":1487844868700},{"_id":"themes/hexo-theme-alex/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1487823302800},{"_id":"themes/hexo-theme-alex/layout/_partial/mobile-nav.ejs","hash":"8692f720b5847458296a052964a455ff7064d554","modified":1487823302801},{"_id":"themes/hexo-theme-alex/layout/_partial/archive.ejs","hash":"61f37ba0ce1eba08a2bcfe09f8691a7320ee8d10","modified":1487823302799},{"_id":"themes/hexo-theme-alex/layout/_partial/sidebar.ejs","hash":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1487823302803},{"_id":"themes/hexo-theme-alex/layout/_widget/archive.ejs","hash":"88e191e3d14541299ed03b9a45be70974df51143","modified":1487823302803},{"_id":"themes/hexo-theme-alex/layout/_widget/category.ejs","hash":"4d3f92e3cd652cb69d71e40d1c64b2369922ca26","modified":1487823302804},{"_id":"themes/hexo-theme-alex/layout/_widget/recent_posts.ejs","hash":"d6591c745402fbc600e682830a343f732e336e4f","modified":1487823302804},{"_id":"themes/hexo-theme-alex/layout/_widget/links.ejs","hash":"50f50a5015bdbcea2f41f071139d68c68c9e6484","modified":1487823302804},{"_id":"themes/hexo-theme-alex/layout/_widget/tag.ejs","hash":"7ba10fbd17b83b9b89eaea99bb78158d318c6d75","modified":1487823302804},{"_id":"themes/hexo-theme-alex/layout/_widget/tagcloud.ejs","hash":"9028129dd2e56813197d0c38db5df8110aaeaabb","modified":1487823302805},{"_id":"themes/hexo-theme-alex/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1487823302821},{"_id":"themes/hexo-theme-alex/layout/_partial/article.ejs","hash":"46e1ab7f03a7d5a8d15e61c5a8d04ca3d0265047","modified":1487823302800},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1487823302822},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1487823302822},{"_id":"themes/hexo-theme-alex/layout/_partial/header.ejs","hash":"8dc197a5c2dc0ecb37eecd24bd9f4904e4c2a65c","modified":1487832289636},{"_id":"themes/hexo-theme-alex/layout/_partial/head.ejs","hash":"251ee51d3235684e02ed9bf9bb46e0f6229305cd","modified":1487823302801},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1487823302822},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1487823302822},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1487823302825},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1487823302823},{"_id":"themes/hexo-theme-alex/source/js/script.js","hash":"2bc7a12ae95ce9e944282aae8f1ef9c117d0de95","modified":1487823302828},{"_id":"themes/hexo-theme-alex/source/js/jquery.scrollLoading.js","hash":"d0729cb06dd7eefd789e7b6b01fb9b4b691741fb","modified":1487823302828},{"_id":"themes/hexo-theme-alex/source/css/_retina.styl","hash":"1bc8f743af27654ed2353ad36e062e37c27a8681","modified":1487823302813},{"_id":"themes/hexo-theme-alex/source/css/_extend.styl","hash":"eb83c785ce83c277a6f8de9510805595c5d7aa1f","modified":1487823302809},{"_id":"themes/hexo-theme-alex/source/css/style.styl","hash":"ccebcce09864d0ac529ea4aab7fed9edaba098b1","modified":1487835436052},{"_id":"source/_posts/android基础之activity/Activity状态保存示意图.png","hash":"a3fb8aab955cb5e40f1b18d7e1b5c1c2b5df37f6","modified":1488446350543},{"_id":"source/_posts/android基础之activity/activity回调方法汇总.png","hash":"283ffc1469fb33b9df2501d34328db84f14cdf0f","modified":1488447688722},{"_id":"source/_posts/android基础之activity/activity生命周期图.png","hash":"ca76d44f5128a045a225f3597fad78a811f0c70d","modified":1488166113702},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1487823302826},{"_id":"themes/hexo-theme-alex/source/css/_variables.styl","hash":"5435c2f061b5e330e7d7ba74ed9fefea8ae86ad1","modified":1487837769783},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1487823302826},{"_id":"themes/hexo-theme-alex/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1487823302802},{"_id":"themes/hexo-theme-alex/source/js/jquery.min.js","hash":"745ab5d6e434cf8d321779da3c527b6d301e2b50","modified":1487823302827},{"_id":"themes/hexo-theme-alex/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1487823302802},{"_id":"themes/hexo-theme-alex/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1487823302802},{"_id":"themes/hexo-theme-alex/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1487823302803},{"_id":"themes/hexo-theme-alex/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1487823302803},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1487823302823},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1487823302824},{"_id":"themes/hexo-theme-alex/layout/_partial/post/nav.ejs","hash":"eb000d9d8a9ebd9087046fa019abe1cddae8fd9c","modified":1487823302802},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1487823302824},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1487823302824},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1487823302825},{"_id":"themes/hexo-theme-alex/source/css/_partial/comment.styl","hash":"3ca87b9b705ff1594aca7c30e3c887fcfb39e385","modified":1487823302810},{"_id":"themes/hexo-theme-alex/source/css/_partial/footer.styl","hash":"60fc6d6184bab3636e1a0fe0cfe56f969507472e","modified":1487823302810},{"_id":"themes/hexo-theme-alex/source/css/_partial/article.styl","hash":"09aed64e36551899cbd4faf2ae586d6eaf3ffe67","modified":1488514329296},{"_id":"themes/hexo-theme-alex/source/css/_partial/header.styl","hash":"5b8fcd91fe31994a3cf2513a6255242242958a44","modified":1487823302811},{"_id":"themes/hexo-theme-alex/source/css/_partial/highlight.styl","hash":"c125e953fb228d4f0089ea27d1527deca6086016","modified":1487823302811},{"_id":"themes/hexo-theme-alex/source/css/_partial/sidebar-aside.styl","hash":"68ca2d9d9459c84c2de530ca9e3965fb63d75a74","modified":1487823302812},{"_id":"themes/hexo-theme-alex/source/css/_partial/sidebar-bottom.styl","hash":"f6023861b2fbd858946e2108438b5f8f17586179","modified":1487823302812},{"_id":"themes/hexo-theme-alex/source/css/_partial/sidebar.styl","hash":"735e2d5898b585a94b0c16f58bd1b46507c752fb","modified":1487823302812},{"_id":"themes/hexo-theme-alex/source/css/_partial/tablet.styl","hash":"60b666c5b134356721dcf8c73fa0162ff904fe7d","modified":1487823302812},{"_id":"themes/hexo-theme-alex/source/css/_partial/archive.styl","hash":"781116f363edd4b59ef0af64a780e9de4d2c4958","modified":1487823302809},{"_id":"themes/hexo-theme-alex/source/css/_partial/mobile.styl","hash":"948f0b1f8e8b5959e5def27f9f0329cfe4fb159f","modified":1487823302811},{"_id":"themes/hexo-theme-alex/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1487823302813},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1487823302824},{"_id":"themes/hexo-theme-alex/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1487823302813},{"_id":"themes/hexo-theme-alex/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1487823302815},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1487823302819},{"_id":"themes/hexo-theme-alex/source/css/images/logo.png","hash":"d1f41cf04419f22cd15b9e36e0658a7654796036","modified":1487823302820},{"_id":"themes/hexo-theme-alex/source/css/images/logo@2x.png","hash":"f02ae098f6676a0e8d945f13d8150965a2f66985","modified":1487823302820},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY.png","hash":"1d8447ba649e78a1b9b30cecf3424f9c29fa23a9","modified":1487837712110},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1487823302816},{"_id":"themes/hexo-theme-alex/source/css/images/preloader.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1487823302820},{"_id":"themes/hexo-theme-alex/source/css/images/preloader@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1487823302821},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1487823302818},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY@2x.png","hash":"82ee4b7dfaf1a57e2ac5c6a6ce4bcc6a1c372b57","modified":1487837743567},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY1.png","hash":"649ede0e15de250b8c965932c3802a84bea4141d","modified":1487837059798},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1487823302817},{"_id":"public/baidusitemap.xml","hash":"7d3f47d54bea8e8f2097fc62962a4c1fa736b8ba","modified":1488524440428},{"_id":"public/sitemap.xml","hash":"36db8bd89e3067d6d5111fe725ed39186949d64a","modified":1488524440545},{"_id":"public/2017/02/27/android基础之BroadcastReceiver/index.html","hash":"18b98134dfcbe24be9b5ede9b6d025316f06e349","modified":1488449881131},{"_id":"public/2017/02/27/android基础之Content-Providers/index.html","hash":"c771b200be47928b4b973d6167a85d8c44d89670","modified":1488449881225},{"_id":"public/2017/03/01/android基础之消息推送/index.html","hash":"54c5daebdbd914ef5dd3dfee63df956822e2350c","modified":1488449881301},{"_id":"public/2017/02/28/android基础之事件分发机制/index.html","hash":"dbb4cfd552d865188225d5d10e7e8d80d4a8bc5a","modified":1488449881311},{"_id":"public/2017/02/28/android基础之SQLite/index.html","hash":"7fad975f936e132d99c0ee79d1c81a3a23a8b39c","modified":1488449881312},{"_id":"public/2017/02/28/android基础之进程间通信/index.html","hash":"dde7795ec49159a88cad2d638f2c78cfc7fdee83","modified":1488449881312},{"_id":"public/2017/02/28/android基础之数据存储/index.html","hash":"671e40febc08f8ddafa9407af55bebfec2345d3f","modified":1488449881312},{"_id":"public/2017/02/28/android基础之缓存/index.html","hash":"6a43e92ed31c3e07c79fffb2e68aeb0e974d708e","modified":1488449881312},{"_id":"public/2017/02/28/android基础之自定义View与ViewGroup/index.html","hash":"9fe7b7fce10a6e625ad2e5f8190e68c3d3a982c3","modified":1488449881312},{"_id":"public/2017/02/27/android基础之Handler与AsycTask/index.html","hash":"54bdea369c9853b6e968eb73c30a068d590c3456","modified":1488449881312},{"_id":"public/2017/02/27/android基础之Fragments/index.html","hash":"0d52354dbf7ae38dc65f3247e614603a3cdc292e","modified":1488449881312},{"_id":"public/2017/02/27/android基础之Service/index.html","hash":"9dacef4028c512fa820a2ce9be70d02ad3521cba","modified":1488449881312},{"_id":"public/2017/02/18/hexo搭建博客指南（二）-主题配置/index.html","hash":"ccb524ca26fe70f5c08d883e692a0fc06707b6f4","modified":1488449881313},{"_id":"public/2017/02/16/hexo搭建博客指南（一）-建站/index.html","hash":"86fcd2a6c104fca3b40b01f440bbb2380660c58f","modified":1488449881313},{"_id":"public/archives/index.html","hash":"a124e4ca97d167029ecf82c52c8d5ee4c5c78fc7","modified":1488449881313},{"_id":"public/archives/2017/index.html","hash":"6f17d7f95bcc112899f793602576f1376107af32","modified":1488449881313},{"_id":"public/archives/2017/02/index.html","hash":"96d983d909ae995a5a5b2dd93ed84c0a7a7d4e2c","modified":1488449881313},{"_id":"public/index.html","hash":"3210c79df61c207c02030698862411e4a3243bd0","modified":1488449881313},{"_id":"public/categories/hexo/index.html","hash":"e9ead687cb22830ee5323e011fa427bf8a005deb","modified":1488449881313},{"_id":"public/categories/android/index.html","hash":"506ad1459dc639945c61812cb16021d59d15b056","modified":1488449881313},{"_id":"public/tags/android/index.html","hash":"063fa7f140e8027ad0481fa164e32dc962246517","modified":1488449881313},{"_id":"public/tags/java/index.html","hash":"e05e2526433c16366f30eeb8f1ece5d1280017df","modified":1488449881314},{"_id":"public/tags/hexo/index.html","hash":"9d7b1d341181ace056e0f99c87668e366b8045ae","modified":1488449881314},{"_id":"public/2017/02/27/android基础之loaders/index.html","hash":"949eb591e7abcb19ebc4e76c21fdd220ca45d6c7","modified":1488449881314},{"_id":"public/2017/02/27/android基础之Intents与Intent-Filters/index.html","hash":"9e3a2e9647e5ae1462cefd10d3a0df4be4de0ecc","modified":1488449881314},{"_id":"public/2017/02/27/android基础之activity/index.html","hash":"4b367e05653b35aa222a424deeb5cf815bdecfd1","modified":1488524440560},{"_id":"public/archives/page/2/index.html","hash":"3b637c189a59f17eb8cb4c395b18e80be3ed3d10","modified":1488449881325},{"_id":"public/archives/2017/page/2/index.html","hash":"7c8c720aadb09d173caebbbca98a7d851da84fd8","modified":1488449881325},{"_id":"public/archives/2017/02/page/2/index.html","hash":"eac21f49719a44b899340014300c385ed0cb8973","modified":1488449881325},{"_id":"public/archives/2017/03/index.html","hash":"a46bea1e1abf0fd51ab4bb5c95b4895cfa37dcc3","modified":1488449881325},{"_id":"public/page/2/index.html","hash":"11682c51b52eb9d2f1081f6623bfbbaa3c46eb7a","modified":1488524440560},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1488449881325},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1488449881325},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1488449881325},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1488449881325},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1488449881326},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1488449881326},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1488449881326},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1488449881326},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1488449881326},{"_id":"public/css/images/logoDIY.png","hash":"1d8447ba649e78a1b9b30cecf3424f9c29fa23a9","modified":1488449881326},{"_id":"public/css/images/logo@2x.png","hash":"f02ae098f6676a0e8d945f13d8150965a2f66985","modified":1488449881326},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1488449881326},{"_id":"public/css/images/logo.png","hash":"d1f41cf04419f22cd15b9e36e0658a7654796036","modified":1488449881326},{"_id":"public/css/images/preloader@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1488449881326},{"_id":"public/css/images/logoDIY@2x.png","hash":"82ee4b7dfaf1a57e2ac5c6a6ce4bcc6a1c372b57","modified":1488449881326},{"_id":"public/css/images/preloader.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1488449881326},{"_id":"public/css/images/logoDIY1.png","hash":"649ede0e15de250b8c965932c3802a84bea4141d","modified":1488449881326},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1488449882263},{"_id":"public/2017/02/27/android基础之activity/activity生命周期图.png","hash":"ca76d44f5128a045a225f3597fad78a811f0c70d","modified":1488449882265},{"_id":"public/2017/02/27/android基础之activity/activity回调方法汇总.png","hash":"283ffc1469fb33b9df2501d34328db84f14cdf0f","modified":1488449882265},{"_id":"public/2017/02/27/android基础之activity/Activity状态保存示意图.png","hash":"a3fb8aab955cb5e40f1b18d7e1b5c1c2b5df37f6","modified":1488449882265},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1488449882270},{"_id":"public/js/script.js","hash":"26f3e43ae838afa8ebc91fa1732374f8836a9f17","modified":1488449882270},{"_id":"public/js/jquery.scrollLoading.js","hash":"1a3eab1ab2c4644fe1ada921bd1bdb083268a751","modified":1488449882270},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1488449882271},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1488449882271},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1488449882271},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1488449882271},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1488449882271},{"_id":"public/css/style.css","hash":"9f5c32d6fa389736dcd99bc2e97997ecf3c65c94","modified":1488449882271},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1488449882271},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1488449882271},{"_id":"public/js/jquery.min.js","hash":"a6eedf84389e1bc9f757bc2d19538f8c8d1cae9d","modified":1488449882271},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1488449882278}],"Category":[{"name":"android","_id":"cizs8mlzs000780nzexwwrobr"},{"name":"hexo","_id":"cizs8mm1p000s80nzs7db5n9d"}],"Data":[],"Page":[],"Post":[{"title":"android基础之BroadcastReceiver","date":"2017-02-27T06:48:31.000Z","_content":"","source":"_posts/android基础之BroadcastReceiver.md","raw":"---\ntitle: android基础之BroadcastReceiver\ndate: 2017-02-27 14:48:31\ncategories:\ntags:\n---\n","slug":"android基础之BroadcastReceiver","published":1,"updated":"2017-02-27T06:48:31.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizs8mlyo000080nzoy6ysouj","content":"","excerpt":"","more":""},{"title":"android基础之Fragments","date":"2017-02-27T06:31:31.000Z","_content":"","source":"_posts/android基础之Fragments.md","raw":"---\ntitle: android基础之Fragments\ndate: 2017-02-27 14:31:31\ncategories:\ntags:\n---\n","slug":"android基础之Fragments","published":1,"updated":"2017-02-27T06:31:31.514Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizs8mlyu000180nzejirzy0s","content":"","excerpt":"","more":""},{"title":"android基础之Content Providers","date":"2017-02-27T06:32:42.000Z","_content":"","source":"_posts/android基础之Content-Providers.md","raw":"---\ntitle: android基础之Content Providers\ndate: 2017-02-27 14:32:42\ncategories:\ntags:\n---\n","slug":"android基础之Content-Providers","published":1,"updated":"2017-02-27T06:32:42.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizs8mlyx000280nzflcxsu9q","content":"","excerpt":"","more":""},{"title":"android基础之Intents与Intent Filters","date":"2017-02-27T06:32:09.000Z","_content":"","source":"_posts/android基础之Intents与Intent-Filters.md","raw":"---\ntitle: android基础之Intents与Intent Filters\ndate: 2017-02-27 14:32:09\ncategories:\ntags:\n---\n","slug":"android基础之Intents与Intent-Filters","published":1,"updated":"2017-02-27T06:32:09.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizs8mlyy000380nzarldtnnn","content":"","excerpt":"","more":""},{"title":"android基础之Handler与AsycTask","date":"2017-02-27T06:47:53.000Z","_content":"","source":"_posts/android基础之Handler与AsycTask.md","raw":"---\ntitle: android基础之Handler与AsycTask\ndate: 2017-02-27 14:47:53\ncategories:\ntags:\n---\n","slug":"android基础之Handler与AsycTask","published":1,"updated":"2017-02-27T06:47:53.910Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizs8mlyz000480nzi9ddlvb1","content":"","excerpt":"","more":""},{"title":"android基础之Service","date":"2017-02-27T06:06:22.000Z","_content":"\n","source":"_posts/android基础之Service.md","raw":"---\ntitle: android基础之Service\ndate: 2017-02-27 14:06:22\ncategories: android\ntags:\n- android\n- java\n---\n\n","slug":"android基础之Service","published":1,"updated":"2017-02-27T08:35:08.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizs8mlzl000580nz993qcif7","content":"","excerpt":"","more":""},{"title":"android基础之SQLite","date":"2017-02-28T10:03:32.000Z","_content":"","source":"_posts/android基础之SQLite.md","raw":"---\ntitle: android基础之SQLite\ndate: 2017-02-28 18:03:32\ncategories:\ntags:\n---\n","slug":"android基础之SQLite","published":1,"updated":"2017-02-28T10:03:32.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizs8mlzp000680nzdy11l828","content":"","excerpt":"","more":""},{"title":"android基础之activity","date":"2017-02-27T02:35:34.000Z","_content":"\n### 一 Activity简介   \nactivity是android四大组件之一，用于android app的界面显示。activity中包含一个window，window中则包含包含相应的view。\n\n### 二 Activity类的层次结构    \n继承的抽象类： ContextThemeWrapper\n实现的接口： ComponentCallbacks2 KeyEvent.Callback LayoutInflater.Factory2 View.OnCreateContextMenuListener Window.Callback      \n\n```java   \njava.lang.Object   \n\tandroid.content.Context\n\t\tandroid.content.ContextWrapper\n\t\t\tandroid.content.ContextThemeWrapper\n\t\t\t\tandroid.app.Activity\n```\n\n直接子类： AccountAuthenticatorActivity, ActivityGroup, AliasActivity, ExpandableListActivity, FragmentActivity, ListActivity, NativeActivity 　　　\n间接子类： ActionBarActivity, LauncherActivity, PreferenceActivity, TabActivity 　　　\n\n### 三 Activity的生命周期   　\nActivity在它的一生中有以下四种状态：  \n- running：此时Activity处于屏幕的前台并且拥有焦点，位于回退栈的顶部（回退栈将在下面介绍）。   \n- paused： 此时另一个Activity位于前台并拥有焦点，也就是说另一个Activity覆盖在本Activity的上面，但是这个Activity是透明的或者没有占据全屏，即从屏幕上还可以看到下面的Activity（比如弹出个红包）。一个paused的activity是完全存活的（Activity 对象仍然保留在内存里，它保持着所有的状态和成员信息，并且保持与window manager的联接），但在系统内存严重不足的情况下它能被杀死。    \n- stopped： 本Activity被其他Activity完全覆盖了，看不见了。一个stopped的activity也仍然是存活的（Activity 对象仍然保留在内存中，它保持着所有的状态和成员信息，但是不再与window manager联接了）。 但是，对于用户而言它已经不再可见了，并且当其它地方需要内存时它将会被杀死。    \n- killed： 当Activity处于paused或者stopped时，若内存不足，它将可能被干掉。当它被再次创建处于前台时，需要调用onCreate方法重新创建并恢复之前的状态    \n下面是activity的生命周期图：      \n{% asset_img activity生命周期图.png activity生命周期图 %}       \n由上图可以看出activity有三种不同的生命周期：　　\n- 完整生命周期： onCreate--onDestroy    \n- 可见生命周期： onResume到onPause之间循环    \n- 前台生命周期： onStart-onStop-onRestart三者之间循环    \nActivity中的回调方法    \n\n```java\npublic class ExampleActivity extends Activity {\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        // The activity is being created.\n    }\n    @Override\n    protected void onStart() {\n        super.onStart();\n        // The activity is about to become visible.\n    }\n    @Override\n    protected void onResume() {\n        super.onResume();\n        // The activity has become visible (it is now \"resumed\").\n    }\n    @Override\n    protected void onPause() {\n        super.onPause();\n        // Another activity is taking focus (this activity is about to be \"paused\").\n    }\n    @Override\n    protected void onStop() {\n        super.onStop();\n        // The activity is no longer visible (it is now \"stopped\")\n    }\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        // The activity is about to be destroyed.\n    }\n}\n```\n \nActivity回调方法汇总：       \n{% asset_img activity回调方法汇总.png activity回调方法汇总 %}       \n标为“之后可否被杀死？”的列指明了系统是否可以在这个方法返回之后的任意时刻杀掉这个activity的宿主进程， 而不再执行其它流程上的activity代码。 有三个方法是标为“可以”：（ onPause()、 onStop()、 和onDestroy()）。 因为onPause()是三个方法中的第一个， 一旦activity被创建， onPause() 就是进程可以被杀死之前最后一个能确保被调用的方法 ——如果系统在某种紧急情况下必须回收内存，则 onStop() 和onDestroy() 可能就不会被调用了。因此，你应该使用 onPause() 来把至关重要的需长期保存的数据写入存储器（比如用户所编辑的内容）。 不过，应该对必须通过 onPause() 方法进行保存的信息有所选择，因为该方法中所有的阻塞操作都会让切换到下一个activity的停滞，并使用户感觉到迟缓。\n\n“之后可否被杀死？”列中标为“否”的方法，在它们被调用时的那一刻起，就会保护本activity的宿主进程不被杀掉。 因此，只有在 onPause() 方法返回时至 onResume() 方法被调用时之间，activity才会被杀掉。直到 onPause() 再次被调用并返回时，activity都不会再次允许被杀死。\n\nNote:表1中标明的技术上不“可杀”的activity仍然有可能会被系统杀死——但那只有在没有任何资源的极端情况下才会发生。     \n\n### 四 保存Activity的状态    \n上一节中已简单提到，当一个activity被paused或者stopped时，activity的状态可以被保存。 的确如此，因为 Activity 对象在paused或者stopped时仍然被保留在内存之中——它所有的成员信息和当前状态都仍然存活。 这样用户在activity里所作的改动全都还保存着，所以当activity返回到前台时（当它“resume“），那些改动仍然有效。\n\n不过，如果系统是为了回收内存而销毁activity，则这个 Activity 对象就会被销毁，这样系统就无法简单地resume一下就能还原完整状态的activity。 如果用户要返回到这个activity的话，系统必须重新创建这个Activity 对象。可是用户并不知道系统是先销毁activity再重新创建了它的，所以，他很可能希望activity完全保持原样。 这种情况下，你可以保证activity状态的相关重要信息都由另一个回调方法保存下来了，此方法让你能保存activity状态的相关信息： onSaveInstanceState()。\n\n在activity变得很容易被销毁之前，系统会调用 onSaveInstanceState()方法。 调用时系统会传入一个Bundle对象， 你可以利用 putString() 之类的方法，以键值对的方式来把activity状态信息保存到该Bundle对象中。 然后，如果系统杀掉了你的application进程并且用户又返回到你的activity，系统就会重建activity并将这个 Bundle 传入onCreate() 和onRestoreInstanceState() 中，你就可以从 Bundle 中解析出已保存信息并恢复activity状态。如果没有储存状态信息，那么传入的 Bundle 将为null（当activity第一次被创建时就是如此）。     \n下图是Activity状态保存示意图：      \n{% asset_img Activity状态保存示意图.png activity状态保存示意图 %}  \n### 五 配置改动后的处理   \n设备的某些配置可能会在运行时发生变化（比如屏幕方向、键盘可用性以及语言）。 当发生这些变化时，Android会重建这个运行中的activity（系统会调用 onDestroy() ，然后再马上调用 onCreate() ）。这种设计有助于应用程序适用新的参数配置，通过把你预置的可替换资源（比如对应各种屏幕方向和尺寸的layout）自动重新装载进入应用程序的方式来实现。\n\n如果你采取了适当的设计，让activity能够正确地处理这些因为屏幕方向而引起的重启，并能如上所述地恢复activity状态， 那么你的应用程序将对生命周期中其它的意外事件更具适应能力。\n\n处理这类重启的最佳方式，就是利用 onSaveInstanceState() 和onRestoreInstanceState() （或者 onCreate() ）进行状态的保存和恢复，如上节所述。   \n\n### 六 Activity的启动方式   \nantivity的启动方式可以通过两种方式定义：     \n\n##### Androidmanifest文件       \nAndroidmanifest文件是android的清单文件，android的四大组件与相应权限皆需在这里设置。在这里你可以利用 <activity> 元素的 launchMode 属性来设定 activity 与 task 的关系。       \n可通过Androidmanifest文件设置的启动模式有：      \n- standard\n- singleTop\n- singleTask\n- singleInstance       \n\n##### Intent标志     \nIntent标志中有以下几种Activity的启动方式:       \n- FLAG_ACTIVITY_NEW_TASK\n- FLAG_ACTIVITY_SINGLE_TOP\n- FLAG_ACTIVITY_CLEAR_TOP       \n通过Intent标志的方式来启动Activity，优先级比manifest的高。    \n\n> **警告**： 大多数应用不应该改变 activity 和 task 默认的工作方式。 如果你确定有必要修改默认方式，请保持\n谨慎，并确保 activity 在启动和从其它 activity 用回退键返回时的可用性。 请确保对可能与用户预期的导航方式\n相冲突的地方进行测试。      \n\n### 七 启动Activity  \n要启动一个activity需要使用Intent，实际上android中组件之前的通信皆由Intent完成（如果你不了解Intent，请看我之后的博客[android基础之Intents与Intent-Filters.md](android基础之Intents与Intent-Filters.md \"android基础之Intents与Intent-Filters\")），而使用Intent启动activity有显示和隐式两种方式。   \n\n\n1. 显示启动      \n\n     \n```java\nIntent intent = new Intent(this, SignInActivity.class);\nstartActivity(intent);//显示启动一个叫SignInActivity的Activity    \n\n```   \n\n\n\n2.  隐式启动    \n要想隐式启动一个activity，你需要使用intent-filter来暴露你的activity。使用filter有java代码和xml文件两种方式，推荐使用第二种方式，你只需在Androidmanifest.xml文件中的activit元素中加入intent-filter属性，并声明一个action即可。但是如果你想使你的activity更独立，那么就不要为你的activity设置filter。那么什么时候使用这种方式呢？    \n如果，你的程序可能想要展示某些动作，例如发邮件，短信，微博，或者使用你activity中的数据。 这时候，你就不应该使用自己的activity来做这些工作。你应该调用系统中其他程序提供的响应功能。 这是intent真正体现其价值的地方。你可以创建一个描述了响应动作的intent,然后系统来为你挑选完成任务的程序。 如果有多个选择，系统会提示用户进行选择。例如你想让用户发邮件，你可以创建下面的intent：        \n\n\n```java\nIntent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_EMAIL, recipientArray);//recipientArray即你想发送过去的联系人信息\nstartActivity(intent);    \n\n```       \n\n\n3. 启动一个带返回结果的Activity    \n有时候，你想要启动一个activity,并从这个activty获得一个结果。 这时，要通过 startActivityForResult() (取代startActivity()) 来启动activity。 然后通过实现onActivityResult()回调方法来获得返回后的结果。 当这个后续的activity被关闭，它将发送一个 Intent 给 onActivityResult() 方法。     \n  \n例如，你可能想要取一个联系人的信息。下面介绍怎么创建intent并处理结果:         \n\n\n```java\nprivate void pickContact() {\n    // Create an intent to \"pick\" a contact, as defined by the content provider URI\n    Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);\n    startActivityForResult(intent, PICK_CONTACT_REQUEST);\n}\n\n@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    // If the request went well (OK) and the request was PICK_CONTACT_REQUEST\n    if (resultCode == Activity.RESULT_OK && requestCode == PICK_CONTACT_REQUEST) {\n        // Perform a query to the contact's content provider for the contact's name\n        Cursor cursor = getContentResolver().query(data.getData(),\n        new String[] {Contacts.DISPLAY_NAME}, null, null, null);\n        if (cursor.moveToFirst()) { // True if the cursor is not empty\n            int columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);\n            String name = cursor.getString(columnIndex);\n            // Do something with the selected contact's name...\n        }\n    }\n}       \n\n```      \n\n\n这个例子展示了使用onActivityResult() 来获取结果的基本方法。 第一步要判断请求是否被成功响应，通过判断resultCode 是不是RESULT_OK—， 然后判断这个响应是不是针对相应的请求— ，此时只要判断requestCode 和发送时提供的第二个参数 startActivityForResult() 是否相匹配。 最后，查询 Intent中的data信息。 (data 参数)。\n\n这个过程中，ContentResolver 开启了一个查询而不是content provider, 它返回一个 Cursor ，这将允许数据被读取。更多content provider相关信息，请阅读我之后的博客[android基础之Content-Providers.md](android基础之Content-Providers.md \"android基础之Content-Providers\")。     \n\n4. 关闭activity    \n你可以通过调用finish() 来终止activity。 你也可以调用finishActivity() 来终止你之前启动了的一个独立activity。    \n\n> **注意**: 多数情况下，你不应该明确地通过这些方式来关闭acitivity。 就像下面要讨论的activity的生命周期。系统会为你管理。所以你不必关闭他们。 调用这些方法将有悖于用户体验。它们仅用于你绝对不想让用户再返回这个activity的实例。   \n\n\n### 八 Task和back stack    \n一个app通常包含多个activity，android使用task来管理这些activity。当你在手机上没点开一个app，android即为这个app创建一个task，task中有一个back stack，你多点开的activity将依次入栈或者出栈，若你的activity调用别的应用的activity，它也会被压入本activity中。（activity与back stack的关系可阅读上文的activity的启动方式，它定义了activity在back stack中的存在方式）。    \n一个app即对应一个task，若你点开一个新的app，则该新app会进入前台，而之前的会被调入后台。当android的内存不足时，后台的task则可能被销毁。    \n\n其实，activity所处的task可以通过<activity>元素的taskAffinity属性指定，taskAffinity 属性是一个字符串值，必须与<manifest> 元素定义的包名称保证唯一性，因为系统把这个包名称用于标识应用的默认 task affinity值。但是，注意，一般情况下如无必要，不要去修改taskAffinity的值。    \n### 九 总结    \n到这里，android的activity相关的知识已经介绍的差不多了，但是这其中还有很多细节需要读者自己去发现。我所说的并不全面，有些地方可能还有谬误，万不可全信，这些仅仅是我个人的理解。其实博客的功能也只是让你对一个陌生的事物知道个大概，要想最终精通还需要多写多做。这些东西你只有自己经历了，研究了它才能成为你自己的东西，否则不过是镜花水月。   \n作为一个程序员最重要的是勤劳，最后以一句话与大家共勉：慈不掌兵，义不行贾，懒不撸码。\n   \n\n","source":"_posts/android基础之activity.md","raw":"---\ntitle: android基础之activity\ndate: 2017-02-27 10:35:34\ncategories: android\ntags:\n- java\n- android\n---\n\n### 一 Activity简介   \nactivity是android四大组件之一，用于android app的界面显示。activity中包含一个window，window中则包含包含相应的view。\n\n### 二 Activity类的层次结构    \n继承的抽象类： ContextThemeWrapper\n实现的接口： ComponentCallbacks2 KeyEvent.Callback LayoutInflater.Factory2 View.OnCreateContextMenuListener Window.Callback      \n\n```java   \njava.lang.Object   \n\tandroid.content.Context\n\t\tandroid.content.ContextWrapper\n\t\t\tandroid.content.ContextThemeWrapper\n\t\t\t\tandroid.app.Activity\n```\n\n直接子类： AccountAuthenticatorActivity, ActivityGroup, AliasActivity, ExpandableListActivity, FragmentActivity, ListActivity, NativeActivity 　　　\n间接子类： ActionBarActivity, LauncherActivity, PreferenceActivity, TabActivity 　　　\n\n### 三 Activity的生命周期   　\nActivity在它的一生中有以下四种状态：  \n- running：此时Activity处于屏幕的前台并且拥有焦点，位于回退栈的顶部（回退栈将在下面介绍）。   \n- paused： 此时另一个Activity位于前台并拥有焦点，也就是说另一个Activity覆盖在本Activity的上面，但是这个Activity是透明的或者没有占据全屏，即从屏幕上还可以看到下面的Activity（比如弹出个红包）。一个paused的activity是完全存活的（Activity 对象仍然保留在内存里，它保持着所有的状态和成员信息，并且保持与window manager的联接），但在系统内存严重不足的情况下它能被杀死。    \n- stopped： 本Activity被其他Activity完全覆盖了，看不见了。一个stopped的activity也仍然是存活的（Activity 对象仍然保留在内存中，它保持着所有的状态和成员信息，但是不再与window manager联接了）。 但是，对于用户而言它已经不再可见了，并且当其它地方需要内存时它将会被杀死。    \n- killed： 当Activity处于paused或者stopped时，若内存不足，它将可能被干掉。当它被再次创建处于前台时，需要调用onCreate方法重新创建并恢复之前的状态    \n下面是activity的生命周期图：      \n{% asset_img activity生命周期图.png activity生命周期图 %}       \n由上图可以看出activity有三种不同的生命周期：　　\n- 完整生命周期： onCreate--onDestroy    \n- 可见生命周期： onResume到onPause之间循环    \n- 前台生命周期： onStart-onStop-onRestart三者之间循环    \nActivity中的回调方法    \n\n```java\npublic class ExampleActivity extends Activity {\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        // The activity is being created.\n    }\n    @Override\n    protected void onStart() {\n        super.onStart();\n        // The activity is about to become visible.\n    }\n    @Override\n    protected void onResume() {\n        super.onResume();\n        // The activity has become visible (it is now \"resumed\").\n    }\n    @Override\n    protected void onPause() {\n        super.onPause();\n        // Another activity is taking focus (this activity is about to be \"paused\").\n    }\n    @Override\n    protected void onStop() {\n        super.onStop();\n        // The activity is no longer visible (it is now \"stopped\")\n    }\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        // The activity is about to be destroyed.\n    }\n}\n```\n \nActivity回调方法汇总：       \n{% asset_img activity回调方法汇总.png activity回调方法汇总 %}       \n标为“之后可否被杀死？”的列指明了系统是否可以在这个方法返回之后的任意时刻杀掉这个activity的宿主进程， 而不再执行其它流程上的activity代码。 有三个方法是标为“可以”：（ onPause()、 onStop()、 和onDestroy()）。 因为onPause()是三个方法中的第一个， 一旦activity被创建， onPause() 就是进程可以被杀死之前最后一个能确保被调用的方法 ——如果系统在某种紧急情况下必须回收内存，则 onStop() 和onDestroy() 可能就不会被调用了。因此，你应该使用 onPause() 来把至关重要的需长期保存的数据写入存储器（比如用户所编辑的内容）。 不过，应该对必须通过 onPause() 方法进行保存的信息有所选择，因为该方法中所有的阻塞操作都会让切换到下一个activity的停滞，并使用户感觉到迟缓。\n\n“之后可否被杀死？”列中标为“否”的方法，在它们被调用时的那一刻起，就会保护本activity的宿主进程不被杀掉。 因此，只有在 onPause() 方法返回时至 onResume() 方法被调用时之间，activity才会被杀掉。直到 onPause() 再次被调用并返回时，activity都不会再次允许被杀死。\n\nNote:表1中标明的技术上不“可杀”的activity仍然有可能会被系统杀死——但那只有在没有任何资源的极端情况下才会发生。     \n\n### 四 保存Activity的状态    \n上一节中已简单提到，当一个activity被paused或者stopped时，activity的状态可以被保存。 的确如此，因为 Activity 对象在paused或者stopped时仍然被保留在内存之中——它所有的成员信息和当前状态都仍然存活。 这样用户在activity里所作的改动全都还保存着，所以当activity返回到前台时（当它“resume“），那些改动仍然有效。\n\n不过，如果系统是为了回收内存而销毁activity，则这个 Activity 对象就会被销毁，这样系统就无法简单地resume一下就能还原完整状态的activity。 如果用户要返回到这个activity的话，系统必须重新创建这个Activity 对象。可是用户并不知道系统是先销毁activity再重新创建了它的，所以，他很可能希望activity完全保持原样。 这种情况下，你可以保证activity状态的相关重要信息都由另一个回调方法保存下来了，此方法让你能保存activity状态的相关信息： onSaveInstanceState()。\n\n在activity变得很容易被销毁之前，系统会调用 onSaveInstanceState()方法。 调用时系统会传入一个Bundle对象， 你可以利用 putString() 之类的方法，以键值对的方式来把activity状态信息保存到该Bundle对象中。 然后，如果系统杀掉了你的application进程并且用户又返回到你的activity，系统就会重建activity并将这个 Bundle 传入onCreate() 和onRestoreInstanceState() 中，你就可以从 Bundle 中解析出已保存信息并恢复activity状态。如果没有储存状态信息，那么传入的 Bundle 将为null（当activity第一次被创建时就是如此）。     \n下图是Activity状态保存示意图：      \n{% asset_img Activity状态保存示意图.png activity状态保存示意图 %}  \n### 五 配置改动后的处理   \n设备的某些配置可能会在运行时发生变化（比如屏幕方向、键盘可用性以及语言）。 当发生这些变化时，Android会重建这个运行中的activity（系统会调用 onDestroy() ，然后再马上调用 onCreate() ）。这种设计有助于应用程序适用新的参数配置，通过把你预置的可替换资源（比如对应各种屏幕方向和尺寸的layout）自动重新装载进入应用程序的方式来实现。\n\n如果你采取了适当的设计，让activity能够正确地处理这些因为屏幕方向而引起的重启，并能如上所述地恢复activity状态， 那么你的应用程序将对生命周期中其它的意外事件更具适应能力。\n\n处理这类重启的最佳方式，就是利用 onSaveInstanceState() 和onRestoreInstanceState() （或者 onCreate() ）进行状态的保存和恢复，如上节所述。   \n\n### 六 Activity的启动方式   \nantivity的启动方式可以通过两种方式定义：     \n\n##### Androidmanifest文件       \nAndroidmanifest文件是android的清单文件，android的四大组件与相应权限皆需在这里设置。在这里你可以利用 <activity> 元素的 launchMode 属性来设定 activity 与 task 的关系。       \n可通过Androidmanifest文件设置的启动模式有：      \n- standard\n- singleTop\n- singleTask\n- singleInstance       \n\n##### Intent标志     \nIntent标志中有以下几种Activity的启动方式:       \n- FLAG_ACTIVITY_NEW_TASK\n- FLAG_ACTIVITY_SINGLE_TOP\n- FLAG_ACTIVITY_CLEAR_TOP       \n通过Intent标志的方式来启动Activity，优先级比manifest的高。    \n\n> **警告**： 大多数应用不应该改变 activity 和 task 默认的工作方式。 如果你确定有必要修改默认方式，请保持\n谨慎，并确保 activity 在启动和从其它 activity 用回退键返回时的可用性。 请确保对可能与用户预期的导航方式\n相冲突的地方进行测试。      \n\n### 七 启动Activity  \n要启动一个activity需要使用Intent，实际上android中组件之前的通信皆由Intent完成（如果你不了解Intent，请看我之后的博客[android基础之Intents与Intent-Filters.md](android基础之Intents与Intent-Filters.md \"android基础之Intents与Intent-Filters\")），而使用Intent启动activity有显示和隐式两种方式。   \n\n\n1. 显示启动      \n\n     \n```java\nIntent intent = new Intent(this, SignInActivity.class);\nstartActivity(intent);//显示启动一个叫SignInActivity的Activity    \n\n```   \n\n\n\n2.  隐式启动    \n要想隐式启动一个activity，你需要使用intent-filter来暴露你的activity。使用filter有java代码和xml文件两种方式，推荐使用第二种方式，你只需在Androidmanifest.xml文件中的activit元素中加入intent-filter属性，并声明一个action即可。但是如果你想使你的activity更独立，那么就不要为你的activity设置filter。那么什么时候使用这种方式呢？    \n如果，你的程序可能想要展示某些动作，例如发邮件，短信，微博，或者使用你activity中的数据。 这时候，你就不应该使用自己的activity来做这些工作。你应该调用系统中其他程序提供的响应功能。 这是intent真正体现其价值的地方。你可以创建一个描述了响应动作的intent,然后系统来为你挑选完成任务的程序。 如果有多个选择，系统会提示用户进行选择。例如你想让用户发邮件，你可以创建下面的intent：        \n\n\n```java\nIntent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_EMAIL, recipientArray);//recipientArray即你想发送过去的联系人信息\nstartActivity(intent);    \n\n```       \n\n\n3. 启动一个带返回结果的Activity    \n有时候，你想要启动一个activity,并从这个activty获得一个结果。 这时，要通过 startActivityForResult() (取代startActivity()) 来启动activity。 然后通过实现onActivityResult()回调方法来获得返回后的结果。 当这个后续的activity被关闭，它将发送一个 Intent 给 onActivityResult() 方法。     \n  \n例如，你可能想要取一个联系人的信息。下面介绍怎么创建intent并处理结果:         \n\n\n```java\nprivate void pickContact() {\n    // Create an intent to \"pick\" a contact, as defined by the content provider URI\n    Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);\n    startActivityForResult(intent, PICK_CONTACT_REQUEST);\n}\n\n@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    // If the request went well (OK) and the request was PICK_CONTACT_REQUEST\n    if (resultCode == Activity.RESULT_OK && requestCode == PICK_CONTACT_REQUEST) {\n        // Perform a query to the contact's content provider for the contact's name\n        Cursor cursor = getContentResolver().query(data.getData(),\n        new String[] {Contacts.DISPLAY_NAME}, null, null, null);\n        if (cursor.moveToFirst()) { // True if the cursor is not empty\n            int columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);\n            String name = cursor.getString(columnIndex);\n            // Do something with the selected contact's name...\n        }\n    }\n}       \n\n```      \n\n\n这个例子展示了使用onActivityResult() 来获取结果的基本方法。 第一步要判断请求是否被成功响应，通过判断resultCode 是不是RESULT_OK—， 然后判断这个响应是不是针对相应的请求— ，此时只要判断requestCode 和发送时提供的第二个参数 startActivityForResult() 是否相匹配。 最后，查询 Intent中的data信息。 (data 参数)。\n\n这个过程中，ContentResolver 开启了一个查询而不是content provider, 它返回一个 Cursor ，这将允许数据被读取。更多content provider相关信息，请阅读我之后的博客[android基础之Content-Providers.md](android基础之Content-Providers.md \"android基础之Content-Providers\")。     \n\n4. 关闭activity    \n你可以通过调用finish() 来终止activity。 你也可以调用finishActivity() 来终止你之前启动了的一个独立activity。    \n\n> **注意**: 多数情况下，你不应该明确地通过这些方式来关闭acitivity。 就像下面要讨论的activity的生命周期。系统会为你管理。所以你不必关闭他们。 调用这些方法将有悖于用户体验。它们仅用于你绝对不想让用户再返回这个activity的实例。   \n\n\n### 八 Task和back stack    \n一个app通常包含多个activity，android使用task来管理这些activity。当你在手机上没点开一个app，android即为这个app创建一个task，task中有一个back stack，你多点开的activity将依次入栈或者出栈，若你的activity调用别的应用的activity，它也会被压入本activity中。（activity与back stack的关系可阅读上文的activity的启动方式，它定义了activity在back stack中的存在方式）。    \n一个app即对应一个task，若你点开一个新的app，则该新app会进入前台，而之前的会被调入后台。当android的内存不足时，后台的task则可能被销毁。    \n\n其实，activity所处的task可以通过<activity>元素的taskAffinity属性指定，taskAffinity 属性是一个字符串值，必须与<manifest> 元素定义的包名称保证唯一性，因为系统把这个包名称用于标识应用的默认 task affinity值。但是，注意，一般情况下如无必要，不要去修改taskAffinity的值。    \n### 九 总结    \n到这里，android的activity相关的知识已经介绍的差不多了，但是这其中还有很多细节需要读者自己去发现。我所说的并不全面，有些地方可能还有谬误，万不可全信，这些仅仅是我个人的理解。其实博客的功能也只是让你对一个陌生的事物知道个大概，要想最终精通还需要多写多做。这些东西你只有自己经历了，研究了它才能成为你自己的东西，否则不过是镜花水月。   \n作为一个程序员最重要的是勤劳，最后以一句话与大家共勉：慈不掌兵，义不行贾，懒不撸码。\n   \n\n","slug":"android基础之activity","published":1,"updated":"2017-03-03T07:00:33.843Z","_id":"cizs8mm00000980nzzpkcvg9b","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"一-Activity简介\"><a href=\"#一-Activity简介\" class=\"headerlink\" title=\"一 Activity简介\"></a>一 Activity简介</h3><p>activity是android四大组件之一，用于android app的界面显示。activity中包含一个window，window中则包含包含相应的view。</p>\n<h3 id=\"二-Activity类的层次结构\"><a href=\"#二-Activity类的层次结构\" class=\"headerlink\" title=\"二 Activity类的层次结构\"></a>二 Activity类的层次结构</h3><p>继承的抽象类： ContextThemeWrapper<br>实现的接口： ComponentCallbacks2 KeyEvent.Callback LayoutInflater.Factory2 View.OnCreateContextMenuListener Window.Callback      </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.lang.Object   </div><div class=\"line\">\tandroid.content.Context</div><div class=\"line\">\t\tandroid.content.ContextWrapper</div><div class=\"line\">\t\t\tandroid.content.ContextThemeWrapper</div><div class=\"line\">\t\t\t\tandroid.app.Activity</div></pre></td></tr></table></figure>\n<p>直接子类： AccountAuthenticatorActivity, ActivityGroup, AliasActivity, ExpandableListActivity, FragmentActivity, ListActivity, NativeActivity 　　　<br>间接子类： ActionBarActivity, LauncherActivity, PreferenceActivity, TabActivity 　　　</p>\n<h3 id=\"三-Activity的生命周期\"><a href=\"#三-Activity的生命周期\" class=\"headerlink\" title=\"三 Activity的生命周期   　\"></a>三 Activity的生命周期   　</h3><p>Activity在它的一生中有以下四种状态：  </p>\n<ul>\n<li>running：此时Activity处于屏幕的前台并且拥有焦点，位于回退栈的顶部（回退栈将在下面介绍）。   </li>\n<li>paused： 此时另一个Activity位于前台并拥有焦点，也就是说另一个Activity覆盖在本Activity的上面，但是这个Activity是透明的或者没有占据全屏，即从屏幕上还可以看到下面的Activity（比如弹出个红包）。一个paused的activity是完全存活的（Activity 对象仍然保留在内存里，它保持着所有的状态和成员信息，并且保持与window manager的联接），但在系统内存严重不足的情况下它能被杀死。    </li>\n<li>stopped： 本Activity被其他Activity完全覆盖了，看不见了。一个stopped的activity也仍然是存活的（Activity 对象仍然保留在内存中，它保持着所有的状态和成员信息，但是不再与window manager联接了）。 但是，对于用户而言它已经不再可见了，并且当其它地方需要内存时它将会被杀死。    </li>\n<li>killed： 当Activity处于paused或者stopped时，若内存不足，它将可能被干掉。当它被再次创建处于前台时，需要调用onCreate方法重新创建并恢复之前的状态<br>下面是activity的生命周期图：      <img src=\"/2017/02/27/android基础之activity/activity生命周期图.png\" alt=\"activity生命周期图\" title=\"activity生命周期图\">       \n由上图可以看出activity有三种不同的生命周期：　　</li>\n<li>完整生命周期： onCreate–onDestroy    </li>\n<li>可见生命周期： onResume到onPause之间循环    </li>\n<li>前台生命周期： onStart-onStop-onRestart三者之间循环<br>Activity中的回调方法    </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        <span class=\"comment\">// The activity is being created.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onStart();</div><div class=\"line\">        <span class=\"comment\">// The activity is about to become visible.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onResume();</div><div class=\"line\">        <span class=\"comment\">// The activity has become visible (it is now \"resumed\").</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onPause();</div><div class=\"line\">        <span class=\"comment\">// Another activity is taking focus (this activity is about to be \"paused\").</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onStop();</div><div class=\"line\">        <span class=\"comment\">// The activity is no longer visible (it is now \"stopped\")</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</div><div class=\"line\">        <span class=\"comment\">// The activity is about to be destroyed.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Activity回调方法汇总：<br><img src=\"/2017/02/27/android基础之activity/activity回调方法汇总.png\" alt=\"activity回调方法汇总\" title=\"activity回调方法汇总\"><br>标为“之后可否被杀死？”的列指明了系统是否可以在这个方法返回之后的任意时刻杀掉这个activity的宿主进程， 而不再执行其它流程上的activity代码。 有三个方法是标为“可以”：（ onPause()、 onStop()、 和onDestroy()）。 因为onPause()是三个方法中的第一个， 一旦activity被创建， onPause() 就是进程可以被杀死之前最后一个能确保被调用的方法 ——如果系统在某种紧急情况下必须回收内存，则 onStop() 和onDestroy() 可能就不会被调用了。因此，你应该使用 onPause() 来把至关重要的需长期保存的数据写入存储器（比如用户所编辑的内容）。 不过，应该对必须通过 onPause() 方法进行保存的信息有所选择，因为该方法中所有的阻塞操作都会让切换到下一个activity的停滞，并使用户感觉到迟缓。</p>\n<p>“之后可否被杀死？”列中标为“否”的方法，在它们被调用时的那一刻起，就会保护本activity的宿主进程不被杀掉。 因此，只有在 onPause() 方法返回时至 onResume() 方法被调用时之间，activity才会被杀掉。直到 onPause() 再次被调用并返回时，activity都不会再次允许被杀死。</p>\n<p>Note:表1中标明的技术上不“可杀”的activity仍然有可能会被系统杀死——但那只有在没有任何资源的极端情况下才会发生。     </p>\n<h3 id=\"四-保存Activity的状态\"><a href=\"#四-保存Activity的状态\" class=\"headerlink\" title=\"四 保存Activity的状态\"></a>四 保存Activity的状态</h3><p>上一节中已简单提到，当一个activity被paused或者stopped时，activity的状态可以被保存。 的确如此，因为 Activity 对象在paused或者stopped时仍然被保留在内存之中——它所有的成员信息和当前状态都仍然存活。 这样用户在activity里所作的改动全都还保存着，所以当activity返回到前台时（当它“resume“），那些改动仍然有效。</p>\n<p>不过，如果系统是为了回收内存而销毁activity，则这个 Activity 对象就会被销毁，这样系统就无法简单地resume一下就能还原完整状态的activity。 如果用户要返回到这个activity的话，系统必须重新创建这个Activity 对象。可是用户并不知道系统是先销毁activity再重新创建了它的，所以，他很可能希望activity完全保持原样。 这种情况下，你可以保证activity状态的相关重要信息都由另一个回调方法保存下来了，此方法让你能保存activity状态的相关信息： onSaveInstanceState()。</p>\n<p>在activity变得很容易被销毁之前，系统会调用 onSaveInstanceState()方法。 调用时系统会传入一个Bundle对象， 你可以利用 putString() 之类的方法，以键值对的方式来把activity状态信息保存到该Bundle对象中。 然后，如果系统杀掉了你的application进程并且用户又返回到你的activity，系统就会重建activity并将这个 Bundle 传入onCreate() 和onRestoreInstanceState() 中，你就可以从 Bundle 中解析出已保存信息并恢复activity状态。如果没有储存状态信息，那么传入的 Bundle 将为null（当activity第一次被创建时就是如此）。<br>下图是Activity状态保存示意图：<br><img src=\"/2017/02/27/android基础之activity/Activity状态保存示意图.png\" alt=\"activity状态保存示意图\" title=\"activity状态保存示意图\">  </p>\n<h3 id=\"五-配置改动后的处理\"><a href=\"#五-配置改动后的处理\" class=\"headerlink\" title=\"五 配置改动后的处理\"></a>五 配置改动后的处理</h3><p>设备的某些配置可能会在运行时发生变化（比如屏幕方向、键盘可用性以及语言）。 当发生这些变化时，Android会重建这个运行中的activity（系统会调用 onDestroy() ，然后再马上调用 onCreate() ）。这种设计有助于应用程序适用新的参数配置，通过把你预置的可替换资源（比如对应各种屏幕方向和尺寸的layout）自动重新装载进入应用程序的方式来实现。</p>\n<p>如果你采取了适当的设计，让activity能够正确地处理这些因为屏幕方向而引起的重启，并能如上所述地恢复activity状态， 那么你的应用程序将对生命周期中其它的意外事件更具适应能力。</p>\n<p>处理这类重启的最佳方式，就是利用 onSaveInstanceState() 和onRestoreInstanceState() （或者 onCreate() ）进行状态的保存和恢复，如上节所述。   </p>\n<h3 id=\"六-Activity的启动方式\"><a href=\"#六-Activity的启动方式\" class=\"headerlink\" title=\"六 Activity的启动方式\"></a>六 Activity的启动方式</h3><p>antivity的启动方式可以通过两种方式定义：     </p>\n<h5 id=\"Androidmanifest文件\"><a href=\"#Androidmanifest文件\" class=\"headerlink\" title=\"Androidmanifest文件\"></a>Androidmanifest文件</h5><p>Androidmanifest文件是android的清单文件，android的四大组件与相应权限皆需在这里设置。在这里你可以利用 <activity> 元素的 launchMode 属性来设定 activity 与 task 的关系。<br>可通过Androidmanifest文件设置的启动模式有：      </activity></p>\n<ul>\n<li>standard</li>\n<li>singleTop</li>\n<li>singleTask</li>\n<li>singleInstance       </li>\n</ul>\n<h5 id=\"Intent标志\"><a href=\"#Intent标志\" class=\"headerlink\" title=\"Intent标志\"></a>Intent标志</h5><p>Intent标志中有以下几种Activity的启动方式:       </p>\n<ul>\n<li>FLAG_ACTIVITY_NEW_TASK</li>\n<li>FLAG_ACTIVITY_SINGLE_TOP</li>\n<li>FLAG_ACTIVITY_CLEAR_TOP<br>通过Intent标志的方式来启动Activity，优先级比manifest的高。    </li>\n</ul>\n<blockquote>\n<p><strong>警告</strong>： 大多数应用不应该改变 activity 和 task 默认的工作方式。 如果你确定有必要修改默认方式，请保持<br>谨慎，并确保 activity 在启动和从其它 activity 用回退键返回时的可用性。 请确保对可能与用户预期的导航方式<br>相冲突的地方进行测试。      </p>\n</blockquote>\n<h3 id=\"七-启动Activity\"><a href=\"#七-启动Activity\" class=\"headerlink\" title=\"七 启动Activity\"></a>七 启动Activity</h3><p>要启动一个activity需要使用Intent，实际上android中组件之前的通信皆由Intent完成（如果你不了解Intent，请看我之后的博客<a href=\"android基础之Intents与Intent-Filters.md\" title=\"android基础之Intents与Intent-Filters\">android基础之Intents与Intent-Filters.md</a>），而使用Intent启动activity有显示和隐式两种方式。   </p>\n<ol>\n<li>显示启动      </li>\n</ol>\n<pre><code class=\"java\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, SignInActivity.class);\nstartActivity(intent);<span class=\"comment\">//显示启动一个叫SignInActivity的Activity</span>\n</code></pre>\n<ol>\n<li>隐式启动<br>要想隐式启动一个activity，你需要使用intent-filter来暴露你的activity。使用filter有java代码和xml文件两种方式，推荐使用第二种方式，你只需在Androidmanifest.xml文件中的activit元素中加入intent-filter属性，并声明一个action即可。但是如果你想使你的activity更独立，那么就不要为你的activity设置filter。那么什么时候使用这种方式呢？<br>如果，你的程序可能想要展示某些动作，例如发邮件，短信，微博，或者使用你activity中的数据。 这时候，你就不应该使用自己的activity来做这些工作。你应该调用系统中其他程序提供的响应功能。 这是intent真正体现其价值的地方。你可以创建一个描述了响应动作的intent,然后系统来为你挑选完成任务的程序。 如果有多个选择，系统会提示用户进行选择。例如你想让用户发邮件，你可以创建下面的intent：        </li>\n</ol>\n<pre><code class=\"java\">Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_EMAIL, recipientArray);<span class=\"comment\">//recipientArray即你想发送过去的联系人信息</span>\nstartActivity(intent);\n</code></pre>\n<ol>\n<li>启动一个带返回结果的Activity<br>有时候，你想要启动一个activity,并从这个activty获得一个结果。 这时，要通过 startActivityForResult() (取代startActivity()) 来启动activity。 然后通过实现onActivityResult()回调方法来获得返回后的结果。 当这个后续的activity被关闭，它将发送一个 Intent 给 onActivityResult() 方法。     </li>\n</ol>\n<p>例如，你可能想要取一个联系人的信息。下面介绍怎么创建intent并处理结果:         </p>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">pickContact</span><span class=\"params\">()</span> </span>{\n    <span class=\"comment\">// Create an intent to \"pick\" a contact, as defined by the content provider URI</span>\n    Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);\n    startActivityForResult(intent, PICK_CONTACT_REQUEST);\n}\n\n<span class=\"meta\">@Override</span>\n<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> resultCode, Intent data)</span> </span>{\n    <span class=\"comment\">// If the request went well (OK) and the request was PICK_CONTACT_REQUEST</span>\n    <span class=\"keyword\">if</span> (resultCode == Activity.RESULT_OK &amp;&amp; requestCode == PICK_CONTACT_REQUEST) {\n        <span class=\"comment\">// Perform a query to the contact's content provider for the contact's name</span>\n        Cursor cursor = getContentResolver().query(data.getData(),\n        <span class=\"keyword\">new</span> String[] {Contacts.DISPLAY_NAME}, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);\n        <span class=\"keyword\">if</span> (cursor.moveToFirst()) { <span class=\"comment\">// True if the cursor is not empty</span>\n            <span class=\"keyword\">int</span> columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);\n            String name = cursor.getString(columnIndex);\n            <span class=\"comment\">// Do something with the selected contact's name...</span>\n        }\n    }\n}\n</code></pre>\n<p>这个例子展示了使用onActivityResult() 来获取结果的基本方法。 第一步要判断请求是否被成功响应，通过判断resultCode 是不是RESULT_OK—， 然后判断这个响应是不是针对相应的请求— ，此时只要判断requestCode 和发送时提供的第二个参数 startActivityForResult() 是否相匹配。 最后，查询 Intent中的data信息。 (data 参数)。</p>\n<p>这个过程中，ContentResolver 开启了一个查询而不是content provider, 它返回一个 Cursor ，这将允许数据被读取。更多content provider相关信息，请阅读我之后的博客<a href=\"android基础之Content-Providers.md\" title=\"android基础之Content-Providers\">android基础之Content-Providers.md</a>。     </p>\n<ol>\n<li>关闭activity<br>你可以通过调用finish() 来终止activity。 你也可以调用finishActivity() 来终止你之前启动了的一个独立activity。    </li>\n</ol>\n<blockquote>\n<p><strong>注意</strong>: 多数情况下，你不应该明确地通过这些方式来关闭acitivity。 就像下面要讨论的activity的生命周期。系统会为你管理。所以你不必关闭他们。 调用这些方法将有悖于用户体验。它们仅用于你绝对不想让用户再返回这个activity的实例。   </p>\n</blockquote>\n<h3 id=\"八-Task和back-stack\"><a href=\"#八-Task和back-stack\" class=\"headerlink\" title=\"八 Task和back stack\"></a>八 Task和back stack</h3><p>一个app通常包含多个activity，android使用task来管理这些activity。当你在手机上没点开一个app，android即为这个app创建一个task，task中有一个back stack，你多点开的activity将依次入栈或者出栈，若你的activity调用别的应用的activity，它也会被压入本activity中。（activity与back stack的关系可阅读上文的activity的启动方式，它定义了activity在back stack中的存在方式）。<br>一个app即对应一个task，若你点开一个新的app，则该新app会进入前台，而之前的会被调入后台。当android的内存不足时，后台的task则可能被销毁。    </p>\n<p>其实，activity所处的task可以通过<activity>元素的taskAffinity属性指定，taskAffinity 属性是一个字符串值，必须与<manifest> 元素定义的包名称保证唯一性，因为系统把这个包名称用于标识应用的默认 task affinity值。但是，注意，一般情况下如无必要，不要去修改taskAffinity的值。    </manifest></activity></p>\n<h3 id=\"九-总结\"><a href=\"#九-总结\" class=\"headerlink\" title=\"九 总结\"></a>九 总结</h3><p>到这里，android的activity相关的知识已经介绍的差不多了，但是这其中还有很多细节需要读者自己去发现。我所说的并不全面，有些地方可能还有谬误，万不可全信，这些仅仅是我个人的理解。其实博客的功能也只是让你对一个陌生的事物知道个大概，要想最终精通还需要多写多做。这些东西你只有自己经历了，研究了它才能成为你自己的东西，否则不过是镜花水月。<br>作为一个程序员最重要的是勤劳，最后以一句话与大家共勉：慈不掌兵，义不行贾，懒不撸码。</p>\n","excerpt":"","more":"<h3 id=\"一-Activity简介\"><a href=\"#一-Activity简介\" class=\"headerlink\" title=\"一 Activity简介\"></a>一 Activity简介</h3><p>activity是android四大组件之一，用于android app的界面显示。activity中包含一个window，window中则包含包含相应的view。</p>\n<h3 id=\"二-Activity类的层次结构\"><a href=\"#二-Activity类的层次结构\" class=\"headerlink\" title=\"二 Activity类的层次结构\"></a>二 Activity类的层次结构</h3><p>继承的抽象类： ContextThemeWrapper<br>实现的接口： ComponentCallbacks2 KeyEvent.Callback LayoutInflater.Factory2 View.OnCreateContextMenuListener Window.Callback      </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.lang.Object   </div><div class=\"line\">\tandroid.content.Context</div><div class=\"line\">\t\tandroid.content.ContextWrapper</div><div class=\"line\">\t\t\tandroid.content.ContextThemeWrapper</div><div class=\"line\">\t\t\t\tandroid.app.Activity</div></pre></td></tr></table></figure>\n<p>直接子类： AccountAuthenticatorActivity, ActivityGroup, AliasActivity, ExpandableListActivity, FragmentActivity, ListActivity, NativeActivity 　　　<br>间接子类： ActionBarActivity, LauncherActivity, PreferenceActivity, TabActivity 　　　</p>\n<h3 id=\"三-Activity的生命周期\"><a href=\"#三-Activity的生命周期\" class=\"headerlink\" title=\"三 Activity的生命周期   　\"></a>三 Activity的生命周期   　</h3><p>Activity在它的一生中有以下四种状态：  </p>\n<ul>\n<li>running：此时Activity处于屏幕的前台并且拥有焦点，位于回退栈的顶部（回退栈将在下面介绍）。   </li>\n<li>paused： 此时另一个Activity位于前台并拥有焦点，也就是说另一个Activity覆盖在本Activity的上面，但是这个Activity是透明的或者没有占据全屏，即从屏幕上还可以看到下面的Activity（比如弹出个红包）。一个paused的activity是完全存活的（Activity 对象仍然保留在内存里，它保持着所有的状态和成员信息，并且保持与window manager的联接），但在系统内存严重不足的情况下它能被杀死。    </li>\n<li>stopped： 本Activity被其他Activity完全覆盖了，看不见了。一个stopped的activity也仍然是存活的（Activity 对象仍然保留在内存中，它保持着所有的状态和成员信息，但是不再与window manager联接了）。 但是，对于用户而言它已经不再可见了，并且当其它地方需要内存时它将会被杀死。    </li>\n<li>killed： 当Activity处于paused或者stopped时，若内存不足，它将可能被干掉。当它被再次创建处于前台时，需要调用onCreate方法重新创建并恢复之前的状态<br>下面是activity的生命周期图：      <img src=\"/2017/02/27/android基础之activity/activity生命周期图.png\" alt=\"activity生命周期图\" title=\"activity生命周期图\">       \n由上图可以看出activity有三种不同的生命周期：　　</li>\n<li>完整生命周期： onCreate–onDestroy    </li>\n<li>可见生命周期： onResume到onPause之间循环    </li>\n<li>前台生命周期： onStart-onStop-onRestart三者之间循环<br>Activity中的回调方法    </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        <span class=\"comment\">// The activity is being created.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onStart();</div><div class=\"line\">        <span class=\"comment\">// The activity is about to become visible.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onResume();</div><div class=\"line\">        <span class=\"comment\">// The activity has become visible (it is now \"resumed\").</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onPause();</div><div class=\"line\">        <span class=\"comment\">// Another activity is taking focus (this activity is about to be \"paused\").</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onStop();</div><div class=\"line\">        <span class=\"comment\">// The activity is no longer visible (it is now \"stopped\")</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</div><div class=\"line\">        <span class=\"comment\">// The activity is about to be destroyed.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Activity回调方法汇总：<br><img src=\"/2017/02/27/android基础之activity/activity回调方法汇总.png\" alt=\"activity回调方法汇总\" title=\"activity回调方法汇总\"><br>标为“之后可否被杀死？”的列指明了系统是否可以在这个方法返回之后的任意时刻杀掉这个activity的宿主进程， 而不再执行其它流程上的activity代码。 有三个方法是标为“可以”：（ onPause()、 onStop()、 和onDestroy()）。 因为onPause()是三个方法中的第一个， 一旦activity被创建， onPause() 就是进程可以被杀死之前最后一个能确保被调用的方法 ——如果系统在某种紧急情况下必须回收内存，则 onStop() 和onDestroy() 可能就不会被调用了。因此，你应该使用 onPause() 来把至关重要的需长期保存的数据写入存储器（比如用户所编辑的内容）。 不过，应该对必须通过 onPause() 方法进行保存的信息有所选择，因为该方法中所有的阻塞操作都会让切换到下一个activity的停滞，并使用户感觉到迟缓。</p>\n<p>“之后可否被杀死？”列中标为“否”的方法，在它们被调用时的那一刻起，就会保护本activity的宿主进程不被杀掉。 因此，只有在 onPause() 方法返回时至 onResume() 方法被调用时之间，activity才会被杀掉。直到 onPause() 再次被调用并返回时，activity都不会再次允许被杀死。</p>\n<p>Note:表1中标明的技术上不“可杀”的activity仍然有可能会被系统杀死——但那只有在没有任何资源的极端情况下才会发生。     </p>\n<h3 id=\"四-保存Activity的状态\"><a href=\"#四-保存Activity的状态\" class=\"headerlink\" title=\"四 保存Activity的状态\"></a>四 保存Activity的状态</h3><p>上一节中已简单提到，当一个activity被paused或者stopped时，activity的状态可以被保存。 的确如此，因为 Activity 对象在paused或者stopped时仍然被保留在内存之中——它所有的成员信息和当前状态都仍然存活。 这样用户在activity里所作的改动全都还保存着，所以当activity返回到前台时（当它“resume“），那些改动仍然有效。</p>\n<p>不过，如果系统是为了回收内存而销毁activity，则这个 Activity 对象就会被销毁，这样系统就无法简单地resume一下就能还原完整状态的activity。 如果用户要返回到这个activity的话，系统必须重新创建这个Activity 对象。可是用户并不知道系统是先销毁activity再重新创建了它的，所以，他很可能希望activity完全保持原样。 这种情况下，你可以保证activity状态的相关重要信息都由另一个回调方法保存下来了，此方法让你能保存activity状态的相关信息： onSaveInstanceState()。</p>\n<p>在activity变得很容易被销毁之前，系统会调用 onSaveInstanceState()方法。 调用时系统会传入一个Bundle对象， 你可以利用 putString() 之类的方法，以键值对的方式来把activity状态信息保存到该Bundle对象中。 然后，如果系统杀掉了你的application进程并且用户又返回到你的activity，系统就会重建activity并将这个 Bundle 传入onCreate() 和onRestoreInstanceState() 中，你就可以从 Bundle 中解析出已保存信息并恢复activity状态。如果没有储存状态信息，那么传入的 Bundle 将为null（当activity第一次被创建时就是如此）。<br>下图是Activity状态保存示意图：<br><img src=\"/2017/02/27/android基础之activity/Activity状态保存示意图.png\" alt=\"activity状态保存示意图\" title=\"activity状态保存示意图\">  </p>\n<h3 id=\"五-配置改动后的处理\"><a href=\"#五-配置改动后的处理\" class=\"headerlink\" title=\"五 配置改动后的处理\"></a>五 配置改动后的处理</h3><p>设备的某些配置可能会在运行时发生变化（比如屏幕方向、键盘可用性以及语言）。 当发生这些变化时，Android会重建这个运行中的activity（系统会调用 onDestroy() ，然后再马上调用 onCreate() ）。这种设计有助于应用程序适用新的参数配置，通过把你预置的可替换资源（比如对应各种屏幕方向和尺寸的layout）自动重新装载进入应用程序的方式来实现。</p>\n<p>如果你采取了适当的设计，让activity能够正确地处理这些因为屏幕方向而引起的重启，并能如上所述地恢复activity状态， 那么你的应用程序将对生命周期中其它的意外事件更具适应能力。</p>\n<p>处理这类重启的最佳方式，就是利用 onSaveInstanceState() 和onRestoreInstanceState() （或者 onCreate() ）进行状态的保存和恢复，如上节所述。   </p>\n<h3 id=\"六-Activity的启动方式\"><a href=\"#六-Activity的启动方式\" class=\"headerlink\" title=\"六 Activity的启动方式\"></a>六 Activity的启动方式</h3><p>antivity的启动方式可以通过两种方式定义：     </p>\n<h5 id=\"Androidmanifest文件\"><a href=\"#Androidmanifest文件\" class=\"headerlink\" title=\"Androidmanifest文件\"></a>Androidmanifest文件</h5><p>Androidmanifest文件是android的清单文件，android的四大组件与相应权限皆需在这里设置。在这里你可以利用 <activity> 元素的 launchMode 属性来设定 activity 与 task 的关系。<br>可通过Androidmanifest文件设置的启动模式有：      </p>\n<ul>\n<li>standard</li>\n<li>singleTop</li>\n<li>singleTask</li>\n<li>singleInstance       </li>\n</ul>\n<h5 id=\"Intent标志\"><a href=\"#Intent标志\" class=\"headerlink\" title=\"Intent标志\"></a>Intent标志</h5><p>Intent标志中有以下几种Activity的启动方式:       </p>\n<ul>\n<li>FLAG_ACTIVITY_NEW_TASK</li>\n<li>FLAG_ACTIVITY_SINGLE_TOP</li>\n<li>FLAG_ACTIVITY_CLEAR_TOP<br>通过Intent标志的方式来启动Activity，优先级比manifest的高。    </li>\n</ul>\n<blockquote>\n<p><strong>警告</strong>： 大多数应用不应该改变 activity 和 task 默认的工作方式。 如果你确定有必要修改默认方式，请保持<br>谨慎，并确保 activity 在启动和从其它 activity 用回退键返回时的可用性。 请确保对可能与用户预期的导航方式<br>相冲突的地方进行测试。      </p>\n</blockquote>\n<h3 id=\"七-启动Activity\"><a href=\"#七-启动Activity\" class=\"headerlink\" title=\"七 启动Activity\"></a>七 启动Activity</h3><p>要启动一个activity需要使用Intent，实际上android中组件之前的通信皆由Intent完成（如果你不了解Intent，请看我之后的博客<a href=\"android基础之Intents与Intent-Filters.md\" title=\"android基础之Intents与Intent-Filters\">android基础之Intents与Intent-Filters.md</a>），而使用Intent启动activity有显示和隐式两种方式。   </p>\n<ol>\n<li>显示启动      </li>\n</ol>\n<pre><code class=\"java\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, SignInActivity.class);\nstartActivity(intent);<span class=\"comment\">//显示启动一个叫SignInActivity的Activity</span>\n</code></pre>\n<ol>\n<li>隐式启动<br>要想隐式启动一个activity，你需要使用intent-filter来暴露你的activity。使用filter有java代码和xml文件两种方式，推荐使用第二种方式，你只需在Androidmanifest.xml文件中的activit元素中加入intent-filter属性，并声明一个action即可。但是如果你想使你的activity更独立，那么就不要为你的activity设置filter。那么什么时候使用这种方式呢？<br>如果，你的程序可能想要展示某些动作，例如发邮件，短信，微博，或者使用你activity中的数据。 这时候，你就不应该使用自己的activity来做这些工作。你应该调用系统中其他程序提供的响应功能。 这是intent真正体现其价值的地方。你可以创建一个描述了响应动作的intent,然后系统来为你挑选完成任务的程序。 如果有多个选择，系统会提示用户进行选择。例如你想让用户发邮件，你可以创建下面的intent：        </li>\n</ol>\n<pre><code class=\"java\">Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_EMAIL, recipientArray);<span class=\"comment\">//recipientArray即你想发送过去的联系人信息</span>\nstartActivity(intent);\n</code></pre>\n<ol>\n<li>启动一个带返回结果的Activity<br>有时候，你想要启动一个activity,并从这个activty获得一个结果。 这时，要通过 startActivityForResult() (取代startActivity()) 来启动activity。 然后通过实现onActivityResult()回调方法来获得返回后的结果。 当这个后续的activity被关闭，它将发送一个 Intent 给 onActivityResult() 方法。     </li>\n</ol>\n<p>例如，你可能想要取一个联系人的信息。下面介绍怎么创建intent并处理结果:         </p>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">pickContact</span><span class=\"params\">()</span> </span>{\n    <span class=\"comment\">// Create an intent to \"pick\" a contact, as defined by the content provider URI</span>\n    Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);\n    startActivityForResult(intent, PICK_CONTACT_REQUEST);\n}\n\n<span class=\"meta\">@Override</span>\n<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> resultCode, Intent data)</span> </span>{\n    <span class=\"comment\">// If the request went well (OK) and the request was PICK_CONTACT_REQUEST</span>\n    <span class=\"keyword\">if</span> (resultCode == Activity.RESULT_OK &amp;&amp; requestCode == PICK_CONTACT_REQUEST) {\n        <span class=\"comment\">// Perform a query to the contact's content provider for the contact's name</span>\n        Cursor cursor = getContentResolver().query(data.getData(),\n        <span class=\"keyword\">new</span> String[] {Contacts.DISPLAY_NAME}, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);\n        <span class=\"keyword\">if</span> (cursor.moveToFirst()) { <span class=\"comment\">// True if the cursor is not empty</span>\n            <span class=\"keyword\">int</span> columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);\n            String name = cursor.getString(columnIndex);\n            <span class=\"comment\">// Do something with the selected contact's name...</span>\n        }\n    }\n}\n</code></pre>\n<p>这个例子展示了使用onActivityResult() 来获取结果的基本方法。 第一步要判断请求是否被成功响应，通过判断resultCode 是不是RESULT_OK—， 然后判断这个响应是不是针对相应的请求— ，此时只要判断requestCode 和发送时提供的第二个参数 startActivityForResult() 是否相匹配。 最后，查询 Intent中的data信息。 (data 参数)。</p>\n<p>这个过程中，ContentResolver 开启了一个查询而不是content provider, 它返回一个 Cursor ，这将允许数据被读取。更多content provider相关信息，请阅读我之后的博客<a href=\"android基础之Content-Providers.md\" title=\"android基础之Content-Providers\">android基础之Content-Providers.md</a>。     </p>\n<ol>\n<li>关闭activity<br>你可以通过调用finish() 来终止activity。 你也可以调用finishActivity() 来终止你之前启动了的一个独立activity。    </li>\n</ol>\n<blockquote>\n<p><strong>注意</strong>: 多数情况下，你不应该明确地通过这些方式来关闭acitivity。 就像下面要讨论的activity的生命周期。系统会为你管理。所以你不必关闭他们。 调用这些方法将有悖于用户体验。它们仅用于你绝对不想让用户再返回这个activity的实例。   </p>\n</blockquote>\n<h3 id=\"八-Task和back-stack\"><a href=\"#八-Task和back-stack\" class=\"headerlink\" title=\"八 Task和back stack\"></a>八 Task和back stack</h3><p>一个app通常包含多个activity，android使用task来管理这些activity。当你在手机上没点开一个app，android即为这个app创建一个task，task中有一个back stack，你多点开的activity将依次入栈或者出栈，若你的activity调用别的应用的activity，它也会被压入本activity中。（activity与back stack的关系可阅读上文的activity的启动方式，它定义了activity在back stack中的存在方式）。<br>一个app即对应一个task，若你点开一个新的app，则该新app会进入前台，而之前的会被调入后台。当android的内存不足时，后台的task则可能被销毁。    </p>\n<p>其实，activity所处的task可以通过<activity>元素的taskAffinity属性指定，taskAffinity 属性是一个字符串值，必须与<manifest> 元素定义的包名称保证唯一性，因为系统把这个包名称用于标识应用的默认 task affinity值。但是，注意，一般情况下如无必要，不要去修改taskAffinity的值。    </p>\n<h3 id=\"九-总结\"><a href=\"#九-总结\" class=\"headerlink\" title=\"九 总结\"></a>九 总结</h3><p>到这里，android的activity相关的知识已经介绍的差不多了，但是这其中还有很多细节需要读者自己去发现。我所说的并不全面，有些地方可能还有谬误，万不可全信，这些仅仅是我个人的理解。其实博客的功能也只是让你对一个陌生的事物知道个大概，要想最终精通还需要多写多做。这些东西你只有自己经历了，研究了它才能成为你自己的东西，否则不过是镜花水月。<br>作为一个程序员最重要的是勤劳，最后以一句话与大家共勉：慈不掌兵，义不行贾，懒不撸码。</p>\n"},{"title":"android基础之loaders","date":"2017-02-27T06:39:21.000Z","_content":"","source":"_posts/android基础之loaders.md","raw":"---\ntitle: android基础之loaders\ndate: 2017-02-27 14:39:21\ncategories:\ntags:\n---\n","slug":"android基础之loaders","published":1,"updated":"2017-02-27T06:39:22.007Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizs8mm03000a80nzfos5s0iu","content":"","excerpt":"","more":""},{"title":"android基础之数据存储","date":"2017-02-28T09:42:52.000Z","_content":"","source":"_posts/android基础之数据存储.md","raw":"---\ntitle: android基础之数据存储\ndate: 2017-02-28 17:42:52\ncategories:\ntags:\n---\n","slug":"android基础之数据存储","published":1,"updated":"2017-02-28T09:42:52.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizs8mm05000b80nz5w2ygdov","content":"","excerpt":"","more":""},{"title":"android基础之消息推送","date":"2017-03-01T06:28:10.000Z","_content":"","source":"_posts/android基础之消息推送.md","raw":"---\ntitle: android基础之消息推送\ndate: 2017-03-01 14:28:10\ncategories:\ntags:\n---\n","slug":"android基础之消息推送","published":1,"updated":"2017-03-01T06:28:10.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizs8mm0b000e80nzksaux697","content":"","excerpt":"","more":""},{"title":"android基础之事件分发机制","date":"2017-02-28T10:25:28.000Z","_content":"","source":"_posts/android基础之事件分发机制.md","raw":"---\ntitle: android基础之事件分发机制\ndate: 2017-02-28 18:25:28\ncategories:\ntags:\n---\n","slug":"android基础之事件分发机制","published":1,"updated":"2017-02-28T10:25:28.020Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizs8mm0n000g80nz540jevvb","content":"","excerpt":"","more":""},{"title":"android基础之进程间通信","date":"2017-02-28T10:00:00.000Z","_content":"","source":"_posts/android基础之进程间通信.md","raw":"---\ntitle: android基础之进程间通信\ndate: 2017-02-28 18:00:00\ncategories:\ntags:\n---\n","slug":"android基础之进程间通信","published":1,"updated":"2017-02-28T10:00:00.191Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizs8mm0p000i80nz6ygwpitz","content":"","excerpt":"","more":""},{"title":"android基础之自定义View与ViewGroup","date":"2017-02-28T08:02:37.000Z","_content":"","source":"_posts/android基础之自定义View与ViewGroup.md","raw":"---\ntitle: android基础之自定义View与ViewGroup\ndate: 2017-02-28 16:02:37\ncategories:\ntags:\n---\n","slug":"android基础之自定义View与ViewGroup","published":1,"updated":"2017-02-28T08:02:37.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizs8mm0r000l80nzclkmb97r","content":"","excerpt":"","more":""},{"title":"android基础之缓存","date":"2017-02-28T09:10:22.000Z","_content":"","source":"_posts/android基础之缓存.md","raw":"---\ntitle: android基础之缓存\ndate: 2017-02-28 17:10:22\ncategories:\ntags:\n---\n","slug":"android基础之缓存","published":1,"updated":"2017-02-28T09:10:22.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizs8mm0w000o80nzqaalhth5","content":"","excerpt":"","more":""},{"title":"hexo搭建博客指南（二）--主题配置","date":"2017-02-18T07:09:07.000Z","_content":"### 一 主题选择  \n\n&emsp;&emsp;由于hexo默认的主题并不让人满意，因此要想搭建一个让自己心仪的博客你还需要一款好看的主题。hexo的主题你可以冲一下两个网站中获取：  \n[https://github.com/hexojs/hexo/wiki/Themes](https://github.com/hexojs/hexo/wiki/Themes)  \n[https://hexo.io/zh-cn/docs/themes.html](https://hexo.io/zh-cn/docs/themes.html)  \n\n\n### 二 主题配置  \n\n#### 2.1 安装主题\n\n&emsp;&emsp;你可以选择自己心仪的主题，然后改一下hexo的配置文件_config.yml文件。  \n``` bash\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: hexo-theme-air\n``` \n你只需要将它改成你的主题名字  \n\n\n#### 2.2 配置主题  \n&emsp;&emsp;你需要了解一下hexo的主题配置文件_config.yml(注意与hexo根目录下的配置文件不是一个文件)的一些配置:\n``` bash\nmenu:\n  首页: /\n  项目: /项目/\n  职业生涯: /职业生涯/\n  随感: /随感/\n  归档: /archives\n  关于我: /about\n\nwidgets:\n- search\n- category\n- recent_posts\n- tagcloud\n\n```  \n##### **menu**\n&emsp;&emsp;下面的是你想要为你的网站划分的版块。前面是版块名称，后面是相应的路径。你可通过如下命令来新建新的版块页面：  \n``` bash\nhexo new page 版块名\n```  \nhexo会自动在source文件下建立相应的文件夹。   \n**注意：**这里有坑。  \n\n- 我曾新建完一个新的页面后却无法访问，究其原因是当我访问这个页面是浏览器的协议自动从https换成了http，结果找不到资源。原因未知，解决办法：将hexo中的东西都删掉，重搭。。。。。   \n- 又遇一坑，当我将我的版块页面所在的文件夹取名为中文时，我需要在主题配置文件中的menu下相应的版块路径后面多家一个“/”，否则报错，而英文的就不需要，原因未知。\n- 坑3，当使用md写博客时，网站默认quote是居中的，可通过修改主题下的source/css/_partial/article.styl文件中blockquote解决。  \n这些估计都是我选择的light主题中的坑。  \n\n##### **widget**  \n&emsp;&emsp;这下面的是一些网站侧边的一些小部件，比如我的网站右边的分类和标签云。你可以在你的主题下面的/layout/_widget下面找到你的主题支持哪些小部件，你只需要将这些部件名依照格式放在widget下即可显示在网站中。  \n\n##### **categories 和 tags**\n&emsp;&emsp;categories和tags是hexo内置的标签，你只需要在编写博客时加入以下配置：  \n``` bash\n---\ntitle: hexo搭建博客指南（二）--主题配置\ndate: 2017-02-18 15:09:07\ncategories: hexo\ntags:\n- hexo\n---\n``` \n即可在widget中的category和tag中显示你的分类与标签，categories一般用于文章分类，你也可用它来生成你的版块页；tags一般则是用于为搜索引擎提供你这篇博文的关键字。  \n\n### 三 总结\n\n&emsp;&emsp;文章到这里也差不多说完了，hexo的其他知识点你可以通过google搜索或者研究hexo的官方文档[https://hexo.io/zh-cn/docs/asset-folders.html](https://hexo.io/zh-cn/docs/asset-folders.html)来获得。下篇我将介绍hexo的相关插件使用。","source":"_posts/hexo搭建博客指南（二）-主题配置.md","raw":"---\ntitle: hexo搭建博客指南（二）--主题配置\ndate: 2017-02-18 15:09:07\ncategories: hexo\ntags:\n- hexo\n---\n### 一 主题选择  \n\n&emsp;&emsp;由于hexo默认的主题并不让人满意，因此要想搭建一个让自己心仪的博客你还需要一款好看的主题。hexo的主题你可以冲一下两个网站中获取：  \n[https://github.com/hexojs/hexo/wiki/Themes](https://github.com/hexojs/hexo/wiki/Themes)  \n[https://hexo.io/zh-cn/docs/themes.html](https://hexo.io/zh-cn/docs/themes.html)  \n\n\n### 二 主题配置  \n\n#### 2.1 安装主题\n\n&emsp;&emsp;你可以选择自己心仪的主题，然后改一下hexo的配置文件_config.yml文件。  \n``` bash\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: hexo-theme-air\n``` \n你只需要将它改成你的主题名字  \n\n\n#### 2.2 配置主题  \n&emsp;&emsp;你需要了解一下hexo的主题配置文件_config.yml(注意与hexo根目录下的配置文件不是一个文件)的一些配置:\n``` bash\nmenu:\n  首页: /\n  项目: /项目/\n  职业生涯: /职业生涯/\n  随感: /随感/\n  归档: /archives\n  关于我: /about\n\nwidgets:\n- search\n- category\n- recent_posts\n- tagcloud\n\n```  \n##### **menu**\n&emsp;&emsp;下面的是你想要为你的网站划分的版块。前面是版块名称，后面是相应的路径。你可通过如下命令来新建新的版块页面：  \n``` bash\nhexo new page 版块名\n```  \nhexo会自动在source文件下建立相应的文件夹。   \n**注意：**这里有坑。  \n\n- 我曾新建完一个新的页面后却无法访问，究其原因是当我访问这个页面是浏览器的协议自动从https换成了http，结果找不到资源。原因未知，解决办法：将hexo中的东西都删掉，重搭。。。。。   \n- 又遇一坑，当我将我的版块页面所在的文件夹取名为中文时，我需要在主题配置文件中的menu下相应的版块路径后面多家一个“/”，否则报错，而英文的就不需要，原因未知。\n- 坑3，当使用md写博客时，网站默认quote是居中的，可通过修改主题下的source/css/_partial/article.styl文件中blockquote解决。  \n这些估计都是我选择的light主题中的坑。  \n\n##### **widget**  \n&emsp;&emsp;这下面的是一些网站侧边的一些小部件，比如我的网站右边的分类和标签云。你可以在你的主题下面的/layout/_widget下面找到你的主题支持哪些小部件，你只需要将这些部件名依照格式放在widget下即可显示在网站中。  \n\n##### **categories 和 tags**\n&emsp;&emsp;categories和tags是hexo内置的标签，你只需要在编写博客时加入以下配置：  \n``` bash\n---\ntitle: hexo搭建博客指南（二）--主题配置\ndate: 2017-02-18 15:09:07\ncategories: hexo\ntags:\n- hexo\n---\n``` \n即可在widget中的category和tag中显示你的分类与标签，categories一般用于文章分类，你也可用它来生成你的版块页；tags一般则是用于为搜索引擎提供你这篇博文的关键字。  \n\n### 三 总结\n\n&emsp;&emsp;文章到这里也差不多说完了，hexo的其他知识点你可以通过google搜索或者研究hexo的官方文档[https://hexo.io/zh-cn/docs/asset-folders.html](https://hexo.io/zh-cn/docs/asset-folders.html)来获得。下篇我将介绍hexo的相关插件使用。","slug":"hexo搭建博客指南（二）-主题配置","published":1,"updated":"2017-02-23T10:55:17.467Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizs8mm1a000r80nz3mst9j59","content":"<h3 id=\"一-主题选择\"><a href=\"#一-主题选择\" class=\"headerlink\" title=\"一 主题选择\"></a>一 主题选择</h3><p>&emsp;&emsp;由于hexo默认的主题并不让人满意，因此要想搭建一个让自己心仪的博客你还需要一款好看的主题。hexo的主题你可以冲一下两个网站中获取：<br><a href=\"https://github.com/hexojs/hexo/wiki/Themes\" target=\"_blank\" rel=\"external\">https://github.com/hexojs/hexo/wiki/Themes</a><br><a href=\"https://hexo.io/zh-cn/docs/themes.html\" target=\"_blank\" rel=\"external\">https://hexo.io/zh-cn/docs/themes.html</a>  </p>\n<h3 id=\"二-主题配置\"><a href=\"#二-主题配置\" class=\"headerlink\" title=\"二 主题配置\"></a>二 主题配置</h3><h4 id=\"2-1-安装主题\"><a href=\"#2-1-安装主题\" class=\"headerlink\" title=\"2.1 安装主题\"></a>2.1 安装主题</h4><p>&emsp;&emsp;你可以选择自己心仪的主题，然后改一下hexo的配置文件_config.yml文件。  </p>\n<pre><code class=\"bash\"><span class=\"comment\"># Extensions</span>\n<span class=\"comment\">## Plugins: https://hexo.io/plugins/</span>\n<span class=\"comment\">## Themes: https://hexo.io/themes/</span>\ntheme: hexo-theme-air\n</code></pre>\n<p>你只需要将它改成你的主题名字  </p>\n<h4 id=\"2-2-配置主题\"><a href=\"#2-2-配置主题\" class=\"headerlink\" title=\"2.2 配置主题\"></a>2.2 配置主题</h4><p>&emsp;&emsp;你需要了解一下hexo的主题配置文件_config.yml(注意与hexo根目录下的配置文件不是一个文件)的一些配置:</p>\n<pre><code class=\"bash\">menu:\n  首页: /\n  项目: /项目/\n  职业生涯: /职业生涯/\n  随感: /随感/\n  归档: /archives\n  关于我: /about\n\nwidgets:\n- search\n- category\n- recent_posts\n- tagcloud\n</code></pre>\n<h5 id=\"menu\"><a href=\"#menu\" class=\"headerlink\" title=\"menu\"></a><strong>menu</strong></h5><p>&emsp;&emsp;下面的是你想要为你的网站划分的版块。前面是版块名称，后面是相应的路径。你可通过如下命令来新建新的版块页面：  </p>\n<pre><code class=\"bash\">hexo new page 版块名\n</code></pre>\n<p>hexo会自动在source文件下建立相应的文件夹。<br><strong>注意：</strong>这里有坑。  </p>\n<ul>\n<li>我曾新建完一个新的页面后却无法访问，究其原因是当我访问这个页面是浏览器的协议自动从https换成了http，结果找不到资源。原因未知，解决办法：将hexo中的东西都删掉，重搭。。。。。   </li>\n<li>又遇一坑，当我将我的版块页面所在的文件夹取名为中文时，我需要在主题配置文件中的menu下相应的版块路径后面多家一个“/”，否则报错，而英文的就不需要，原因未知。</li>\n<li>坑3，当使用md写博客时，网站默认quote是居中的，可通过修改主题下的source/css/_partial/article.styl文件中blockquote解决。<br>这些估计都是我选择的light主题中的坑。  </li>\n</ul>\n<h5 id=\"widget\"><a href=\"#widget\" class=\"headerlink\" title=\"widget\"></a><strong>widget</strong></h5><p>&emsp;&emsp;这下面的是一些网站侧边的一些小部件，比如我的网站右边的分类和标签云。你可以在你的主题下面的/layout/_widget下面找到你的主题支持哪些小部件，你只需要将这些部件名依照格式放在widget下即可显示在网站中。  </p>\n<h5 id=\"categories-和-tags\"><a href=\"#categories-和-tags\" class=\"headerlink\" title=\"categories 和 tags\"></a><strong>categories 和 tags</strong></h5><p>&emsp;&emsp;categories和tags是hexo内置的标签，你只需要在编写博客时加入以下配置：  </p>\n<pre><code class=\"bash\">---\ntitle: hexo搭建博客指南（二）--主题配置\ndate: 2017-02-18 15:09:07\ncategories: hexo\ntags:\n- hexo\n---\n</code></pre>\n<p>即可在widget中的category和tag中显示你的分类与标签，categories一般用于文章分类，你也可用它来生成你的版块页；tags一般则是用于为搜索引擎提供你这篇博文的关键字。  </p>\n<h3 id=\"三-总结\"><a href=\"#三-总结\" class=\"headerlink\" title=\"三 总结\"></a>三 总结</h3><p>&emsp;&emsp;文章到这里也差不多说完了，hexo的其他知识点你可以通过google搜索或者研究hexo的官方文档<a href=\"https://hexo.io/zh-cn/docs/asset-folders.html\" target=\"_blank\" rel=\"external\">https://hexo.io/zh-cn/docs/asset-folders.html</a>来获得。下篇我将介绍hexo的相关插件使用。</p>\n","excerpt":"","more":"<h3 id=\"一-主题选择\"><a href=\"#一-主题选择\" class=\"headerlink\" title=\"一 主题选择\"></a>一 主题选择</h3><p>&emsp;&emsp;由于hexo默认的主题并不让人满意，因此要想搭建一个让自己心仪的博客你还需要一款好看的主题。hexo的主题你可以冲一下两个网站中获取：<br><a href=\"https://github.com/hexojs/hexo/wiki/Themes\">https://github.com/hexojs/hexo/wiki/Themes</a><br><a href=\"https://hexo.io/zh-cn/docs/themes.html\">https://hexo.io/zh-cn/docs/themes.html</a>  </p>\n<h3 id=\"二-主题配置\"><a href=\"#二-主题配置\" class=\"headerlink\" title=\"二 主题配置\"></a>二 主题配置</h3><h4 id=\"2-1-安装主题\"><a href=\"#2-1-安装主题\" class=\"headerlink\" title=\"2.1 安装主题\"></a>2.1 安装主题</h4><p>&emsp;&emsp;你可以选择自己心仪的主题，然后改一下hexo的配置文件_config.yml文件。  </p>\n<pre><code class=\"bash\"><span class=\"comment\"># Extensions</span>\n<span class=\"comment\">## Plugins: https://hexo.io/plugins/</span>\n<span class=\"comment\">## Themes: https://hexo.io/themes/</span>\ntheme: hexo-theme-air\n</code></pre>\n<p>你只需要将它改成你的主题名字  </p>\n<h4 id=\"2-2-配置主题\"><a href=\"#2-2-配置主题\" class=\"headerlink\" title=\"2.2 配置主题\"></a>2.2 配置主题</h4><p>&emsp;&emsp;你需要了解一下hexo的主题配置文件_config.yml(注意与hexo根目录下的配置文件不是一个文件)的一些配置:</p>\n<pre><code class=\"bash\">menu:\n  首页: /\n  项目: /项目/\n  职业生涯: /职业生涯/\n  随感: /随感/\n  归档: /archives\n  关于我: /about\n\nwidgets:\n- search\n- category\n- recent_posts\n- tagcloud\n</code></pre>\n<h5 id=\"menu\"><a href=\"#menu\" class=\"headerlink\" title=\"menu\"></a><strong>menu</strong></h5><p>&emsp;&emsp;下面的是你想要为你的网站划分的版块。前面是版块名称，后面是相应的路径。你可通过如下命令来新建新的版块页面：  </p>\n<pre><code class=\"bash\">hexo new page 版块名\n</code></pre>\n<p>hexo会自动在source文件下建立相应的文件夹。<br><strong>注意：</strong>这里有坑。  </p>\n<ul>\n<li>我曾新建完一个新的页面后却无法访问，究其原因是当我访问这个页面是浏览器的协议自动从https换成了http，结果找不到资源。原因未知，解决办法：将hexo中的东西都删掉，重搭。。。。。   </li>\n<li>又遇一坑，当我将我的版块页面所在的文件夹取名为中文时，我需要在主题配置文件中的menu下相应的版块路径后面多家一个“/”，否则报错，而英文的就不需要，原因未知。</li>\n<li>坑3，当使用md写博客时，网站默认quote是居中的，可通过修改主题下的source/css/_partial/article.styl文件中blockquote解决。<br>这些估计都是我选择的light主题中的坑。  </li>\n</ul>\n<h5 id=\"widget\"><a href=\"#widget\" class=\"headerlink\" title=\"widget\"></a><strong>widget</strong></h5><p>&emsp;&emsp;这下面的是一些网站侧边的一些小部件，比如我的网站右边的分类和标签云。你可以在你的主题下面的/layout/_widget下面找到你的主题支持哪些小部件，你只需要将这些部件名依照格式放在widget下即可显示在网站中。  </p>\n<h5 id=\"categories-和-tags\"><a href=\"#categories-和-tags\" class=\"headerlink\" title=\"categories 和 tags\"></a><strong>categories 和 tags</strong></h5><p>&emsp;&emsp;categories和tags是hexo内置的标签，你只需要在编写博客时加入以下配置：  </p>\n<pre><code class=\"bash\">---\ntitle: hexo搭建博客指南（二）--主题配置\ndate: 2017-02-18 15:09:07\ncategories: hexo\ntags:\n- hexo\n---\n</code></pre>\n<p>即可在widget中的category和tag中显示你的分类与标签，categories一般用于文章分类，你也可用它来生成你的版块页；tags一般则是用于为搜索引擎提供你这篇博文的关键字。  </p>\n<h3 id=\"三-总结\"><a href=\"#三-总结\" class=\"headerlink\" title=\"三 总结\"></a>三 总结</h3><p>&emsp;&emsp;文章到这里也差不多说完了，hexo的其他知识点你可以通过google搜索或者研究hexo的官方文档<a href=\"https://hexo.io/zh-cn/docs/asset-folders.html\">https://hexo.io/zh-cn/docs/asset-folders.html</a>来获得。下篇我将介绍hexo的相关插件使用。</p>\n"},{"title":"hexo搭建博客指南（一）--建站","date":"2017-02-16T07:08:29.000Z","_content":"### 一 hexo简介   \n\n> hexo是一款快速，高效，简洁的博客框架。\n\n### 二 搭建博客   \n\n#### 2.1 安装环境\n\n&emsp;&emsp;hexo是基于node.js的，因此要想使用hexo，必须安装node环境，同时还需要git，用于将hexo部署到github上。所需软件：  \nnode.js &emsp;&emsp;下载链接：[http://nodejs.cn/download/](http://nodejs.cn/download/)  \ngit &emsp;&emsp;&emsp;&emsp;下载链接：[https://git-for-windows.github.io/](https://git-for-windows.github.io/)  \n\n\n下载后直接安装，完成后打开windows的cmd，输入以下命令：  \n\n``` bash\nnode -v    \nnpm -v \n```        \n\n当出现以下信息时，则说明安装成功。    \n   \n``` bash\nzhengrui-ds@ZHENGRUI-DS MINGW64 ~\n$ node -v\nv6.9.4\n\nzhengrui-ds@ZHENGRUI-DS MINGW64 ~\n$ npm -v\n3.10.10\n```\n\n\n#### 2.2 安装hexo    \n\n安装客户端   \n\n```bash\nnpm install -g hexo-cli    \n```   \n\n安装服务端  \n\n```bash\nnpm install hexo --save   \n```   \n\n新建一个用于装在hexo的文件夹，如hexo  \n切换到该文件夹，执行以下命令：   \n\n```bash\n hexo init  //初始化该文件夹  \n npm install  //安装相应的依赖包\n```    \n\n此时hexo搭建博客已基本完成。可执行以下命令来查看博客的初始效果：  \n\n```bash\n\thexo clean   //清空public文件夹下面的内容，该文件夹用于存放生成的网页文件。  \n\thexo g       //该命令用于产生相应的网页文件，在public文件夹下  \n\thexo s      //启动一个本地服务器，一般是http://localhost:4000，可查看生成的网页情况。\n```    \n\n**注意**：有时会存在4000端口被占用的情况，此时可以使用hexo s -p 端口号&emsp;来指定端口号。其实如果你有使用linux的经验，应该知道这些命令一般都可以在命令的后面加上-h或者--help来查看它的用法。hexo中的命令可以连写，如hexo g与hexo s可合写成hexo s -g  \n\n#### 2.3 将博客部署到github上  \n&emsp;&emsp;要想将博客部署到github上，你需要先有一个github账号，并且将你本地的git（计算机）与github关联起来。本文已认为你已经有了自己的github账号并已关联本地，如果没有请移步我的另一篇博客TODO  \n其次你需要了解一下hexo的配置文件_config.yml：  \n站点配置\n``` bash\n# Site\ntitle: ZHENGRUI'BLOG\nsubtitle: 今日之果，皆因曾经之因\ndescription:\nauthor: zhengrui\nlanguage: zh-CN\ntimezone:\n``` \n将博客部署到github上  \n``` bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: git@github.com:zhezaoyizhuding/zhezaoyizhuding.github.io.git\n  branch: master\n```  \n你需要执行以下命令，安装hexo的git插件  \n\n```bash\nnpm install hexo-deployer-git --save\n```    \n\n后面要加--save否则无法将依赖写入hexo的package.json中，执行以下命令即可将网站部署到github上。  \n\n```bash\nhexo d\n```  \n\n至此你一讲将博客部署到github上了，在浏览器输入https://你的github用户名.github.io即可访问。","source":"_posts/hexo搭建博客指南（一）-建站.md","raw":"---\ntitle: hexo搭建博客指南（一）--建站\ndate: 2017-02-16 15:08:29\ncategories: hexo\ntags:\n- hexo\n---\n### 一 hexo简介   \n\n> hexo是一款快速，高效，简洁的博客框架。\n\n### 二 搭建博客   \n\n#### 2.1 安装环境\n\n&emsp;&emsp;hexo是基于node.js的，因此要想使用hexo，必须安装node环境，同时还需要git，用于将hexo部署到github上。所需软件：  \nnode.js &emsp;&emsp;下载链接：[http://nodejs.cn/download/](http://nodejs.cn/download/)  \ngit &emsp;&emsp;&emsp;&emsp;下载链接：[https://git-for-windows.github.io/](https://git-for-windows.github.io/)  \n\n\n下载后直接安装，完成后打开windows的cmd，输入以下命令：  \n\n``` bash\nnode -v    \nnpm -v \n```        \n\n当出现以下信息时，则说明安装成功。    \n   \n``` bash\nzhengrui-ds@ZHENGRUI-DS MINGW64 ~\n$ node -v\nv6.9.4\n\nzhengrui-ds@ZHENGRUI-DS MINGW64 ~\n$ npm -v\n3.10.10\n```\n\n\n#### 2.2 安装hexo    \n\n安装客户端   \n\n```bash\nnpm install -g hexo-cli    \n```   \n\n安装服务端  \n\n```bash\nnpm install hexo --save   \n```   \n\n新建一个用于装在hexo的文件夹，如hexo  \n切换到该文件夹，执行以下命令：   \n\n```bash\n hexo init  //初始化该文件夹  \n npm install  //安装相应的依赖包\n```    \n\n此时hexo搭建博客已基本完成。可执行以下命令来查看博客的初始效果：  \n\n```bash\n\thexo clean   //清空public文件夹下面的内容，该文件夹用于存放生成的网页文件。  \n\thexo g       //该命令用于产生相应的网页文件，在public文件夹下  \n\thexo s      //启动一个本地服务器，一般是http://localhost:4000，可查看生成的网页情况。\n```    \n\n**注意**：有时会存在4000端口被占用的情况，此时可以使用hexo s -p 端口号&emsp;来指定端口号。其实如果你有使用linux的经验，应该知道这些命令一般都可以在命令的后面加上-h或者--help来查看它的用法。hexo中的命令可以连写，如hexo g与hexo s可合写成hexo s -g  \n\n#### 2.3 将博客部署到github上  \n&emsp;&emsp;要想将博客部署到github上，你需要先有一个github账号，并且将你本地的git（计算机）与github关联起来。本文已认为你已经有了自己的github账号并已关联本地，如果没有请移步我的另一篇博客TODO  \n其次你需要了解一下hexo的配置文件_config.yml：  \n站点配置\n``` bash\n# Site\ntitle: ZHENGRUI'BLOG\nsubtitle: 今日之果，皆因曾经之因\ndescription:\nauthor: zhengrui\nlanguage: zh-CN\ntimezone:\n``` \n将博客部署到github上  \n``` bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: git@github.com:zhezaoyizhuding/zhezaoyizhuding.github.io.git\n  branch: master\n```  \n你需要执行以下命令，安装hexo的git插件  \n\n```bash\nnpm install hexo-deployer-git --save\n```    \n\n后面要加--save否则无法将依赖写入hexo的package.json中，执行以下命令即可将网站部署到github上。  \n\n```bash\nhexo d\n```  \n\n至此你一讲将博客部署到github上了，在浏览器输入https://你的github用户名.github.io即可访问。","slug":"hexo搭建博客指南（一）-建站","published":1,"updated":"2017-02-23T08:34:12.388Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizs8mm29000w80nzzp8i3r7z","content":"<h3 id=\"一-hexo简介\"><a href=\"#一-hexo简介\" class=\"headerlink\" title=\"一 hexo简介\"></a>一 hexo简介</h3><blockquote>\n<p>hexo是一款快速，高效，简洁的博客框架。</p>\n</blockquote>\n<h3 id=\"二-搭建博客\"><a href=\"#二-搭建博客\" class=\"headerlink\" title=\"二 搭建博客\"></a>二 搭建博客</h3><h4 id=\"2-1-安装环境\"><a href=\"#2-1-安装环境\" class=\"headerlink\" title=\"2.1 安装环境\"></a>2.1 安装环境</h4><p>&emsp;&emsp;hexo是基于node.js的，因此要想使用hexo，必须安装node环境，同时还需要git，用于将hexo部署到github上。所需软件：<br>node.js &emsp;&emsp;下载链接：<a href=\"http://nodejs.cn/download/\" target=\"_blank\" rel=\"external\">http://nodejs.cn/download/</a><br>git &emsp;&emsp;&emsp;&emsp;下载链接：<a href=\"https://git-for-windows.github.io/\" target=\"_blank\" rel=\"external\">https://git-for-windows.github.io/</a>  </p>\n<p>下载后直接安装，完成后打开windows的cmd，输入以下命令：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">node -v    </div><div class=\"line\">npm -v </div><div class=\"line\">```        </div><div class=\"line\"></div><div class=\"line\">当出现以下信息时，则说明安装成功。    </div><div class=\"line\">   </div><div class=\"line\">``` bash</div><div class=\"line\">zhengrui-ds@ZHENGRUI-DS MINGW64 ~</div><div class=\"line\">$ node -v</div><div class=\"line\">v6.9.4</div><div class=\"line\"></div><div class=\"line\">zhengrui-ds@ZHENGRUI-DS MINGW64 ~</div><div class=\"line\">$ npm -v</div><div class=\"line\">3.10.10</div></pre></td></tr></table></figure>\n<h4 id=\"2-2-安装hexo\"><a href=\"#2-2-安装hexo\" class=\"headerlink\" title=\"2.2 安装hexo\"></a>2.2 安装hexo</h4><p>安装客户端   </p>\n<pre><code class=\"bash\">npm install -g hexo-cli\n</code></pre>\n<p>安装服务端  </p>\n<pre><code class=\"bash\">npm install hexo --save\n</code></pre>\n<p>新建一个用于装在hexo的文件夹，如hexo<br>切换到该文件夹，执行以下命令：   </p>\n<pre><code class=\"bash\">hexo init  //初始化该文件夹  \nnpm install  //安装相应的依赖包\n</code></pre>\n<p>此时hexo搭建博客已基本完成。可执行以下命令来查看博客的初始效果：  </p>\n<pre><code class=\"bash\">hexo clean   //清空public文件夹下面的内容，该文件夹用于存放生成的网页文件。  \nhexo g       //该命令用于产生相应的网页文件，在public文件夹下  \nhexo s      //启动一个本地服务器，一般是http://localhost:4000，可查看生成的网页情况。\n</code></pre>\n<p><strong>注意</strong>：有时会存在4000端口被占用的情况，此时可以使用hexo s -p 端口号&emsp;来指定端口号。其实如果你有使用linux的经验，应该知道这些命令一般都可以在命令的后面加上-h或者–help来查看它的用法。hexo中的命令可以连写，如hexo g与hexo s可合写成hexo s -g  </p>\n<h4 id=\"2-3-将博客部署到github上\"><a href=\"#2-3-将博客部署到github上\" class=\"headerlink\" title=\"2.3 将博客部署到github上\"></a>2.3 将博客部署到github上</h4><p>&emsp;&emsp;要想将博客部署到github上，你需要先有一个github账号，并且将你本地的git（计算机）与github关联起来。本文已认为你已经有了自己的github账号并已关联本地，如果没有请移步我的另一篇博客TODO<br>其次你需要了解一下hexo的配置文件_config.yml：<br>站点配置</p>\n<pre><code class=\"bash\"><span class=\"comment\"># Site</span>\ntitle: ZHENGRUI<span class=\"string\">'BLOG\nsubtitle: 今日之果，皆因曾经之因\ndescription:\nauthor: zhengrui\nlanguage: zh-CN\ntimezone:</span>\n</code></pre>\n<p>将博客部署到github上  </p>\n<pre><code class=\"bash\"><span class=\"comment\"># Deployment</span>\n<span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span>\ndeploy:\n  <span class=\"built_in\">type</span>: git\n  repo: git@github.com:zhezaoyizhuding/zhezaoyizhuding.github.io.git\n  branch: master\n</code></pre>\n<p>你需要执行以下命令，安装hexo的git插件  </p>\n<pre><code class=\"bash\">npm install hexo-deployer-git --save\n</code></pre>\n<p>后面要加–save否则无法将依赖写入hexo的package.json中，执行以下命令即可将网站部署到github上。  </p>\n<pre><code class=\"bash\">hexo d\n</code></pre>\n<p>至此你一讲将博客部署到github上了，在浏览器输入<a href=\"https://你的github用户名.github.io即可访问。\" target=\"_blank\" rel=\"external\">https://你的github用户名.github.io即可访问。</a></p>\n","excerpt":"","more":"<h3 id=\"一-hexo简介\"><a href=\"#一-hexo简介\" class=\"headerlink\" title=\"一 hexo简介\"></a>一 hexo简介</h3><blockquote>\n<p>hexo是一款快速，高效，简洁的博客框架。</p>\n</blockquote>\n<h3 id=\"二-搭建博客\"><a href=\"#二-搭建博客\" class=\"headerlink\" title=\"二 搭建博客\"></a>二 搭建博客</h3><h4 id=\"2-1-安装环境\"><a href=\"#2-1-安装环境\" class=\"headerlink\" title=\"2.1 安装环境\"></a>2.1 安装环境</h4><p>&emsp;&emsp;hexo是基于node.js的，因此要想使用hexo，必须安装node环境，同时还需要git，用于将hexo部署到github上。所需软件：<br>node.js &emsp;&emsp;下载链接：<a href=\"http://nodejs.cn/download/\">http://nodejs.cn/download/</a><br>git &emsp;&emsp;&emsp;&emsp;下载链接：<a href=\"https://git-for-windows.github.io/\">https://git-for-windows.github.io/</a>  </p>\n<p>下载后直接安装，完成后打开windows的cmd，输入以下命令：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">node -v    </div><div class=\"line\">npm -v </div><div class=\"line\">```        </div><div class=\"line\"></div><div class=\"line\">当出现以下信息时，则说明安装成功。    </div><div class=\"line\">   </div><div class=\"line\">``` bash</div><div class=\"line\">zhengrui-ds@ZHENGRUI-DS MINGW64 ~</div><div class=\"line\">$ node -v</div><div class=\"line\">v6.9.4</div><div class=\"line\"></div><div class=\"line\">zhengrui-ds@ZHENGRUI-DS MINGW64 ~</div><div class=\"line\">$ npm -v</div><div class=\"line\">3.10.10</div></pre></td></tr></table></figure>\n<h4 id=\"2-2-安装hexo\"><a href=\"#2-2-安装hexo\" class=\"headerlink\" title=\"2.2 安装hexo\"></a>2.2 安装hexo</h4><p>安装客户端   </p>\n<pre><code class=\"bash\">npm install -g hexo-cli\n</code></pre>\n<p>安装服务端  </p>\n<pre><code class=\"bash\">npm install hexo --save\n</code></pre>\n<p>新建一个用于装在hexo的文件夹，如hexo<br>切换到该文件夹，执行以下命令：   </p>\n<pre><code class=\"bash\">hexo init  //初始化该文件夹  \nnpm install  //安装相应的依赖包\n</code></pre>\n<p>此时hexo搭建博客已基本完成。可执行以下命令来查看博客的初始效果：  </p>\n<pre><code class=\"bash\">hexo clean   //清空public文件夹下面的内容，该文件夹用于存放生成的网页文件。  \nhexo g       //该命令用于产生相应的网页文件，在public文件夹下  \nhexo s      //启动一个本地服务器，一般是http://localhost:4000，可查看生成的网页情况。\n</code></pre>\n<p><strong>注意</strong>：有时会存在4000端口被占用的情况，此时可以使用hexo s -p 端口号&emsp;来指定端口号。其实如果你有使用linux的经验，应该知道这些命令一般都可以在命令的后面加上-h或者–help来查看它的用法。hexo中的命令可以连写，如hexo g与hexo s可合写成hexo s -g  </p>\n<h4 id=\"2-3-将博客部署到github上\"><a href=\"#2-3-将博客部署到github上\" class=\"headerlink\" title=\"2.3 将博客部署到github上\"></a>2.3 将博客部署到github上</h4><p>&emsp;&emsp;要想将博客部署到github上，你需要先有一个github账号，并且将你本地的git（计算机）与github关联起来。本文已认为你已经有了自己的github账号并已关联本地，如果没有请移步我的另一篇博客TODO<br>其次你需要了解一下hexo的配置文件_config.yml：<br>站点配置</p>\n<pre><code class=\"bash\"><span class=\"comment\"># Site</span>\ntitle: ZHENGRUI<span class=\"string\">'BLOG\nsubtitle: 今日之果，皆因曾经之因\ndescription:\nauthor: zhengrui\nlanguage: zh-CN\ntimezone:</span>\n</code></pre>\n<p>将博客部署到github上  </p>\n<pre><code class=\"bash\"><span class=\"comment\"># Deployment</span>\n<span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span>\ndeploy:\n  <span class=\"built_in\">type</span>: git\n  repo: git@github.com:zhezaoyizhuding/zhezaoyizhuding.github.io.git\n  branch: master\n</code></pre>\n<p>你需要执行以下命令，安装hexo的git插件  </p>\n<pre><code class=\"bash\">npm install hexo-deployer-git --save\n</code></pre>\n<p>后面要加–save否则无法将依赖写入hexo的package.json中，执行以下命令即可将网站部署到github上。  </p>\n<pre><code class=\"bash\">hexo d\n</code></pre>\n<p>至此你一讲将博客部署到github上了，在浏览器输入<a href=\"https://你的github用户名.github.io即可访问。\">https://你的github用户名.github.io即可访问。</a></p>\n"}],"PostAsset":[{"_id":"source/_posts/android基础之activity/Activity状态保存示意图.png","slug":"Activity状态保存示意图.png","post":"cizs8mm00000980nzzpkcvg9b","modified":0,"renderable":0},{"_id":"source/_posts/android基础之activity/activity回调方法汇总.png","slug":"activity回调方法汇总.png","post":"cizs8mm00000980nzzpkcvg9b","modified":0,"renderable":0},{"_id":"source/_posts/android基础之activity/activity生命周期图.png","slug":"activity生命周期图.png","post":"cizs8mm00000980nzzpkcvg9b","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cizs8mlzl000580nz993qcif7","category_id":"cizs8mlzs000780nzexwwrobr","_id":"cizs8mm0m000f80nzrx5u67rq"},{"post_id":"cizs8mm00000980nzzpkcvg9b","category_id":"cizs8mlzs000780nzexwwrobr","_id":"cizs8mm0q000k80nzkqmr1r4q"},{"post_id":"cizs8mm1a000r80nz3mst9j59","category_id":"cizs8mm1p000s80nzs7db5n9d","_id":"cizs8mm1t000v80nzea5pa6ye"},{"post_id":"cizs8mm29000w80nzzp8i3r7z","category_id":"cizs8mm1p000s80nzs7db5n9d","_id":"cizs8mm2d000y80nzmchx1hzk"}],"PostTag":[{"post_id":"cizs8mlzl000580nz993qcif7","tag_id":"cizs8mlzz000880nzbuu0df5r","_id":"cizs8mm0q000j80nzlvt1xkoc"},{"post_id":"cizs8mlzl000580nz993qcif7","tag_id":"cizs8mm09000d80nzz54ftfac","_id":"cizs8mm0s000m80nzifzdt9cy"},{"post_id":"cizs8mm00000980nzzpkcvg9b","tag_id":"cizs8mm09000d80nzz54ftfac","_id":"cizs8mm0y000p80nzh4hp60mt"},{"post_id":"cizs8mm00000980nzzpkcvg9b","tag_id":"cizs8mlzz000880nzbuu0df5r","_id":"cizs8mm0z000q80nz1cjz7iou"},{"post_id":"cizs8mm1a000r80nz3mst9j59","tag_id":"cizs8mm1q000t80nz61wghsia","_id":"cizs8mm1s000u80nzedthkecg"},{"post_id":"cizs8mm29000w80nzzp8i3r7z","tag_id":"cizs8mm1q000t80nz61wghsia","_id":"cizs8mm2d000x80nz0rnqmbm7"}],"Tag":[{"name":"android","_id":"cizs8mlzz000880nzbuu0df5r"},{"name":"java","_id":"cizs8mm09000d80nzz54ftfac"},{"name":"hexo","_id":"cizs8mm1q000t80nz61wghsia"}]}}