{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-alex/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/js/jquery.scrollLoading.js","path":"js/jquery.scrollLoading.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY.png","path":"css/images/logoDIY.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/logo.png","path":"css/images/logo.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/logo@2x.png","path":"css/images/logo@2x.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY1.png","path":"css/images/logoDIY1.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/preloader@2x.gif","path":"css/images/preloader@2x.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY@2x.png","path":"css/images/logoDIY@2x.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/preloader.gif","path":"css/images/preloader.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-alex/LICENSE","hash":"f0c7cd0dcb6f00b98393878068ff3e6bf5f321f1","modified":1487823302798},{"_id":"themes/hexo-theme-alex/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1487823302797},{"_id":"themes/hexo-theme-alex/README.md","hash":"31e9ee4a08a89afc067733d6ac32302badbad95d","modified":1487823302798},{"_id":"themes/hexo-theme-alex/package.json","hash":"d07f326588fef82f1d23ae3101c9ddfff34c132f","modified":1487823302807},{"_id":"themes/hexo-theme-alex/_config.yml","hash":"1326fcd415c81b47652a6c7b702916dfdcfdbd62","modified":1487823698754},{"_id":"source/_posts/android基础之BroadcastReceiver.md","hash":"61ea20ac43cb867512cdb589569cb4a2ed534af9","modified":1488882328582},{"_id":"source/_posts/android基础之Content-Providers.md","hash":"0b8aa167e8293834baa15802ca47336573f60cc5","modified":1488882410614},{"_id":"source/_posts/android基础之Fragments.md","hash":"7ed1a03b22b8261255d4877a5a92424d534492fd","modified":1488859235804},{"_id":"source/_posts/android基础之Intents与Intent-Filters.md","hash":"54c43c29b923fe20a3f319e080570c42d5c5d903","modified":1488945817360},{"_id":"source/_posts/android基础之SQLite.md","hash":"317bbf7fda9ac549a091706a8e00da6125c7add7","modified":1488276212716},{"_id":"source/_posts/android基础之Service.md","hash":"c3f80664b1aa694144627b4925d7bcd4516c6cd7","modified":1488791842399},{"_id":"source/_posts/android基础之Handler与AsycTask.md","hash":"dba7e3aa538c1d8469595908d693866fbde7db09","modified":1488178073910},{"_id":"source/_posts/android基础之activity.md","hash":"3c896b500f0b1689f733b663c8101f3fbaa6dc3c","modified":1488524968373},{"_id":"source/_posts/android基础之loaders.md","hash":"365d0bb94dbc63841f0efae38a40be71ce2c39af","modified":1488177562007},{"_id":"source/_posts/android基础之数据存储.md","hash":"8dd38b7ff4752b487123eda0b357a42a1e5c87b9","modified":1488274972277},{"_id":"source/_posts/android基础之消息推送.md","hash":"e5b0daec1280a70265aa492fec5d6c051336dbf2","modified":1488349690850},{"_id":"source/_posts/android基础之缓存.md","hash":"73c19c5fd165c978b6ce8345fc4b49c7d55fc9f8","modified":1488273022046},{"_id":"source/_posts/android基础之自定义View与ViewGroup.md","hash":"d937576cb8f13e24c071dd8b3681c73cd0bf71fc","modified":1488268957153},{"_id":"source/_posts/android基础之事件分发机制.md","hash":"875967b2b2c4e9d052a6e792c39860907ca29bca","modified":1488277528020},{"_id":"source/_posts/android基础之进程间通信.md","hash":"cbfc60b60fc51d0401e9ab44a42d3a07f6797ab3","modified":1488276000191},{"_id":"source/_posts/hexo搭建博客指南（一）-建站.md","hash":"843c243de558b7a23e5e929337f739f7ab6ee5ba","modified":1487838852388},{"_id":"source/_posts/hexo搭建博客指南（二）-主题配置.md","hash":"2c72a279f51933a4b954019e259e6ba9aae8129e","modified":1487847317467},{"_id":"themes/hexo-theme-alex/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1487823302805},{"_id":"themes/hexo-theme-alex/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1487823302805},{"_id":"themes/hexo-theme-alex/layout/layout.ejs","hash":"6722d4980da4a8b6ae9ebee5fbb3df625d4cccc0","modified":1487823302805},{"_id":"themes/hexo-theme-alex/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1487823302805},{"_id":"themes/hexo-theme-alex/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1487823302806},{"_id":"themes/hexo-theme-alex/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1487823302807},{"_id":"themes/hexo-theme-alex/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1487823302808},{"_id":"themes/hexo-theme-alex/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1487823302807},{"_id":"source/_posts/android基础之Fragments/Fragment显示图.png","hash":"690d35d73cede5e01eafba3fdd882ad0757e8009","modified":1488794510187},{"_id":"source/_posts/android基础之Fragments/Fragment与Activity生命周期对比.png","hash":"21a7ffdf3a9e7e39f0e4a8856e327d8a18ff21cc","modified":1488855688697},{"_id":"themes/hexo-theme-alex/source/css/_extend.styl","hash":"eb83c785ce83c277a6f8de9510805595c5d7aa1f","modified":1487823302809},{"_id":"themes/hexo-theme-alex/source/css/_retina.styl","hash":"1bc8f743af27654ed2353ad36e062e37c27a8681","modified":1487823302813},{"_id":"themes/hexo-theme-alex/source/css/_variables.styl","hash":"5435c2f061b5e330e7d7ba74ed9fefea8ae86ad1","modified":1487837769783},{"_id":"themes/hexo-theme-alex/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1487823302821},{"_id":"themes/hexo-theme-alex/source/css/style.styl","hash":"ccebcce09864d0ac529ea4aab7fed9edaba098b1","modified":1487835436052},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1487823302822},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1487823302822},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1487823302822},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1487823302823},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1487823302822},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1487823302825},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1487823302826},{"_id":"themes/hexo-theme-alex/source/js/jquery.scrollLoading.js","hash":"d0729cb06dd7eefd789e7b6b01fb9b4b691741fb","modified":1487823302828},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1487823302826},{"_id":"themes/hexo-theme-alex/layout/_partial/after-footer.ejs","hash":"473fd916d73a634865d776ff591860f4680f2a5a","modified":1487823302799},{"_id":"themes/hexo-theme-alex/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1487823302799},{"_id":"themes/hexo-theme-alex/layout/_partial/archive.ejs","hash":"61f37ba0ce1eba08a2bcfe09f8691a7320ee8d10","modified":1487823302799},{"_id":"themes/hexo-theme-alex/layout/_partial/footer.ejs","hash":"f4c0fb5d3ac8f3ede1d1a668b362ebadc157c5a9","modified":1487844868700},{"_id":"themes/hexo-theme-alex/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1487823302800},{"_id":"themes/hexo-theme-alex/layout/_partial/article.ejs","hash":"46e1ab7f03a7d5a8d15e61c5a8d04ca3d0265047","modified":1487823302800},{"_id":"themes/hexo-theme-alex/layout/_partial/head.ejs","hash":"251ee51d3235684e02ed9bf9bb46e0f6229305cd","modified":1487823302801},{"_id":"themes/hexo-theme-alex/layout/_partial/header.ejs","hash":"8dc197a5c2dc0ecb37eecd24bd9f4904e4c2a65c","modified":1487832289636},{"_id":"themes/hexo-theme-alex/layout/_partial/mobile-nav.ejs","hash":"8692f720b5847458296a052964a455ff7064d554","modified":1487823302801},{"_id":"themes/hexo-theme-alex/layout/_widget/archive.ejs","hash":"88e191e3d14541299ed03b9a45be70974df51143","modified":1487823302803},{"_id":"themes/hexo-theme-alex/layout/_partial/sidebar.ejs","hash":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1487823302803},{"_id":"themes/hexo-theme-alex/source/js/script.js","hash":"2bc7a12ae95ce9e944282aae8f1ef9c117d0de95","modified":1487823302828},{"_id":"themes/hexo-theme-alex/layout/_widget/links.ejs","hash":"50f50a5015bdbcea2f41f071139d68c68c9e6484","modified":1487823302804},{"_id":"themes/hexo-theme-alex/layout/_widget/category.ejs","hash":"4d3f92e3cd652cb69d71e40d1c64b2369922ca26","modified":1487823302804},{"_id":"themes/hexo-theme-alex/layout/_widget/recent_posts.ejs","hash":"d6591c745402fbc600e682830a343f732e336e4f","modified":1487823302804},{"_id":"themes/hexo-theme-alex/layout/_widget/tagcloud.ejs","hash":"9028129dd2e56813197d0c38db5df8110aaeaabb","modified":1487823302805},{"_id":"themes/hexo-theme-alex/layout/_widget/tag.ejs","hash":"7ba10fbd17b83b9b89eaea99bb78158d318c6d75","modified":1487823302804},{"_id":"source/_posts/android基础之Fragments/Fragment生命周期图.png","hash":"f100e3a864b1be55e28bb2ae6f69580c4874dbbc","modified":1488852449132},{"_id":"source/_posts/android基础之Service/Service生命周期图.png","hash":"8f58fa262d06b6ea8e20ca738da45a6c06d42ecb","modified":1488772565467},{"_id":"source/_posts/android基础之activity/Activity状态保存示意图.png","hash":"a3fb8aab955cb5e40f1b18d7e1b5c1c2b5df37f6","modified":1488446350543},{"_id":"source/_posts/android基础之activity/activity回调方法汇总.png","hash":"283ffc1469fb33b9df2501d34328db84f14cdf0f","modified":1488447688722},{"_id":"source/_posts/android基础之activity/activity生命周期图.png","hash":"ca76d44f5128a045a225f3597fad78a811f0c70d","modified":1488166113702},{"_id":"themes/hexo-theme-alex/source/js/jquery.min.js","hash":"745ab5d6e434cf8d321779da3c527b6d301e2b50","modified":1487823302827},{"_id":"themes/hexo-theme-alex/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1487823302813},{"_id":"themes/hexo-theme-alex/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1487823302813},{"_id":"themes/hexo-theme-alex/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1487823302815},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1487823302816},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1487823302819},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY.png","hash":"1d8447ba649e78a1b9b30cecf3424f9c29fa23a9","modified":1487837712110},{"_id":"themes/hexo-theme-alex/source/css/images/logo.png","hash":"d1f41cf04419f22cd15b9e36e0658a7654796036","modified":1487823302820},{"_id":"themes/hexo-theme-alex/source/css/images/logo@2x.png","hash":"f02ae098f6676a0e8d945f13d8150965a2f66985","modified":1487823302820},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY1.png","hash":"649ede0e15de250b8c965932c3802a84bea4141d","modified":1487837059798},{"_id":"themes/hexo-theme-alex/source/css/images/preloader@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1487823302821},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY@2x.png","hash":"82ee4b7dfaf1a57e2ac5c6a6ce4bcc6a1c372b57","modified":1487837743567},{"_id":"themes/hexo-theme-alex/source/css/images/preloader.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1487823302820},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1487823302823},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1487823302824},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1487823302824},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1487823302824},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1487823302824},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1487823302825},{"_id":"themes/hexo-theme-alex/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1487823302802},{"_id":"themes/hexo-theme-alex/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1487823302802},{"_id":"themes/hexo-theme-alex/layout/_partial/post/nav.ejs","hash":"eb000d9d8a9ebd9087046fa019abe1cddae8fd9c","modified":1487823302802},{"_id":"themes/hexo-theme-alex/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1487823302802},{"_id":"themes/hexo-theme-alex/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1487823302803},{"_id":"themes/hexo-theme-alex/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1487823302803},{"_id":"themes/hexo-theme-alex/source/css/_partial/article.styl","hash":"09aed64e36551899cbd4faf2ae586d6eaf3ffe67","modified":1488514329296},{"_id":"themes/hexo-theme-alex/source/css/_partial/archive.styl","hash":"781116f363edd4b59ef0af64a780e9de4d2c4958","modified":1487823302809},{"_id":"themes/hexo-theme-alex/source/css/_partial/comment.styl","hash":"3ca87b9b705ff1594aca7c30e3c887fcfb39e385","modified":1487823302810},{"_id":"themes/hexo-theme-alex/source/css/_partial/highlight.styl","hash":"c125e953fb228d4f0089ea27d1527deca6086016","modified":1487823302811},{"_id":"themes/hexo-theme-alex/source/css/_partial/sidebar-aside.styl","hash":"68ca2d9d9459c84c2de530ca9e3965fb63d75a74","modified":1487823302812},{"_id":"themes/hexo-theme-alex/source/css/_partial/mobile.styl","hash":"948f0b1f8e8b5959e5def27f9f0329cfe4fb159f","modified":1487823302811},{"_id":"themes/hexo-theme-alex/source/css/_partial/sidebar-bottom.styl","hash":"f6023861b2fbd858946e2108438b5f8f17586179","modified":1487823302812},{"_id":"themes/hexo-theme-alex/source/css/_partial/header.styl","hash":"5b8fcd91fe31994a3cf2513a6255242242958a44","modified":1487823302811},{"_id":"themes/hexo-theme-alex/source/css/_partial/tablet.styl","hash":"60b666c5b134356721dcf8c73fa0162ff904fe7d","modified":1487823302812},{"_id":"themes/hexo-theme-alex/source/css/_partial/sidebar.styl","hash":"735e2d5898b585a94b0c16f58bd1b46507c752fb","modified":1487823302812},{"_id":"themes/hexo-theme-alex/source/css/_partial/footer.styl","hash":"60fc6d6184bab3636e1a0fe0cfe56f969507472e","modified":1487823302810},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1487823302818},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1487823302817},{"_id":"public/sitemap.xml","hash":"5e2784a93aa42d487af76cf1e6a7c4aa1b2e17da","modified":1488946570329},{"_id":"public/baidusitemap.xml","hash":"58731ab50a08a777c499a94831bf75b527092800","modified":1488946570179},{"_id":"public/2017/03/01/android基础之消息推送/index.html","hash":"92619f03dc191c6b8ef8a98fb48ec568f97f55d7","modified":1488946570355},{"_id":"public/2017/02/28/android基础之事件分发机制/index.html","hash":"b89999c1c3466173dcd380615b45b8df5e84574f","modified":1488946570359},{"_id":"public/2017/02/28/android基础之SQLite/index.html","hash":"1b4a2b3a5f1a8eef2ed7434d3b03f626918b9699","modified":1488946570359},{"_id":"public/2017/02/28/android基础之进程间通信/index.html","hash":"803a82ddb1549133e90661cff97686df8c630612","modified":1488946570359},{"_id":"public/2017/02/28/android基础之数据存储/index.html","hash":"ec4cc34c19f9ae88feb06c366289117cfba24e1e","modified":1488946570359},{"_id":"public/2017/02/28/android基础之缓存/index.html","hash":"c1eac8f0255130dfa845b1f4b05275a64b5f86ef","modified":1488946570359},{"_id":"public/2017/02/28/android基础之自定义View与ViewGroup/index.html","hash":"5ddf686568cff730c8e2e3d3273c0e9f87dd07b5","modified":1488946570359},{"_id":"public/2017/02/27/android基础之BroadcastReceiver/index.html","hash":"a59022ba2319efff88a4a373ed80430eb5709945","modified":1488946570362},{"_id":"public/2017/02/27/android基础之Handler与AsycTask/index.html","hash":"90ffba7f48600f7bf7a05b0c125d0a435212d557","modified":1488946570359},{"_id":"public/2017/02/27/android基础之loaders/index.html","hash":"120199cfd3c98edaae7179f094a95b68464596cc","modified":1488946570359},{"_id":"public/2017/02/27/android基础之Content-Providers/index.html","hash":"ec33f48d3eb72babb3e5d91b2f9e5d12884048d6","modified":1488946570362},{"_id":"public/2017/02/27/android基础之Intents与Intent-Filters/index.html","hash":"eaff8552e7fa70e503d022d87dd300f5982275f5","modified":1488946570362},{"_id":"public/2017/02/18/hexo搭建博客指南（二）-主题配置/index.html","hash":"7ec6acac0068a569cffffe36a1e9dbc02230a79c","modified":1488946570359},{"_id":"public/2017/02/16/hexo搭建博客指南（一）-建站/index.html","hash":"5bafd5589067d1ac352f49135a5aadff3539ad77","modified":1488946570360},{"_id":"public/archives/index.html","hash":"9d949f2a94fb0619f8148205e35d03f1d9fb5e58","modified":1488946570360},{"_id":"public/archives/page/2/index.html","hash":"445ef5d17342aa1d28abe5a14bfa990bcc7d2b63","modified":1488946570360},{"_id":"public/archives/2017/index.html","hash":"6c2b1118c906d82e82c663a02037c8e4fd8f6e2b","modified":1488946570360},{"_id":"public/archives/2017/page/2/index.html","hash":"e4da6b7de88b8adcbe518f6b64f16f91c3549e33","modified":1488946570360},{"_id":"public/archives/2017/02/index.html","hash":"5382e1852a45e1b0e05331790e2a99ef8a593382","modified":1488946570361},{"_id":"public/archives/2017/02/page/2/index.html","hash":"ef0f8a0febe35d7066503a43a58280539c3e3525","modified":1488946570361},{"_id":"public/archives/2017/03/index.html","hash":"ec4a5e64c10420b71049777abcd2660951d255ac","modified":1488946570361},{"_id":"public/tags/android/index.html","hash":"cced15a98f229274d8d1518558c36511c19e88bd","modified":1488946570361},{"_id":"public/tags/java/index.html","hash":"aa1981b7b874f7391a4e33df6156fb860dfdadce","modified":1488946570361},{"_id":"public/tags/service/index.html","hash":"20fb309aec1cc60782e1318578cb770221e20092","modified":1488946570361},{"_id":"public/tags/activity/index.html","hash":"d676b391f3c7ea09ff364943cc377e3f9ec015df","modified":1488946570361},{"_id":"public/tags/hexo/index.html","hash":"47e21668ff915530ef2f64a06c2ca18eda2bab37","modified":1488946570361},{"_id":"public/categories/android/index.html","hash":"5c480380818e310b8ed6c313193f04776b982392","modified":1488946570361},{"_id":"public/categories/hexo/index.html","hash":"93cfde0421f05abdd9073a0527acf011ba8060e9","modified":1488946570361},{"_id":"public/2017/02/27/android基础之Service/index.html","hash":"b3553a5f9f3704fc8cefdf11dbc77705cd8eb850","modified":1488946570362},{"_id":"public/2017/02/27/android基础之activity/index.html","hash":"fb5063e6d4347f1eba06687bea6ad3c6ead4bf04","modified":1488946570362},{"_id":"public/index.html","hash":"6f5c7d7b9d92f6403a1bf031d2c8c72e8281703f","modified":1488946570362},{"_id":"public/page/2/index.html","hash":"4f36794b18329110197c38c8b658452a44c00731","modified":1488946570362},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1488859092873},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1488859092873},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1488859092873},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1488859092873},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1488859092873},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1488859092874},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1488859092874},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1488859092874},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1488859092874},{"_id":"public/css/images/logoDIY.png","hash":"1d8447ba649e78a1b9b30cecf3424f9c29fa23a9","modified":1488859092874},{"_id":"public/css/images/logo.png","hash":"d1f41cf04419f22cd15b9e36e0658a7654796036","modified":1488859092874},{"_id":"public/css/images/logo@2x.png","hash":"f02ae098f6676a0e8d945f13d8150965a2f66985","modified":1488859092874},{"_id":"public/css/images/preloader@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1488859092874},{"_id":"public/css/images/logoDIY1.png","hash":"649ede0e15de250b8c965932c3802a84bea4141d","modified":1488859092875},{"_id":"public/css/images/logoDIY@2x.png","hash":"82ee4b7dfaf1a57e2ac5c6a6ce4bcc6a1c372b57","modified":1488859092875},{"_id":"public/css/images/preloader.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1488859092875},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1488859092875},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1488859093502},{"_id":"public/2017/02/27/android基础之activity/Activity状态保存示意图.png","hash":"a3fb8aab955cb5e40f1b18d7e1b5c1c2b5df37f6","modified":1488859093504},{"_id":"public/2017/02/27/android基础之Service/Service生命周期图.png","hash":"8f58fa262d06b6ea8e20ca738da45a6c06d42ecb","modified":1488859093504},{"_id":"public/2017/02/27/android基础之activity/activity回调方法汇总.png","hash":"283ffc1469fb33b9df2501d34328db84f14cdf0f","modified":1488859093504},{"_id":"public/2017/02/27/android基础之activity/activity生命周期图.png","hash":"ca76d44f5128a045a225f3597fad78a811f0c70d","modified":1488859093504},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1488859093510},{"_id":"public/js/jquery.scrollLoading.js","hash":"1a3eab1ab2c4644fe1ada921bd1bdb083268a751","modified":1488859093510},{"_id":"public/js/script.js","hash":"26f3e43ae838afa8ebc91fa1732374f8836a9f17","modified":1488859093510},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1488859093510},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1488859093510},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1488859093510},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1488859093510},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1488859093510},{"_id":"public/css/style.css","hash":"c40504c5970e0d638f0c5a89487b43951988a94c","modified":1488859093511},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1488859093511},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1488859093511},{"_id":"public/js/jquery.min.js","hash":"a6eedf84389e1bc9f757bc2d19538f8c8d1cae9d","modified":1488859093511},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1488859093514},{"_id":"public/tags/Fragment/index.html","hash":"90be29b550179c0046df009944dc7cf5f401d35b","modified":1488946570361},{"_id":"public/2017/02/27/android基础之Fragments/index.html","hash":"2de3a14f1ac47508dfa7227132f6d56040a8a9f7","modified":1488946570362},{"_id":"public/2017/02/27/android基础之Fragments/Fragment与Activity生命周期对比.png","hash":"21a7ffdf3a9e7e39f0e4a8856e327d8a18ff21cc","modified":1488859245388},{"_id":"public/2017/02/27/android基础之Fragments/Fragment显示图.png","hash":"690d35d73cede5e01eafba3fdd882ad0757e8009","modified":1488859245389},{"_id":"public/2017/02/27/android基础之Fragments/Fragment生命周期图.png","hash":"f100e3a864b1be55e28bb2ae6f69580c4874dbbc","modified":1488859245392},{"_id":"public/tags/BroadcastReceiver/index.html","hash":"ccd057e0065276b0679e184fa110e8f83a3b2bbe","modified":1488946570361},{"_id":"public/tags/Content-Provider/index.html","hash":"70689f767eb8c55dadb503c1f5dcc8a3f582d372","modified":1488946570362},{"_id":"public/tags/Intent/index.html","hash":"698f982646de83eba53eac97c87286c1041b540a","modified":1488946570369},{"_id":"public/tags/IntentFilter/index.html","hash":"421bd365b1172a1fb01e5af6c2bd662277d92b1d","modified":1488946570369}],"Category":[{"name":"android","_id":"cizz09ftg0005aonznymvtcu0"},{"name":"hexo","_id":"cizz09fua000taonzczca9cbw"}],"Data":[],"Page":[],"Post":[{"title":"android基础之BroadcastReceiver","date":"2017-02-27T06:48:31.000Z","_content":"\n### 一 BroadcastReceiver简介\n\n广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。如：在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。\n\nBroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。\n\n当系统或应用发出广播时，将会扫描系统中的所有广播接收者，通过action匹配将广播发送给相应的接收者，接收者收到广播后将会产生一个广播接收者的实例，执行其中的onReceiver()这个方法；特别需要注意的是这个实例的生命周期只有10秒，如果10秒内没执行结束onReceiver()，系统将会报错。在onReceiver()执行完毕之后，该实例将会被销毁，所以不要在onReceiver()中执行耗时操作，也不要在里面创建子线程处理业务（因为可能子线程没处理完，接收者就被回收了，那么子线程也会跟着被回收掉）；正确的处理方法就是通过in调用activity或者service处理业务。\n\n### 二 BroadcastReceiver的两种注册方式\n\n##### 1.静态注册（推荐）\n\n静态注册的广播接收者是一个常驻在系统中的全局监听器，当你在应用中配置了一个静态的BroadcastReceiver，安装了应用后而无论应用是否处于运行状态，广播接收者都是已经常驻在系统中了。同时应用里的所有receiver都在清单文件里面，方便查看。　 　　 　　要销毁掉静态注册的广播接收者，可以通过调用PackageManager将Receiver禁用。\n\n在AndroidManifest.xml的application里面定义receiver并设置要接收的action。下面是代码示例：\n\n```java\n< receiver android:name = \".MyBroadcastReceiver\" > \n\n < intent-filter android:priority = \"777\" >             \n<action android:name = \"android.provider.Telephony.SMS_RECEIVED\" />\n</ intent-filter > \n\n</ receiver >\n```\n\n这里的priority取值是　-1000到1000，值越大优先级越高，同时注意加上系统接收短信的限权。\n\n```java\n< uses-permission android:name =\"android.permission.RECEIVE_SMS\" />\n```\n\n##### 2.动态注册\n\n在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载. \n\n```java\npublic class MainActivity extends Activity {\n    MyBroadcastReceiver receiver;\n    @Override\n     protected void onResume() {\n        // 动态注册广播 (代码执行到这才会开始监听广播消息，并对广播消息作为相应的处理)\n        receiver = new MyBroadcastReceiver();\n        IntentFilter intentFilter = new IntentFilter( \"android.provider.Telephony.SMS_RECEIVED\" );\n        registerReceiver( receiver , intentFilter);\n\n        super.onResume();\n    }\n    @Override\n    protected void onPause() {  \n        // 撤销注册 (撤销注册后广播接收者将不会再监听系统的广播消息)\n        unregisterReceiver(receiver);\n        super.onPause();\n    }\n}\n```\n\n接收广播示例：\n\n```java\npublic class MyBroadcastReceiver extends BroadcastReceiver {\n\n// action 名称\nString SMS_RECEIVED = \"android.provider.Telephony.SMS_RECEIVED\" ;\n\n    public void onReceive(Context context, Intent intent) {\n\n       if (intent.getAction().equals( SMS_RECEIVED )) {\n           // 一个receiver可以接收多个action的，即可以有多个intent-filter，需要在onReceive里面对intent.getAction(action name)进行判断。\n       }\n    }\n}\n```\n\n##### 3.静态注册和动态注册的区别\n\n1. 静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者； 　　动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。\n2. 当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。　 　　动态注册的广播接收者将会导致应用报错 　　而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。\n\n### 三 发送广播\n\n发送广播主要有两种类型：\n\n##### 1.普通广播\n\n应用在需要通知各个广播接收者的情况下使用，如 开机启动，使用方法：sendBroadcast()。\n\n```java\nIntent intent = new Intent(\"android.provider.Telephony.SMS_RECEIVED\"); \n//通过intent传递少量数据\nintent.putExtra(\"data\", \"finch\"); \n// 发送普通广播\nsendBroadcast(Intent); \n```\n\n普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，所有满足条件的 BroadcastReceiver 都会随机地执行其 onReceive() 方法。 　　同级别接收是先后是随机的；级别低的收到广播； 　　消息传递的效率比较高，并且无法中断广播的传播。\n\n##### 有序广播\n\n应用在需要有特定拦截的场景下使用，如黑名单短信、电话拦截。\n\n使用方法：\n\n```java\nsendOrderedBroadcast(intent, receiverPermission);\n```\n\nreceiverPermission ：一个接收器必须持以接收您的广播。如果为 null ，不经许可的要求（一般都为null）,如：\n\n\n```java\n//发送有序广播\nsendOrderedBroadcast(intent, null);\n```\n\n在有序广播中，我们可以在前一个广播接收者将处理好的数据传送给后面的广播接收者，也可以调用abortBroadcast()来终结广播的传播。\n\n```java\npublic void onReceive(Context arg0, Intent intent) {\n　　//获取上一个广播的bundle数据\n　　Bundle bundle = getResultExtras(true);//true：前一个广播没有结果时创建新的Bundle；false：不创建Bundle\n　　bundle.putString(\"key\", \"777\");\n　　//将bundle数据放入广播中传给下一个广播接收者\n　　setResultExtras(bundle);　\n　　\n　　//终止广播传给下一个广播接收者\n　　abortBroadcast();\n}\n```\n\n高级别的广播收到该广播后，可以决定把该广播是否截断掉。 　　同级别接收是先后是随机的，如果先接收到的把广播截断了，同级别的例外的接收者是无法收到该广播。 　\n\n##### 异步广播\n\n使用方法：sendStickyBroadcast() ：\n\n发出的Intent当接收Activity（动态注册）重新处于onResume状态之后就能重新接受到其Intent.（the Intent will be held to be re-broadcast to future receivers）。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Activity处于活跃的时候又会接受到它\n\n发这个广播需要权限：\n\n```java\n<uses-permission android:name=\"android.permission.BROADCAST_STICKY\" />\n```\n\n卸载该广播：\n\n```java\nremoveStickyBroadcast(intent);\n```\n\n在卸载之前该intent会保留，接收者在可接收状态都能获得。\n\n##### 异步有序广播\n\n使用方法：sendStickyOrderedBroadcast(intent, resultReceiver, scheduler, initialCode, initialData, initialExtras)：\n\n这个方法具有有序广播的特性也有异步广播的特性；同时需要限权：\n\n```java\n<uses-permission android:name=\"android.permission.BROADCAST_STICKY\" /> \n```\n\n### 四 安全性\n\nBroadcastReceiver的设计初衷就是从全局考虑的，可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言BroadcastReceiver是存在安全性问题的，相应问题及解决如下：   \n\n- 当应用程序发送某个广播时系统会将发送的Intent与系统中所有注册的BroadcastReceiver的IntentFilter进行匹配，若匹配成功则执行相应的onReceive函数。可以通过类似sendBroadcast(Intent, String)的接口在发送广播时指定接收者必须具备的permission。或通过Intent.setPackage设置广播仅对某个程序有效。\n- 当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。对于动态注册的广播可以通过类似registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)的接口指定发送者必须具备的permission，对于静态注册的广播可以通过android:exported=\"false\"属性表示接收者对外部应用程序不可用，即不接受来自外部的广播。\n- 上面两个问题其实都可以通过LocalBroadcastManager来解决，LocalBroadcastManager只会将广播限定在当前应用程序中。\n- 使用android:protectionLevel\n\nandroid引入了LocalBroadcastManager解决在第4部分安全性介绍的一些问题，LocalBroadcastManager除了能解决BroadcastReceiver进程间安全性问题外，相对Context操作的BroadcastReceiver而言还具有更高的运行效率。使用LocalBroadcastManager需要引入Android Support Library，如何引入见Add Support Package。\n本地广播通过LocalBroadcastManager.getInstance(context).sendBroadcast(intent)发送广播，LocalBroadcastManager.getInstance(context).registerReceiver注册服务，通过LocalBroadcastManager.getInstance(context).unregisterReceiver取消注册服务，其他同普通广播.\n\n### 五 一些常用的系统广播的action 和permission\n\n##### 1.开机启动\n\n```java\n<action android:name=\"android.intent.action.BOOT_COMPLETED\"/> \n\n<uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\" />  \n\n```\n\n##### 2.网络状态\n\n```java\n<action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\"/>  \n\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/> \n\n```\n\n网络是否可用的方法：\n\n```java\npublic static boolean isNetworkAvailable(Context context) {  \n        ConnectivityManager mgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);  \n        NetworkInfo[] info = mgr.getAllNetworkInfo();  \n        if (info != null) {  \n            for (int i = 0; i < info.length; i++) {  \n      if (info[i].getState() == NetworkInfo.State.CONNECTED) {  \n                    return true;  \n                }  \n            }  \n        }  \n        return false;  \n    } \n```\n\n##### 3.电量变化\n\n```java\n<action android:name=\"android.intent.action.BATTERY_CHANGED\"/>  \n```\n\nBroadcastReceiver 的onReceive方法：\n\n```java\npublic void onReceive(Context context, Intent intent) {  \n        int currLevel = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, 0);  //当前电量  　\n\n        int total = intent.getIntExtra(BatteryManager.EXTRA_SCALE, 1);    //总电量  \n        int percent = currLevel * 100 / total;  \n        Log.i(TAG, \"battery: \" + percent + \"%\");  \n    }  \n\n```\n\n\n\n### 六 总结\n\n- 静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。\n- 动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：1)这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。2)这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。\n- 广播发出的时候，广播接收者接收的顺序如下：    \n1)当广播为普通广播时，有如下的接收顺序：  \n\na、无视优先级   \nb、动态优先于静态    \nc、同优先级的动态广播接收器，先注册的大于后注册的   \nd、同优先级的静态广播接收器，先扫描的大于后扫描的　   \n\n2）如果广播为有序广播，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：　 \n   　　 　　\na、优先级高的先接收　 　  \nb、同优先级的动静态广播接收器，动态优先于静态 　　  \nc、同优先级的动态广播接收器，先注册的大于后注册的 　　  \nd、同优先级的静态广播接收器，先扫描的大于后扫描的　   ","source":"_posts/android基础之BroadcastReceiver.md","raw":"---\ntitle: android基础之BroadcastReceiver\ndate: 2017-02-27 14:48:31\ncategories: android\ntags:\n- android\n- java\n- BroadcastReceiver\n---\n\n### 一 BroadcastReceiver简介\n\n广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。如：在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。\n\nBroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。\n\n当系统或应用发出广播时，将会扫描系统中的所有广播接收者，通过action匹配将广播发送给相应的接收者，接收者收到广播后将会产生一个广播接收者的实例，执行其中的onReceiver()这个方法；特别需要注意的是这个实例的生命周期只有10秒，如果10秒内没执行结束onReceiver()，系统将会报错。在onReceiver()执行完毕之后，该实例将会被销毁，所以不要在onReceiver()中执行耗时操作，也不要在里面创建子线程处理业务（因为可能子线程没处理完，接收者就被回收了，那么子线程也会跟着被回收掉）；正确的处理方法就是通过in调用activity或者service处理业务。\n\n### 二 BroadcastReceiver的两种注册方式\n\n##### 1.静态注册（推荐）\n\n静态注册的广播接收者是一个常驻在系统中的全局监听器，当你在应用中配置了一个静态的BroadcastReceiver，安装了应用后而无论应用是否处于运行状态，广播接收者都是已经常驻在系统中了。同时应用里的所有receiver都在清单文件里面，方便查看。　 　　 　　要销毁掉静态注册的广播接收者，可以通过调用PackageManager将Receiver禁用。\n\n在AndroidManifest.xml的application里面定义receiver并设置要接收的action。下面是代码示例：\n\n```java\n< receiver android:name = \".MyBroadcastReceiver\" > \n\n < intent-filter android:priority = \"777\" >             \n<action android:name = \"android.provider.Telephony.SMS_RECEIVED\" />\n</ intent-filter > \n\n</ receiver >\n```\n\n这里的priority取值是　-1000到1000，值越大优先级越高，同时注意加上系统接收短信的限权。\n\n```java\n< uses-permission android:name =\"android.permission.RECEIVE_SMS\" />\n```\n\n##### 2.动态注册\n\n在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载. \n\n```java\npublic class MainActivity extends Activity {\n    MyBroadcastReceiver receiver;\n    @Override\n     protected void onResume() {\n        // 动态注册广播 (代码执行到这才会开始监听广播消息，并对广播消息作为相应的处理)\n        receiver = new MyBroadcastReceiver();\n        IntentFilter intentFilter = new IntentFilter( \"android.provider.Telephony.SMS_RECEIVED\" );\n        registerReceiver( receiver , intentFilter);\n\n        super.onResume();\n    }\n    @Override\n    protected void onPause() {  \n        // 撤销注册 (撤销注册后广播接收者将不会再监听系统的广播消息)\n        unregisterReceiver(receiver);\n        super.onPause();\n    }\n}\n```\n\n接收广播示例：\n\n```java\npublic class MyBroadcastReceiver extends BroadcastReceiver {\n\n// action 名称\nString SMS_RECEIVED = \"android.provider.Telephony.SMS_RECEIVED\" ;\n\n    public void onReceive(Context context, Intent intent) {\n\n       if (intent.getAction().equals( SMS_RECEIVED )) {\n           // 一个receiver可以接收多个action的，即可以有多个intent-filter，需要在onReceive里面对intent.getAction(action name)进行判断。\n       }\n    }\n}\n```\n\n##### 3.静态注册和动态注册的区别\n\n1. 静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者； 　　动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。\n2. 当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。　 　　动态注册的广播接收者将会导致应用报错 　　而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。\n\n### 三 发送广播\n\n发送广播主要有两种类型：\n\n##### 1.普通广播\n\n应用在需要通知各个广播接收者的情况下使用，如 开机启动，使用方法：sendBroadcast()。\n\n```java\nIntent intent = new Intent(\"android.provider.Telephony.SMS_RECEIVED\"); \n//通过intent传递少量数据\nintent.putExtra(\"data\", \"finch\"); \n// 发送普通广播\nsendBroadcast(Intent); \n```\n\n普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，所有满足条件的 BroadcastReceiver 都会随机地执行其 onReceive() 方法。 　　同级别接收是先后是随机的；级别低的收到广播； 　　消息传递的效率比较高，并且无法中断广播的传播。\n\n##### 有序广播\n\n应用在需要有特定拦截的场景下使用，如黑名单短信、电话拦截。\n\n使用方法：\n\n```java\nsendOrderedBroadcast(intent, receiverPermission);\n```\n\nreceiverPermission ：一个接收器必须持以接收您的广播。如果为 null ，不经许可的要求（一般都为null）,如：\n\n\n```java\n//发送有序广播\nsendOrderedBroadcast(intent, null);\n```\n\n在有序广播中，我们可以在前一个广播接收者将处理好的数据传送给后面的广播接收者，也可以调用abortBroadcast()来终结广播的传播。\n\n```java\npublic void onReceive(Context arg0, Intent intent) {\n　　//获取上一个广播的bundle数据\n　　Bundle bundle = getResultExtras(true);//true：前一个广播没有结果时创建新的Bundle；false：不创建Bundle\n　　bundle.putString(\"key\", \"777\");\n　　//将bundle数据放入广播中传给下一个广播接收者\n　　setResultExtras(bundle);　\n　　\n　　//终止广播传给下一个广播接收者\n　　abortBroadcast();\n}\n```\n\n高级别的广播收到该广播后，可以决定把该广播是否截断掉。 　　同级别接收是先后是随机的，如果先接收到的把广播截断了，同级别的例外的接收者是无法收到该广播。 　\n\n##### 异步广播\n\n使用方法：sendStickyBroadcast() ：\n\n发出的Intent当接收Activity（动态注册）重新处于onResume状态之后就能重新接受到其Intent.（the Intent will be held to be re-broadcast to future receivers）。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Activity处于活跃的时候又会接受到它\n\n发这个广播需要权限：\n\n```java\n<uses-permission android:name=\"android.permission.BROADCAST_STICKY\" />\n```\n\n卸载该广播：\n\n```java\nremoveStickyBroadcast(intent);\n```\n\n在卸载之前该intent会保留，接收者在可接收状态都能获得。\n\n##### 异步有序广播\n\n使用方法：sendStickyOrderedBroadcast(intent, resultReceiver, scheduler, initialCode, initialData, initialExtras)：\n\n这个方法具有有序广播的特性也有异步广播的特性；同时需要限权：\n\n```java\n<uses-permission android:name=\"android.permission.BROADCAST_STICKY\" /> \n```\n\n### 四 安全性\n\nBroadcastReceiver的设计初衷就是从全局考虑的，可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言BroadcastReceiver是存在安全性问题的，相应问题及解决如下：   \n\n- 当应用程序发送某个广播时系统会将发送的Intent与系统中所有注册的BroadcastReceiver的IntentFilter进行匹配，若匹配成功则执行相应的onReceive函数。可以通过类似sendBroadcast(Intent, String)的接口在发送广播时指定接收者必须具备的permission。或通过Intent.setPackage设置广播仅对某个程序有效。\n- 当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。对于动态注册的广播可以通过类似registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)的接口指定发送者必须具备的permission，对于静态注册的广播可以通过android:exported=\"false\"属性表示接收者对外部应用程序不可用，即不接受来自外部的广播。\n- 上面两个问题其实都可以通过LocalBroadcastManager来解决，LocalBroadcastManager只会将广播限定在当前应用程序中。\n- 使用android:protectionLevel\n\nandroid引入了LocalBroadcastManager解决在第4部分安全性介绍的一些问题，LocalBroadcastManager除了能解决BroadcastReceiver进程间安全性问题外，相对Context操作的BroadcastReceiver而言还具有更高的运行效率。使用LocalBroadcastManager需要引入Android Support Library，如何引入见Add Support Package。\n本地广播通过LocalBroadcastManager.getInstance(context).sendBroadcast(intent)发送广播，LocalBroadcastManager.getInstance(context).registerReceiver注册服务，通过LocalBroadcastManager.getInstance(context).unregisterReceiver取消注册服务，其他同普通广播.\n\n### 五 一些常用的系统广播的action 和permission\n\n##### 1.开机启动\n\n```java\n<action android:name=\"android.intent.action.BOOT_COMPLETED\"/> \n\n<uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\" />  \n\n```\n\n##### 2.网络状态\n\n```java\n<action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\"/>  \n\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/> \n\n```\n\n网络是否可用的方法：\n\n```java\npublic static boolean isNetworkAvailable(Context context) {  \n        ConnectivityManager mgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);  \n        NetworkInfo[] info = mgr.getAllNetworkInfo();  \n        if (info != null) {  \n            for (int i = 0; i < info.length; i++) {  \n      if (info[i].getState() == NetworkInfo.State.CONNECTED) {  \n                    return true;  \n                }  \n            }  \n        }  \n        return false;  \n    } \n```\n\n##### 3.电量变化\n\n```java\n<action android:name=\"android.intent.action.BATTERY_CHANGED\"/>  \n```\n\nBroadcastReceiver 的onReceive方法：\n\n```java\npublic void onReceive(Context context, Intent intent) {  \n        int currLevel = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, 0);  //当前电量  　\n\n        int total = intent.getIntExtra(BatteryManager.EXTRA_SCALE, 1);    //总电量  \n        int percent = currLevel * 100 / total;  \n        Log.i(TAG, \"battery: \" + percent + \"%\");  \n    }  \n\n```\n\n\n\n### 六 总结\n\n- 静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。\n- 动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：1)这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。2)这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。\n- 广播发出的时候，广播接收者接收的顺序如下：    \n1)当广播为普通广播时，有如下的接收顺序：  \n\na、无视优先级   \nb、动态优先于静态    \nc、同优先级的动态广播接收器，先注册的大于后注册的   \nd、同优先级的静态广播接收器，先扫描的大于后扫描的　   \n\n2）如果广播为有序广播，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：　 \n   　　 　　\na、优先级高的先接收　 　  \nb、同优先级的动静态广播接收器，动态优先于静态 　　  \nc、同优先级的动态广播接收器，先注册的大于后注册的 　　  \nd、同优先级的静态广播接收器，先扫描的大于后扫描的　   ","slug":"android基础之BroadcastReceiver","published":1,"updated":"2017-03-07T10:25:28.582Z","_id":"cizz09ft60000aonzbu39zxst","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"一-BroadcastReceiver简介\"><a href=\"#一-BroadcastReceiver简介\" class=\"headerlink\" title=\"一 BroadcastReceiver简介\"></a>一 BroadcastReceiver简介</h3><p>广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。如：在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。</p>\n<p>BroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。</p>\n<p>当系统或应用发出广播时，将会扫描系统中的所有广播接收者，通过action匹配将广播发送给相应的接收者，接收者收到广播后将会产生一个广播接收者的实例，执行其中的onReceiver()这个方法；特别需要注意的是这个实例的生命周期只有10秒，如果10秒内没执行结束onReceiver()，系统将会报错。在onReceiver()执行完毕之后，该实例将会被销毁，所以不要在onReceiver()中执行耗时操作，也不要在里面创建子线程处理业务（因为可能子线程没处理完，接收者就被回收了，那么子线程也会跟着被回收掉）；正确的处理方法就是通过in调用activity或者service处理业务。</p>\n<h3 id=\"二-BroadcastReceiver的两种注册方式\"><a href=\"#二-BroadcastReceiver的两种注册方式\" class=\"headerlink\" title=\"二 BroadcastReceiver的两种注册方式\"></a>二 BroadcastReceiver的两种注册方式</h3><h5 id=\"1-静态注册（推荐）\"><a href=\"#1-静态注册（推荐）\" class=\"headerlink\" title=\"1.静态注册（推荐）\"></a>1.静态注册（推荐）</h5><p>静态注册的广播接收者是一个常驻在系统中的全局监听器，当你在应用中配置了一个静态的BroadcastReceiver，安装了应用后而无论应用是否处于运行状态，广播接收者都是已经常驻在系统中了。同时应用里的所有receiver都在清单文件里面，方便查看。　 　　 　　要销毁掉静态注册的广播接收者，可以通过调用PackageManager将Receiver禁用。</p>\n<p>在AndroidManifest.xml的application里面定义receiver并设置要接收的action。下面是代码示例：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt; receiver android:name = \".MyBroadcastReceiver\" &gt; </div><div class=\"line\"></div><div class=\"line\"> &lt; intent-filter android:priority = \"777\" &gt;             </div><div class=\"line\">&lt;action android:name = \"android.provider.Telephony.SMS_RECEIVED\" /&gt;</div><div class=\"line\">&lt;/ intent-filter &gt; </div><div class=\"line\"></div><div class=\"line\">&lt;/ receiver &gt;</div></pre></td></tr></table></figure>\n<p>这里的priority取值是　-1000到1000，值越大优先级越高，同时注意加上系统接收短信的限权。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt; uses-permission android:name =<span class=\"string\">\"android.permission.RECEIVE_SMS\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"2-动态注册\"><a href=\"#2-动态注册\" class=\"headerlink\" title=\"2.动态注册\"></a>2.动态注册</h5><p>在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">    MyBroadcastReceiver receiver;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 动态注册广播 (代码执行到这才会开始监听广播消息，并对广播消息作为相应的处理)</span></div><div class=\"line\">        receiver = <span class=\"keyword\">new</span> MyBroadcastReceiver();</div><div class=\"line\">        IntentFilter intentFilter = <span class=\"keyword\">new</span> IntentFilter( <span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span> );</div><div class=\"line\">        registerReceiver( receiver , intentFilter);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">super</span>.onResume();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">// 撤销注册 (撤销注册后广播接收者将不会再监听系统的广播消息)</span></div><div class=\"line\">        unregisterReceiver(receiver);</div><div class=\"line\">        <span class=\"keyword\">super</span>.onPause();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接收广播示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBroadcastReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// action 名称</span></div><div class=\"line\">String SMS_RECEIVED = <span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span> ;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (intent.getAction().equals( SMS_RECEIVED )) &#123;</div><div class=\"line\">           <span class=\"comment\">// 一个receiver可以接收多个action的，即可以有多个intent-filter，需要在onReceive里面对intent.getAction(action name)进行判断。</span></div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"3-静态注册和动态注册的区别\"><a href=\"#3-静态注册和动态注册的区别\" class=\"headerlink\" title=\"3.静态注册和动态注册的区别\"></a>3.静态注册和动态注册的区别</h5><ol>\n<li>静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者； 　　动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。</li>\n<li>当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。　 　　动态注册的广播接收者将会导致应用报错 　　而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。</li>\n</ol>\n<h3 id=\"三-发送广播\"><a href=\"#三-发送广播\" class=\"headerlink\" title=\"三 发送广播\"></a>三 发送广播</h3><p>发送广播主要有两种类型：</p>\n<h5 id=\"1-普通广播\"><a href=\"#1-普通广播\" class=\"headerlink\" title=\"1.普通广播\"></a>1.普通广播</h5><p>应用在需要通知各个广播接收者的情况下使用，如 开机启动，使用方法：sendBroadcast()。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span>); </div><div class=\"line\"><span class=\"comment\">//通过intent传递少量数据</span></div><div class=\"line\">intent.putExtra(<span class=\"string\">\"data\"</span>, <span class=\"string\">\"finch\"</span>); </div><div class=\"line\"><span class=\"comment\">// 发送普通广播</span></div><div class=\"line\">sendBroadcast(Intent);</div></pre></td></tr></table></figure>\n<p>普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，所有满足条件的 BroadcastReceiver 都会随机地执行其 onReceive() 方法。 　　同级别接收是先后是随机的；级别低的收到广播； 　　消息传递的效率比较高，并且无法中断广播的传播。</p>\n<h5 id=\"有序广播\"><a href=\"#有序广播\" class=\"headerlink\" title=\"有序广播\"></a>有序广播</h5><p>应用在需要有特定拦截的场景下使用，如黑名单短信、电话拦截。</p>\n<p>使用方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sendOrderedBroadcast(intent, receiverPermission);</div></pre></td></tr></table></figure>\n<p>receiverPermission ：一个接收器必须持以接收您的广播。如果为 null ，不经许可的要求（一般都为null）,如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//发送有序广播</span></div><div class=\"line\">sendOrderedBroadcast(intent, <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<p>在有序广播中，我们可以在前一个广播接收者将处理好的数据传送给后面的广播接收者，也可以调用abortBroadcast()来终结广播的传播。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context arg0, Intent intent)</span> </span>&#123;</div><div class=\"line\">　　<span class=\"comment\">//获取上一个广播的bundle数据</span></div><div class=\"line\">　　Bundle bundle = getResultExtras(<span class=\"keyword\">true</span>);<span class=\"comment\">//true：前一个广播没有结果时创建新的Bundle；false：不创建Bundle</span></div><div class=\"line\">　　bundle.putString(<span class=\"string\">\"key\"</span>, <span class=\"string\">\"777\"</span>);</div><div class=\"line\">　　<span class=\"comment\">//将bundle数据放入广播中传给下一个广播接收者</span></div><div class=\"line\">　　setResultExtras(bundle);　</div><div class=\"line\">　　</div><div class=\"line\">　　<span class=\"comment\">//终止广播传给下一个广播接收者</span></div><div class=\"line\">　　abortBroadcast();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>高级别的广播收到该广播后，可以决定把该广播是否截断掉。 　　同级别接收是先后是随机的，如果先接收到的把广播截断了，同级别的例外的接收者是无法收到该广播。 　</p>\n<h5 id=\"异步广播\"><a href=\"#异步广播\" class=\"headerlink\" title=\"异步广播\"></a>异步广播</h5><p>使用方法：sendStickyBroadcast() ：</p>\n<p>发出的Intent当接收Activity（动态注册）重新处于onResume状态之后就能重新接受到其Intent.（the Intent will be held to be re-broadcast to future receivers）。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Activity处于活跃的时候又会接受到它</p>\n<p>发这个广播需要权限：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.BROADCAST_STICKY\"</span> /&gt;</div></pre></td></tr></table></figure>\n<p>卸载该广播：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">removeStickyBroadcast(intent);</div></pre></td></tr></table></figure>\n<p>在卸载之前该intent会保留，接收者在可接收状态都能获得。</p>\n<h5 id=\"异步有序广播\"><a href=\"#异步有序广播\" class=\"headerlink\" title=\"异步有序广播\"></a>异步有序广播</h5><p>使用方法：sendStickyOrderedBroadcast(intent, resultReceiver, scheduler, initialCode, initialData, initialExtras)：</p>\n<p>这个方法具有有序广播的特性也有异步广播的特性；同时需要限权：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.BROADCAST_STICKY\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"四-安全性\"><a href=\"#四-安全性\" class=\"headerlink\" title=\"四 安全性\"></a>四 安全性</h3><p>BroadcastReceiver的设计初衷就是从全局考虑的，可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言BroadcastReceiver是存在安全性问题的，相应问题及解决如下：   </p>\n<ul>\n<li>当应用程序发送某个广播时系统会将发送的Intent与系统中所有注册的BroadcastReceiver的IntentFilter进行匹配，若匹配成功则执行相应的onReceive函数。可以通过类似sendBroadcast(Intent, String)的接口在发送广播时指定接收者必须具备的permission。或通过Intent.setPackage设置广播仅对某个程序有效。</li>\n<li>当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。对于动态注册的广播可以通过类似registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)的接口指定发送者必须具备的permission，对于静态注册的广播可以通过android:exported=”false”属性表示接收者对外部应用程序不可用，即不接受来自外部的广播。</li>\n<li>上面两个问题其实都可以通过LocalBroadcastManager来解决，LocalBroadcastManager只会将广播限定在当前应用程序中。</li>\n<li>使用android:protectionLevel</li>\n</ul>\n<p>android引入了LocalBroadcastManager解决在第4部分安全性介绍的一些问题，LocalBroadcastManager除了能解决BroadcastReceiver进程间安全性问题外，相对Context操作的BroadcastReceiver而言还具有更高的运行效率。使用LocalBroadcastManager需要引入Android Support Library，如何引入见Add Support Package。<br>本地广播通过LocalBroadcastManager.getInstance(context).sendBroadcast(intent)发送广播，LocalBroadcastManager.getInstance(context).registerReceiver注册服务，通过LocalBroadcastManager.getInstance(context).unregisterReceiver取消注册服务，其他同普通广播.</p>\n<h3 id=\"五-一些常用的系统广播的action-和permission\"><a href=\"#五-一些常用的系统广播的action-和permission\" class=\"headerlink\" title=\"五 一些常用的系统广播的action 和permission\"></a>五 一些常用的系统广播的action 和permission</h3><h5 id=\"1-开机启动\"><a href=\"#1-开机启动\" class=\"headerlink\" title=\"1.开机启动\"></a>1.开机启动</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;action android:name=<span class=\"string\">\"android.intent.action.BOOT_COMPLETED\"</span>/&gt; </div><div class=\"line\"></div><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.RECEIVE_BOOT_COMPLETED\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"2-网络状态\"><a href=\"#2-网络状态\" class=\"headerlink\" title=\"2.网络状态\"></a>2.网络状态</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;action android:name=<span class=\"string\">\"android.net.conn.CONNECTIVITY_CHANGE\"</span>/&gt;  </div><div class=\"line\"></div><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.ACCESS_NETWORK_STATE\"</span>/&gt;</div></pre></td></tr></table></figure>\n<p>网络是否可用的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isNetworkAvailable</span><span class=\"params\">(Context context)</span> </span>&#123;  </div><div class=\"line\">        ConnectivityManager mgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);  </div><div class=\"line\">        NetworkInfo[] info = mgr.getAllNetworkInfo();  </div><div class=\"line\">        <span class=\"keyword\">if</span> (info != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; info.length; i++) &#123;  </div><div class=\"line\">      <span class=\"keyword\">if</span> (info[i].getState() == NetworkInfo.State.CONNECTED) &#123;  </div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h5 id=\"3-电量变化\"><a href=\"#3-电量变化\" class=\"headerlink\" title=\"3.电量变化\"></a>3.电量变化</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;action android:name=<span class=\"string\">\"android.intent.action.BATTERY_CHANGED\"</span>/&gt;</div></pre></td></tr></table></figure>\n<p>BroadcastReceiver 的onReceive方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">int</span> currLevel = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, <span class=\"number\">0</span>);  <span class=\"comment\">//当前电量  　</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> total = intent.getIntExtra(BatteryManager.EXTRA_SCALE, <span class=\"number\">1</span>);    <span class=\"comment\">//总电量  </span></div><div class=\"line\">        <span class=\"keyword\">int</span> percent = currLevel * <span class=\"number\">100</span> / total;  </div><div class=\"line\">        Log.i(TAG, <span class=\"string\">\"battery: \"</span> + percent + <span class=\"string\">\"%\"</span>);  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"六-总结\"><a href=\"#六-总结\" class=\"headerlink\" title=\"六 总结\"></a>六 总结</h3><ul>\n<li>静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。</li>\n<li>动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：1)这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。2)这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。</li>\n<li>广播发出的时候，广播接收者接收的顺序如下：<br>1)当广播为普通广播时，有如下的接收顺序：  </li>\n</ul>\n<p>a、无视优先级<br>b、动态优先于静态<br>c、同优先级的动态广播接收器，先注册的大于后注册的<br>d、同优先级的静态广播接收器，先扫描的大于后扫描的　   </p>\n<p>2）如果广播为有序广播，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：　<br>   　　 　　<br>a、优先级高的先接收　 　<br>b、同优先级的动静态广播接收器，动态优先于静态 　　<br>c、同优先级的动态广播接收器，先注册的大于后注册的 　　<br>d、同优先级的静态广播接收器，先扫描的大于后扫描的　   </p>\n","excerpt":"","more":"<h3 id=\"一-BroadcastReceiver简介\"><a href=\"#一-BroadcastReceiver简介\" class=\"headerlink\" title=\"一 BroadcastReceiver简介\"></a>一 BroadcastReceiver简介</h3><p>广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。如：在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。</p>\n<p>BroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。</p>\n<p>当系统或应用发出广播时，将会扫描系统中的所有广播接收者，通过action匹配将广播发送给相应的接收者，接收者收到广播后将会产生一个广播接收者的实例，执行其中的onReceiver()这个方法；特别需要注意的是这个实例的生命周期只有10秒，如果10秒内没执行结束onReceiver()，系统将会报错。在onReceiver()执行完毕之后，该实例将会被销毁，所以不要在onReceiver()中执行耗时操作，也不要在里面创建子线程处理业务（因为可能子线程没处理完，接收者就被回收了，那么子线程也会跟着被回收掉）；正确的处理方法就是通过in调用activity或者service处理业务。</p>\n<h3 id=\"二-BroadcastReceiver的两种注册方式\"><a href=\"#二-BroadcastReceiver的两种注册方式\" class=\"headerlink\" title=\"二 BroadcastReceiver的两种注册方式\"></a>二 BroadcastReceiver的两种注册方式</h3><h5 id=\"1-静态注册（推荐）\"><a href=\"#1-静态注册（推荐）\" class=\"headerlink\" title=\"1.静态注册（推荐）\"></a>1.静态注册（推荐）</h5><p>静态注册的广播接收者是一个常驻在系统中的全局监听器，当你在应用中配置了一个静态的BroadcastReceiver，安装了应用后而无论应用是否处于运行状态，广播接收者都是已经常驻在系统中了。同时应用里的所有receiver都在清单文件里面，方便查看。　 　　 　　要销毁掉静态注册的广播接收者，可以通过调用PackageManager将Receiver禁用。</p>\n<p>在AndroidManifest.xml的application里面定义receiver并设置要接收的action。下面是代码示例：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt; receiver android:name = \".MyBroadcastReceiver\" &gt; </div><div class=\"line\"></div><div class=\"line\"> &lt; intent-filter android:priority = \"777\" &gt;             </div><div class=\"line\">&lt;action android:name = \"android.provider.Telephony.SMS_RECEIVED\" /&gt;</div><div class=\"line\">&lt;/ intent-filter &gt; </div><div class=\"line\"></div><div class=\"line\">&lt;/ receiver &gt;</div></pre></td></tr></table></figure>\n<p>这里的priority取值是　-1000到1000，值越大优先级越高，同时注意加上系统接收短信的限权。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt; uses-permission android:name =<span class=\"string\">\"android.permission.RECEIVE_SMS\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"2-动态注册\"><a href=\"#2-动态注册\" class=\"headerlink\" title=\"2.动态注册\"></a>2.动态注册</h5><p>在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">    MyBroadcastReceiver receiver;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 动态注册广播 (代码执行到这才会开始监听广播消息，并对广播消息作为相应的处理)</span></div><div class=\"line\">        receiver = <span class=\"keyword\">new</span> MyBroadcastReceiver();</div><div class=\"line\">        IntentFilter intentFilter = <span class=\"keyword\">new</span> IntentFilter( <span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span> );</div><div class=\"line\">        registerReceiver( receiver , intentFilter);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">super</span>.onResume();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">// 撤销注册 (撤销注册后广播接收者将不会再监听系统的广播消息)</span></div><div class=\"line\">        unregisterReceiver(receiver);</div><div class=\"line\">        <span class=\"keyword\">super</span>.onPause();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接收广播示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBroadcastReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// action 名称</span></div><div class=\"line\">String SMS_RECEIVED = <span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span> ;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (intent.getAction().equals( SMS_RECEIVED )) &#123;</div><div class=\"line\">           <span class=\"comment\">// 一个receiver可以接收多个action的，即可以有多个intent-filter，需要在onReceive里面对intent.getAction(action name)进行判断。</span></div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"3-静态注册和动态注册的区别\"><a href=\"#3-静态注册和动态注册的区别\" class=\"headerlink\" title=\"3.静态注册和动态注册的区别\"></a>3.静态注册和动态注册的区别</h5><ol>\n<li>静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者； 　　动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。</li>\n<li>当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。　 　　动态注册的广播接收者将会导致应用报错 　　而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。</li>\n</ol>\n<h3 id=\"三-发送广播\"><a href=\"#三-发送广播\" class=\"headerlink\" title=\"三 发送广播\"></a>三 发送广播</h3><p>发送广播主要有两种类型：</p>\n<h5 id=\"1-普通广播\"><a href=\"#1-普通广播\" class=\"headerlink\" title=\"1.普通广播\"></a>1.普通广播</h5><p>应用在需要通知各个广播接收者的情况下使用，如 开机启动，使用方法：sendBroadcast()。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span>); </div><div class=\"line\"><span class=\"comment\">//通过intent传递少量数据</span></div><div class=\"line\">intent.putExtra(<span class=\"string\">\"data\"</span>, <span class=\"string\">\"finch\"</span>); </div><div class=\"line\"><span class=\"comment\">// 发送普通广播</span></div><div class=\"line\">sendBroadcast(Intent);</div></pre></td></tr></table></figure>\n<p>普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，所有满足条件的 BroadcastReceiver 都会随机地执行其 onReceive() 方法。 　　同级别接收是先后是随机的；级别低的收到广播； 　　消息传递的效率比较高，并且无法中断广播的传播。</p>\n<h5 id=\"有序广播\"><a href=\"#有序广播\" class=\"headerlink\" title=\"有序广播\"></a>有序广播</h5><p>应用在需要有特定拦截的场景下使用，如黑名单短信、电话拦截。</p>\n<p>使用方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sendOrderedBroadcast(intent, receiverPermission);</div></pre></td></tr></table></figure>\n<p>receiverPermission ：一个接收器必须持以接收您的广播。如果为 null ，不经许可的要求（一般都为null）,如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//发送有序广播</span></div><div class=\"line\">sendOrderedBroadcast(intent, <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<p>在有序广播中，我们可以在前一个广播接收者将处理好的数据传送给后面的广播接收者，也可以调用abortBroadcast()来终结广播的传播。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context arg0, Intent intent)</span> </span>&#123;</div><div class=\"line\">　　<span class=\"comment\">//获取上一个广播的bundle数据</span></div><div class=\"line\">　　Bundle bundle = getResultExtras(<span class=\"keyword\">true</span>);<span class=\"comment\">//true：前一个广播没有结果时创建新的Bundle；false：不创建Bundle</span></div><div class=\"line\">　　bundle.putString(<span class=\"string\">\"key\"</span>, <span class=\"string\">\"777\"</span>);</div><div class=\"line\">　　<span class=\"comment\">//将bundle数据放入广播中传给下一个广播接收者</span></div><div class=\"line\">　　setResultExtras(bundle);　</div><div class=\"line\">　　</div><div class=\"line\">　　<span class=\"comment\">//终止广播传给下一个广播接收者</span></div><div class=\"line\">　　abortBroadcast();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>高级别的广播收到该广播后，可以决定把该广播是否截断掉。 　　同级别接收是先后是随机的，如果先接收到的把广播截断了，同级别的例外的接收者是无法收到该广播。 　</p>\n<h5 id=\"异步广播\"><a href=\"#异步广播\" class=\"headerlink\" title=\"异步广播\"></a>异步广播</h5><p>使用方法：sendStickyBroadcast() ：</p>\n<p>发出的Intent当接收Activity（动态注册）重新处于onResume状态之后就能重新接受到其Intent.（the Intent will be held to be re-broadcast to future receivers）。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Activity处于活跃的时候又会接受到它</p>\n<p>发这个广播需要权限：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.BROADCAST_STICKY\"</span> /&gt;</div></pre></td></tr></table></figure>\n<p>卸载该广播：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">removeStickyBroadcast(intent);</div></pre></td></tr></table></figure>\n<p>在卸载之前该intent会保留，接收者在可接收状态都能获得。</p>\n<h5 id=\"异步有序广播\"><a href=\"#异步有序广播\" class=\"headerlink\" title=\"异步有序广播\"></a>异步有序广播</h5><p>使用方法：sendStickyOrderedBroadcast(intent, resultReceiver, scheduler, initialCode, initialData, initialExtras)：</p>\n<p>这个方法具有有序广播的特性也有异步广播的特性；同时需要限权：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.BROADCAST_STICKY\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"四-安全性\"><a href=\"#四-安全性\" class=\"headerlink\" title=\"四 安全性\"></a>四 安全性</h3><p>BroadcastReceiver的设计初衷就是从全局考虑的，可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言BroadcastReceiver是存在安全性问题的，相应问题及解决如下：   </p>\n<ul>\n<li>当应用程序发送某个广播时系统会将发送的Intent与系统中所有注册的BroadcastReceiver的IntentFilter进行匹配，若匹配成功则执行相应的onReceive函数。可以通过类似sendBroadcast(Intent, String)的接口在发送广播时指定接收者必须具备的permission。或通过Intent.setPackage设置广播仅对某个程序有效。</li>\n<li>当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。对于动态注册的广播可以通过类似registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)的接口指定发送者必须具备的permission，对于静态注册的广播可以通过android:exported=”false”属性表示接收者对外部应用程序不可用，即不接受来自外部的广播。</li>\n<li>上面两个问题其实都可以通过LocalBroadcastManager来解决，LocalBroadcastManager只会将广播限定在当前应用程序中。</li>\n<li>使用android:protectionLevel</li>\n</ul>\n<p>android引入了LocalBroadcastManager解决在第4部分安全性介绍的一些问题，LocalBroadcastManager除了能解决BroadcastReceiver进程间安全性问题外，相对Context操作的BroadcastReceiver而言还具有更高的运行效率。使用LocalBroadcastManager需要引入Android Support Library，如何引入见Add Support Package。<br>本地广播通过LocalBroadcastManager.getInstance(context).sendBroadcast(intent)发送广播，LocalBroadcastManager.getInstance(context).registerReceiver注册服务，通过LocalBroadcastManager.getInstance(context).unregisterReceiver取消注册服务，其他同普通广播.</p>\n<h3 id=\"五-一些常用的系统广播的action-和permission\"><a href=\"#五-一些常用的系统广播的action-和permission\" class=\"headerlink\" title=\"五 一些常用的系统广播的action 和permission\"></a>五 一些常用的系统广播的action 和permission</h3><h5 id=\"1-开机启动\"><a href=\"#1-开机启动\" class=\"headerlink\" title=\"1.开机启动\"></a>1.开机启动</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;action android:name=<span class=\"string\">\"android.intent.action.BOOT_COMPLETED\"</span>/&gt; </div><div class=\"line\"></div><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.RECEIVE_BOOT_COMPLETED\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"2-网络状态\"><a href=\"#2-网络状态\" class=\"headerlink\" title=\"2.网络状态\"></a>2.网络状态</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;action android:name=<span class=\"string\">\"android.net.conn.CONNECTIVITY_CHANGE\"</span>/&gt;  </div><div class=\"line\"></div><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.ACCESS_NETWORK_STATE\"</span>/&gt;</div></pre></td></tr></table></figure>\n<p>网络是否可用的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isNetworkAvailable</span><span class=\"params\">(Context context)</span> </span>&#123;  </div><div class=\"line\">        ConnectivityManager mgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);  </div><div class=\"line\">        NetworkInfo[] info = mgr.getAllNetworkInfo();  </div><div class=\"line\">        <span class=\"keyword\">if</span> (info != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; info.length; i++) &#123;  </div><div class=\"line\">      <span class=\"keyword\">if</span> (info[i].getState() == NetworkInfo.State.CONNECTED) &#123;  </div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h5 id=\"3-电量变化\"><a href=\"#3-电量变化\" class=\"headerlink\" title=\"3.电量变化\"></a>3.电量变化</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;action android:name=<span class=\"string\">\"android.intent.action.BATTERY_CHANGED\"</span>/&gt;</div></pre></td></tr></table></figure>\n<p>BroadcastReceiver 的onReceive方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">int</span> currLevel = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, <span class=\"number\">0</span>);  <span class=\"comment\">//当前电量  　</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> total = intent.getIntExtra(BatteryManager.EXTRA_SCALE, <span class=\"number\">1</span>);    <span class=\"comment\">//总电量  </span></div><div class=\"line\">        <span class=\"keyword\">int</span> percent = currLevel * <span class=\"number\">100</span> / total;  </div><div class=\"line\">        Log.i(TAG, <span class=\"string\">\"battery: \"</span> + percent + <span class=\"string\">\"%\"</span>);  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"六-总结\"><a href=\"#六-总结\" class=\"headerlink\" title=\"六 总结\"></a>六 总结</h3><ul>\n<li>静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。</li>\n<li>动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：1)这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。2)这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。</li>\n<li>广播发出的时候，广播接收者接收的顺序如下：<br>1)当广播为普通广播时，有如下的接收顺序：  </li>\n</ul>\n<p>a、无视优先级<br>b、动态优先于静态<br>c、同优先级的动态广播接收器，先注册的大于后注册的<br>d、同优先级的静态广播接收器，先扫描的大于后扫描的　   </p>\n<p>2）如果广播为有序广播，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：　<br>   　　 　　<br>a、优先级高的先接收　 　<br>b、同优先级的动静态广播接收器，动态优先于静态 　　<br>c、同优先级的动态广播接收器，先注册的大于后注册的 　　<br>d、同优先级的静态广播接收器，先扫描的大于后扫描的　   </p>\n"},{"title":"android基础之Content Provider","date":"2017-02-27T06:32:42.000Z","_content":"\n### 一 概述\n\nContentProvider（内容提供者）是Android的四大组件之一，通过它可以向其他的应用程序共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。而且Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。\n\n但注意ContentProvider它也只是一个中间人，真正操作的数据源可能是数据库，也可以是文件、xml或网络等其他存储方式。\n\n### Uri类简介\n\n```java\nUri uri = Uri.parse(\"content://com.changcheng.provider.contactprovider/contact\")\n```\n\n在Content Provider中使用的查询字符串有别于标准的SQL查询。很多诸如select, add, delete, modify等操作我们都使用一种特殊的URI来进行，这种URI由3个部分组成， “content://”, 代表数据的路径，和一个可选的标识数据的ID。以下是一些示例URI:    \n\n```java\ncontent://media/internal/images  //这个URI将返回设备上存储的所有图片\ncontent://contacts/people/  //这个URI将返回设备上的所有联系人信息\ncontent://contacts/people/45  //这个URI返回单个结果（联系人信息中ID为45的联系人记录）\n```\n\n尽管这种查询字符串格式很常见，但是它看起来还是有点令人迷惑。为此，Android提供一系列的帮助类（在android.provider包下），里面包含了很多以类变量形式给出的查询字符串，这种方式更容易让我们理解一点，因此，如上面content://contacts/people/45这个URI就可以写成如下形式：\n\n```java\nUri person = ContentUris.withAppendedId(People.CONTENT_URI,  45);\n```\n\n然后执行数据查询:\n\n```java\nCursor cur = managedQuery(person, null, null, null);\n```\n\n这个查询返回一个包含所有数据字段的游标，我们可以通过迭代这个游标来获取所有的数据.\n\n### 三 ContentProvider类简介\n\n##### 1.主要方法\n\n- public boolean onCreate()   \nContentProvider创建后　或　打开系统后其它应用第一次访问该ContentProvider时调用。      \n- public Uri insert(Uri uri, ContentValues values)    \n外部应用向ContentProvider中添加数据。    \n- public int delete(Uri uri, String selection, String[] selectionArgs)     \n外部应用从ContentProvider删除数据。    \n- public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)         \n外部应用更新ContentProvider中的数据。    \n- public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)　    \n供外部应用从ContentProvider中获取数据。 　    \n- public String getType(Uri uri)     \n该方法用于返回当前Url所代表数据的MIME类型  \n\n##### 2.创建步骤\n\n要创建我们自己的Content Provider的话，我们需要遵循以下几步：\n\n1.创建一个继承了ContentProvider父类的类   \n2.定义一个名为CONTENT_URI，并且是public static final的Uri类型的类变量，你必须为其指定一个唯一的字符串值，最好的方案是以类的全名称， 如:\n\n\n```java\npublic static final Uri CONTENT_URI = Uri.parse( “content://com.google.android.MyContentProvider”);\n```\n\n3.定义你要返回给客户端的数据列名。如果你正在使用Android数据库，必须为其定义一个叫_id的列，它用来表示每条记录的唯一性。     \n4.创建你的数据存储系统。大多数Content Provider使用Android文件系统或SQLite数据库来保持数据，但是你也可以以任何你想要的方式来存储。      \n5.如果你要存储字节型数据，比如位图文件等，数据列其实是一个表示实际保存文件的URI字符串，通过它来读取对应的文件数据。处理这种数据类型的Content Provider需要实现一个名为_data的字段，_data字段列出了该文件在Android文件系统上的精确路径。这个字段不仅是供客户端使用，而且也可以供ContentResolver使用。客户端可以调用ContentResolver.openOutputStream()方法来处理该URI指向的文件资源；如果是ContentResolver本身的话，由于其持有的权限比客户端要高，所以它能直接访问该数据文件。    \n6.声明public static String型的变量，用于指定要从游标处返回的数据列。    \n7.查询返回一个Cursor类型的对象。所有执行写操作的方法如insert(), update() 以及delete()都将被监听。我们可以通过使用ContentResover().notifyChange()方法来通知监听器关于数据更新的信息。     \n8.在AndroidMenifest.xml中使用<provider>标签来设置Content Provider。    \n9.如果你要处理的数据类型是一种比较新的类型，你就必须先定义一个新的MIME类型，以供ContentProvider.geType(url)来返回。MIME类型有两种形式:一种是为指定的单个记录的，还有一种是为多条记录的。这里给出一种常用的格式：   \n- vnd.android.cursor.item/vnd.yourcompanyname.contenttype （单个记录的MIME类型）   \n比如, 一个请求列车信息的URI如content://com.example.transportationprovider/trains/122 可能就会返回typevnd.android.cursor.item/vnd.example.rail这样一个MIME类型。   \n- vnd.android.cursor.dir/vnd.yourcompanyname.contenttype （多个记录的MIME类型）     \n比如, 一个请求所有列车信息的URI如content://com.example.transportationprovider/trains 可能就会返回vnd.android.cursor.dir/vnd.example.rail这样一个MIME 类型。\n\n下面是一个Content Provider代码示例：\n\n\n> 代码\n\n一个名为MyContentProvider的Content Provider创建完成了，它用于从Sqlite数据库中添加和读取记录。\n\n### 四 ContentResolver\n\n一个ContentProvider新建好了之后，我们需要一个ContentResolver类来获取其共享出的数据。\n\n##### 1.ContentResolver的主要方法\n\n- public Uri insert(Uri uri, ContentValues values)　//添加\n- public int delete(Uri uri, String selection, String[] selectionArgs)　//删除\n- public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)　//更新\n- public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)//获取\n\n\n示例代码：\n\n```java\nContentResolver resolver =  getContentResolver();\nUri uri = Uri.parse(\"content://cn.scu.myprovider/user\");\n\n//插入\nContentValues values = new ContentValues();\nvalues.put(\"name\", \"fanrunqi\");\nvalues.put(\"age\", 24);\nresolver.insert(uri, values);  \n\n//查询\nCursor cursor = resolver.query(uri, null, null, null, \"userid desc\");\nwhile(cursor.moveToNext()){\n   //操作\n}\n\n//更新\nContentValues updateValues = new ContentValues();\nupdateValues.put(\"name\", \"finch\");\nUri updateIdUri = ContentUris.withAppendedId(uri, 1);\nresolver.update(updateIdUri, updateValues, null, null);\n\n//删除\nUri deleteIdUri = ContentUris.withAppendedId(uri, 2);\nresolver.delete(deleteIdUri, null, null);\n```\n\n##### 使用ContentResolver获取数据的步骤\n\n1. 通过getContentResolver()方法得到ContentResol1.ver对象。\n2. 调用ContentResolver类的query()方法查询数据，该方法会返回一个Cursor对象。\n3. 对得到的Cursor对象进行分析，得到需要的数据。\n4. 调用Cursor类的close()方法将Cursor对象关闭。\n\n示例代码（与上面ContentProvider处的代码相连）：\n\n> 代码\n\n\n### 五 总结\n\n\n\n\n      \n\n\n\n\n\n\n\n","source":"_posts/android基础之Content-Providers.md","raw":"---\ntitle: android基础之Content Provider\ndate: 2017-02-27 14:32:42\ncategories: android\ntags:\n- android\n- java\n- Content Provider\n---\n\n### 一 概述\n\nContentProvider（内容提供者）是Android的四大组件之一，通过它可以向其他的应用程序共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。而且Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。\n\n但注意ContentProvider它也只是一个中间人，真正操作的数据源可能是数据库，也可以是文件、xml或网络等其他存储方式。\n\n### Uri类简介\n\n```java\nUri uri = Uri.parse(\"content://com.changcheng.provider.contactprovider/contact\")\n```\n\n在Content Provider中使用的查询字符串有别于标准的SQL查询。很多诸如select, add, delete, modify等操作我们都使用一种特殊的URI来进行，这种URI由3个部分组成， “content://”, 代表数据的路径，和一个可选的标识数据的ID。以下是一些示例URI:    \n\n```java\ncontent://media/internal/images  //这个URI将返回设备上存储的所有图片\ncontent://contacts/people/  //这个URI将返回设备上的所有联系人信息\ncontent://contacts/people/45  //这个URI返回单个结果（联系人信息中ID为45的联系人记录）\n```\n\n尽管这种查询字符串格式很常见，但是它看起来还是有点令人迷惑。为此，Android提供一系列的帮助类（在android.provider包下），里面包含了很多以类变量形式给出的查询字符串，这种方式更容易让我们理解一点，因此，如上面content://contacts/people/45这个URI就可以写成如下形式：\n\n```java\nUri person = ContentUris.withAppendedId(People.CONTENT_URI,  45);\n```\n\n然后执行数据查询:\n\n```java\nCursor cur = managedQuery(person, null, null, null);\n```\n\n这个查询返回一个包含所有数据字段的游标，我们可以通过迭代这个游标来获取所有的数据.\n\n### 三 ContentProvider类简介\n\n##### 1.主要方法\n\n- public boolean onCreate()   \nContentProvider创建后　或　打开系统后其它应用第一次访问该ContentProvider时调用。      \n- public Uri insert(Uri uri, ContentValues values)    \n外部应用向ContentProvider中添加数据。    \n- public int delete(Uri uri, String selection, String[] selectionArgs)     \n外部应用从ContentProvider删除数据。    \n- public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)         \n外部应用更新ContentProvider中的数据。    \n- public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)　    \n供外部应用从ContentProvider中获取数据。 　    \n- public String getType(Uri uri)     \n该方法用于返回当前Url所代表数据的MIME类型  \n\n##### 2.创建步骤\n\n要创建我们自己的Content Provider的话，我们需要遵循以下几步：\n\n1.创建一个继承了ContentProvider父类的类   \n2.定义一个名为CONTENT_URI，并且是public static final的Uri类型的类变量，你必须为其指定一个唯一的字符串值，最好的方案是以类的全名称， 如:\n\n\n```java\npublic static final Uri CONTENT_URI = Uri.parse( “content://com.google.android.MyContentProvider”);\n```\n\n3.定义你要返回给客户端的数据列名。如果你正在使用Android数据库，必须为其定义一个叫_id的列，它用来表示每条记录的唯一性。     \n4.创建你的数据存储系统。大多数Content Provider使用Android文件系统或SQLite数据库来保持数据，但是你也可以以任何你想要的方式来存储。      \n5.如果你要存储字节型数据，比如位图文件等，数据列其实是一个表示实际保存文件的URI字符串，通过它来读取对应的文件数据。处理这种数据类型的Content Provider需要实现一个名为_data的字段，_data字段列出了该文件在Android文件系统上的精确路径。这个字段不仅是供客户端使用，而且也可以供ContentResolver使用。客户端可以调用ContentResolver.openOutputStream()方法来处理该URI指向的文件资源；如果是ContentResolver本身的话，由于其持有的权限比客户端要高，所以它能直接访问该数据文件。    \n6.声明public static String型的变量，用于指定要从游标处返回的数据列。    \n7.查询返回一个Cursor类型的对象。所有执行写操作的方法如insert(), update() 以及delete()都将被监听。我们可以通过使用ContentResover().notifyChange()方法来通知监听器关于数据更新的信息。     \n8.在AndroidMenifest.xml中使用<provider>标签来设置Content Provider。    \n9.如果你要处理的数据类型是一种比较新的类型，你就必须先定义一个新的MIME类型，以供ContentProvider.geType(url)来返回。MIME类型有两种形式:一种是为指定的单个记录的，还有一种是为多条记录的。这里给出一种常用的格式：   \n- vnd.android.cursor.item/vnd.yourcompanyname.contenttype （单个记录的MIME类型）   \n比如, 一个请求列车信息的URI如content://com.example.transportationprovider/trains/122 可能就会返回typevnd.android.cursor.item/vnd.example.rail这样一个MIME类型。   \n- vnd.android.cursor.dir/vnd.yourcompanyname.contenttype （多个记录的MIME类型）     \n比如, 一个请求所有列车信息的URI如content://com.example.transportationprovider/trains 可能就会返回vnd.android.cursor.dir/vnd.example.rail这样一个MIME 类型。\n\n下面是一个Content Provider代码示例：\n\n\n> 代码\n\n一个名为MyContentProvider的Content Provider创建完成了，它用于从Sqlite数据库中添加和读取记录。\n\n### 四 ContentResolver\n\n一个ContentProvider新建好了之后，我们需要一个ContentResolver类来获取其共享出的数据。\n\n##### 1.ContentResolver的主要方法\n\n- public Uri insert(Uri uri, ContentValues values)　//添加\n- public int delete(Uri uri, String selection, String[] selectionArgs)　//删除\n- public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)　//更新\n- public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)//获取\n\n\n示例代码：\n\n```java\nContentResolver resolver =  getContentResolver();\nUri uri = Uri.parse(\"content://cn.scu.myprovider/user\");\n\n//插入\nContentValues values = new ContentValues();\nvalues.put(\"name\", \"fanrunqi\");\nvalues.put(\"age\", 24);\nresolver.insert(uri, values);  \n\n//查询\nCursor cursor = resolver.query(uri, null, null, null, \"userid desc\");\nwhile(cursor.moveToNext()){\n   //操作\n}\n\n//更新\nContentValues updateValues = new ContentValues();\nupdateValues.put(\"name\", \"finch\");\nUri updateIdUri = ContentUris.withAppendedId(uri, 1);\nresolver.update(updateIdUri, updateValues, null, null);\n\n//删除\nUri deleteIdUri = ContentUris.withAppendedId(uri, 2);\nresolver.delete(deleteIdUri, null, null);\n```\n\n##### 使用ContentResolver获取数据的步骤\n\n1. 通过getContentResolver()方法得到ContentResol1.ver对象。\n2. 调用ContentResolver类的query()方法查询数据，该方法会返回一个Cursor对象。\n3. 对得到的Cursor对象进行分析，得到需要的数据。\n4. 调用Cursor类的close()方法将Cursor对象关闭。\n\n示例代码（与上面ContentProvider处的代码相连）：\n\n> 代码\n\n\n### 五 总结\n\n\n\n\n      \n\n\n\n\n\n\n\n","slug":"android基础之Content-Providers","published":1,"updated":"2017-03-07T10:26:50.614Z","_id":"cizz09fta0001aonz46fftrf2","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>ContentProvider（内容提供者）是Android的四大组件之一，通过它可以向其他的应用程序共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。而且Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。</p>\n<p>但注意ContentProvider它也只是一个中间人，真正操作的数据源可能是数据库，也可以是文件、xml或网络等其他存储方式。</p>\n<h3 id=\"Uri类简介\"><a href=\"#Uri类简介\" class=\"headerlink\" title=\"Uri类简介\"></a>Uri类简介</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri uri = Uri.parse(<span class=\"string\">\"content://com.changcheng.provider.contactprovider/contact\"</span>)</div></pre></td></tr></table></figure>\n<p>在Content Provider中使用的查询字符串有别于标准的SQL查询。很多诸如select, add, delete, modify等操作我们都使用一种特殊的URI来进行，这种URI由3个部分组成， “content://”, 代表数据的路径，和一个可选的标识数据的ID。以下是一些示例URI:    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">content:<span class=\"comment\">//media/internal/images  //这个URI将返回设备上存储的所有图片</span></div><div class=\"line\">content:<span class=\"comment\">//contacts/people/  //这个URI将返回设备上的所有联系人信息</span></div><div class=\"line\">content:<span class=\"comment\">//contacts/people/45  //这个URI返回单个结果（联系人信息中ID为45的联系人记录）</span></div></pre></td></tr></table></figure>\n<p>尽管这种查询字符串格式很常见，但是它看起来还是有点令人迷惑。为此，Android提供一系列的帮助类（在android.provider包下），里面包含了很多以类变量形式给出的查询字符串，这种方式更容易让我们理解一点，因此，如上面content://contacts/people/45这个URI就可以写成如下形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri person = ContentUris.withAppendedId(People.CONTENT_URI,  <span class=\"number\">45</span>);</div></pre></td></tr></table></figure>\n<p>然后执行数据查询:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cursor cur = managedQuery(person, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<p>这个查询返回一个包含所有数据字段的游标，我们可以通过迭代这个游标来获取所有的数据.</p>\n<h3 id=\"三-ContentProvider类简介\"><a href=\"#三-ContentProvider类简介\" class=\"headerlink\" title=\"三 ContentProvider类简介\"></a>三 ContentProvider类简介</h3><h5 id=\"1-主要方法\"><a href=\"#1-主要方法\" class=\"headerlink\" title=\"1.主要方法\"></a>1.主要方法</h5><ul>\n<li>public boolean onCreate()<br>ContentProvider创建后　或　打开系统后其它应用第一次访问该ContentProvider时调用。      </li>\n<li>public Uri insert(Uri uri, ContentValues values)<br>外部应用向ContentProvider中添加数据。    </li>\n<li>public int delete(Uri uri, String selection, String[] selectionArgs)<br>外部应用从ContentProvider删除数据。    </li>\n<li>public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)<br>外部应用更新ContentProvider中的数据。    </li>\n<li>public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)　<br>供外部应用从ContentProvider中获取数据。 　    </li>\n<li>public String getType(Uri uri)<br>该方法用于返回当前Url所代表数据的MIME类型  </li>\n</ul>\n<h5 id=\"2-创建步骤\"><a href=\"#2-创建步骤\" class=\"headerlink\" title=\"2.创建步骤\"></a>2.创建步骤</h5><p>要创建我们自己的Content Provider的话，我们需要遵循以下几步：</p>\n<p>1.创建一个继承了ContentProvider父类的类<br>2.定义一个名为CONTENT_URI，并且是public static final的Uri类型的类变量，你必须为其指定一个唯一的字符串值，最好的方案是以类的全名称， 如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Uri CONTENT_URI = Uri.parse( “content:<span class=\"comment\">//com.google.android.MyContentProvider”);</span></div></pre></td></tr></table></figure>\n<p>3.定义你要返回给客户端的数据列名。如果你正在使用Android数据库，必须为其定义一个叫_id的列，它用来表示每条记录的唯一性。<br>4.创建你的数据存储系统。大多数Content Provider使用Android文件系统或SQLite数据库来保持数据，但是你也可以以任何你想要的方式来存储。<br>5.如果你要存储字节型数据，比如位图文件等，数据列其实是一个表示实际保存文件的URI字符串，通过它来读取对应的文件数据。处理这种数据类型的Content Provider需要实现一个名为_data的字段，_data字段列出了该文件在Android文件系统上的精确路径。这个字段不仅是供客户端使用，而且也可以供ContentResolver使用。客户端可以调用ContentResolver.openOutputStream()方法来处理该URI指向的文件资源；如果是ContentResolver本身的话，由于其持有的权限比客户端要高，所以它能直接访问该数据文件。<br>6.声明public static String型的变量，用于指定要从游标处返回的数据列。<br>7.查询返回一个Cursor类型的对象。所有执行写操作的方法如insert(), update() 以及delete()都将被监听。我们可以通过使用ContentResover().notifyChange()方法来通知监听器关于数据更新的信息。<br>8.在AndroidMenifest.xml中使用<provider>标签来设置Content Provider。<br>9.如果你要处理的数据类型是一种比较新的类型，你就必须先定义一个新的MIME类型，以供ContentProvider.geType(url)来返回。MIME类型有两种形式:一种是为指定的单个记录的，还有一种是为多条记录的。这里给出一种常用的格式：   </provider></p>\n<ul>\n<li>vnd.android.cursor.item/vnd.yourcompanyname.contenttype （单个记录的MIME类型）<br>比如, 一个请求列车信息的URI如content://com.example.transportationprovider/trains/122 可能就会返回typevnd.android.cursor.item/vnd.example.rail这样一个MIME类型。   </li>\n<li>vnd.android.cursor.dir/vnd.yourcompanyname.contenttype （多个记录的MIME类型）<br>比如, 一个请求所有列车信息的URI如content://com.example.transportationprovider/trains 可能就会返回vnd.android.cursor.dir/vnd.example.rail这样一个MIME 类型。</li>\n</ul>\n<p>下面是一个Content Provider代码示例：</p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<p>一个名为MyContentProvider的Content Provider创建完成了，它用于从Sqlite数据库中添加和读取记录。</p>\n<h3 id=\"四-ContentResolver\"><a href=\"#四-ContentResolver\" class=\"headerlink\" title=\"四 ContentResolver\"></a>四 ContentResolver</h3><p>一个ContentProvider新建好了之后，我们需要一个ContentResolver类来获取其共享出的数据。</p>\n<h5 id=\"1-ContentResolver的主要方法\"><a href=\"#1-ContentResolver的主要方法\" class=\"headerlink\" title=\"1.ContentResolver的主要方法\"></a>1.ContentResolver的主要方法</h5><ul>\n<li>public Uri insert(Uri uri, ContentValues values)　//添加</li>\n<li>public int delete(Uri uri, String selection, String[] selectionArgs)　//删除</li>\n<li>public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)　//更新</li>\n<li>public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)//获取</li>\n</ul>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">ContentResolver resolver =  getContentResolver();</div><div class=\"line\">Uri uri = Uri.parse(<span class=\"string\">\"content://cn.scu.myprovider/user\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//插入</span></div><div class=\"line\">ContentValues values = <span class=\"keyword\">new</span> ContentValues();</div><div class=\"line\">values.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"fanrunqi\"</span>);</div><div class=\"line\">values.put(<span class=\"string\">\"age\"</span>, <span class=\"number\">24</span>);</div><div class=\"line\">resolver.insert(uri, values);  </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//查询</span></div><div class=\"line\">Cursor cursor = resolver.query(uri, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"string\">\"userid desc\"</span>);</div><div class=\"line\"><span class=\"keyword\">while</span>(cursor.moveToNext())&#123;</div><div class=\"line\">   <span class=\"comment\">//操作</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//更新</span></div><div class=\"line\">ContentValues updateValues = <span class=\"keyword\">new</span> ContentValues();</div><div class=\"line\">updateValues.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"finch\"</span>);</div><div class=\"line\">Uri updateIdUri = ContentUris.withAppendedId(uri, <span class=\"number\">1</span>);</div><div class=\"line\">resolver.update(updateIdUri, updateValues, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//删除</span></div><div class=\"line\">Uri deleteIdUri = ContentUris.withAppendedId(uri, <span class=\"number\">2</span>);</div><div class=\"line\">resolver.delete(deleteIdUri, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<h5 id=\"使用ContentResolver获取数据的步骤\"><a href=\"#使用ContentResolver获取数据的步骤\" class=\"headerlink\" title=\"使用ContentResolver获取数据的步骤\"></a>使用ContentResolver获取数据的步骤</h5><ol>\n<li>通过getContentResolver()方法得到ContentResol1.ver对象。</li>\n<li>调用ContentResolver类的query()方法查询数据，该方法会返回一个Cursor对象。</li>\n<li>对得到的Cursor对象进行分析，得到需要的数据。</li>\n<li>调用Cursor类的close()方法将Cursor对象关闭。</li>\n</ol>\n<p>示例代码（与上面ContentProvider处的代码相连）：</p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<h3 id=\"五-总结\"><a href=\"#五-总结\" class=\"headerlink\" title=\"五 总结\"></a>五 总结</h3>","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>ContentProvider（内容提供者）是Android的四大组件之一，通过它可以向其他的应用程序共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。而且Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。</p>\n<p>但注意ContentProvider它也只是一个中间人，真正操作的数据源可能是数据库，也可以是文件、xml或网络等其他存储方式。</p>\n<h3 id=\"Uri类简介\"><a href=\"#Uri类简介\" class=\"headerlink\" title=\"Uri类简介\"></a>Uri类简介</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri uri = Uri.parse(<span class=\"string\">\"content://com.changcheng.provider.contactprovider/contact\"</span>)</div></pre></td></tr></table></figure>\n<p>在Content Provider中使用的查询字符串有别于标准的SQL查询。很多诸如select, add, delete, modify等操作我们都使用一种特殊的URI来进行，这种URI由3个部分组成， “content://”, 代表数据的路径，和一个可选的标识数据的ID。以下是一些示例URI:    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">content:<span class=\"comment\">//media/internal/images  //这个URI将返回设备上存储的所有图片</span></div><div class=\"line\">content:<span class=\"comment\">//contacts/people/  //这个URI将返回设备上的所有联系人信息</span></div><div class=\"line\">content:<span class=\"comment\">//contacts/people/45  //这个URI返回单个结果（联系人信息中ID为45的联系人记录）</span></div></pre></td></tr></table></figure>\n<p>尽管这种查询字符串格式很常见，但是它看起来还是有点令人迷惑。为此，Android提供一系列的帮助类（在android.provider包下），里面包含了很多以类变量形式给出的查询字符串，这种方式更容易让我们理解一点，因此，如上面content://contacts/people/45这个URI就可以写成如下形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri person = ContentUris.withAppendedId(People.CONTENT_URI,  <span class=\"number\">45</span>);</div></pre></td></tr></table></figure>\n<p>然后执行数据查询:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cursor cur = managedQuery(person, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<p>这个查询返回一个包含所有数据字段的游标，我们可以通过迭代这个游标来获取所有的数据.</p>\n<h3 id=\"三-ContentProvider类简介\"><a href=\"#三-ContentProvider类简介\" class=\"headerlink\" title=\"三 ContentProvider类简介\"></a>三 ContentProvider类简介</h3><h5 id=\"1-主要方法\"><a href=\"#1-主要方法\" class=\"headerlink\" title=\"1.主要方法\"></a>1.主要方法</h5><ul>\n<li>public boolean onCreate()<br>ContentProvider创建后　或　打开系统后其它应用第一次访问该ContentProvider时调用。      </li>\n<li>public Uri insert(Uri uri, ContentValues values)<br>外部应用向ContentProvider中添加数据。    </li>\n<li>public int delete(Uri uri, String selection, String[] selectionArgs)<br>外部应用从ContentProvider删除数据。    </li>\n<li>public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)<br>外部应用更新ContentProvider中的数据。    </li>\n<li>public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)　<br>供外部应用从ContentProvider中获取数据。 　    </li>\n<li>public String getType(Uri uri)<br>该方法用于返回当前Url所代表数据的MIME类型  </li>\n</ul>\n<h5 id=\"2-创建步骤\"><a href=\"#2-创建步骤\" class=\"headerlink\" title=\"2.创建步骤\"></a>2.创建步骤</h5><p>要创建我们自己的Content Provider的话，我们需要遵循以下几步：</p>\n<p>1.创建一个继承了ContentProvider父类的类<br>2.定义一个名为CONTENT_URI，并且是public static final的Uri类型的类变量，你必须为其指定一个唯一的字符串值，最好的方案是以类的全名称， 如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Uri CONTENT_URI = Uri.parse( “content:<span class=\"comment\">//com.google.android.MyContentProvider”);</span></div></pre></td></tr></table></figure>\n<p>3.定义你要返回给客户端的数据列名。如果你正在使用Android数据库，必须为其定义一个叫_id的列，它用来表示每条记录的唯一性。<br>4.创建你的数据存储系统。大多数Content Provider使用Android文件系统或SQLite数据库来保持数据，但是你也可以以任何你想要的方式来存储。<br>5.如果你要存储字节型数据，比如位图文件等，数据列其实是一个表示实际保存文件的URI字符串，通过它来读取对应的文件数据。处理这种数据类型的Content Provider需要实现一个名为_data的字段，_data字段列出了该文件在Android文件系统上的精确路径。这个字段不仅是供客户端使用，而且也可以供ContentResolver使用。客户端可以调用ContentResolver.openOutputStream()方法来处理该URI指向的文件资源；如果是ContentResolver本身的话，由于其持有的权限比客户端要高，所以它能直接访问该数据文件。<br>6.声明public static String型的变量，用于指定要从游标处返回的数据列。<br>7.查询返回一个Cursor类型的对象。所有执行写操作的方法如insert(), update() 以及delete()都将被监听。我们可以通过使用ContentResover().notifyChange()方法来通知监听器关于数据更新的信息。<br>8.在AndroidMenifest.xml中使用<provider>标签来设置Content Provider。<br>9.如果你要处理的数据类型是一种比较新的类型，你就必须先定义一个新的MIME类型，以供ContentProvider.geType(url)来返回。MIME类型有两种形式:一种是为指定的单个记录的，还有一种是为多条记录的。这里给出一种常用的格式：   </p>\n<ul>\n<li>vnd.android.cursor.item/vnd.yourcompanyname.contenttype （单个记录的MIME类型）<br>比如, 一个请求列车信息的URI如content://com.example.transportationprovider/trains/122 可能就会返回typevnd.android.cursor.item/vnd.example.rail这样一个MIME类型。   </li>\n<li>vnd.android.cursor.dir/vnd.yourcompanyname.contenttype （多个记录的MIME类型）<br>比如, 一个请求所有列车信息的URI如content://com.example.transportationprovider/trains 可能就会返回vnd.android.cursor.dir/vnd.example.rail这样一个MIME 类型。</li>\n</ul>\n<p>下面是一个Content Provider代码示例：</p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<p>一个名为MyContentProvider的Content Provider创建完成了，它用于从Sqlite数据库中添加和读取记录。</p>\n<h3 id=\"四-ContentResolver\"><a href=\"#四-ContentResolver\" class=\"headerlink\" title=\"四 ContentResolver\"></a>四 ContentResolver</h3><p>一个ContentProvider新建好了之后，我们需要一个ContentResolver类来获取其共享出的数据。</p>\n<h5 id=\"1-ContentResolver的主要方法\"><a href=\"#1-ContentResolver的主要方法\" class=\"headerlink\" title=\"1.ContentResolver的主要方法\"></a>1.ContentResolver的主要方法</h5><ul>\n<li>public Uri insert(Uri uri, ContentValues values)　//添加</li>\n<li>public int delete(Uri uri, String selection, String[] selectionArgs)　//删除</li>\n<li>public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)　//更新</li>\n<li>public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)//获取</li>\n</ul>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">ContentResolver resolver =  getContentResolver();</div><div class=\"line\">Uri uri = Uri.parse(<span class=\"string\">\"content://cn.scu.myprovider/user\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//插入</span></div><div class=\"line\">ContentValues values = <span class=\"keyword\">new</span> ContentValues();</div><div class=\"line\">values.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"fanrunqi\"</span>);</div><div class=\"line\">values.put(<span class=\"string\">\"age\"</span>, <span class=\"number\">24</span>);</div><div class=\"line\">resolver.insert(uri, values);  </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//查询</span></div><div class=\"line\">Cursor cursor = resolver.query(uri, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"string\">\"userid desc\"</span>);</div><div class=\"line\"><span class=\"keyword\">while</span>(cursor.moveToNext())&#123;</div><div class=\"line\">   <span class=\"comment\">//操作</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//更新</span></div><div class=\"line\">ContentValues updateValues = <span class=\"keyword\">new</span> ContentValues();</div><div class=\"line\">updateValues.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"finch\"</span>);</div><div class=\"line\">Uri updateIdUri = ContentUris.withAppendedId(uri, <span class=\"number\">1</span>);</div><div class=\"line\">resolver.update(updateIdUri, updateValues, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//删除</span></div><div class=\"line\">Uri deleteIdUri = ContentUris.withAppendedId(uri, <span class=\"number\">2</span>);</div><div class=\"line\">resolver.delete(deleteIdUri, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<h5 id=\"使用ContentResolver获取数据的步骤\"><a href=\"#使用ContentResolver获取数据的步骤\" class=\"headerlink\" title=\"使用ContentResolver获取数据的步骤\"></a>使用ContentResolver获取数据的步骤</h5><ol>\n<li>通过getContentResolver()方法得到ContentResol1.ver对象。</li>\n<li>调用ContentResolver类的query()方法查询数据，该方法会返回一个Cursor对象。</li>\n<li>对得到的Cursor对象进行分析，得到需要的数据。</li>\n<li>调用Cursor类的close()方法将Cursor对象关闭。</li>\n</ol>\n<p>示例代码（与上面ContentProvider处的代码相连）：</p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<h3 id=\"五-总结\"><a href=\"#五-总结\" class=\"headerlink\" title=\"五 总结\"></a>五 总结</h3>"},{"title":"android基础之Intents与Intent Filters","date":"2017-02-27T06:32:09.000Z","_content":"\n### 一 概述\n\nIntent是Android中组件之间传递消息的一种机制，这个组件可以是同一个应用程序的，也可以是不同的应用程序。Android四大组件中除了ContentProvider，其余三者皆可通过Intent来传递数据。而且Intent是一种运行时绑定机制。\n\nIntent在Android的三个组件中传递的机制是不同的：\n\n- 使用Context.startActivity() 或 Activity.startActivityForResult()，传入一个intent来启动一个activity。使用 Activity.setResult()，传入一个intent来从activity中返回结果。\n- 将intent对象传给Context.startService()来启动一个service或者传消息给一个运行的service。将intent对象传给 Context.bindService()来绑定一个service。\n- 将intent对象传给 Context.sendBroadcast()，Context.sendOrderedBroadcast()，或者Context.sendStickyBroadcast()等广播方法，则它们被传给 broadcast receiver。\n\n### 二 Intent的结构\n\nIntent主要包含以下属性：\n\n- component(组件)：目的组件    \nComponent属性明确指定Intent的目标组件的类名称。（属于直接Intent）。组件的名字通过函数setComponent()、setClass()、setClassName()设置，通过函数读取getComponent()。   \n\n- action（动作）：用来表现意图的行动  \nAction主要用来描述应用程序的组件，一个组件可以用于多个action，也可以多个组件拥有同一个action。\n\n\n- category（类别）：用来表现动作的类别     \ncategory通常和Action放在一起用的，用于描述这个action。一个action可以包含多个categoty，必须所有的categoty都匹配成功才算是与这个action匹配成功。如果一个action只有一个默认的categoty DEFAULT，则不需向Intent中添加categoty，系统会自动添加。addCategory() 放置一个intent里的类别，removeCategory()删除之前添加的，getCategories()获取当前所有的类别。      \n类别越多，动作越具体，意图越明确    \n\n\n- data（数据）：表示与动作要操纵的数据      \nData属性是Android要访问的数据，和action和Category声明方式相同，也是在<intent-filter>中。多个组件匹配成功显示优先级高的； 相同显示列表。Data是用一个uri对象来表示的，uri代表数据的地址，属于一种标识符。通常情况下，我们使用action+data属性的组合来描述一个意图：做什么    \n\n\n- type（数据类型）：对于data范例的描写     \n如果Intent对象中既包含Uri又包含Type，那么，在<intent-filter>中也必须二者都包含才能通过测试。Type属性用于明确指定Data属性的数据类型或MIME类型，但是通常来说，当Intent不指定Data属性时，Type属性才会起作用，否则Android系统将会根据Data属性值来分析数据的类型，所以无需指定Type属性。data和type属性一般只需要一个，通过setData方法会把type属性设置为null，相反设置setType方法会把data设置为null，如果想要两个属性同时设置，要使用Intent.setDataAndType()方法    \n\n\n- extras（扩展信息）：扩展信息     \n是其它所有附加信息的集合。以键值对的形式放入Intent中    \n\n\n- Flags（标志位）：期望这个意图的运行模式      \n用于指定Activity与task之间的关系。\n\n### 三 Intent发现组件的两种方式\n   \nIntent启动组件有两种方式：显示启动和隐式启动。\n\n上面Intent的Intent的7个属性中，只有component属于显示启动，action，category，data皆为隐式启动。\n\n##### 1.显示启动\n\n代码示例：\n\n```java\n    button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  //创建一个意图对象\n                  Intent intent = new Intent();\n                  //创建组件，通过组件来响应\n                  ComponentName component = new ComponentName(MainActivity.this, SecondActivity.class);\n                  intent.setComponent(component);                \n                  startActivity(intent);                \n             }\n         });\n```\n\n如果写的简单一点，监听事件onClick()方法里可以这样写：\n\n```java\n      Intent intent = new Intent();\n      //setClass函数的第一个参数是一个Context对象\n      //Context是一个类，Activity是Context类的子类，也就是说，所有的Activity对象，都可以向上转型为Context对象\n      //setClass函数的第二个参数是一个Class对象，在当前场景下，应该传入需要被启动的Activity类的class对象\n      intent.setClass(MainActivity.this, SecondActivity.class);\n      startActivity(intent);    \n```\n\n再简单一点，可以这样写：（当然，也是最常见的写法）\n\n```java\n                 Intent intent = new Intent(MainActivity.this,SecondActivity.class);\n                 startActivity(intent);\n```\n\n##### 2.隐式启动\n\n- action\n\n在Androidmanifest.xml中定义\n\n```java\n         <activity \n             android:name=\".SecondActivity\">\n             <intent-filter>\n                  <action android:name=\"com.example.smyh006intent01.MY_ACTION\"/>\n                  <category android:name=\"android.intent.category.DEFAULT\" />\n             </intent-filter>            \n         </activity>\n```\n\njava代码调用\n\n```java\n          button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  //启动另一个Activity，（通过action属性进行查找）\n                  Intent intent = new Intent();\n                  //设置动作（实际action属性就是一个字符串标记而已）\n                  intent.setAction(\"com.example.smyh006intent01.MY_ACTION\"); //方法：Intent android.content.Intent.setAction(String action)\n                  startActivity(intent);        \n              }\n         });\n```\n\n上面代码也可简写成\n\n```java\n         button1.setOnClickListener(new OnClickListener() {            \n             @Override\n             public void onClick(View v) {\n                 //启动另一个Activity，（通过action属性进行查找）\n                 Intent intent = new Intent(\"com.example.smyh006intent01.MY_ACTION\");//方法： android.content.Intent.Intent(String action)                \n                 startActivity(intent);        \n             }\n         });\n```\n\n- action+categoty\n\nAndroidmanifest.xml文件：\n\n```java\n         <activity\n             android:name=\".SecondActivity\">\n             <intent-filter>\n                  <action android:name=\"com.example.smyh006intent01.MY_ACTION\"/>\n                  <category android:name=\"android.intent.category.DEFAULT\" />\n                  <category android:name=\"com.example.smyh006intent01.MY_CATEGORY\" />\n             </intent-filter>            \n         </activity>\n```\n\njava文件中：\n\n```java\n         button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  //启动另一个Activity，（通过action属性进行查找）\n                  Intent intent = new Intent();\n                  //设置动作（实际action属性就是一个字符串标记而已）\n                  intent.setAction(\"com.example.smyh006intent01.MY_ACTION\"); //方法：Intent android.content.Intent.setAction(String action)\n                  intent.addCategory(\"com.example.smyh006intent01.MY_CATEGORY\");\n                  startActivity(intent);        \n             }\n         });\n```\n\n- action+data\n\n示例：打开指定网页\n\n```java\n         <activity \n             android:name=\".SecondActivity\">\n             <intent-filter>\n                  <action android:name=\"android.intent.action.VIEW\" />\n                  <category android:name=\"android.intent.category.DEFAULT\" />\n                  <data android:scheme=\"http\" android:host=\"www.baidu.com\"/>                 \n             </intent-filter>            \n         </activity>\n```\n\njava文件中：\n\n```java\n          button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  Intent intent = new Intent();\n                  intent.setAction(Intent.ACTION_VIEW);\n                  Uri data = Uri.parse(\"http://www.baidu.com\");\n                  intent.setData(data);                \n                  startActivity(intent);        \n              }\n         });\n```\n\n上面代码也可简写成：\n\n```java\n         button1.setOnClickListener(new OnClickListener() {            \n             @Override\n             public void onClick(View v) {\n                 Intent intent = new Intent(Intent.ACTION_VIEW);\n                 intent.setData(Uri.parse(\"http://www.baidu.com\"));                \n                 startActivity(intent);        \n             }\n         });\n```\n\n### 四 IntentFilter\n\nIntentFilter用于与Intent中的数据对比，来挑选出符合条件的组件。它分为静态注册（推荐）和动态注册两种方式。Intent与IntentFilter比较的步骤如下：\n\n1. 加载安装所有的IntentFilter到一个列表中\n2. 剔除所有action匹配失败的IntentFilter\n3. 剔除URI数据匹配失败的IntentFilter\n4. 剔除category匹配失败的IntentFilter\n5. 剩下的IntentFilter是否为0。是，查找失败，抛出异常；否将剩下的IntentFilter按优先级排列，返回优先级最高的IntentFilter\n\n代码示例：\n\n静态注册\n\n```java\n<receiver android:name=\".MyBroadCastReceiver\">  \n            <!-- android:priority属性是设置此接收者的优先级（从-1000到1000） -->\n            <intent-filter android:priority=\"20\">\n            <actionandroid:name=\"android.provider.Telephony.SMS_RECEIVED\"/>  \n            </intent-filter>  \n</receiver>\n```\n\n动态注册\n\n```java\nIntentFilter intentFilter = new IntentFilter(\"android.provider.Telephony.SMS_RECEIVED\");\n```\n\n\n### 五 总结","source":"_posts/android基础之Intents与Intent-Filters.md","raw":"---\ntitle: android基础之Intents与Intent Filters\ndate: 2017-02-27 14:32:09\ncategories: android\ntags:\n- android\n- java\n- Intent\n- IntentFilter\n---\n\n### 一 概述\n\nIntent是Android中组件之间传递消息的一种机制，这个组件可以是同一个应用程序的，也可以是不同的应用程序。Android四大组件中除了ContentProvider，其余三者皆可通过Intent来传递数据。而且Intent是一种运行时绑定机制。\n\nIntent在Android的三个组件中传递的机制是不同的：\n\n- 使用Context.startActivity() 或 Activity.startActivityForResult()，传入一个intent来启动一个activity。使用 Activity.setResult()，传入一个intent来从activity中返回结果。\n- 将intent对象传给Context.startService()来启动一个service或者传消息给一个运行的service。将intent对象传给 Context.bindService()来绑定一个service。\n- 将intent对象传给 Context.sendBroadcast()，Context.sendOrderedBroadcast()，或者Context.sendStickyBroadcast()等广播方法，则它们被传给 broadcast receiver。\n\n### 二 Intent的结构\n\nIntent主要包含以下属性：\n\n- component(组件)：目的组件    \nComponent属性明确指定Intent的目标组件的类名称。（属于直接Intent）。组件的名字通过函数setComponent()、setClass()、setClassName()设置，通过函数读取getComponent()。   \n\n- action（动作）：用来表现意图的行动  \nAction主要用来描述应用程序的组件，一个组件可以用于多个action，也可以多个组件拥有同一个action。\n\n\n- category（类别）：用来表现动作的类别     \ncategory通常和Action放在一起用的，用于描述这个action。一个action可以包含多个categoty，必须所有的categoty都匹配成功才算是与这个action匹配成功。如果一个action只有一个默认的categoty DEFAULT，则不需向Intent中添加categoty，系统会自动添加。addCategory() 放置一个intent里的类别，removeCategory()删除之前添加的，getCategories()获取当前所有的类别。      \n类别越多，动作越具体，意图越明确    \n\n\n- data（数据）：表示与动作要操纵的数据      \nData属性是Android要访问的数据，和action和Category声明方式相同，也是在<intent-filter>中。多个组件匹配成功显示优先级高的； 相同显示列表。Data是用一个uri对象来表示的，uri代表数据的地址，属于一种标识符。通常情况下，我们使用action+data属性的组合来描述一个意图：做什么    \n\n\n- type（数据类型）：对于data范例的描写     \n如果Intent对象中既包含Uri又包含Type，那么，在<intent-filter>中也必须二者都包含才能通过测试。Type属性用于明确指定Data属性的数据类型或MIME类型，但是通常来说，当Intent不指定Data属性时，Type属性才会起作用，否则Android系统将会根据Data属性值来分析数据的类型，所以无需指定Type属性。data和type属性一般只需要一个，通过setData方法会把type属性设置为null，相反设置setType方法会把data设置为null，如果想要两个属性同时设置，要使用Intent.setDataAndType()方法    \n\n\n- extras（扩展信息）：扩展信息     \n是其它所有附加信息的集合。以键值对的形式放入Intent中    \n\n\n- Flags（标志位）：期望这个意图的运行模式      \n用于指定Activity与task之间的关系。\n\n### 三 Intent发现组件的两种方式\n   \nIntent启动组件有两种方式：显示启动和隐式启动。\n\n上面Intent的Intent的7个属性中，只有component属于显示启动，action，category，data皆为隐式启动。\n\n##### 1.显示启动\n\n代码示例：\n\n```java\n    button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  //创建一个意图对象\n                  Intent intent = new Intent();\n                  //创建组件，通过组件来响应\n                  ComponentName component = new ComponentName(MainActivity.this, SecondActivity.class);\n                  intent.setComponent(component);                \n                  startActivity(intent);                \n             }\n         });\n```\n\n如果写的简单一点，监听事件onClick()方法里可以这样写：\n\n```java\n      Intent intent = new Intent();\n      //setClass函数的第一个参数是一个Context对象\n      //Context是一个类，Activity是Context类的子类，也就是说，所有的Activity对象，都可以向上转型为Context对象\n      //setClass函数的第二个参数是一个Class对象，在当前场景下，应该传入需要被启动的Activity类的class对象\n      intent.setClass(MainActivity.this, SecondActivity.class);\n      startActivity(intent);    \n```\n\n再简单一点，可以这样写：（当然，也是最常见的写法）\n\n```java\n                 Intent intent = new Intent(MainActivity.this,SecondActivity.class);\n                 startActivity(intent);\n```\n\n##### 2.隐式启动\n\n- action\n\n在Androidmanifest.xml中定义\n\n```java\n         <activity \n             android:name=\".SecondActivity\">\n             <intent-filter>\n                  <action android:name=\"com.example.smyh006intent01.MY_ACTION\"/>\n                  <category android:name=\"android.intent.category.DEFAULT\" />\n             </intent-filter>            \n         </activity>\n```\n\njava代码调用\n\n```java\n          button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  //启动另一个Activity，（通过action属性进行查找）\n                  Intent intent = new Intent();\n                  //设置动作（实际action属性就是一个字符串标记而已）\n                  intent.setAction(\"com.example.smyh006intent01.MY_ACTION\"); //方法：Intent android.content.Intent.setAction(String action)\n                  startActivity(intent);        \n              }\n         });\n```\n\n上面代码也可简写成\n\n```java\n         button1.setOnClickListener(new OnClickListener() {            \n             @Override\n             public void onClick(View v) {\n                 //启动另一个Activity，（通过action属性进行查找）\n                 Intent intent = new Intent(\"com.example.smyh006intent01.MY_ACTION\");//方法： android.content.Intent.Intent(String action)                \n                 startActivity(intent);        \n             }\n         });\n```\n\n- action+categoty\n\nAndroidmanifest.xml文件：\n\n```java\n         <activity\n             android:name=\".SecondActivity\">\n             <intent-filter>\n                  <action android:name=\"com.example.smyh006intent01.MY_ACTION\"/>\n                  <category android:name=\"android.intent.category.DEFAULT\" />\n                  <category android:name=\"com.example.smyh006intent01.MY_CATEGORY\" />\n             </intent-filter>            \n         </activity>\n```\n\njava文件中：\n\n```java\n         button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  //启动另一个Activity，（通过action属性进行查找）\n                  Intent intent = new Intent();\n                  //设置动作（实际action属性就是一个字符串标记而已）\n                  intent.setAction(\"com.example.smyh006intent01.MY_ACTION\"); //方法：Intent android.content.Intent.setAction(String action)\n                  intent.addCategory(\"com.example.smyh006intent01.MY_CATEGORY\");\n                  startActivity(intent);        \n             }\n         });\n```\n\n- action+data\n\n示例：打开指定网页\n\n```java\n         <activity \n             android:name=\".SecondActivity\">\n             <intent-filter>\n                  <action android:name=\"android.intent.action.VIEW\" />\n                  <category android:name=\"android.intent.category.DEFAULT\" />\n                  <data android:scheme=\"http\" android:host=\"www.baidu.com\"/>                 \n             </intent-filter>            \n         </activity>\n```\n\njava文件中：\n\n```java\n          button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  Intent intent = new Intent();\n                  intent.setAction(Intent.ACTION_VIEW);\n                  Uri data = Uri.parse(\"http://www.baidu.com\");\n                  intent.setData(data);                \n                  startActivity(intent);        \n              }\n         });\n```\n\n上面代码也可简写成：\n\n```java\n         button1.setOnClickListener(new OnClickListener() {            \n             @Override\n             public void onClick(View v) {\n                 Intent intent = new Intent(Intent.ACTION_VIEW);\n                 intent.setData(Uri.parse(\"http://www.baidu.com\"));                \n                 startActivity(intent);        \n             }\n         });\n```\n\n### 四 IntentFilter\n\nIntentFilter用于与Intent中的数据对比，来挑选出符合条件的组件。它分为静态注册（推荐）和动态注册两种方式。Intent与IntentFilter比较的步骤如下：\n\n1. 加载安装所有的IntentFilter到一个列表中\n2. 剔除所有action匹配失败的IntentFilter\n3. 剔除URI数据匹配失败的IntentFilter\n4. 剔除category匹配失败的IntentFilter\n5. 剩下的IntentFilter是否为0。是，查找失败，抛出异常；否将剩下的IntentFilter按优先级排列，返回优先级最高的IntentFilter\n\n代码示例：\n\n静态注册\n\n```java\n<receiver android:name=\".MyBroadCastReceiver\">  \n            <!-- android:priority属性是设置此接收者的优先级（从-1000到1000） -->\n            <intent-filter android:priority=\"20\">\n            <actionandroid:name=\"android.provider.Telephony.SMS_RECEIVED\"/>  \n            </intent-filter>  \n</receiver>\n```\n\n动态注册\n\n```java\nIntentFilter intentFilter = new IntentFilter(\"android.provider.Telephony.SMS_RECEIVED\");\n```\n\n\n### 五 总结","slug":"android基础之Intents与Intent-Filters","published":1,"updated":"2017-03-08T04:03:37.360Z","_id":"cizz09ftd0002aonz04754wf9","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Intent是Android中组件之间传递消息的一种机制，这个组件可以是同一个应用程序的，也可以是不同的应用程序。Android四大组件中除了ContentProvider，其余三者皆可通过Intent来传递数据。而且Intent是一种运行时绑定机制。</p>\n<p>Intent在Android的三个组件中传递的机制是不同的：</p>\n<ul>\n<li>使用Context.startActivity() 或 Activity.startActivityForResult()，传入一个intent来启动一个activity。使用 Activity.setResult()，传入一个intent来从activity中返回结果。</li>\n<li>将intent对象传给Context.startService()来启动一个service或者传消息给一个运行的service。将intent对象传给 Context.bindService()来绑定一个service。</li>\n<li>将intent对象传给 Context.sendBroadcast()，Context.sendOrderedBroadcast()，或者Context.sendStickyBroadcast()等广播方法，则它们被传给 broadcast receiver。</li>\n</ul>\n<h3 id=\"二-Intent的结构\"><a href=\"#二-Intent的结构\" class=\"headerlink\" title=\"二 Intent的结构\"></a>二 Intent的结构</h3><p>Intent主要包含以下属性：</p>\n<ul>\n<li><p>component(组件)：目的组件<br>Component属性明确指定Intent的目标组件的类名称。（属于直接Intent）。组件的名字通过函数setComponent()、setClass()、setClassName()设置，通过函数读取getComponent()。   </p>\n</li>\n<li><p>action（动作）：用来表现意图的行动<br>Action主要用来描述应用程序的组件，一个组件可以用于多个action，也可以多个组件拥有同一个action。</p>\n</li>\n</ul>\n<ul>\n<li>category（类别）：用来表现动作的类别<br>category通常和Action放在一起用的，用于描述这个action。一个action可以包含多个categoty，必须所有的categoty都匹配成功才算是与这个action匹配成功。如果一个action只有一个默认的categoty DEFAULT，则不需向Intent中添加categoty，系统会自动添加。addCategory() 放置一个intent里的类别，removeCategory()删除之前添加的，getCategories()获取当前所有的类别。<br>类别越多，动作越具体，意图越明确    </li>\n</ul>\n<ul>\n<li>data（数据）：表示与动作要操纵的数据<br>Data属性是Android要访问的数据，和action和Category声明方式相同，也是在<intent-filter>中。多个组件匹配成功显示优先级高的； 相同显示列表。Data是用一个uri对象来表示的，uri代表数据的地址，属于一种标识符。通常情况下，我们使用action+data属性的组合来描述一个意图：做什么    </intent-filter></li>\n</ul>\n<ul>\n<li>type（数据类型）：对于data范例的描写<br>如果Intent对象中既包含Uri又包含Type，那么，在<intent-filter>中也必须二者都包含才能通过测试。Type属性用于明确指定Data属性的数据类型或MIME类型，但是通常来说，当Intent不指定Data属性时，Type属性才会起作用，否则Android系统将会根据Data属性值来分析数据的类型，所以无需指定Type属性。data和type属性一般只需要一个，通过setData方法会把type属性设置为null，相反设置setType方法会把data设置为null，如果想要两个属性同时设置，要使用Intent.setDataAndType()方法    </intent-filter></li>\n</ul>\n<ul>\n<li>extras（扩展信息）：扩展信息<br>是其它所有附加信息的集合。以键值对的形式放入Intent中    </li>\n</ul>\n<ul>\n<li>Flags（标志位）：期望这个意图的运行模式<br>用于指定Activity与task之间的关系。</li>\n</ul>\n<h3 id=\"三-Intent发现组件的两种方式\"><a href=\"#三-Intent发现组件的两种方式\" class=\"headerlink\" title=\"三 Intent发现组件的两种方式\"></a>三 Intent发现组件的两种方式</h3><p>Intent启动组件有两种方式：显示启动和隐式启动。</p>\n<p>上面Intent的Intent的7个属性中，只有component属于显示启动，action，category，data皆为隐式启动。</p>\n<h5 id=\"1-显示启动\"><a href=\"#1-显示启动\" class=\"headerlink\" title=\"1.显示启动\"></a>1.显示启动</h5><p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">          <span class=\"meta\">@Override</span></div><div class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">              <span class=\"comment\">//创建一个意图对象</span></div><div class=\"line\">              Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">              <span class=\"comment\">//创建组件，通过组件来响应</span></div><div class=\"line\">              ComponentName component = <span class=\"keyword\">new</span> ComponentName(MainActivity.<span class=\"keyword\">this</span>, SecondActivity.class);</div><div class=\"line\">              intent.setComponent(component);                </div><div class=\"line\">              startActivity(intent);                </div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;);</div></pre></td></tr></table></figure>\n<p>如果写的简单一点，监听事件onClick()方法里可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\"><span class=\"comment\">//setClass函数的第一个参数是一个Context对象</span></div><div class=\"line\"><span class=\"comment\">//Context是一个类，Activity是Context类的子类，也就是说，所有的Activity对象，都可以向上转型为Context对象</span></div><div class=\"line\"><span class=\"comment\">//setClass函数的第二个参数是一个Class对象，在当前场景下，应该传入需要被启动的Activity类的class对象</span></div><div class=\"line\">intent.setClass(MainActivity.<span class=\"keyword\">this</span>, SecondActivity.class);</div><div class=\"line\">startActivity(intent);</div></pre></td></tr></table></figure>\n<p>再简单一点，可以这样写：（当然，也是最常见的写法）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(MainActivity.<span class=\"keyword\">this</span>,SecondActivity.class);</div><div class=\"line\">startActivity(intent);</div></pre></td></tr></table></figure>\n<h5 id=\"2-隐式启动\"><a href=\"#2-隐式启动\" class=\"headerlink\" title=\"2.隐式启动\"></a>2.隐式启动</h5><ul>\n<li>action</li>\n</ul>\n<p>在Androidmanifest.xml中定义</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;activity </div><div class=\"line\">    android:name=\".SecondActivity\"&gt;</div><div class=\"line\">    &lt;intent-filter&gt;</div><div class=\"line\">         &lt;action android:name=\"com.example.smyh006intent01.MY_ACTION\"/&gt;</div><div class=\"line\">         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</div><div class=\"line\">    &lt;/intent-filter&gt;            </div><div class=\"line\">&lt;/activity&gt;</div></pre></td></tr></table></figure>\n<p>java代码调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">         <span class=\"comment\">//启动另一个Activity，（通过action属性进行查找）</span></div><div class=\"line\">         Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">         <span class=\"comment\">//设置动作（实际action属性就是一个字符串标记而已）</span></div><div class=\"line\">         intent.setAction(<span class=\"string\">\"com.example.smyh006intent01.MY_ACTION\"</span>); <span class=\"comment\">//方法：Intent android.content.Intent.setAction(String action)</span></div><div class=\"line\">         startActivity(intent);        </div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>上面代码也可简写成</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//启动另一个Activity，（通过action属性进行查找）</span></div><div class=\"line\">        Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"string\">\"com.example.smyh006intent01.MY_ACTION\"</span>);<span class=\"comment\">//方法： android.content.Intent.Intent(String action)                </span></div><div class=\"line\">        startActivity(intent);        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>action+categoty</li>\n</ul>\n<p>Androidmanifest.xml文件：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;activity</div><div class=\"line\">    android:name=\".SecondActivity\"&gt;</div><div class=\"line\">    &lt;intent-filter&gt;</div><div class=\"line\">         &lt;action android:name=\"com.example.smyh006intent01.MY_ACTION\"/&gt;</div><div class=\"line\">         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</div><div class=\"line\">         &lt;category android:name=\"com.example.smyh006intent01.MY_CATEGORY\" /&gt;</div><div class=\"line\">    &lt;/intent-filter&gt;            </div><div class=\"line\">&lt;/activity&gt;</div></pre></td></tr></table></figure>\n<p>java文件中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">         <span class=\"comment\">//启动另一个Activity，（通过action属性进行查找）</span></div><div class=\"line\">         Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">         <span class=\"comment\">//设置动作（实际action属性就是一个字符串标记而已）</span></div><div class=\"line\">         intent.setAction(<span class=\"string\">\"com.example.smyh006intent01.MY_ACTION\"</span>); <span class=\"comment\">//方法：Intent android.content.Intent.setAction(String action)</span></div><div class=\"line\">         intent.addCategory(<span class=\"string\">\"com.example.smyh006intent01.MY_CATEGORY\"</span>);</div><div class=\"line\">         startActivity(intent);        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>action+data</li>\n</ul>\n<p>示例：打开指定网页</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;activity </div><div class=\"line\">    android:name=\".SecondActivity\"&gt;</div><div class=\"line\">    &lt;intent-filter&gt;</div><div class=\"line\">         &lt;action android:name=\"android.intent.action.VIEW\" /&gt;</div><div class=\"line\">         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</div><div class=\"line\">         &lt;data android:scheme=\"http\" android:host=\"www.baidu.com\"/&gt;                 </div><div class=\"line\">    &lt;/intent-filter&gt;            </div><div class=\"line\">&lt;/activity&gt;</div></pre></td></tr></table></figure>\n<p>java文件中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">         Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">         intent.setAction(Intent.ACTION_VIEW);</div><div class=\"line\">         Uri data = Uri.parse(<span class=\"string\">\"http://www.baidu.com\"</span>);</div><div class=\"line\">         intent.setData(data);                </div><div class=\"line\">         startActivity(intent);        </div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>上面代码也可简写成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">        Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_VIEW);</div><div class=\"line\">        intent.setData(Uri.parse(<span class=\"string\">\"http://www.baidu.com\"</span>));                </div><div class=\"line\">        startActivity(intent);        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"四-IntentFilter\"><a href=\"#四-IntentFilter\" class=\"headerlink\" title=\"四 IntentFilter\"></a>四 IntentFilter</h3><p>IntentFilter用于与Intent中的数据对比，来挑选出符合条件的组件。它分为静态注册（推荐）和动态注册两种方式。Intent与IntentFilter比较的步骤如下：</p>\n<ol>\n<li>加载安装所有的IntentFilter到一个列表中</li>\n<li>剔除所有action匹配失败的IntentFilter</li>\n<li>剔除URI数据匹配失败的IntentFilter</li>\n<li>剔除category匹配失败的IntentFilter</li>\n<li>剩下的IntentFilter是否为0。是，查找失败，抛出异常；否将剩下的IntentFilter按优先级排列，返回优先级最高的IntentFilter</li>\n</ol>\n<p>代码示例：</p>\n<p>静态注册</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;receiver android:name=\".MyBroadCastReceiver\"&gt;  </div><div class=\"line\">            &lt;!-- android:priority属性是设置此接收者的优先级（从-1000到1000） --&gt;</div><div class=\"line\">            &lt;intent-filter android:priority=\"20\"&gt;</div><div class=\"line\">            &lt;actionandroid:name=\"android.provider.Telephony.SMS_RECEIVED\"/&gt;  </div><div class=\"line\">            &lt;/intent-filter&gt;  </div><div class=\"line\">&lt;/receiver&gt;</div></pre></td></tr></table></figure>\n<p>动态注册</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">IntentFilter intentFilter = <span class=\"keyword\">new</span> IntentFilter(<span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span>);</div></pre></td></tr></table></figure>\n<h3 id=\"五-总结\"><a href=\"#五-总结\" class=\"headerlink\" title=\"五 总结\"></a>五 总结</h3>","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Intent是Android中组件之间传递消息的一种机制，这个组件可以是同一个应用程序的，也可以是不同的应用程序。Android四大组件中除了ContentProvider，其余三者皆可通过Intent来传递数据。而且Intent是一种运行时绑定机制。</p>\n<p>Intent在Android的三个组件中传递的机制是不同的：</p>\n<ul>\n<li>使用Context.startActivity() 或 Activity.startActivityForResult()，传入一个intent来启动一个activity。使用 Activity.setResult()，传入一个intent来从activity中返回结果。</li>\n<li>将intent对象传给Context.startService()来启动一个service或者传消息给一个运行的service。将intent对象传给 Context.bindService()来绑定一个service。</li>\n<li>将intent对象传给 Context.sendBroadcast()，Context.sendOrderedBroadcast()，或者Context.sendStickyBroadcast()等广播方法，则它们被传给 broadcast receiver。</li>\n</ul>\n<h3 id=\"二-Intent的结构\"><a href=\"#二-Intent的结构\" class=\"headerlink\" title=\"二 Intent的结构\"></a>二 Intent的结构</h3><p>Intent主要包含以下属性：</p>\n<ul>\n<li><p>component(组件)：目的组件<br>Component属性明确指定Intent的目标组件的类名称。（属于直接Intent）。组件的名字通过函数setComponent()、setClass()、setClassName()设置，通过函数读取getComponent()。   </p>\n</li>\n<li><p>action（动作）：用来表现意图的行动<br>Action主要用来描述应用程序的组件，一个组件可以用于多个action，也可以多个组件拥有同一个action。</p>\n</li>\n</ul>\n<ul>\n<li>category（类别）：用来表现动作的类别<br>category通常和Action放在一起用的，用于描述这个action。一个action可以包含多个categoty，必须所有的categoty都匹配成功才算是与这个action匹配成功。如果一个action只有一个默认的categoty DEFAULT，则不需向Intent中添加categoty，系统会自动添加。addCategory() 放置一个intent里的类别，removeCategory()删除之前添加的，getCategories()获取当前所有的类别。<br>类别越多，动作越具体，意图越明确    </li>\n</ul>\n<ul>\n<li>data（数据）：表示与动作要操纵的数据<br>Data属性是Android要访问的数据，和action和Category声明方式相同，也是在<intent-filter>中。多个组件匹配成功显示优先级高的； 相同显示列表。Data是用一个uri对象来表示的，uri代表数据的地址，属于一种标识符。通常情况下，我们使用action+data属性的组合来描述一个意图：做什么    </li>\n</ul>\n<ul>\n<li>type（数据类型）：对于data范例的描写<br>如果Intent对象中既包含Uri又包含Type，那么，在<intent-filter>中也必须二者都包含才能通过测试。Type属性用于明确指定Data属性的数据类型或MIME类型，但是通常来说，当Intent不指定Data属性时，Type属性才会起作用，否则Android系统将会根据Data属性值来分析数据的类型，所以无需指定Type属性。data和type属性一般只需要一个，通过setData方法会把type属性设置为null，相反设置setType方法会把data设置为null，如果想要两个属性同时设置，要使用Intent.setDataAndType()方法    </li>\n</ul>\n<ul>\n<li>extras（扩展信息）：扩展信息<br>是其它所有附加信息的集合。以键值对的形式放入Intent中    </li>\n</ul>\n<ul>\n<li>Flags（标志位）：期望这个意图的运行模式<br>用于指定Activity与task之间的关系。</li>\n</ul>\n<h3 id=\"三-Intent发现组件的两种方式\"><a href=\"#三-Intent发现组件的两种方式\" class=\"headerlink\" title=\"三 Intent发现组件的两种方式\"></a>三 Intent发现组件的两种方式</h3><p>Intent启动组件有两种方式：显示启动和隐式启动。</p>\n<p>上面Intent的Intent的7个属性中，只有component属于显示启动，action，category，data皆为隐式启动。</p>\n<h5 id=\"1-显示启动\"><a href=\"#1-显示启动\" class=\"headerlink\" title=\"1.显示启动\"></a>1.显示启动</h5><p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">          <span class=\"meta\">@Override</span></div><div class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">              <span class=\"comment\">//创建一个意图对象</span></div><div class=\"line\">              Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">              <span class=\"comment\">//创建组件，通过组件来响应</span></div><div class=\"line\">              ComponentName component = <span class=\"keyword\">new</span> ComponentName(MainActivity.<span class=\"keyword\">this</span>, SecondActivity.class);</div><div class=\"line\">              intent.setComponent(component);                </div><div class=\"line\">              startActivity(intent);                </div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;);</div></pre></td></tr></table></figure>\n<p>如果写的简单一点，监听事件onClick()方法里可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\"><span class=\"comment\">//setClass函数的第一个参数是一个Context对象</span></div><div class=\"line\"><span class=\"comment\">//Context是一个类，Activity是Context类的子类，也就是说，所有的Activity对象，都可以向上转型为Context对象</span></div><div class=\"line\"><span class=\"comment\">//setClass函数的第二个参数是一个Class对象，在当前场景下，应该传入需要被启动的Activity类的class对象</span></div><div class=\"line\">intent.setClass(MainActivity.<span class=\"keyword\">this</span>, SecondActivity.class);</div><div class=\"line\">startActivity(intent);</div></pre></td></tr></table></figure>\n<p>再简单一点，可以这样写：（当然，也是最常见的写法）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(MainActivity.<span class=\"keyword\">this</span>,SecondActivity.class);</div><div class=\"line\">startActivity(intent);</div></pre></td></tr></table></figure>\n<h5 id=\"2-隐式启动\"><a href=\"#2-隐式启动\" class=\"headerlink\" title=\"2.隐式启动\"></a>2.隐式启动</h5><ul>\n<li>action</li>\n</ul>\n<p>在Androidmanifest.xml中定义</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;activity </div><div class=\"line\">    android:name=\".SecondActivity\"&gt;</div><div class=\"line\">    &lt;intent-filter&gt;</div><div class=\"line\">         &lt;action android:name=\"com.example.smyh006intent01.MY_ACTION\"/&gt;</div><div class=\"line\">         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</div><div class=\"line\">    &lt;/intent-filter&gt;            </div><div class=\"line\">&lt;/activity&gt;</div></pre></td></tr></table></figure>\n<p>java代码调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">         <span class=\"comment\">//启动另一个Activity，（通过action属性进行查找）</span></div><div class=\"line\">         Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">         <span class=\"comment\">//设置动作（实际action属性就是一个字符串标记而已）</span></div><div class=\"line\">         intent.setAction(<span class=\"string\">\"com.example.smyh006intent01.MY_ACTION\"</span>); <span class=\"comment\">//方法：Intent android.content.Intent.setAction(String action)</span></div><div class=\"line\">         startActivity(intent);        </div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>上面代码也可简写成</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//启动另一个Activity，（通过action属性进行查找）</span></div><div class=\"line\">        Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"string\">\"com.example.smyh006intent01.MY_ACTION\"</span>);<span class=\"comment\">//方法： android.content.Intent.Intent(String action)                </span></div><div class=\"line\">        startActivity(intent);        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>action+categoty</li>\n</ul>\n<p>Androidmanifest.xml文件：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;activity</div><div class=\"line\">    android:name=\".SecondActivity\"&gt;</div><div class=\"line\">    &lt;intent-filter&gt;</div><div class=\"line\">         &lt;action android:name=\"com.example.smyh006intent01.MY_ACTION\"/&gt;</div><div class=\"line\">         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</div><div class=\"line\">         &lt;category android:name=\"com.example.smyh006intent01.MY_CATEGORY\" /&gt;</div><div class=\"line\">    &lt;/intent-filter&gt;            </div><div class=\"line\">&lt;/activity&gt;</div></pre></td></tr></table></figure>\n<p>java文件中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">         <span class=\"comment\">//启动另一个Activity，（通过action属性进行查找）</span></div><div class=\"line\">         Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">         <span class=\"comment\">//设置动作（实际action属性就是一个字符串标记而已）</span></div><div class=\"line\">         intent.setAction(<span class=\"string\">\"com.example.smyh006intent01.MY_ACTION\"</span>); <span class=\"comment\">//方法：Intent android.content.Intent.setAction(String action)</span></div><div class=\"line\">         intent.addCategory(<span class=\"string\">\"com.example.smyh006intent01.MY_CATEGORY\"</span>);</div><div class=\"line\">         startActivity(intent);        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>action+data</li>\n</ul>\n<p>示例：打开指定网页</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;activity </div><div class=\"line\">    android:name=\".SecondActivity\"&gt;</div><div class=\"line\">    &lt;intent-filter&gt;</div><div class=\"line\">         &lt;action android:name=\"android.intent.action.VIEW\" /&gt;</div><div class=\"line\">         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</div><div class=\"line\">         &lt;data android:scheme=\"http\" android:host=\"www.baidu.com\"/&gt;                 </div><div class=\"line\">    &lt;/intent-filter&gt;            </div><div class=\"line\">&lt;/activity&gt;</div></pre></td></tr></table></figure>\n<p>java文件中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">         Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">         intent.setAction(Intent.ACTION_VIEW);</div><div class=\"line\">         Uri data = Uri.parse(<span class=\"string\">\"http://www.baidu.com\"</span>);</div><div class=\"line\">         intent.setData(data);                </div><div class=\"line\">         startActivity(intent);        </div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>上面代码也可简写成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">        Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_VIEW);</div><div class=\"line\">        intent.setData(Uri.parse(<span class=\"string\">\"http://www.baidu.com\"</span>));                </div><div class=\"line\">        startActivity(intent);        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"四-IntentFilter\"><a href=\"#四-IntentFilter\" class=\"headerlink\" title=\"四 IntentFilter\"></a>四 IntentFilter</h3><p>IntentFilter用于与Intent中的数据对比，来挑选出符合条件的组件。它分为静态注册（推荐）和动态注册两种方式。Intent与IntentFilter比较的步骤如下：</p>\n<ol>\n<li>加载安装所有的IntentFilter到一个列表中</li>\n<li>剔除所有action匹配失败的IntentFilter</li>\n<li>剔除URI数据匹配失败的IntentFilter</li>\n<li>剔除category匹配失败的IntentFilter</li>\n<li>剩下的IntentFilter是否为0。是，查找失败，抛出异常；否将剩下的IntentFilter按优先级排列，返回优先级最高的IntentFilter</li>\n</ol>\n<p>代码示例：</p>\n<p>静态注册</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;receiver android:name=\".MyBroadCastReceiver\"&gt;  </div><div class=\"line\">            &lt;!-- android:priority属性是设置此接收者的优先级（从-1000到1000） --&gt;</div><div class=\"line\">            &lt;intent-filter android:priority=\"20\"&gt;</div><div class=\"line\">            &lt;actionandroid:name=\"android.provider.Telephony.SMS_RECEIVED\"/&gt;  </div><div class=\"line\">            &lt;/intent-filter&gt;  </div><div class=\"line\">&lt;/receiver&gt;</div></pre></td></tr></table></figure>\n<p>动态注册</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">IntentFilter intentFilter = <span class=\"keyword\">new</span> IntentFilter(<span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span>);</div></pre></td></tr></table></figure>\n<h3 id=\"五-总结\"><a href=\"#五-总结\" class=\"headerlink\" title=\"五 总结\"></a>五 总结</h3>"},{"title":"android基础之Service","date":"2017-02-27T06:06:22.000Z","_content":"\n### 一 Service简介    \nService也是Android的四大组件之一，它并不提供用户界面，主要做一些即使该应用程序被调入后台也需要运行的事务。比如下载，音乐播放，执行文件I/O或者与content provider进行交互等。Service主要做的就是上面这些比较耗时的操作，但是由于Service也是运行在主线程中，因此最好在其中另开一个线程做这些耗时操作，否者可能会引起UI阻塞。       \n\n### 二 Service的两种启动方式     \nService有started和bound两种启动方式，当然也可以两种都启用。你可通过startService()启动服务后再通过bindService()将activity于Service绑定。     \n\n##### 1.startService()启动    \n通过startService()启动的Service，Service一旦启动即与它的调用者（通常是某个activity）不再关联，即使调用它的组件被销毁，它也能在后台一直运行下去。通常，该类服务执行单一的操作并且不会向调用者返回结果，比如它可以通过网络下载或上传文件。此类服务应该在其工作完成后通过重写stopSelf()使其自行终止，或者由其他组件调用stopService()来终止。       \n通过startService()启动的服务需要实现它的生命周期中onStartCommand()方法        \n\n\n\n##### 2.bindService()启动      \n通过bindService()启动的服务，该服务的生命周期将与启动它的组件相关联，即如果启动它的组件被销毁则该服务也会被销毁，或者通过调用unBindService()与服务解绑，解绑后服务被销毁。多个组件可以同时与一个服务绑定，当所有组件都与服务解绑后，该服务才会被销毁。    \nbind服务提供了一个客户端/服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至进行进程间通信（IPC）。       \n通过bindService()启动的服务需要实现Service中的onBind()方法。   \n\n\n\n\n### 三 Service的生命周期     \n两种Service的生命周期如下图：     \n{% asset_img Service生命周期图.png Service生命周期图 %}     \n其回调方法如下：     \n\n   \n```java       \npublic class ExampleService extends Service {\n    int mStartMode;       // indicates how to behave if the service is killed\n    IBinder mBinder;      // interface for clients that bind\n    boolean mAllowRebind; // indicates whether onRebind should be used\n\n    @Override\n    public void onCreate() {\n        // The service is being created\n    }\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        // The service is starting, due to a call to startService()\n        return mStartMode;\n    }\n    @Override\n    public IBinder onBind(Intent intent) {\n        // A client is binding to the service with bindService()\n        return mBinder;\n    }\n    @Override\n    public boolean onUnbind(Intent intent) {\n        // All clients have unbound with unbindService()\n        return mAllowRebind;\n    }\n    @Override\n    public void onRebind(Intent intent) {\n        // A client is binding to the service with bindService(),\n        // after onUnbind() has already been called\n    }\n    @Override\n    public void onDestroy() {\n        // The service is no longer used and is being destroyed\n    }\n}\n```         \n\n\n\n### 四 Service与线程的区别    \n- Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。     \n- Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。       \n其实谈Service和线程的区别毫无意义，它们本来就是毫无关联的两样东西，我觉得应该谈的是在什么情况下，什么地方使用线程更合适。   \n比如：如果你的线程主要用于对UI的更新，那么在Activity中新建即可。但是如果你的线程用于app和服务器之间的消息推送，你需要隔一段时间就要连接服务器做数据同步的话，那么就不能在Activity中新建线程。因为此时的线程在Activity被销毁时，它仍然需要运行。此时将面对一个问题，如果你是Activity中创建得线程，那么当该Activity被销毁时，你将失去该线程的实例。另一方面，你没办法在不同的Activity中对同一线程进行控制。这种情况你就需要在Service中创建它，一方面Service在Activity被销毁时仍然可以运行，另一方面其他的Activity重建后也可以通过与Service进行绑定获得Service的实例，进而控制该线程。\n\n### 五 保证Service不被杀死    \n- onStartCommand方法，返回START_STICKY   \n- 提升service优先级   \n- 提升service进程优先级,将其提升为前台服务    \n- onDestroy方法里重启service  \n- 监听系统广播判断Service状态    \n- 将APK安装到/system/app，变身系统级应用      \n\n\n### 六 IntentService    \n\n因为大多数started服务都不需要同时处理多个请求（这实际上是一个危险的多线程情况），所以最佳方式也许就是用IntentService类来实现你的服务。   \nIntentService将执行以下步骤：    　　\n- 创建一个缺省的工作（worker）线程，它独立于应用程序主线程来执行所有发送到onStartCommand()的intent。　　　\n- 创建一个工作队列，每次向你的onHandleIntent()传入一个intent，这样你就永远不必担心多线程问题了。　\n- 在处理完所有的启动请求后，终止服务，因此你就永远不需调用stopSelf()了。　　\n- 提供缺省的onBind()实现代码，它返回null。\n- 提供缺省的onStartCommand()实现代码，它把intent送入工作队列，稍后会再传给你的onHandleIntent()实现代码。　　　\n\n以上所有步骤将汇成一个结果：你要做的全部工作就是实现onHandleIntent()的代码，来完成客户端提交的任务。（当然你还需要为服务提供一小段构造方法。）       \n\n以下是个IntentService的实现例程：    \n\n```java    \n\npublic class HelloIntentService extends IntentService {\n\n  /** \n   * 构造方法是必需的，必须用工作线程名称作为参数\n   * 调用父类的[http://developer.android.com/reference/android/app/IntentService.html#IntentService(java.lang.String) IntentService(String)]构造方法。\n   */\n  public HelloIntentService() {\n      super(\"HelloIntentService\");\n  }\n\n  /**\n   * IntentService从缺省的工作线程中调用本方法，并用启动服务的intent作为参数。 \n   * 本方法返回后，IntentService将适时终止这个服务。\n   */\n  @Override\n  protected void onHandleIntent(Intent intent) {\n      // 通常我们会在这里执行一些工作，比如下载文件。\n      // 作为例子，我们只是睡5秒钟。\n      long endTime = System.currentTimeMillis() + 5*1000;\n      while (System.currentTimeMillis() < endTime) {\n          synchronized (this) {\n              try {\n                  wait(endTime - System.currentTimeMillis());\n              } catch (Exception e) {\n              }\n          }\n      }\n  }\n}  \n\n```    \n\n所有你需要做的就是：一个构造方法和一个onHandleIntent()方法的实现。\n\n如果你还决定重写其它的回调方法，比如onCreate()、onStartCommand()、onDestroy()， 请确保调用一下父类的实现代码，以便IntentService能正确处理工作线程的生命周期。\n\n比如说，onStartCommand()必须返回缺省实现代码的结果（缺省代码实现了如何获取传给onHandleIntent()的intent）：    \n\n```java  \n@Override\npublic int onStartCommand(Intent intent, int flags, int startId) {\n    Toast.makeText(this, \"service starting\", Toast.LENGTH_SHORT).show();\n    return super.onStartCommand(intent,flags,startId);\n}\n```   \n\n除了onHandleIntent()以外，唯一不需要调用父类实现代码的方法是onBind()（不过如果你的服务允许绑定，你还是需要实现它）。    \n\n\n### 七 扩展Service   \n\n如上节所述，利用IntentService来实现一个started服务非常简单。 不过，假如你的服务需要多线程运行（而不是通过一个工作队列来处理启动请求），那你可以扩展Service类来完成每个intent的处理。\n\n作为对照，以下例程实现了 Service 类，它执行的工作与上述使用IntentService的例子相同。确切地说，对于每一个启动请求，它都用一个工作线程来完成处理工作，并且每次只处理一个请求。    \n\n```java    \npublic class HelloService extends Service {\n  private Looper mServiceLooper;\n  private ServiceHandler mServiceHandler;\n\n  // 处理从线程接收的消息\n  private final class ServiceHandler extends Handler {\n      public ServiceHandler(Looper looper) {\n          super(looper);\n      }\n      @Override\n      public void handleMessage(Message msg) {\n          // 通常我们在这里执行一些工作，比如下载文件。\n          // 作为例子，我们只是睡个5秒钟。\n          long endTime = System.currentTimeMillis() + 5*1000;\n          while (System.currentTimeMillis() < endTime) {\n              synchronized (this) {\n                  try {\n                      wait(endTime - System.currentTimeMillis());\n                  } catch (Exception e) {\n                  }\n              }\n          }\n          // 根据startId终止服务，这样我们就不会在处理其它工作的过程中再来终止服务\n          stopSelf(msg.arg1);\n      }\n  }\n\n  @Override\n  public void onCreate() {\n    // 启动运行服务的线程。\n    // 请记住我们要创建一个单独的线程，因为服务通常运行于进程的主线程中，可我们不想阻塞主线程。\n    // 我们还要赋予它后台运行的优先级，以便计算密集的工作不会干扰我们的UI。\n    HandlerThread thread = new HandlerThread(\"ServiceStartArguments\",\n            Process.THREAD_PRIORITY_BACKGROUND);\n    thread.start();\n    \n    // 获得HandlerThread的Looper队列并用于Handler\n    mServiceLooper = thread.getLooper();\n    mServiceHandler = new ServiceHandler(mServiceLooper);\n  }\n\n  @Override\n  public int onStartCommand(Intent intent, int flags, int startId) {\n      Toast.makeText(this, \"service starting\", Toast.LENGTH_SHORT).show();\n\n      // 对于每一个启动请求，都发送一个消息来启动一个处理\n      // 同时传入启动ID，以便任务完成后我们知道该终止哪一个请求。\n      Message msg = mServiceHandler.obtainMessage();\n      msg.arg1 = startId;\n      mServiceHandler.sendMessage(msg);\n      \n      // 如果我们被杀死了，那从这里返回之后被重启\n      return START_STICKY;\n  }\n\n  @Override\n  public IBinder onBind(Intent intent) {\n      // 我们不支持绑定，所以返回null\n      return null;\n  }\n  \n  @Override\n  public void onDestroy() {\n    Toast.makeText(this, \"service done\", Toast.LENGTH_SHORT).show(); \n  }\n}\n```    \n\n如你所见，它要干的事情比用IntentService时多了很多。\n\n不过，因为是自行处理每个onStartCommand()调用，你可以同时处理多个请求。 本例中没有这么去实现，但只要你愿意，你就可以为每个请求创建一个新的线程，并立即运行它们（而不是等待前一个请求处理完毕）。\n\n请注意onStartCommand()方法必须返回一个整数。这个整数是描述系统在杀死服务之后应该如何继续运行（上一节中缺省的 IntentService 实现代码会替你处理这一点，当然那样你就无法修改这个处理过程）。onStartCommand()的返回值必须是以下常量之一：\n\n\n- START_NOT_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则不会重建服务了，除非还存在未发送的intent。 当服务不再是必需的，并且应用程序能够简单地重启那些未完成的工作时，这是避免服务运行的最安全的选项。 \n\n\n- START_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并调用onStartCommand()，但不会再次送入上一个intent， 而是用null intent来调用onStartCommand() 。除非还有启动服务的intent未发送完，那么这些剩下的intent会继续发送。 这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命。 \n\n\n- START_REDELIVER_INTENT: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并用上一个已送过的intent调用onStartCommand()。任何未发送完的intent也都会依次送入。这适用于那些需要立即恢复工作的活跃服务，比如下载文件。    ","source":"_posts/android基础之Service.md","raw":"---\ntitle: android基础之Service\ndate: 2017-02-27 14:06:22\ncategories: android\ntags:\n- android\n- java\n- service\n---\n\n### 一 Service简介    \nService也是Android的四大组件之一，它并不提供用户界面，主要做一些即使该应用程序被调入后台也需要运行的事务。比如下载，音乐播放，执行文件I/O或者与content provider进行交互等。Service主要做的就是上面这些比较耗时的操作，但是由于Service也是运行在主线程中，因此最好在其中另开一个线程做这些耗时操作，否者可能会引起UI阻塞。       \n\n### 二 Service的两种启动方式     \nService有started和bound两种启动方式，当然也可以两种都启用。你可通过startService()启动服务后再通过bindService()将activity于Service绑定。     \n\n##### 1.startService()启动    \n通过startService()启动的Service，Service一旦启动即与它的调用者（通常是某个activity）不再关联，即使调用它的组件被销毁，它也能在后台一直运行下去。通常，该类服务执行单一的操作并且不会向调用者返回结果，比如它可以通过网络下载或上传文件。此类服务应该在其工作完成后通过重写stopSelf()使其自行终止，或者由其他组件调用stopService()来终止。       \n通过startService()启动的服务需要实现它的生命周期中onStartCommand()方法        \n\n\n\n##### 2.bindService()启动      \n通过bindService()启动的服务，该服务的生命周期将与启动它的组件相关联，即如果启动它的组件被销毁则该服务也会被销毁，或者通过调用unBindService()与服务解绑，解绑后服务被销毁。多个组件可以同时与一个服务绑定，当所有组件都与服务解绑后，该服务才会被销毁。    \nbind服务提供了一个客户端/服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至进行进程间通信（IPC）。       \n通过bindService()启动的服务需要实现Service中的onBind()方法。   \n\n\n\n\n### 三 Service的生命周期     \n两种Service的生命周期如下图：     \n{% asset_img Service生命周期图.png Service生命周期图 %}     \n其回调方法如下：     \n\n   \n```java       \npublic class ExampleService extends Service {\n    int mStartMode;       // indicates how to behave if the service is killed\n    IBinder mBinder;      // interface for clients that bind\n    boolean mAllowRebind; // indicates whether onRebind should be used\n\n    @Override\n    public void onCreate() {\n        // The service is being created\n    }\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        // The service is starting, due to a call to startService()\n        return mStartMode;\n    }\n    @Override\n    public IBinder onBind(Intent intent) {\n        // A client is binding to the service with bindService()\n        return mBinder;\n    }\n    @Override\n    public boolean onUnbind(Intent intent) {\n        // All clients have unbound with unbindService()\n        return mAllowRebind;\n    }\n    @Override\n    public void onRebind(Intent intent) {\n        // A client is binding to the service with bindService(),\n        // after onUnbind() has already been called\n    }\n    @Override\n    public void onDestroy() {\n        // The service is no longer used and is being destroyed\n    }\n}\n```         \n\n\n\n### 四 Service与线程的区别    \n- Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。     \n- Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。       \n其实谈Service和线程的区别毫无意义，它们本来就是毫无关联的两样东西，我觉得应该谈的是在什么情况下，什么地方使用线程更合适。   \n比如：如果你的线程主要用于对UI的更新，那么在Activity中新建即可。但是如果你的线程用于app和服务器之间的消息推送，你需要隔一段时间就要连接服务器做数据同步的话，那么就不能在Activity中新建线程。因为此时的线程在Activity被销毁时，它仍然需要运行。此时将面对一个问题，如果你是Activity中创建得线程，那么当该Activity被销毁时，你将失去该线程的实例。另一方面，你没办法在不同的Activity中对同一线程进行控制。这种情况你就需要在Service中创建它，一方面Service在Activity被销毁时仍然可以运行，另一方面其他的Activity重建后也可以通过与Service进行绑定获得Service的实例，进而控制该线程。\n\n### 五 保证Service不被杀死    \n- onStartCommand方法，返回START_STICKY   \n- 提升service优先级   \n- 提升service进程优先级,将其提升为前台服务    \n- onDestroy方法里重启service  \n- 监听系统广播判断Service状态    \n- 将APK安装到/system/app，变身系统级应用      \n\n\n### 六 IntentService    \n\n因为大多数started服务都不需要同时处理多个请求（这实际上是一个危险的多线程情况），所以最佳方式也许就是用IntentService类来实现你的服务。   \nIntentService将执行以下步骤：    　　\n- 创建一个缺省的工作（worker）线程，它独立于应用程序主线程来执行所有发送到onStartCommand()的intent。　　　\n- 创建一个工作队列，每次向你的onHandleIntent()传入一个intent，这样你就永远不必担心多线程问题了。　\n- 在处理完所有的启动请求后，终止服务，因此你就永远不需调用stopSelf()了。　　\n- 提供缺省的onBind()实现代码，它返回null。\n- 提供缺省的onStartCommand()实现代码，它把intent送入工作队列，稍后会再传给你的onHandleIntent()实现代码。　　　\n\n以上所有步骤将汇成一个结果：你要做的全部工作就是实现onHandleIntent()的代码，来完成客户端提交的任务。（当然你还需要为服务提供一小段构造方法。）       \n\n以下是个IntentService的实现例程：    \n\n```java    \n\npublic class HelloIntentService extends IntentService {\n\n  /** \n   * 构造方法是必需的，必须用工作线程名称作为参数\n   * 调用父类的[http://developer.android.com/reference/android/app/IntentService.html#IntentService(java.lang.String) IntentService(String)]构造方法。\n   */\n  public HelloIntentService() {\n      super(\"HelloIntentService\");\n  }\n\n  /**\n   * IntentService从缺省的工作线程中调用本方法，并用启动服务的intent作为参数。 \n   * 本方法返回后，IntentService将适时终止这个服务。\n   */\n  @Override\n  protected void onHandleIntent(Intent intent) {\n      // 通常我们会在这里执行一些工作，比如下载文件。\n      // 作为例子，我们只是睡5秒钟。\n      long endTime = System.currentTimeMillis() + 5*1000;\n      while (System.currentTimeMillis() < endTime) {\n          synchronized (this) {\n              try {\n                  wait(endTime - System.currentTimeMillis());\n              } catch (Exception e) {\n              }\n          }\n      }\n  }\n}  \n\n```    \n\n所有你需要做的就是：一个构造方法和一个onHandleIntent()方法的实现。\n\n如果你还决定重写其它的回调方法，比如onCreate()、onStartCommand()、onDestroy()， 请确保调用一下父类的实现代码，以便IntentService能正确处理工作线程的生命周期。\n\n比如说，onStartCommand()必须返回缺省实现代码的结果（缺省代码实现了如何获取传给onHandleIntent()的intent）：    \n\n```java  \n@Override\npublic int onStartCommand(Intent intent, int flags, int startId) {\n    Toast.makeText(this, \"service starting\", Toast.LENGTH_SHORT).show();\n    return super.onStartCommand(intent,flags,startId);\n}\n```   \n\n除了onHandleIntent()以外，唯一不需要调用父类实现代码的方法是onBind()（不过如果你的服务允许绑定，你还是需要实现它）。    \n\n\n### 七 扩展Service   \n\n如上节所述，利用IntentService来实现一个started服务非常简单。 不过，假如你的服务需要多线程运行（而不是通过一个工作队列来处理启动请求），那你可以扩展Service类来完成每个intent的处理。\n\n作为对照，以下例程实现了 Service 类，它执行的工作与上述使用IntentService的例子相同。确切地说，对于每一个启动请求，它都用一个工作线程来完成处理工作，并且每次只处理一个请求。    \n\n```java    \npublic class HelloService extends Service {\n  private Looper mServiceLooper;\n  private ServiceHandler mServiceHandler;\n\n  // 处理从线程接收的消息\n  private final class ServiceHandler extends Handler {\n      public ServiceHandler(Looper looper) {\n          super(looper);\n      }\n      @Override\n      public void handleMessage(Message msg) {\n          // 通常我们在这里执行一些工作，比如下载文件。\n          // 作为例子，我们只是睡个5秒钟。\n          long endTime = System.currentTimeMillis() + 5*1000;\n          while (System.currentTimeMillis() < endTime) {\n              synchronized (this) {\n                  try {\n                      wait(endTime - System.currentTimeMillis());\n                  } catch (Exception e) {\n                  }\n              }\n          }\n          // 根据startId终止服务，这样我们就不会在处理其它工作的过程中再来终止服务\n          stopSelf(msg.arg1);\n      }\n  }\n\n  @Override\n  public void onCreate() {\n    // 启动运行服务的线程。\n    // 请记住我们要创建一个单独的线程，因为服务通常运行于进程的主线程中，可我们不想阻塞主线程。\n    // 我们还要赋予它后台运行的优先级，以便计算密集的工作不会干扰我们的UI。\n    HandlerThread thread = new HandlerThread(\"ServiceStartArguments\",\n            Process.THREAD_PRIORITY_BACKGROUND);\n    thread.start();\n    \n    // 获得HandlerThread的Looper队列并用于Handler\n    mServiceLooper = thread.getLooper();\n    mServiceHandler = new ServiceHandler(mServiceLooper);\n  }\n\n  @Override\n  public int onStartCommand(Intent intent, int flags, int startId) {\n      Toast.makeText(this, \"service starting\", Toast.LENGTH_SHORT).show();\n\n      // 对于每一个启动请求，都发送一个消息来启动一个处理\n      // 同时传入启动ID，以便任务完成后我们知道该终止哪一个请求。\n      Message msg = mServiceHandler.obtainMessage();\n      msg.arg1 = startId;\n      mServiceHandler.sendMessage(msg);\n      \n      // 如果我们被杀死了，那从这里返回之后被重启\n      return START_STICKY;\n  }\n\n  @Override\n  public IBinder onBind(Intent intent) {\n      // 我们不支持绑定，所以返回null\n      return null;\n  }\n  \n  @Override\n  public void onDestroy() {\n    Toast.makeText(this, \"service done\", Toast.LENGTH_SHORT).show(); \n  }\n}\n```    \n\n如你所见，它要干的事情比用IntentService时多了很多。\n\n不过，因为是自行处理每个onStartCommand()调用，你可以同时处理多个请求。 本例中没有这么去实现，但只要你愿意，你就可以为每个请求创建一个新的线程，并立即运行它们（而不是等待前一个请求处理完毕）。\n\n请注意onStartCommand()方法必须返回一个整数。这个整数是描述系统在杀死服务之后应该如何继续运行（上一节中缺省的 IntentService 实现代码会替你处理这一点，当然那样你就无法修改这个处理过程）。onStartCommand()的返回值必须是以下常量之一：\n\n\n- START_NOT_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则不会重建服务了，除非还存在未发送的intent。 当服务不再是必需的，并且应用程序能够简单地重启那些未完成的工作时，这是避免服务运行的最安全的选项。 \n\n\n- START_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并调用onStartCommand()，但不会再次送入上一个intent， 而是用null intent来调用onStartCommand() 。除非还有启动服务的intent未发送完，那么这些剩下的intent会继续发送。 这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命。 \n\n\n- START_REDELIVER_INTENT: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并用上一个已送过的intent调用onStartCommand()。任何未发送完的intent也都会依次送入。这适用于那些需要立即恢复工作的活跃服务，比如下载文件。    ","slug":"android基础之Service","published":1,"updated":"2017-03-06T09:17:22.399Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizz09fte0003aonza5029hwx","content":"<h3 id=\"一-Service简介\"><a href=\"#一-Service简介\" class=\"headerlink\" title=\"一 Service简介\"></a>一 Service简介</h3><p>Service也是Android的四大组件之一，它并不提供用户界面，主要做一些即使该应用程序被调入后台也需要运行的事务。比如下载，音乐播放，执行文件I/O或者与content provider进行交互等。Service主要做的就是上面这些比较耗时的操作，但是由于Service也是运行在主线程中，因此最好在其中另开一个线程做这些耗时操作，否者可能会引起UI阻塞。       </p>\n<h3 id=\"二-Service的两种启动方式\"><a href=\"#二-Service的两种启动方式\" class=\"headerlink\" title=\"二 Service的两种启动方式\"></a>二 Service的两种启动方式</h3><p>Service有started和bound两种启动方式，当然也可以两种都启用。你可通过startService()启动服务后再通过bindService()将activity于Service绑定。     </p>\n<h5 id=\"1-startService-启动\"><a href=\"#1-startService-启动\" class=\"headerlink\" title=\"1.startService()启动\"></a>1.startService()启动</h5><p>通过startService()启动的Service，Service一旦启动即与它的调用者（通常是某个activity）不再关联，即使调用它的组件被销毁，它也能在后台一直运行下去。通常，该类服务执行单一的操作并且不会向调用者返回结果，比如它可以通过网络下载或上传文件。此类服务应该在其工作完成后通过重写stopSelf()使其自行终止，或者由其他组件调用stopService()来终止。<br>通过startService()启动的服务需要实现它的生命周期中onStartCommand()方法        </p>\n<h5 id=\"2-bindService-启动\"><a href=\"#2-bindService-启动\" class=\"headerlink\" title=\"2.bindService()启动\"></a>2.bindService()启动</h5><p>通过bindService()启动的服务，该服务的生命周期将与启动它的组件相关联，即如果启动它的组件被销毁则该服务也会被销毁，或者通过调用unBindService()与服务解绑，解绑后服务被销毁。多个组件可以同时与一个服务绑定，当所有组件都与服务解绑后，该服务才会被销毁。<br>bind服务提供了一个客户端/服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至进行进程间通信（IPC）。<br>通过bindService()启动的服务需要实现Service中的onBind()方法。   </p>\n<h3 id=\"三-Service的生命周期\"><a href=\"#三-Service的生命周期\" class=\"headerlink\" title=\"三 Service的生命周期\"></a>三 Service的生命周期</h3><p>两种Service的生命周期如下图：<br><img src=\"/2017/02/27/android基础之Service/Service生命周期图.png\" alt=\"Service生命周期图\" title=\"Service生命周期图\"><br>其回调方法如下：     </p>\n<pre><code class=\"java\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>{\n    <span class=\"keyword\">int</span> mStartMode;       <span class=\"comment\">// indicates how to behave if the service is killed</span>\n    IBinder mBinder;      <span class=\"comment\">// interface for clients that bind</span>\n    <span class=\"keyword\">boolean</span> mAllowRebind; <span class=\"comment\">// indicates whether onRebind should be used</span>\n\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>{\n        <span class=\"comment\">// The service is being created</span>\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>{\n        <span class=\"comment\">// The service is starting, due to a call to startService()</span>\n        <span class=\"keyword\">return</span> mStartMode;\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>{\n        <span class=\"comment\">// A client is binding to the service with bindService()</span>\n        <span class=\"keyword\">return</span> mBinder;\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onUnbind</span><span class=\"params\">(Intent intent)</span> </span>{\n        <span class=\"comment\">// All clients have unbound with unbindService()</span>\n        <span class=\"keyword\">return</span> mAllowRebind;\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRebind</span><span class=\"params\">(Intent intent)</span> </span>{\n        <span class=\"comment\">// A client is binding to the service with bindService(),</span>\n        <span class=\"comment\">// after onUnbind() has already been called</span>\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>{\n        <span class=\"comment\">// The service is no longer used and is being destroyed</span>\n    }\n}\n</code></pre>\n<h3 id=\"四-Service与线程的区别\"><a href=\"#四-Service与线程的区别\" class=\"headerlink\" title=\"四 Service与线程的区别\"></a>四 Service与线程的区别</h3><ul>\n<li>Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。     </li>\n<li>Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。<br>其实谈Service和线程的区别毫无意义，它们本来就是毫无关联的两样东西，我觉得应该谈的是在什么情况下，什么地方使用线程更合适。<br>比如：如果你的线程主要用于对UI的更新，那么在Activity中新建即可。但是如果你的线程用于app和服务器之间的消息推送，你需要隔一段时间就要连接服务器做数据同步的话，那么就不能在Activity中新建线程。因为此时的线程在Activity被销毁时，它仍然需要运行。此时将面对一个问题，如果你是Activity中创建得线程，那么当该Activity被销毁时，你将失去该线程的实例。另一方面，你没办法在不同的Activity中对同一线程进行控制。这种情况你就需要在Service中创建它，一方面Service在Activity被销毁时仍然可以运行，另一方面其他的Activity重建后也可以通过与Service进行绑定获得Service的实例，进而控制该线程。</li>\n</ul>\n<h3 id=\"五-保证Service不被杀死\"><a href=\"#五-保证Service不被杀死\" class=\"headerlink\" title=\"五 保证Service不被杀死\"></a>五 保证Service不被杀死</h3><ul>\n<li>onStartCommand方法，返回START_STICKY   </li>\n<li>提升service优先级   </li>\n<li>提升service进程优先级,将其提升为前台服务    </li>\n<li>onDestroy方法里重启service  </li>\n<li>监听系统广播判断Service状态    </li>\n<li>将APK安装到/system/app，变身系统级应用      </li>\n</ul>\n<h3 id=\"六-IntentService\"><a href=\"#六-IntentService\" class=\"headerlink\" title=\"六 IntentService\"></a>六 IntentService</h3><p>因为大多数started服务都不需要同时处理多个请求（这实际上是一个危险的多线程情况），所以最佳方式也许就是用IntentService类来实现你的服务。<br>IntentService将执行以下步骤：    　　</p>\n<ul>\n<li>创建一个缺省的工作（worker）线程，它独立于应用程序主线程来执行所有发送到onStartCommand()的intent。　　　</li>\n<li>创建一个工作队列，每次向你的onHandleIntent()传入一个intent，这样你就永远不必担心多线程问题了。　</li>\n<li>在处理完所有的启动请求后，终止服务，因此你就永远不需调用stopSelf()了。　　</li>\n<li>提供缺省的onBind()实现代码，它返回null。</li>\n<li>提供缺省的onStartCommand()实现代码，它把intent送入工作队列，稍后会再传给你的onHandleIntent()实现代码。　　　</li>\n</ul>\n<p>以上所有步骤将汇成一个结果：你要做的全部工作就是实现onHandleIntent()的代码，来完成客户端提交的任务。（当然你还需要为服务提供一小段构造方法。）       </p>\n<p>以下是个IntentService的实现例程：    </p>\n<pre><code class=\"java\">\n<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloIntentService</span> <span class=\"keyword\">extends</span> <span class=\"title\">IntentService</span> </span>{\n\n  <span class=\"comment\">/** \n   * 构造方法是必需的，必须用工作线程名称作为参数\n   * 调用父类的[http://developer.android.com/reference/android/app/IntentService.html#IntentService(java.lang.String) IntentService(String)]构造方法。\n   */</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HelloIntentService</span><span class=\"params\">()</span> </span>{\n      <span class=\"keyword\">super</span>(<span class=\"string\">\"HelloIntentService\"</span>);\n  }\n\n  <span class=\"comment\">/**\n   * IntentService从缺省的工作线程中调用本方法，并用启动服务的intent作为参数。 \n   * 本方法返回后，IntentService将适时终止这个服务。\n   */</span>\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onHandleIntent</span><span class=\"params\">(Intent intent)</span> </span>{\n      <span class=\"comment\">// 通常我们会在这里执行一些工作，比如下载文件。</span>\n      <span class=\"comment\">// 作为例子，我们只是睡5秒钟。</span>\n      <span class=\"keyword\">long</span> endTime = System.currentTimeMillis() + <span class=\"number\">5</span>*<span class=\"number\">1000</span>;\n      <span class=\"keyword\">while</span> (System.currentTimeMillis() &lt; endTime) {\n          <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) {\n              <span class=\"keyword\">try</span> {\n                  wait(endTime - System.currentTimeMillis());\n              } <span class=\"keyword\">catch</span> (Exception e) {\n              }\n          }\n      }\n  }\n}\n</code></pre>\n<p>所有你需要做的就是：一个构造方法和一个onHandleIntent()方法的实现。</p>\n<p>如果你还决定重写其它的回调方法，比如onCreate()、onStartCommand()、onDestroy()， 请确保调用一下父类的实现代码，以便IntentService能正确处理工作线程的生命周期。</p>\n<p>比如说，onStartCommand()必须返回缺省实现代码的结果（缺省代码实现了如何获取传给onHandleIntent()的intent）：    </p>\n<pre><code class=\"java\"><span class=\"meta\">@Override</span>\n<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>{\n    Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"service starting\"</span>, Toast.LENGTH_SHORT).show();\n    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onStartCommand(intent,flags,startId);\n}\n</code></pre>\n<p>除了onHandleIntent()以外，唯一不需要调用父类实现代码的方法是onBind()（不过如果你的服务允许绑定，你还是需要实现它）。    </p>\n<h3 id=\"七-扩展Service\"><a href=\"#七-扩展Service\" class=\"headerlink\" title=\"七 扩展Service\"></a>七 扩展Service</h3><p>如上节所述，利用IntentService来实现一个started服务非常简单。 不过，假如你的服务需要多线程运行（而不是通过一个工作队列来处理启动请求），那你可以扩展Service类来完成每个intent的处理。</p>\n<p>作为对照，以下例程实现了 Service 类，它执行的工作与上述使用IntentService的例子相同。确切地说，对于每一个启动请求，它都用一个工作线程来完成处理工作，并且每次只处理一个请求。    </p>\n<pre><code class=\"java\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>{\n  <span class=\"keyword\">private</span> Looper mServiceLooper;\n  <span class=\"keyword\">private</span> ServiceHandler mServiceHandler;\n\n  <span class=\"comment\">// 处理从线程接收的消息</span>\n  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>{\n      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServiceHandler</span><span class=\"params\">(Looper looper)</span> </span>{\n          <span class=\"keyword\">super</span>(looper);\n      }\n      <span class=\"meta\">@Override</span>\n      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>{\n          <span class=\"comment\">// 通常我们在这里执行一些工作，比如下载文件。</span>\n          <span class=\"comment\">// 作为例子，我们只是睡个5秒钟。</span>\n          <span class=\"keyword\">long</span> endTime = System.currentTimeMillis() + <span class=\"number\">5</span>*<span class=\"number\">1000</span>;\n          <span class=\"keyword\">while</span> (System.currentTimeMillis() &lt; endTime) {\n              <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) {\n                  <span class=\"keyword\">try</span> {\n                      wait(endTime - System.currentTimeMillis());\n                  } <span class=\"keyword\">catch</span> (Exception e) {\n                  }\n              }\n          }\n          <span class=\"comment\">// 根据startId终止服务，这样我们就不会在处理其它工作的过程中再来终止服务</span>\n          stopSelf(msg.arg1);\n      }\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>{\n    <span class=\"comment\">// 启动运行服务的线程。</span>\n    <span class=\"comment\">// 请记住我们要创建一个单独的线程，因为服务通常运行于进程的主线程中，可我们不想阻塞主线程。</span>\n    <span class=\"comment\">// 我们还要赋予它后台运行的优先级，以便计算密集的工作不会干扰我们的UI。</span>\n    HandlerThread thread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">\"ServiceStartArguments\"</span>,\n            Process.THREAD_PRIORITY_BACKGROUND);\n    thread.start();\n\n    <span class=\"comment\">// 获得HandlerThread的Looper队列并用于Handler</span>\n    mServiceLooper = thread.getLooper();\n    mServiceHandler = <span class=\"keyword\">new</span> ServiceHandler(mServiceLooper);\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>{\n      Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"service starting\"</span>, Toast.LENGTH_SHORT).show();\n\n      <span class=\"comment\">// 对于每一个启动请求，都发送一个消息来启动一个处理</span>\n      <span class=\"comment\">// 同时传入启动ID，以便任务完成后我们知道该终止哪一个请求。</span>\n      Message msg = mServiceHandler.obtainMessage();\n      msg.arg1 = startId;\n      mServiceHandler.sendMessage(msg);\n\n      <span class=\"comment\">// 如果我们被杀死了，那从这里返回之后被重启</span>\n      <span class=\"keyword\">return</span> START_STICKY;\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>{\n      <span class=\"comment\">// 我们不支持绑定，所以返回null</span>\n      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>{\n    Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"service done\"</span>, Toast.LENGTH_SHORT).show(); \n  }\n}\n</code></pre>\n<p>如你所见，它要干的事情比用IntentService时多了很多。</p>\n<p>不过，因为是自行处理每个onStartCommand()调用，你可以同时处理多个请求。 本例中没有这么去实现，但只要你愿意，你就可以为每个请求创建一个新的线程，并立即运行它们（而不是等待前一个请求处理完毕）。</p>\n<p>请注意onStartCommand()方法必须返回一个整数。这个整数是描述系统在杀死服务之后应该如何继续运行（上一节中缺省的 IntentService 实现代码会替你处理这一点，当然那样你就无法修改这个处理过程）。onStartCommand()的返回值必须是以下常量之一：</p>\n<ul>\n<li>START_NOT_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则不会重建服务了，除非还存在未发送的intent。 当服务不再是必需的，并且应用程序能够简单地重启那些未完成的工作时，这是避免服务运行的最安全的选项。 </li>\n</ul>\n<ul>\n<li>START_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并调用onStartCommand()，但不会再次送入上一个intent， 而是用null intent来调用onStartCommand() 。除非还有启动服务的intent未发送完，那么这些剩下的intent会继续发送。 这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命。 </li>\n</ul>\n<ul>\n<li>START_REDELIVER_INTENT: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并用上一个已送过的intent调用onStartCommand()。任何未发送完的intent也都会依次送入。这适用于那些需要立即恢复工作的活跃服务，比如下载文件。    </li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一-Service简介\"><a href=\"#一-Service简介\" class=\"headerlink\" title=\"一 Service简介\"></a>一 Service简介</h3><p>Service也是Android的四大组件之一，它并不提供用户界面，主要做一些即使该应用程序被调入后台也需要运行的事务。比如下载，音乐播放，执行文件I/O或者与content provider进行交互等。Service主要做的就是上面这些比较耗时的操作，但是由于Service也是运行在主线程中，因此最好在其中另开一个线程做这些耗时操作，否者可能会引起UI阻塞。       </p>\n<h3 id=\"二-Service的两种启动方式\"><a href=\"#二-Service的两种启动方式\" class=\"headerlink\" title=\"二 Service的两种启动方式\"></a>二 Service的两种启动方式</h3><p>Service有started和bound两种启动方式，当然也可以两种都启用。你可通过startService()启动服务后再通过bindService()将activity于Service绑定。     </p>\n<h5 id=\"1-startService-启动\"><a href=\"#1-startService-启动\" class=\"headerlink\" title=\"1.startService()启动\"></a>1.startService()启动</h5><p>通过startService()启动的Service，Service一旦启动即与它的调用者（通常是某个activity）不再关联，即使调用它的组件被销毁，它也能在后台一直运行下去。通常，该类服务执行单一的操作并且不会向调用者返回结果，比如它可以通过网络下载或上传文件。此类服务应该在其工作完成后通过重写stopSelf()使其自行终止，或者由其他组件调用stopService()来终止。<br>通过startService()启动的服务需要实现它的生命周期中onStartCommand()方法        </p>\n<h5 id=\"2-bindService-启动\"><a href=\"#2-bindService-启动\" class=\"headerlink\" title=\"2.bindService()启动\"></a>2.bindService()启动</h5><p>通过bindService()启动的服务，该服务的生命周期将与启动它的组件相关联，即如果启动它的组件被销毁则该服务也会被销毁，或者通过调用unBindService()与服务解绑，解绑后服务被销毁。多个组件可以同时与一个服务绑定，当所有组件都与服务解绑后，该服务才会被销毁。<br>bind服务提供了一个客户端/服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至进行进程间通信（IPC）。<br>通过bindService()启动的服务需要实现Service中的onBind()方法。   </p>\n<h3 id=\"三-Service的生命周期\"><a href=\"#三-Service的生命周期\" class=\"headerlink\" title=\"三 Service的生命周期\"></a>三 Service的生命周期</h3><p>两种Service的生命周期如下图：<br><img src=\"/2017/02/27/android基础之Service/Service生命周期图.png\" alt=\"Service生命周期图\" title=\"Service生命周期图\"><br>其回调方法如下：     </p>\n<pre><code class=\"java\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>{\n    <span class=\"keyword\">int</span> mStartMode;       <span class=\"comment\">// indicates how to behave if the service is killed</span>\n    IBinder mBinder;      <span class=\"comment\">// interface for clients that bind</span>\n    <span class=\"keyword\">boolean</span> mAllowRebind; <span class=\"comment\">// indicates whether onRebind should be used</span>\n\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>{\n        <span class=\"comment\">// The service is being created</span>\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>{\n        <span class=\"comment\">// The service is starting, due to a call to startService()</span>\n        <span class=\"keyword\">return</span> mStartMode;\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>{\n        <span class=\"comment\">// A client is binding to the service with bindService()</span>\n        <span class=\"keyword\">return</span> mBinder;\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onUnbind</span><span class=\"params\">(Intent intent)</span> </span>{\n        <span class=\"comment\">// All clients have unbound with unbindService()</span>\n        <span class=\"keyword\">return</span> mAllowRebind;\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRebind</span><span class=\"params\">(Intent intent)</span> </span>{\n        <span class=\"comment\">// A client is binding to the service with bindService(),</span>\n        <span class=\"comment\">// after onUnbind() has already been called</span>\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>{\n        <span class=\"comment\">// The service is no longer used and is being destroyed</span>\n    }\n}\n</code></pre>\n<h3 id=\"四-Service与线程的区别\"><a href=\"#四-Service与线程的区别\" class=\"headerlink\" title=\"四 Service与线程的区别\"></a>四 Service与线程的区别</h3><ul>\n<li>Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。     </li>\n<li>Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。<br>其实谈Service和线程的区别毫无意义，它们本来就是毫无关联的两样东西，我觉得应该谈的是在什么情况下，什么地方使用线程更合适。<br>比如：如果你的线程主要用于对UI的更新，那么在Activity中新建即可。但是如果你的线程用于app和服务器之间的消息推送，你需要隔一段时间就要连接服务器做数据同步的话，那么就不能在Activity中新建线程。因为此时的线程在Activity被销毁时，它仍然需要运行。此时将面对一个问题，如果你是Activity中创建得线程，那么当该Activity被销毁时，你将失去该线程的实例。另一方面，你没办法在不同的Activity中对同一线程进行控制。这种情况你就需要在Service中创建它，一方面Service在Activity被销毁时仍然可以运行，另一方面其他的Activity重建后也可以通过与Service进行绑定获得Service的实例，进而控制该线程。</li>\n</ul>\n<h3 id=\"五-保证Service不被杀死\"><a href=\"#五-保证Service不被杀死\" class=\"headerlink\" title=\"五 保证Service不被杀死\"></a>五 保证Service不被杀死</h3><ul>\n<li>onStartCommand方法，返回START_STICKY   </li>\n<li>提升service优先级   </li>\n<li>提升service进程优先级,将其提升为前台服务    </li>\n<li>onDestroy方法里重启service  </li>\n<li>监听系统广播判断Service状态    </li>\n<li>将APK安装到/system/app，变身系统级应用      </li>\n</ul>\n<h3 id=\"六-IntentService\"><a href=\"#六-IntentService\" class=\"headerlink\" title=\"六 IntentService\"></a>六 IntentService</h3><p>因为大多数started服务都不需要同时处理多个请求（这实际上是一个危险的多线程情况），所以最佳方式也许就是用IntentService类来实现你的服务。<br>IntentService将执行以下步骤：    　　</p>\n<ul>\n<li>创建一个缺省的工作（worker）线程，它独立于应用程序主线程来执行所有发送到onStartCommand()的intent。　　　</li>\n<li>创建一个工作队列，每次向你的onHandleIntent()传入一个intent，这样你就永远不必担心多线程问题了。　</li>\n<li>在处理完所有的启动请求后，终止服务，因此你就永远不需调用stopSelf()了。　　</li>\n<li>提供缺省的onBind()实现代码，它返回null。</li>\n<li>提供缺省的onStartCommand()实现代码，它把intent送入工作队列，稍后会再传给你的onHandleIntent()实现代码。　　　</li>\n</ul>\n<p>以上所有步骤将汇成一个结果：你要做的全部工作就是实现onHandleIntent()的代码，来完成客户端提交的任务。（当然你还需要为服务提供一小段构造方法。）       </p>\n<p>以下是个IntentService的实现例程：    </p>\n<pre><code class=\"java\">\n<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloIntentService</span> <span class=\"keyword\">extends</span> <span class=\"title\">IntentService</span> </span>{\n\n  <span class=\"comment\">/** \n   * 构造方法是必需的，必须用工作线程名称作为参数\n   * 调用父类的[http://developer.android.com/reference/android/app/IntentService.html#IntentService(java.lang.String) IntentService(String)]构造方法。\n   */</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HelloIntentService</span><span class=\"params\">()</span> </span>{\n      <span class=\"keyword\">super</span>(<span class=\"string\">\"HelloIntentService\"</span>);\n  }\n\n  <span class=\"comment\">/**\n   * IntentService从缺省的工作线程中调用本方法，并用启动服务的intent作为参数。 \n   * 本方法返回后，IntentService将适时终止这个服务。\n   */</span>\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onHandleIntent</span><span class=\"params\">(Intent intent)</span> </span>{\n      <span class=\"comment\">// 通常我们会在这里执行一些工作，比如下载文件。</span>\n      <span class=\"comment\">// 作为例子，我们只是睡5秒钟。</span>\n      <span class=\"keyword\">long</span> endTime = System.currentTimeMillis() + <span class=\"number\">5</span>*<span class=\"number\">1000</span>;\n      <span class=\"keyword\">while</span> (System.currentTimeMillis() &lt; endTime) {\n          <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) {\n              <span class=\"keyword\">try</span> {\n                  wait(endTime - System.currentTimeMillis());\n              } <span class=\"keyword\">catch</span> (Exception e) {\n              }\n          }\n      }\n  }\n}\n</code></pre>\n<p>所有你需要做的就是：一个构造方法和一个onHandleIntent()方法的实现。</p>\n<p>如果你还决定重写其它的回调方法，比如onCreate()、onStartCommand()、onDestroy()， 请确保调用一下父类的实现代码，以便IntentService能正确处理工作线程的生命周期。</p>\n<p>比如说，onStartCommand()必须返回缺省实现代码的结果（缺省代码实现了如何获取传给onHandleIntent()的intent）：    </p>\n<pre><code class=\"java\"><span class=\"meta\">@Override</span>\n<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>{\n    Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"service starting\"</span>, Toast.LENGTH_SHORT).show();\n    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onStartCommand(intent,flags,startId);\n}\n</code></pre>\n<p>除了onHandleIntent()以外，唯一不需要调用父类实现代码的方法是onBind()（不过如果你的服务允许绑定，你还是需要实现它）。    </p>\n<h3 id=\"七-扩展Service\"><a href=\"#七-扩展Service\" class=\"headerlink\" title=\"七 扩展Service\"></a>七 扩展Service</h3><p>如上节所述，利用IntentService来实现一个started服务非常简单。 不过，假如你的服务需要多线程运行（而不是通过一个工作队列来处理启动请求），那你可以扩展Service类来完成每个intent的处理。</p>\n<p>作为对照，以下例程实现了 Service 类，它执行的工作与上述使用IntentService的例子相同。确切地说，对于每一个启动请求，它都用一个工作线程来完成处理工作，并且每次只处理一个请求。    </p>\n<pre><code class=\"java\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>{\n  <span class=\"keyword\">private</span> Looper mServiceLooper;\n  <span class=\"keyword\">private</span> ServiceHandler mServiceHandler;\n\n  <span class=\"comment\">// 处理从线程接收的消息</span>\n  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>{\n      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServiceHandler</span><span class=\"params\">(Looper looper)</span> </span>{\n          <span class=\"keyword\">super</span>(looper);\n      }\n      <span class=\"meta\">@Override</span>\n      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>{\n          <span class=\"comment\">// 通常我们在这里执行一些工作，比如下载文件。</span>\n          <span class=\"comment\">// 作为例子，我们只是睡个5秒钟。</span>\n          <span class=\"keyword\">long</span> endTime = System.currentTimeMillis() + <span class=\"number\">5</span>*<span class=\"number\">1000</span>;\n          <span class=\"keyword\">while</span> (System.currentTimeMillis() &lt; endTime) {\n              <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) {\n                  <span class=\"keyword\">try</span> {\n                      wait(endTime - System.currentTimeMillis());\n                  } <span class=\"keyword\">catch</span> (Exception e) {\n                  }\n              }\n          }\n          <span class=\"comment\">// 根据startId终止服务，这样我们就不会在处理其它工作的过程中再来终止服务</span>\n          stopSelf(msg.arg1);\n      }\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>{\n    <span class=\"comment\">// 启动运行服务的线程。</span>\n    <span class=\"comment\">// 请记住我们要创建一个单独的线程，因为服务通常运行于进程的主线程中，可我们不想阻塞主线程。</span>\n    <span class=\"comment\">// 我们还要赋予它后台运行的优先级，以便计算密集的工作不会干扰我们的UI。</span>\n    HandlerThread thread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">\"ServiceStartArguments\"</span>,\n            Process.THREAD_PRIORITY_BACKGROUND);\n    thread.start();\n\n    <span class=\"comment\">// 获得HandlerThread的Looper队列并用于Handler</span>\n    mServiceLooper = thread.getLooper();\n    mServiceHandler = <span class=\"keyword\">new</span> ServiceHandler(mServiceLooper);\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>{\n      Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"service starting\"</span>, Toast.LENGTH_SHORT).show();\n\n      <span class=\"comment\">// 对于每一个启动请求，都发送一个消息来启动一个处理</span>\n      <span class=\"comment\">// 同时传入启动ID，以便任务完成后我们知道该终止哪一个请求。</span>\n      Message msg = mServiceHandler.obtainMessage();\n      msg.arg1 = startId;\n      mServiceHandler.sendMessage(msg);\n\n      <span class=\"comment\">// 如果我们被杀死了，那从这里返回之后被重启</span>\n      <span class=\"keyword\">return</span> START_STICKY;\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>{\n      <span class=\"comment\">// 我们不支持绑定，所以返回null</span>\n      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>{\n    Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"service done\"</span>, Toast.LENGTH_SHORT).show(); \n  }\n}\n</code></pre>\n<p>如你所见，它要干的事情比用IntentService时多了很多。</p>\n<p>不过，因为是自行处理每个onStartCommand()调用，你可以同时处理多个请求。 本例中没有这么去实现，但只要你愿意，你就可以为每个请求创建一个新的线程，并立即运行它们（而不是等待前一个请求处理完毕）。</p>\n<p>请注意onStartCommand()方法必须返回一个整数。这个整数是描述系统在杀死服务之后应该如何继续运行（上一节中缺省的 IntentService 实现代码会替你处理这一点，当然那样你就无法修改这个处理过程）。onStartCommand()的返回值必须是以下常量之一：</p>\n<ul>\n<li>START_NOT_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则不会重建服务了，除非还存在未发送的intent。 当服务不再是必需的，并且应用程序能够简单地重启那些未完成的工作时，这是避免服务运行的最安全的选项。 </li>\n</ul>\n<ul>\n<li>START_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并调用onStartCommand()，但不会再次送入上一个intent， 而是用null intent来调用onStartCommand() 。除非还有启动服务的intent未发送完，那么这些剩下的intent会继续发送。 这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命。 </li>\n</ul>\n<ul>\n<li>START_REDELIVER_INTENT: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并用上一个已送过的intent调用onStartCommand()。任何未发送完的intent也都会依次送入。这适用于那些需要立即恢复工作的活跃服务，比如下载文件。    </li>\n</ul>\n"},{"title":"android基础之activity","date":"2017-02-27T02:35:34.000Z","_content":"\n### 一 Activity简介   \nactivity是android四大组件之一，用于android app的界面显示。activity中包含一个window，window中则包含包含相应的view。\n\n### 二 Activity类的层次结构    \n继承的抽象类： ContextThemeWrapper\n实现的接口： ComponentCallbacks2 KeyEvent.Callback LayoutInflater.Factory2 View.OnCreateContextMenuListener Window.Callback      \n\n```java   \njava.lang.Object   \n\tandroid.content.Context\n\t\tandroid.content.ContextWrapper\n\t\t\tandroid.content.ContextThemeWrapper\n\t\t\t\tandroid.app.Activity\n```\n\n直接子类： AccountAuthenticatorActivity, ActivityGroup, AliasActivity, ExpandableListActivity, FragmentActivity, ListActivity, NativeActivity 　　　\n间接子类： ActionBarActivity, LauncherActivity, PreferenceActivity, TabActivity 　　　\n\n### 三 Activity的生命周期   　\nActivity在它的一生中有以下四种状态：  \n- running：此时Activity处于屏幕的前台并且拥有焦点，位于回退栈的顶部（回退栈将在下面介绍）。   \n- paused： 此时另一个Activity位于前台并拥有焦点，也就是说另一个Activity覆盖在本Activity的上面，但是这个Activity是透明的或者没有占据全屏，即从屏幕上还可以看到下面的Activity（比如弹出个红包）。一个paused的activity是完全存活的（Activity 对象仍然保留在内存里，它保持着所有的状态和成员信息，并且保持与window manager的联接），但在系统内存严重不足的情况下它能被杀死。    \n- stopped： 本Activity被其他Activity完全覆盖了，看不见了。一个stopped的activity也仍然是存活的（Activity 对象仍然保留在内存中，它保持着所有的状态和成员信息，但是不再与window manager联接了）。 但是，对于用户而言它已经不再可见了，并且当其它地方需要内存时它将会被杀死。    \n- killed： 当Activity处于paused或者stopped时，若内存不足，它将可能被干掉。当它被再次创建处于前台时，需要调用onCreate方法重新创建并恢复之前的状态    \n下面是activity的生命周期图：      \n{% asset_img activity生命周期图.png activity生命周期图 %}       \n由上图可以看出activity有三种不同的生命周期：　　\n- 完整生命周期： onCreate--onDestroy    \n- 可见生命周期： onResume到onPause之间循环    \n- 前台生命周期： onStart-onStop-onRestart三者之间循环    \nActivity中的回调方法    \n\n```java\npublic class ExampleActivity extends Activity {\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        // The activity is being created.\n    }\n    @Override\n    protected void onStart() {\n        super.onStart();\n        // The activity is about to become visible.\n    }\n    @Override\n    protected void onResume() {\n        super.onResume();\n        // The activity has become visible (it is now \"resumed\").\n    }\n    @Override\n    protected void onPause() {\n        super.onPause();\n        // Another activity is taking focus (this activity is about to be \"paused\").\n    }\n    @Override\n    protected void onStop() {\n        super.onStop();\n        // The activity is no longer visible (it is now \"stopped\")\n    }\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        // The activity is about to be destroyed.\n    }\n}\n```\n \nActivity回调方法汇总：       \n{% asset_img activity回调方法汇总.png activity回调方法汇总 %}       \n标为“之后可否被杀死？”的列指明了系统是否可以在这个方法返回之后的任意时刻杀掉这个activity的宿主进程， 而不再执行其它流程上的activity代码。 有三个方法是标为“可以”：（ onPause()、 onStop()、 和onDestroy()）。 因为onPause()是三个方法中的第一个， 一旦activity被创建， onPause() 就是进程可以被杀死之前最后一个能确保被调用的方法 ——如果系统在某种紧急情况下必须回收内存，则 onStop() 和onDestroy() 可能就不会被调用了。因此，你应该使用 onPause() 来把至关重要的需长期保存的数据写入存储器（比如用户所编辑的内容）。 不过，应该对必须通过 onPause() 方法进行保存的信息有所选择，因为该方法中所有的阻塞操作都会让切换到下一个activity的停滞，并使用户感觉到迟缓。\n\n“之后可否被杀死？”列中标为“否”的方法，在它们被调用时的那一刻起，就会保护本activity的宿主进程不被杀掉。 因此，只有在 onPause() 方法返回时至 onResume() 方法被调用时之间，activity才会被杀掉。直到 onPause() 再次被调用并返回时，activity都不会再次允许被杀死。\n\nNote:表1中标明的技术上不“可杀”的activity仍然有可能会被系统杀死——但那只有在没有任何资源的极端情况下才会发生。     \n\n### 四 保存Activity的状态    \n上一节中已简单提到，当一个activity被paused或者stopped时，activity的状态可以被保存。 的确如此，因为 Activity 对象在paused或者stopped时仍然被保留在内存之中——它所有的成员信息和当前状态都仍然存活。 这样用户在activity里所作的改动全都还保存着，所以当activity返回到前台时（当它“resume“），那些改动仍然有效。\n\n不过，如果系统是为了回收内存而销毁activity，则这个 Activity 对象就会被销毁，这样系统就无法简单地resume一下就能还原完整状态的activity。 如果用户要返回到这个activity的话，系统必须重新创建这个Activity 对象。可是用户并不知道系统是先销毁activity再重新创建了它的，所以，他很可能希望activity完全保持原样。 这种情况下，你可以保证activity状态的相关重要信息都由另一个回调方法保存下来了，此方法让你能保存activity状态的相关信息： onSaveInstanceState()。\n\n在activity变得很容易被销毁之前，系统会调用 onSaveInstanceState()方法。 调用时系统会传入一个Bundle对象， 你可以利用 putString() 之类的方法，以键值对的方式来把activity状态信息保存到该Bundle对象中。 然后，如果系统杀掉了你的application进程并且用户又返回到你的activity，系统就会重建activity并将这个 Bundle 传入onCreate() 和onRestoreInstanceState() 中，你就可以从 Bundle 中解析出已保存信息并恢复activity状态。如果没有储存状态信息，那么传入的 Bundle 将为null（当activity第一次被创建时就是如此）。     \n下图是Activity状态保存示意图：      \n{% asset_img Activity状态保存示意图.png activity状态保存示意图 %}  \n### 五 配置改动后的处理   \n设备的某些配置可能会在运行时发生变化（比如屏幕方向、键盘可用性以及语言）。 当发生这些变化时，Android会重建这个运行中的activity（系统会调用 onDestroy() ，然后再马上调用 onCreate() ）。这种设计有助于应用程序适用新的参数配置，通过把你预置的可替换资源（比如对应各种屏幕方向和尺寸的layout）自动重新装载进入应用程序的方式来实现。\n\n如果你采取了适当的设计，让activity能够正确地处理这些因为屏幕方向而引起的重启，并能如上所述地恢复activity状态， 那么你的应用程序将对生命周期中其它的意外事件更具适应能力。\n\n处理这类重启的最佳方式，就是利用 onSaveInstanceState() 和onRestoreInstanceState() （或者 onCreate() ）进行状态的保存和恢复，如上节所述。   \n\n### 六 Activity的启动方式   \nantivity的启动方式可以通过两种方式定义：     \n\n##### Androidmanifest文件       \nAndroidmanifest文件是android的清单文件，android的四大组件与相应权限皆需在这里设置。在这里你可以利用 <activity> 元素的 launchMode 属性来设定 activity 与 task 的关系。       \n可通过Androidmanifest文件设置的启动模式有：      \n- standard\n- singleTop\n- singleTask\n- singleInstance       \n\n##### Intent标志     \nIntent标志中有以下几种Activity的启动方式:       \n- FLAG_ACTIVITY_NEW_TASK\n- FLAG_ACTIVITY_SINGLE_TOP\n- FLAG_ACTIVITY_CLEAR_TOP       \n通过Intent标志的方式来启动Activity，优先级比manifest的高。    \n\n> **警告**： 大多数应用不应该改变 activity 和 task 默认的工作方式。 如果你确定有必要修改默认方式，请保持\n谨慎，并确保 activity 在启动和从其它 activity 用回退键返回时的可用性。 请确保对可能与用户预期的导航方式\n相冲突的地方进行测试。      \n\n### 七 启动Activity  \n要启动一个activity需要使用Intent，实际上android中组件之前的通信皆由Intent完成（如果你不了解Intent，请看我之后的博客[android基础之Intents与Intent-Filters.md](android基础之Intents与Intent-Filters.md \"android基础之Intents与Intent-Filters\")），而使用Intent启动activity有显示和隐式两种方式。   \n\n\n##### 显示启动      \n\n     \n```java\nIntent intent = new Intent(this, SignInActivity.class);\nstartActivity(intent);//显示启动一个叫SignInActivity的Activity    \n\n```   \n\n\n\n#####  隐式启动    \n要想隐式启动一个activity，你需要使用intent-filter来暴露你的activity。使用filter有java代码和xml文件两种方式，推荐使用第二种方式，你只需在Androidmanifest.xml文件中的activit元素中加入intent-filter属性，并声明一个action即可。但是如果你想使你的activity更独立，那么就不要为你的activity设置filter。那么什么时候使用这种方式呢？    \n如果，你的程序可能想要展示某些动作，例如发邮件，短信，微博，或者使用你activity中的数据。 这时候，你就不应该使用自己的activity来做这些工作。你应该调用系统中其他程序提供的响应功能。 这是intent真正体现其价值的地方。你可以创建一个描述了响应动作的intent,然后系统来为你挑选完成任务的程序。 如果有多个选择，系统会提示用户进行选择。例如你想让用户发邮件，你可以创建下面的intent：        \n\n\n```java\nIntent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_EMAIL, recipientArray);//recipientArray即你想发送过去的联系人信息\nstartActivity(intent);    \n\n```       \n\n##### 启动一个带返回结果的Activity    \n有时候，你想要启动一个activity,并从这个activty获得一个结果。 这时，要通过 startActivityForResult() (取代startActivity()) 来启动activity。 然后通过实现onActivityResult()回调方法来获得返回后的结果。 当这个后续的activity被关闭，它将发送一个 Intent 给 onActivityResult() 方法。     \n  \n例如，你可能想要取一个联系人的信息。下面介绍怎么创建intent并处理结果:         \n\n\n```java\nprivate void pickContact() {\n    // Create an intent to \"pick\" a contact, as defined by the content provider URI\n    Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);\n    startActivityForResult(intent, PICK_CONTACT_REQUEST);\n}\n\n@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    // If the request went well (OK) and the request was PICK_CONTACT_REQUEST\n    if (resultCode == Activity.RESULT_OK && requestCode == PICK_CONTACT_REQUEST) {\n        // Perform a query to the contact's content provider for the contact's name\n        Cursor cursor = getContentResolver().query(data.getData(),\n        new String[] {Contacts.DISPLAY_NAME}, null, null, null);\n        if (cursor.moveToFirst()) { // True if the cursor is not empty\n            int columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);\n            String name = cursor.getString(columnIndex);\n            // Do something with the selected contact's name...\n        }\n    }\n}       \n\n```      \n\n\n这个例子展示了使用onActivityResult() 来获取结果的基本方法。 第一步要判断请求是否被成功响应，通过判断resultCode 是不是RESULT_OK—， 然后判断这个响应是不是针对相应的请求— ，此时只要判断requestCode 和发送时提供的第二个参数 startActivityForResult() 是否相匹配。 最后，查询 Intent中的data信息。 (data 参数)。\n\n这个过程中，ContentResolver 开启了一个查询而不是content provider, 它返回一个 Cursor ，这将允许数据被读取。更多content provider相关信息，请阅读我之后的博客[android基础之Content-Providers.md](android基础之Content-Providers.md \"android基础之Content-Providers\")。     \n\n##### 关闭activity    \n你可以通过调用finish() 来终止activity。 你也可以调用finishActivity() 来终止你之前启动了的一个独立activity。    \n\n> **注意**: 多数情况下，你不应该明确地通过这些方式来关闭acitivity。 就像下面要讨论的activity的生命周期。系统会为你管理。所以你不必关闭他们。 调用这些方法将有悖于用户体验。它们仅用于你绝对不想让用户再返回这个activity的实例。   \n\n\n### 八 Task和back stack    \n一个app通常包含多个activity，android使用task来管理这些activity。当你在手机上没点开一个app，android即为这个app创建一个task，task中有一个back stack，你多点开的activity将依次入栈或者出栈，若你的activity调用别的应用的activity，它也会被压入本activity中。（activity与back stack的关系可阅读上文的activity的启动方式，它定义了activity在back stack中的存在方式）。    \n一个app即对应一个task，若你点开一个新的app，则该新app会进入前台，而之前的会被调入后台。当android的内存不足时，后台的task则可能被销毁。    \n\n其实，activity所处的task可以通过<activity>元素的taskAffinity属性指定，taskAffinity 属性是一个字符串值，必须与<manifest> 元素定义的包名称保证唯一性，因为系统把这个包名称用于标识应用的默认 task affinity值。但是，注意，一般情况下如无必要，不要去修改taskAffinity的值。    \n### 九 总结    \n到这里，android的activity相关的知识已经介绍的差不多了，但是这其中还有很多细节需要读者自己去发现。我所说的并不全面，有些地方可能还有谬误，万不可全信，这些仅仅是我个人的理解。其实博客的功能也只是让你对一个陌生的事物知道个大概，要想最终精通还需要多写多做。这些东西你只有自己经历了，研究了它才能成为你自己的东西，否则不过是镜花水月。   \n作为一个程序员最重要的是勤劳，最后以一句话与大家共勉：慈不掌兵，义不行贾，懒不撸码。\n   \n\n","source":"_posts/android基础之activity.md","raw":"---\ntitle: android基础之activity\ndate: 2017-02-27 10:35:34\ncategories: android\ntags:\n- java\n- android\n- activity\n---\n\n### 一 Activity简介   \nactivity是android四大组件之一，用于android app的界面显示。activity中包含一个window，window中则包含包含相应的view。\n\n### 二 Activity类的层次结构    \n继承的抽象类： ContextThemeWrapper\n实现的接口： ComponentCallbacks2 KeyEvent.Callback LayoutInflater.Factory2 View.OnCreateContextMenuListener Window.Callback      \n\n```java   \njava.lang.Object   \n\tandroid.content.Context\n\t\tandroid.content.ContextWrapper\n\t\t\tandroid.content.ContextThemeWrapper\n\t\t\t\tandroid.app.Activity\n```\n\n直接子类： AccountAuthenticatorActivity, ActivityGroup, AliasActivity, ExpandableListActivity, FragmentActivity, ListActivity, NativeActivity 　　　\n间接子类： ActionBarActivity, LauncherActivity, PreferenceActivity, TabActivity 　　　\n\n### 三 Activity的生命周期   　\nActivity在它的一生中有以下四种状态：  \n- running：此时Activity处于屏幕的前台并且拥有焦点，位于回退栈的顶部（回退栈将在下面介绍）。   \n- paused： 此时另一个Activity位于前台并拥有焦点，也就是说另一个Activity覆盖在本Activity的上面，但是这个Activity是透明的或者没有占据全屏，即从屏幕上还可以看到下面的Activity（比如弹出个红包）。一个paused的activity是完全存活的（Activity 对象仍然保留在内存里，它保持着所有的状态和成员信息，并且保持与window manager的联接），但在系统内存严重不足的情况下它能被杀死。    \n- stopped： 本Activity被其他Activity完全覆盖了，看不见了。一个stopped的activity也仍然是存活的（Activity 对象仍然保留在内存中，它保持着所有的状态和成员信息，但是不再与window manager联接了）。 但是，对于用户而言它已经不再可见了，并且当其它地方需要内存时它将会被杀死。    \n- killed： 当Activity处于paused或者stopped时，若内存不足，它将可能被干掉。当它被再次创建处于前台时，需要调用onCreate方法重新创建并恢复之前的状态    \n下面是activity的生命周期图：      \n{% asset_img activity生命周期图.png activity生命周期图 %}       \n由上图可以看出activity有三种不同的生命周期：　　\n- 完整生命周期： onCreate--onDestroy    \n- 可见生命周期： onResume到onPause之间循环    \n- 前台生命周期： onStart-onStop-onRestart三者之间循环    \nActivity中的回调方法    \n\n```java\npublic class ExampleActivity extends Activity {\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        // The activity is being created.\n    }\n    @Override\n    protected void onStart() {\n        super.onStart();\n        // The activity is about to become visible.\n    }\n    @Override\n    protected void onResume() {\n        super.onResume();\n        // The activity has become visible (it is now \"resumed\").\n    }\n    @Override\n    protected void onPause() {\n        super.onPause();\n        // Another activity is taking focus (this activity is about to be \"paused\").\n    }\n    @Override\n    protected void onStop() {\n        super.onStop();\n        // The activity is no longer visible (it is now \"stopped\")\n    }\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        // The activity is about to be destroyed.\n    }\n}\n```\n \nActivity回调方法汇总：       \n{% asset_img activity回调方法汇总.png activity回调方法汇总 %}       \n标为“之后可否被杀死？”的列指明了系统是否可以在这个方法返回之后的任意时刻杀掉这个activity的宿主进程， 而不再执行其它流程上的activity代码。 有三个方法是标为“可以”：（ onPause()、 onStop()、 和onDestroy()）。 因为onPause()是三个方法中的第一个， 一旦activity被创建， onPause() 就是进程可以被杀死之前最后一个能确保被调用的方法 ——如果系统在某种紧急情况下必须回收内存，则 onStop() 和onDestroy() 可能就不会被调用了。因此，你应该使用 onPause() 来把至关重要的需长期保存的数据写入存储器（比如用户所编辑的内容）。 不过，应该对必须通过 onPause() 方法进行保存的信息有所选择，因为该方法中所有的阻塞操作都会让切换到下一个activity的停滞，并使用户感觉到迟缓。\n\n“之后可否被杀死？”列中标为“否”的方法，在它们被调用时的那一刻起，就会保护本activity的宿主进程不被杀掉。 因此，只有在 onPause() 方法返回时至 onResume() 方法被调用时之间，activity才会被杀掉。直到 onPause() 再次被调用并返回时，activity都不会再次允许被杀死。\n\nNote:表1中标明的技术上不“可杀”的activity仍然有可能会被系统杀死——但那只有在没有任何资源的极端情况下才会发生。     \n\n### 四 保存Activity的状态    \n上一节中已简单提到，当一个activity被paused或者stopped时，activity的状态可以被保存。 的确如此，因为 Activity 对象在paused或者stopped时仍然被保留在内存之中——它所有的成员信息和当前状态都仍然存活。 这样用户在activity里所作的改动全都还保存着，所以当activity返回到前台时（当它“resume“），那些改动仍然有效。\n\n不过，如果系统是为了回收内存而销毁activity，则这个 Activity 对象就会被销毁，这样系统就无法简单地resume一下就能还原完整状态的activity。 如果用户要返回到这个activity的话，系统必须重新创建这个Activity 对象。可是用户并不知道系统是先销毁activity再重新创建了它的，所以，他很可能希望activity完全保持原样。 这种情况下，你可以保证activity状态的相关重要信息都由另一个回调方法保存下来了，此方法让你能保存activity状态的相关信息： onSaveInstanceState()。\n\n在activity变得很容易被销毁之前，系统会调用 onSaveInstanceState()方法。 调用时系统会传入一个Bundle对象， 你可以利用 putString() 之类的方法，以键值对的方式来把activity状态信息保存到该Bundle对象中。 然后，如果系统杀掉了你的application进程并且用户又返回到你的activity，系统就会重建activity并将这个 Bundle 传入onCreate() 和onRestoreInstanceState() 中，你就可以从 Bundle 中解析出已保存信息并恢复activity状态。如果没有储存状态信息，那么传入的 Bundle 将为null（当activity第一次被创建时就是如此）。     \n下图是Activity状态保存示意图：      \n{% asset_img Activity状态保存示意图.png activity状态保存示意图 %}  \n### 五 配置改动后的处理   \n设备的某些配置可能会在运行时发生变化（比如屏幕方向、键盘可用性以及语言）。 当发生这些变化时，Android会重建这个运行中的activity（系统会调用 onDestroy() ，然后再马上调用 onCreate() ）。这种设计有助于应用程序适用新的参数配置，通过把你预置的可替换资源（比如对应各种屏幕方向和尺寸的layout）自动重新装载进入应用程序的方式来实现。\n\n如果你采取了适当的设计，让activity能够正确地处理这些因为屏幕方向而引起的重启，并能如上所述地恢复activity状态， 那么你的应用程序将对生命周期中其它的意外事件更具适应能力。\n\n处理这类重启的最佳方式，就是利用 onSaveInstanceState() 和onRestoreInstanceState() （或者 onCreate() ）进行状态的保存和恢复，如上节所述。   \n\n### 六 Activity的启动方式   \nantivity的启动方式可以通过两种方式定义：     \n\n##### Androidmanifest文件       \nAndroidmanifest文件是android的清单文件，android的四大组件与相应权限皆需在这里设置。在这里你可以利用 <activity> 元素的 launchMode 属性来设定 activity 与 task 的关系。       \n可通过Androidmanifest文件设置的启动模式有：      \n- standard\n- singleTop\n- singleTask\n- singleInstance       \n\n##### Intent标志     \nIntent标志中有以下几种Activity的启动方式:       \n- FLAG_ACTIVITY_NEW_TASK\n- FLAG_ACTIVITY_SINGLE_TOP\n- FLAG_ACTIVITY_CLEAR_TOP       \n通过Intent标志的方式来启动Activity，优先级比manifest的高。    \n\n> **警告**： 大多数应用不应该改变 activity 和 task 默认的工作方式。 如果你确定有必要修改默认方式，请保持\n谨慎，并确保 activity 在启动和从其它 activity 用回退键返回时的可用性。 请确保对可能与用户预期的导航方式\n相冲突的地方进行测试。      \n\n### 七 启动Activity  \n要启动一个activity需要使用Intent，实际上android中组件之前的通信皆由Intent完成（如果你不了解Intent，请看我之后的博客[android基础之Intents与Intent-Filters.md](android基础之Intents与Intent-Filters.md \"android基础之Intents与Intent-Filters\")），而使用Intent启动activity有显示和隐式两种方式。   \n\n\n##### 显示启动      \n\n     \n```java\nIntent intent = new Intent(this, SignInActivity.class);\nstartActivity(intent);//显示启动一个叫SignInActivity的Activity    \n\n```   \n\n\n\n#####  隐式启动    \n要想隐式启动一个activity，你需要使用intent-filter来暴露你的activity。使用filter有java代码和xml文件两种方式，推荐使用第二种方式，你只需在Androidmanifest.xml文件中的activit元素中加入intent-filter属性，并声明一个action即可。但是如果你想使你的activity更独立，那么就不要为你的activity设置filter。那么什么时候使用这种方式呢？    \n如果，你的程序可能想要展示某些动作，例如发邮件，短信，微博，或者使用你activity中的数据。 这时候，你就不应该使用自己的activity来做这些工作。你应该调用系统中其他程序提供的响应功能。 这是intent真正体现其价值的地方。你可以创建一个描述了响应动作的intent,然后系统来为你挑选完成任务的程序。 如果有多个选择，系统会提示用户进行选择。例如你想让用户发邮件，你可以创建下面的intent：        \n\n\n```java\nIntent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_EMAIL, recipientArray);//recipientArray即你想发送过去的联系人信息\nstartActivity(intent);    \n\n```       \n\n##### 启动一个带返回结果的Activity    \n有时候，你想要启动一个activity,并从这个activty获得一个结果。 这时，要通过 startActivityForResult() (取代startActivity()) 来启动activity。 然后通过实现onActivityResult()回调方法来获得返回后的结果。 当这个后续的activity被关闭，它将发送一个 Intent 给 onActivityResult() 方法。     \n  \n例如，你可能想要取一个联系人的信息。下面介绍怎么创建intent并处理结果:         \n\n\n```java\nprivate void pickContact() {\n    // Create an intent to \"pick\" a contact, as defined by the content provider URI\n    Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);\n    startActivityForResult(intent, PICK_CONTACT_REQUEST);\n}\n\n@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    // If the request went well (OK) and the request was PICK_CONTACT_REQUEST\n    if (resultCode == Activity.RESULT_OK && requestCode == PICK_CONTACT_REQUEST) {\n        // Perform a query to the contact's content provider for the contact's name\n        Cursor cursor = getContentResolver().query(data.getData(),\n        new String[] {Contacts.DISPLAY_NAME}, null, null, null);\n        if (cursor.moveToFirst()) { // True if the cursor is not empty\n            int columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);\n            String name = cursor.getString(columnIndex);\n            // Do something with the selected contact's name...\n        }\n    }\n}       \n\n```      \n\n\n这个例子展示了使用onActivityResult() 来获取结果的基本方法。 第一步要判断请求是否被成功响应，通过判断resultCode 是不是RESULT_OK—， 然后判断这个响应是不是针对相应的请求— ，此时只要判断requestCode 和发送时提供的第二个参数 startActivityForResult() 是否相匹配。 最后，查询 Intent中的data信息。 (data 参数)。\n\n这个过程中，ContentResolver 开启了一个查询而不是content provider, 它返回一个 Cursor ，这将允许数据被读取。更多content provider相关信息，请阅读我之后的博客[android基础之Content-Providers.md](android基础之Content-Providers.md \"android基础之Content-Providers\")。     \n\n##### 关闭activity    \n你可以通过调用finish() 来终止activity。 你也可以调用finishActivity() 来终止你之前启动了的一个独立activity。    \n\n> **注意**: 多数情况下，你不应该明确地通过这些方式来关闭acitivity。 就像下面要讨论的activity的生命周期。系统会为你管理。所以你不必关闭他们。 调用这些方法将有悖于用户体验。它们仅用于你绝对不想让用户再返回这个activity的实例。   \n\n\n### 八 Task和back stack    \n一个app通常包含多个activity，android使用task来管理这些activity。当你在手机上没点开一个app，android即为这个app创建一个task，task中有一个back stack，你多点开的activity将依次入栈或者出栈，若你的activity调用别的应用的activity，它也会被压入本activity中。（activity与back stack的关系可阅读上文的activity的启动方式，它定义了activity在back stack中的存在方式）。    \n一个app即对应一个task，若你点开一个新的app，则该新app会进入前台，而之前的会被调入后台。当android的内存不足时，后台的task则可能被销毁。    \n\n其实，activity所处的task可以通过<activity>元素的taskAffinity属性指定，taskAffinity 属性是一个字符串值，必须与<manifest> 元素定义的包名称保证唯一性，因为系统把这个包名称用于标识应用的默认 task affinity值。但是，注意，一般情况下如无必要，不要去修改taskAffinity的值。    \n### 九 总结    \n到这里，android的activity相关的知识已经介绍的差不多了，但是这其中还有很多细节需要读者自己去发现。我所说的并不全面，有些地方可能还有谬误，万不可全信，这些仅仅是我个人的理解。其实博客的功能也只是让你对一个陌生的事物知道个大概，要想最终精通还需要多写多做。这些东西你只有自己经历了，研究了它才能成为你自己的东西，否则不过是镜花水月。   \n作为一个程序员最重要的是勤劳，最后以一句话与大家共勉：慈不掌兵，义不行贾，懒不撸码。\n   \n\n","slug":"android基础之activity","published":1,"updated":"2017-03-03T07:09:28.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizz09fte0004aonzxdrgabhp","content":"<h3 id=\"一-Activity简介\"><a href=\"#一-Activity简介\" class=\"headerlink\" title=\"一 Activity简介\"></a>一 Activity简介</h3><p>activity是android四大组件之一，用于android app的界面显示。activity中包含一个window，window中则包含包含相应的view。</p>\n<h3 id=\"二-Activity类的层次结构\"><a href=\"#二-Activity类的层次结构\" class=\"headerlink\" title=\"二 Activity类的层次结构\"></a>二 Activity类的层次结构</h3><p>继承的抽象类： ContextThemeWrapper<br>实现的接口： ComponentCallbacks2 KeyEvent.Callback LayoutInflater.Factory2 View.OnCreateContextMenuListener Window.Callback      </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.lang.Object   </div><div class=\"line\">\tandroid.content.Context</div><div class=\"line\">\t\tandroid.content.ContextWrapper</div><div class=\"line\">\t\t\tandroid.content.ContextThemeWrapper</div><div class=\"line\">\t\t\t\tandroid.app.Activity</div></pre></td></tr></table></figure>\n<p>直接子类： AccountAuthenticatorActivity, ActivityGroup, AliasActivity, ExpandableListActivity, FragmentActivity, ListActivity, NativeActivity 　　　<br>间接子类： ActionBarActivity, LauncherActivity, PreferenceActivity, TabActivity 　　　</p>\n<h3 id=\"三-Activity的生命周期\"><a href=\"#三-Activity的生命周期\" class=\"headerlink\" title=\"三 Activity的生命周期   　\"></a>三 Activity的生命周期   　</h3><p>Activity在它的一生中有以下四种状态：  </p>\n<ul>\n<li>running：此时Activity处于屏幕的前台并且拥有焦点，位于回退栈的顶部（回退栈将在下面介绍）。   </li>\n<li>paused： 此时另一个Activity位于前台并拥有焦点，也就是说另一个Activity覆盖在本Activity的上面，但是这个Activity是透明的或者没有占据全屏，即从屏幕上还可以看到下面的Activity（比如弹出个红包）。一个paused的activity是完全存活的（Activity 对象仍然保留在内存里，它保持着所有的状态和成员信息，并且保持与window manager的联接），但在系统内存严重不足的情况下它能被杀死。    </li>\n<li>stopped： 本Activity被其他Activity完全覆盖了，看不见了。一个stopped的activity也仍然是存活的（Activity 对象仍然保留在内存中，它保持着所有的状态和成员信息，但是不再与window manager联接了）。 但是，对于用户而言它已经不再可见了，并且当其它地方需要内存时它将会被杀死。    </li>\n<li>killed： 当Activity处于paused或者stopped时，若内存不足，它将可能被干掉。当它被再次创建处于前台时，需要调用onCreate方法重新创建并恢复之前的状态<br>下面是activity的生命周期图：      <img src=\"/2017/02/27/android基础之activity/activity生命周期图.png\" alt=\"activity生命周期图\" title=\"activity生命周期图\">       \n由上图可以看出activity有三种不同的生命周期：　　</li>\n<li>完整生命周期： onCreate–onDestroy    </li>\n<li>可见生命周期： onResume到onPause之间循环    </li>\n<li>前台生命周期： onStart-onStop-onRestart三者之间循环<br>Activity中的回调方法    </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        <span class=\"comment\">// The activity is being created.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onStart();</div><div class=\"line\">        <span class=\"comment\">// The activity is about to become visible.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onResume();</div><div class=\"line\">        <span class=\"comment\">// The activity has become visible (it is now \"resumed\").</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onPause();</div><div class=\"line\">        <span class=\"comment\">// Another activity is taking focus (this activity is about to be \"paused\").</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onStop();</div><div class=\"line\">        <span class=\"comment\">// The activity is no longer visible (it is now \"stopped\")</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</div><div class=\"line\">        <span class=\"comment\">// The activity is about to be destroyed.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Activity回调方法汇总：<br><img src=\"/2017/02/27/android基础之activity/activity回调方法汇总.png\" alt=\"activity回调方法汇总\" title=\"activity回调方法汇总\"><br>标为“之后可否被杀死？”的列指明了系统是否可以在这个方法返回之后的任意时刻杀掉这个activity的宿主进程， 而不再执行其它流程上的activity代码。 有三个方法是标为“可以”：（ onPause()、 onStop()、 和onDestroy()）。 因为onPause()是三个方法中的第一个， 一旦activity被创建， onPause() 就是进程可以被杀死之前最后一个能确保被调用的方法 ——如果系统在某种紧急情况下必须回收内存，则 onStop() 和onDestroy() 可能就不会被调用了。因此，你应该使用 onPause() 来把至关重要的需长期保存的数据写入存储器（比如用户所编辑的内容）。 不过，应该对必须通过 onPause() 方法进行保存的信息有所选择，因为该方法中所有的阻塞操作都会让切换到下一个activity的停滞，并使用户感觉到迟缓。</p>\n<p>“之后可否被杀死？”列中标为“否”的方法，在它们被调用时的那一刻起，就会保护本activity的宿主进程不被杀掉。 因此，只有在 onPause() 方法返回时至 onResume() 方法被调用时之间，activity才会被杀掉。直到 onPause() 再次被调用并返回时，activity都不会再次允许被杀死。</p>\n<p>Note:表1中标明的技术上不“可杀”的activity仍然有可能会被系统杀死——但那只有在没有任何资源的极端情况下才会发生。     </p>\n<h3 id=\"四-保存Activity的状态\"><a href=\"#四-保存Activity的状态\" class=\"headerlink\" title=\"四 保存Activity的状态\"></a>四 保存Activity的状态</h3><p>上一节中已简单提到，当一个activity被paused或者stopped时，activity的状态可以被保存。 的确如此，因为 Activity 对象在paused或者stopped时仍然被保留在内存之中——它所有的成员信息和当前状态都仍然存活。 这样用户在activity里所作的改动全都还保存着，所以当activity返回到前台时（当它“resume“），那些改动仍然有效。</p>\n<p>不过，如果系统是为了回收内存而销毁activity，则这个 Activity 对象就会被销毁，这样系统就无法简单地resume一下就能还原完整状态的activity。 如果用户要返回到这个activity的话，系统必须重新创建这个Activity 对象。可是用户并不知道系统是先销毁activity再重新创建了它的，所以，他很可能希望activity完全保持原样。 这种情况下，你可以保证activity状态的相关重要信息都由另一个回调方法保存下来了，此方法让你能保存activity状态的相关信息： onSaveInstanceState()。</p>\n<p>在activity变得很容易被销毁之前，系统会调用 onSaveInstanceState()方法。 调用时系统会传入一个Bundle对象， 你可以利用 putString() 之类的方法，以键值对的方式来把activity状态信息保存到该Bundle对象中。 然后，如果系统杀掉了你的application进程并且用户又返回到你的activity，系统就会重建activity并将这个 Bundle 传入onCreate() 和onRestoreInstanceState() 中，你就可以从 Bundle 中解析出已保存信息并恢复activity状态。如果没有储存状态信息，那么传入的 Bundle 将为null（当activity第一次被创建时就是如此）。<br>下图是Activity状态保存示意图：<br><img src=\"/2017/02/27/android基础之activity/Activity状态保存示意图.png\" alt=\"activity状态保存示意图\" title=\"activity状态保存示意图\">  </p>\n<h3 id=\"五-配置改动后的处理\"><a href=\"#五-配置改动后的处理\" class=\"headerlink\" title=\"五 配置改动后的处理\"></a>五 配置改动后的处理</h3><p>设备的某些配置可能会在运行时发生变化（比如屏幕方向、键盘可用性以及语言）。 当发生这些变化时，Android会重建这个运行中的activity（系统会调用 onDestroy() ，然后再马上调用 onCreate() ）。这种设计有助于应用程序适用新的参数配置，通过把你预置的可替换资源（比如对应各种屏幕方向和尺寸的layout）自动重新装载进入应用程序的方式来实现。</p>\n<p>如果你采取了适当的设计，让activity能够正确地处理这些因为屏幕方向而引起的重启，并能如上所述地恢复activity状态， 那么你的应用程序将对生命周期中其它的意外事件更具适应能力。</p>\n<p>处理这类重启的最佳方式，就是利用 onSaveInstanceState() 和onRestoreInstanceState() （或者 onCreate() ）进行状态的保存和恢复，如上节所述。   </p>\n<h3 id=\"六-Activity的启动方式\"><a href=\"#六-Activity的启动方式\" class=\"headerlink\" title=\"六 Activity的启动方式\"></a>六 Activity的启动方式</h3><p>antivity的启动方式可以通过两种方式定义：     </p>\n<h5 id=\"Androidmanifest文件\"><a href=\"#Androidmanifest文件\" class=\"headerlink\" title=\"Androidmanifest文件\"></a>Androidmanifest文件</h5><p>Androidmanifest文件是android的清单文件，android的四大组件与相应权限皆需在这里设置。在这里你可以利用 <activity> 元素的 launchMode 属性来设定 activity 与 task 的关系。<br>可通过Androidmanifest文件设置的启动模式有：      </activity></p>\n<ul>\n<li>standard</li>\n<li>singleTop</li>\n<li>singleTask</li>\n<li>singleInstance       </li>\n</ul>\n<h5 id=\"Intent标志\"><a href=\"#Intent标志\" class=\"headerlink\" title=\"Intent标志\"></a>Intent标志</h5><p>Intent标志中有以下几种Activity的启动方式:       </p>\n<ul>\n<li>FLAG_ACTIVITY_NEW_TASK</li>\n<li>FLAG_ACTIVITY_SINGLE_TOP</li>\n<li>FLAG_ACTIVITY_CLEAR_TOP<br>通过Intent标志的方式来启动Activity，优先级比manifest的高。    </li>\n</ul>\n<blockquote>\n<p><strong>警告</strong>： 大多数应用不应该改变 activity 和 task 默认的工作方式。 如果你确定有必要修改默认方式，请保持<br>谨慎，并确保 activity 在启动和从其它 activity 用回退键返回时的可用性。 请确保对可能与用户预期的导航方式<br>相冲突的地方进行测试。      </p>\n</blockquote>\n<h3 id=\"七-启动Activity\"><a href=\"#七-启动Activity\" class=\"headerlink\" title=\"七 启动Activity\"></a>七 启动Activity</h3><p>要启动一个activity需要使用Intent，实际上android中组件之前的通信皆由Intent完成（如果你不了解Intent，请看我之后的博客<a href=\"android基础之Intents与Intent-Filters.md\" title=\"android基础之Intents与Intent-Filters\">android基础之Intents与Intent-Filters.md</a>），而使用Intent启动activity有显示和隐式两种方式。   </p>\n<h5 id=\"显示启动\"><a href=\"#显示启动\" class=\"headerlink\" title=\"显示启动\"></a>显示启动</h5><pre><code class=\"java\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, SignInActivity.class);\nstartActivity(intent);<span class=\"comment\">//显示启动一个叫SignInActivity的Activity</span>\n</code></pre>\n<h5 id=\"隐式启动\"><a href=\"#隐式启动\" class=\"headerlink\" title=\"隐式启动\"></a>隐式启动</h5><p>要想隐式启动一个activity，你需要使用intent-filter来暴露你的activity。使用filter有java代码和xml文件两种方式，推荐使用第二种方式，你只需在Androidmanifest.xml文件中的activit元素中加入intent-filter属性，并声明一个action即可。但是如果你想使你的activity更独立，那么就不要为你的activity设置filter。那么什么时候使用这种方式呢？<br>如果，你的程序可能想要展示某些动作，例如发邮件，短信，微博，或者使用你activity中的数据。 这时候，你就不应该使用自己的activity来做这些工作。你应该调用系统中其他程序提供的响应功能。 这是intent真正体现其价值的地方。你可以创建一个描述了响应动作的intent,然后系统来为你挑选完成任务的程序。 如果有多个选择，系统会提示用户进行选择。例如你想让用户发邮件，你可以创建下面的intent：        </p>\n<pre><code class=\"java\">Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_EMAIL, recipientArray);<span class=\"comment\">//recipientArray即你想发送过去的联系人信息</span>\nstartActivity(intent);\n</code></pre>\n<h5 id=\"启动一个带返回结果的Activity\"><a href=\"#启动一个带返回结果的Activity\" class=\"headerlink\" title=\"启动一个带返回结果的Activity\"></a>启动一个带返回结果的Activity</h5><p>有时候，你想要启动一个activity,并从这个activty获得一个结果。 这时，要通过 startActivityForResult() (取代startActivity()) 来启动activity。 然后通过实现onActivityResult()回调方法来获得返回后的结果。 当这个后续的activity被关闭，它将发送一个 Intent 给 onActivityResult() 方法。     </p>\n<p>例如，你可能想要取一个联系人的信息。下面介绍怎么创建intent并处理结果:         </p>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">pickContact</span><span class=\"params\">()</span> </span>{\n    <span class=\"comment\">// Create an intent to \"pick\" a contact, as defined by the content provider URI</span>\n    Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);\n    startActivityForResult(intent, PICK_CONTACT_REQUEST);\n}\n\n<span class=\"meta\">@Override</span>\n<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> resultCode, Intent data)</span> </span>{\n    <span class=\"comment\">// If the request went well (OK) and the request was PICK_CONTACT_REQUEST</span>\n    <span class=\"keyword\">if</span> (resultCode == Activity.RESULT_OK &amp;&amp; requestCode == PICK_CONTACT_REQUEST) {\n        <span class=\"comment\">// Perform a query to the contact's content provider for the contact's name</span>\n        Cursor cursor = getContentResolver().query(data.getData(),\n        <span class=\"keyword\">new</span> String[] {Contacts.DISPLAY_NAME}, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);\n        <span class=\"keyword\">if</span> (cursor.moveToFirst()) { <span class=\"comment\">// True if the cursor is not empty</span>\n            <span class=\"keyword\">int</span> columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);\n            String name = cursor.getString(columnIndex);\n            <span class=\"comment\">// Do something with the selected contact's name...</span>\n        }\n    }\n}\n</code></pre>\n<p>这个例子展示了使用onActivityResult() 来获取结果的基本方法。 第一步要判断请求是否被成功响应，通过判断resultCode 是不是RESULT_OK—， 然后判断这个响应是不是针对相应的请求— ，此时只要判断requestCode 和发送时提供的第二个参数 startActivityForResult() 是否相匹配。 最后，查询 Intent中的data信息。 (data 参数)。</p>\n<p>这个过程中，ContentResolver 开启了一个查询而不是content provider, 它返回一个 Cursor ，这将允许数据被读取。更多content provider相关信息，请阅读我之后的博客<a href=\"android基础之Content-Providers.md\" title=\"android基础之Content-Providers\">android基础之Content-Providers.md</a>。     </p>\n<h5 id=\"关闭activity\"><a href=\"#关闭activity\" class=\"headerlink\" title=\"关闭activity\"></a>关闭activity</h5><p>你可以通过调用finish() 来终止activity。 你也可以调用finishActivity() 来终止你之前启动了的一个独立activity。    </p>\n<blockquote>\n<p><strong>注意</strong>: 多数情况下，你不应该明确地通过这些方式来关闭acitivity。 就像下面要讨论的activity的生命周期。系统会为你管理。所以你不必关闭他们。 调用这些方法将有悖于用户体验。它们仅用于你绝对不想让用户再返回这个activity的实例。   </p>\n</blockquote>\n<h3 id=\"八-Task和back-stack\"><a href=\"#八-Task和back-stack\" class=\"headerlink\" title=\"八 Task和back stack\"></a>八 Task和back stack</h3><p>一个app通常包含多个activity，android使用task来管理这些activity。当你在手机上没点开一个app，android即为这个app创建一个task，task中有一个back stack，你多点开的activity将依次入栈或者出栈，若你的activity调用别的应用的activity，它也会被压入本activity中。（activity与back stack的关系可阅读上文的activity的启动方式，它定义了activity在back stack中的存在方式）。<br>一个app即对应一个task，若你点开一个新的app，则该新app会进入前台，而之前的会被调入后台。当android的内存不足时，后台的task则可能被销毁。    </p>\n<p>其实，activity所处的task可以通过<activity>元素的taskAffinity属性指定，taskAffinity 属性是一个字符串值，必须与<manifest> 元素定义的包名称保证唯一性，因为系统把这个包名称用于标识应用的默认 task affinity值。但是，注意，一般情况下如无必要，不要去修改taskAffinity的值。    </manifest></activity></p>\n<h3 id=\"九-总结\"><a href=\"#九-总结\" class=\"headerlink\" title=\"九 总结\"></a>九 总结</h3><p>到这里，android的activity相关的知识已经介绍的差不多了，但是这其中还有很多细节需要读者自己去发现。我所说的并不全面，有些地方可能还有谬误，万不可全信，这些仅仅是我个人的理解。其实博客的功能也只是让你对一个陌生的事物知道个大概，要想最终精通还需要多写多做。这些东西你只有自己经历了，研究了它才能成为你自己的东西，否则不过是镜花水月。<br>作为一个程序员最重要的是勤劳，最后以一句话与大家共勉：慈不掌兵，义不行贾，懒不撸码。</p>\n","excerpt":"","more":"<h3 id=\"一-Activity简介\"><a href=\"#一-Activity简介\" class=\"headerlink\" title=\"一 Activity简介\"></a>一 Activity简介</h3><p>activity是android四大组件之一，用于android app的界面显示。activity中包含一个window，window中则包含包含相应的view。</p>\n<h3 id=\"二-Activity类的层次结构\"><a href=\"#二-Activity类的层次结构\" class=\"headerlink\" title=\"二 Activity类的层次结构\"></a>二 Activity类的层次结构</h3><p>继承的抽象类： ContextThemeWrapper<br>实现的接口： ComponentCallbacks2 KeyEvent.Callback LayoutInflater.Factory2 View.OnCreateContextMenuListener Window.Callback      </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.lang.Object   </div><div class=\"line\">\tandroid.content.Context</div><div class=\"line\">\t\tandroid.content.ContextWrapper</div><div class=\"line\">\t\t\tandroid.content.ContextThemeWrapper</div><div class=\"line\">\t\t\t\tandroid.app.Activity</div></pre></td></tr></table></figure>\n<p>直接子类： AccountAuthenticatorActivity, ActivityGroup, AliasActivity, ExpandableListActivity, FragmentActivity, ListActivity, NativeActivity 　　　<br>间接子类： ActionBarActivity, LauncherActivity, PreferenceActivity, TabActivity 　　　</p>\n<h3 id=\"三-Activity的生命周期\"><a href=\"#三-Activity的生命周期\" class=\"headerlink\" title=\"三 Activity的生命周期   　\"></a>三 Activity的生命周期   　</h3><p>Activity在它的一生中有以下四种状态：  </p>\n<ul>\n<li>running：此时Activity处于屏幕的前台并且拥有焦点，位于回退栈的顶部（回退栈将在下面介绍）。   </li>\n<li>paused： 此时另一个Activity位于前台并拥有焦点，也就是说另一个Activity覆盖在本Activity的上面，但是这个Activity是透明的或者没有占据全屏，即从屏幕上还可以看到下面的Activity（比如弹出个红包）。一个paused的activity是完全存活的（Activity 对象仍然保留在内存里，它保持着所有的状态和成员信息，并且保持与window manager的联接），但在系统内存严重不足的情况下它能被杀死。    </li>\n<li>stopped： 本Activity被其他Activity完全覆盖了，看不见了。一个stopped的activity也仍然是存活的（Activity 对象仍然保留在内存中，它保持着所有的状态和成员信息，但是不再与window manager联接了）。 但是，对于用户而言它已经不再可见了，并且当其它地方需要内存时它将会被杀死。    </li>\n<li>killed： 当Activity处于paused或者stopped时，若内存不足，它将可能被干掉。当它被再次创建处于前台时，需要调用onCreate方法重新创建并恢复之前的状态<br>下面是activity的生命周期图：      <img src=\"/2017/02/27/android基础之activity/activity生命周期图.png\" alt=\"activity生命周期图\" title=\"activity生命周期图\">       \n由上图可以看出activity有三种不同的生命周期：　　</li>\n<li>完整生命周期： onCreate–onDestroy    </li>\n<li>可见生命周期： onResume到onPause之间循环    </li>\n<li>前台生命周期： onStart-onStop-onRestart三者之间循环<br>Activity中的回调方法    </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        <span class=\"comment\">// The activity is being created.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onStart();</div><div class=\"line\">        <span class=\"comment\">// The activity is about to become visible.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onResume();</div><div class=\"line\">        <span class=\"comment\">// The activity has become visible (it is now \"resumed\").</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onPause();</div><div class=\"line\">        <span class=\"comment\">// Another activity is taking focus (this activity is about to be \"paused\").</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onStop();</div><div class=\"line\">        <span class=\"comment\">// The activity is no longer visible (it is now \"stopped\")</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</div><div class=\"line\">        <span class=\"comment\">// The activity is about to be destroyed.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Activity回调方法汇总：<br><img src=\"/2017/02/27/android基础之activity/activity回调方法汇总.png\" alt=\"activity回调方法汇总\" title=\"activity回调方法汇总\"><br>标为“之后可否被杀死？”的列指明了系统是否可以在这个方法返回之后的任意时刻杀掉这个activity的宿主进程， 而不再执行其它流程上的activity代码。 有三个方法是标为“可以”：（ onPause()、 onStop()、 和onDestroy()）。 因为onPause()是三个方法中的第一个， 一旦activity被创建， onPause() 就是进程可以被杀死之前最后一个能确保被调用的方法 ——如果系统在某种紧急情况下必须回收内存，则 onStop() 和onDestroy() 可能就不会被调用了。因此，你应该使用 onPause() 来把至关重要的需长期保存的数据写入存储器（比如用户所编辑的内容）。 不过，应该对必须通过 onPause() 方法进行保存的信息有所选择，因为该方法中所有的阻塞操作都会让切换到下一个activity的停滞，并使用户感觉到迟缓。</p>\n<p>“之后可否被杀死？”列中标为“否”的方法，在它们被调用时的那一刻起，就会保护本activity的宿主进程不被杀掉。 因此，只有在 onPause() 方法返回时至 onResume() 方法被调用时之间，activity才会被杀掉。直到 onPause() 再次被调用并返回时，activity都不会再次允许被杀死。</p>\n<p>Note:表1中标明的技术上不“可杀”的activity仍然有可能会被系统杀死——但那只有在没有任何资源的极端情况下才会发生。     </p>\n<h3 id=\"四-保存Activity的状态\"><a href=\"#四-保存Activity的状态\" class=\"headerlink\" title=\"四 保存Activity的状态\"></a>四 保存Activity的状态</h3><p>上一节中已简单提到，当一个activity被paused或者stopped时，activity的状态可以被保存。 的确如此，因为 Activity 对象在paused或者stopped时仍然被保留在内存之中——它所有的成员信息和当前状态都仍然存活。 这样用户在activity里所作的改动全都还保存着，所以当activity返回到前台时（当它“resume“），那些改动仍然有效。</p>\n<p>不过，如果系统是为了回收内存而销毁activity，则这个 Activity 对象就会被销毁，这样系统就无法简单地resume一下就能还原完整状态的activity。 如果用户要返回到这个activity的话，系统必须重新创建这个Activity 对象。可是用户并不知道系统是先销毁activity再重新创建了它的，所以，他很可能希望activity完全保持原样。 这种情况下，你可以保证activity状态的相关重要信息都由另一个回调方法保存下来了，此方法让你能保存activity状态的相关信息： onSaveInstanceState()。</p>\n<p>在activity变得很容易被销毁之前，系统会调用 onSaveInstanceState()方法。 调用时系统会传入一个Bundle对象， 你可以利用 putString() 之类的方法，以键值对的方式来把activity状态信息保存到该Bundle对象中。 然后，如果系统杀掉了你的application进程并且用户又返回到你的activity，系统就会重建activity并将这个 Bundle 传入onCreate() 和onRestoreInstanceState() 中，你就可以从 Bundle 中解析出已保存信息并恢复activity状态。如果没有储存状态信息，那么传入的 Bundle 将为null（当activity第一次被创建时就是如此）。<br>下图是Activity状态保存示意图：<br><img src=\"/2017/02/27/android基础之activity/Activity状态保存示意图.png\" alt=\"activity状态保存示意图\" title=\"activity状态保存示意图\">  </p>\n<h3 id=\"五-配置改动后的处理\"><a href=\"#五-配置改动后的处理\" class=\"headerlink\" title=\"五 配置改动后的处理\"></a>五 配置改动后的处理</h3><p>设备的某些配置可能会在运行时发生变化（比如屏幕方向、键盘可用性以及语言）。 当发生这些变化时，Android会重建这个运行中的activity（系统会调用 onDestroy() ，然后再马上调用 onCreate() ）。这种设计有助于应用程序适用新的参数配置，通过把你预置的可替换资源（比如对应各种屏幕方向和尺寸的layout）自动重新装载进入应用程序的方式来实现。</p>\n<p>如果你采取了适当的设计，让activity能够正确地处理这些因为屏幕方向而引起的重启，并能如上所述地恢复activity状态， 那么你的应用程序将对生命周期中其它的意外事件更具适应能力。</p>\n<p>处理这类重启的最佳方式，就是利用 onSaveInstanceState() 和onRestoreInstanceState() （或者 onCreate() ）进行状态的保存和恢复，如上节所述。   </p>\n<h3 id=\"六-Activity的启动方式\"><a href=\"#六-Activity的启动方式\" class=\"headerlink\" title=\"六 Activity的启动方式\"></a>六 Activity的启动方式</h3><p>antivity的启动方式可以通过两种方式定义：     </p>\n<h5 id=\"Androidmanifest文件\"><a href=\"#Androidmanifest文件\" class=\"headerlink\" title=\"Androidmanifest文件\"></a>Androidmanifest文件</h5><p>Androidmanifest文件是android的清单文件，android的四大组件与相应权限皆需在这里设置。在这里你可以利用 <activity> 元素的 launchMode 属性来设定 activity 与 task 的关系。<br>可通过Androidmanifest文件设置的启动模式有：      </p>\n<ul>\n<li>standard</li>\n<li>singleTop</li>\n<li>singleTask</li>\n<li>singleInstance       </li>\n</ul>\n<h5 id=\"Intent标志\"><a href=\"#Intent标志\" class=\"headerlink\" title=\"Intent标志\"></a>Intent标志</h5><p>Intent标志中有以下几种Activity的启动方式:       </p>\n<ul>\n<li>FLAG_ACTIVITY_NEW_TASK</li>\n<li>FLAG_ACTIVITY_SINGLE_TOP</li>\n<li>FLAG_ACTIVITY_CLEAR_TOP<br>通过Intent标志的方式来启动Activity，优先级比manifest的高。    </li>\n</ul>\n<blockquote>\n<p><strong>警告</strong>： 大多数应用不应该改变 activity 和 task 默认的工作方式。 如果你确定有必要修改默认方式，请保持<br>谨慎，并确保 activity 在启动和从其它 activity 用回退键返回时的可用性。 请确保对可能与用户预期的导航方式<br>相冲突的地方进行测试。      </p>\n</blockquote>\n<h3 id=\"七-启动Activity\"><a href=\"#七-启动Activity\" class=\"headerlink\" title=\"七 启动Activity\"></a>七 启动Activity</h3><p>要启动一个activity需要使用Intent，实际上android中组件之前的通信皆由Intent完成（如果你不了解Intent，请看我之后的博客<a href=\"android基础之Intents与Intent-Filters.md\" title=\"android基础之Intents与Intent-Filters\">android基础之Intents与Intent-Filters.md</a>），而使用Intent启动activity有显示和隐式两种方式。   </p>\n<h5 id=\"显示启动\"><a href=\"#显示启动\" class=\"headerlink\" title=\"显示启动\"></a>显示启动</h5><pre><code class=\"java\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, SignInActivity.class);\nstartActivity(intent);<span class=\"comment\">//显示启动一个叫SignInActivity的Activity</span>\n</code></pre>\n<h5 id=\"隐式启动\"><a href=\"#隐式启动\" class=\"headerlink\" title=\"隐式启动\"></a>隐式启动</h5><p>要想隐式启动一个activity，你需要使用intent-filter来暴露你的activity。使用filter有java代码和xml文件两种方式，推荐使用第二种方式，你只需在Androidmanifest.xml文件中的activit元素中加入intent-filter属性，并声明一个action即可。但是如果你想使你的activity更独立，那么就不要为你的activity设置filter。那么什么时候使用这种方式呢？<br>如果，你的程序可能想要展示某些动作，例如发邮件，短信，微博，或者使用你activity中的数据。 这时候，你就不应该使用自己的activity来做这些工作。你应该调用系统中其他程序提供的响应功能。 这是intent真正体现其价值的地方。你可以创建一个描述了响应动作的intent,然后系统来为你挑选完成任务的程序。 如果有多个选择，系统会提示用户进行选择。例如你想让用户发邮件，你可以创建下面的intent：        </p>\n<pre><code class=\"java\">Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_EMAIL, recipientArray);<span class=\"comment\">//recipientArray即你想发送过去的联系人信息</span>\nstartActivity(intent);\n</code></pre>\n<h5 id=\"启动一个带返回结果的Activity\"><a href=\"#启动一个带返回结果的Activity\" class=\"headerlink\" title=\"启动一个带返回结果的Activity\"></a>启动一个带返回结果的Activity</h5><p>有时候，你想要启动一个activity,并从这个activty获得一个结果。 这时，要通过 startActivityForResult() (取代startActivity()) 来启动activity。 然后通过实现onActivityResult()回调方法来获得返回后的结果。 当这个后续的activity被关闭，它将发送一个 Intent 给 onActivityResult() 方法。     </p>\n<p>例如，你可能想要取一个联系人的信息。下面介绍怎么创建intent并处理结果:         </p>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">pickContact</span><span class=\"params\">()</span> </span>{\n    <span class=\"comment\">// Create an intent to \"pick\" a contact, as defined by the content provider URI</span>\n    Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);\n    startActivityForResult(intent, PICK_CONTACT_REQUEST);\n}\n\n<span class=\"meta\">@Override</span>\n<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> resultCode, Intent data)</span> </span>{\n    <span class=\"comment\">// If the request went well (OK) and the request was PICK_CONTACT_REQUEST</span>\n    <span class=\"keyword\">if</span> (resultCode == Activity.RESULT_OK &amp;&amp; requestCode == PICK_CONTACT_REQUEST) {\n        <span class=\"comment\">// Perform a query to the contact's content provider for the contact's name</span>\n        Cursor cursor = getContentResolver().query(data.getData(),\n        <span class=\"keyword\">new</span> String[] {Contacts.DISPLAY_NAME}, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);\n        <span class=\"keyword\">if</span> (cursor.moveToFirst()) { <span class=\"comment\">// True if the cursor is not empty</span>\n            <span class=\"keyword\">int</span> columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);\n            String name = cursor.getString(columnIndex);\n            <span class=\"comment\">// Do something with the selected contact's name...</span>\n        }\n    }\n}\n</code></pre>\n<p>这个例子展示了使用onActivityResult() 来获取结果的基本方法。 第一步要判断请求是否被成功响应，通过判断resultCode 是不是RESULT_OK—， 然后判断这个响应是不是针对相应的请求— ，此时只要判断requestCode 和发送时提供的第二个参数 startActivityForResult() 是否相匹配。 最后，查询 Intent中的data信息。 (data 参数)。</p>\n<p>这个过程中，ContentResolver 开启了一个查询而不是content provider, 它返回一个 Cursor ，这将允许数据被读取。更多content provider相关信息，请阅读我之后的博客<a href=\"android基础之Content-Providers.md\" title=\"android基础之Content-Providers\">android基础之Content-Providers.md</a>。     </p>\n<h5 id=\"关闭activity\"><a href=\"#关闭activity\" class=\"headerlink\" title=\"关闭activity\"></a>关闭activity</h5><p>你可以通过调用finish() 来终止activity。 你也可以调用finishActivity() 来终止你之前启动了的一个独立activity。    </p>\n<blockquote>\n<p><strong>注意</strong>: 多数情况下，你不应该明确地通过这些方式来关闭acitivity。 就像下面要讨论的activity的生命周期。系统会为你管理。所以你不必关闭他们。 调用这些方法将有悖于用户体验。它们仅用于你绝对不想让用户再返回这个activity的实例。   </p>\n</blockquote>\n<h3 id=\"八-Task和back-stack\"><a href=\"#八-Task和back-stack\" class=\"headerlink\" title=\"八 Task和back stack\"></a>八 Task和back stack</h3><p>一个app通常包含多个activity，android使用task来管理这些activity。当你在手机上没点开一个app，android即为这个app创建一个task，task中有一个back stack，你多点开的activity将依次入栈或者出栈，若你的activity调用别的应用的activity，它也会被压入本activity中。（activity与back stack的关系可阅读上文的activity的启动方式，它定义了activity在back stack中的存在方式）。<br>一个app即对应一个task，若你点开一个新的app，则该新app会进入前台，而之前的会被调入后台。当android的内存不足时，后台的task则可能被销毁。    </p>\n<p>其实，activity所处的task可以通过<activity>元素的taskAffinity属性指定，taskAffinity 属性是一个字符串值，必须与<manifest> 元素定义的包名称保证唯一性，因为系统把这个包名称用于标识应用的默认 task affinity值。但是，注意，一般情况下如无必要，不要去修改taskAffinity的值。    </p>\n<h3 id=\"九-总结\"><a href=\"#九-总结\" class=\"headerlink\" title=\"九 总结\"></a>九 总结</h3><p>到这里，android的activity相关的知识已经介绍的差不多了，但是这其中还有很多细节需要读者自己去发现。我所说的并不全面，有些地方可能还有谬误，万不可全信，这些仅仅是我个人的理解。其实博客的功能也只是让你对一个陌生的事物知道个大概，要想最终精通还需要多写多做。这些东西你只有自己经历了，研究了它才能成为你自己的东西，否则不过是镜花水月。<br>作为一个程序员最重要的是勤劳，最后以一句话与大家共勉：慈不掌兵，义不行贾，懒不撸码。</p>\n"},{"title":"android基础之SQLite","date":"2017-02-28T10:03:32.000Z","_content":"","source":"_posts/android基础之SQLite.md","raw":"---\ntitle: android基础之SQLite\ndate: 2017-02-28 18:03:32\ncategories:\ntags:\n---\n","slug":"android基础之SQLite","published":1,"updated":"2017-02-28T10:03:32.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizz09ftp0007aonz3zdeqxg0","content":"","excerpt":"","more":""},{"title":"android基础之loaders","date":"2017-02-27T06:39:21.000Z","_content":"","source":"_posts/android基础之loaders.md","raw":"---\ntitle: android基础之loaders\ndate: 2017-02-27 14:39:21\ncategories:\ntags:\n---\n","slug":"android基础之loaders","published":1,"updated":"2017-02-27T06:39:22.007Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizz09ftr0008aonznyywjc3j","content":"","excerpt":"","more":""},{"title":"android基础之数据存储","date":"2017-02-28T09:42:52.000Z","_content":"","source":"_posts/android基础之数据存储.md","raw":"---\ntitle: android基础之数据存储\ndate: 2017-02-28 17:42:52\ncategories:\ntags:\n---\n","slug":"android基础之数据存储","published":1,"updated":"2017-02-28T09:42:52.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizz09fts0009aonzkx2uffyk","content":"","excerpt":"","more":""},{"title":"android基础之Handler与AsycTask","date":"2017-02-27T06:47:53.000Z","_content":"","source":"_posts/android基础之Handler与AsycTask.md","raw":"---\ntitle: android基础之Handler与AsycTask\ndate: 2017-02-27 14:47:53\ncategories:\ntags:\n---\n","slug":"android基础之Handler与AsycTask","published":1,"updated":"2017-02-27T06:47:53.910Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizz09ftv000caonzblin6tf7","content":"","excerpt":"","more":""},{"title":"android基础之消息推送","date":"2017-03-01T06:28:10.000Z","_content":"","source":"_posts/android基础之消息推送.md","raw":"---\ntitle: android基础之消息推送\ndate: 2017-03-01 14:28:10\ncategories:\ntags:\n---\n","slug":"android基础之消息推送","published":1,"updated":"2017-03-01T06:28:10.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizz09fty000eaonzuuin9eey","content":"","excerpt":"","more":""},{"title":"android基础之事件分发机制","date":"2017-02-28T10:25:28.000Z","_content":"","source":"_posts/android基础之事件分发机制.md","raw":"---\ntitle: android基础之事件分发机制\ndate: 2017-02-28 18:25:28\ncategories:\ntags:\n---\n","slug":"android基础之事件分发机制","published":1,"updated":"2017-02-28T10:25:28.020Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizz09fu0000gaonzr25wl8n1","content":"","excerpt":"","more":""},{"title":"android基础之进程间通信","date":"2017-02-28T10:00:00.000Z","_content":"","source":"_posts/android基础之进程间通信.md","raw":"---\ntitle: android基础之进程间通信\ndate: 2017-02-28 18:00:00\ncategories:\ntags:\n---\n","slug":"android基础之进程间通信","published":1,"updated":"2017-02-28T10:00:00.191Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizz09fu3000iaonzvdx73afz","content":"","excerpt":"","more":""},{"title":"android基础之自定义View与ViewGroup","date":"2017-02-28T08:02:37.000Z","_content":"","source":"_posts/android基础之自定义View与ViewGroup.md","raw":"---\ntitle: android基础之自定义View与ViewGroup\ndate: 2017-02-28 16:02:37\ncategories:\ntags:\n---\n","slug":"android基础之自定义View与ViewGroup","published":1,"updated":"2017-02-28T08:02:37.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizz09fu5000kaonzur339xvr","content":"","excerpt":"","more":""},{"title":"android基础之缓存","date":"2017-02-28T09:10:22.000Z","_content":"","source":"_posts/android基础之缓存.md","raw":"---\ntitle: android基础之缓存\ndate: 2017-02-28 17:10:22\ncategories:\ntags:\n---\n","slug":"android基础之缓存","published":1,"updated":"2017-02-28T09:10:22.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizz09fu7000maonziqma1jfx","content":"","excerpt":"","more":""},{"title":"hexo搭建博客指南（一）--建站","date":"2017-02-16T07:08:29.000Z","_content":"### 一 hexo简介   \n\n> hexo是一款快速，高效，简洁的博客框架。\n\n### 二 搭建博客   \n\n#### 2.1 安装环境\n\n&emsp;&emsp;hexo是基于node.js的，因此要想使用hexo，必须安装node环境，同时还需要git，用于将hexo部署到github上。所需软件：  \nnode.js &emsp;&emsp;下载链接：[http://nodejs.cn/download/](http://nodejs.cn/download/)  \ngit &emsp;&emsp;&emsp;&emsp;下载链接：[https://git-for-windows.github.io/](https://git-for-windows.github.io/)  \n\n\n下载后直接安装，完成后打开windows的cmd，输入以下命令：  \n\n``` bash\nnode -v    \nnpm -v \n```        \n\n当出现以下信息时，则说明安装成功。    \n   \n``` bash\nzhengrui-ds@ZHENGRUI-DS MINGW64 ~\n$ node -v\nv6.9.4\n\nzhengrui-ds@ZHENGRUI-DS MINGW64 ~\n$ npm -v\n3.10.10\n```\n\n\n#### 2.2 安装hexo    \n\n安装客户端   \n\n```bash\nnpm install -g hexo-cli    \n```   \n\n安装服务端  \n\n```bash\nnpm install hexo --save   \n```   \n\n新建一个用于装在hexo的文件夹，如hexo  \n切换到该文件夹，执行以下命令：   \n\n```bash\n hexo init  //初始化该文件夹  \n npm install  //安装相应的依赖包\n```    \n\n此时hexo搭建博客已基本完成。可执行以下命令来查看博客的初始效果：  \n\n```bash\n\thexo clean   //清空public文件夹下面的内容，该文件夹用于存放生成的网页文件。  \n\thexo g       //该命令用于产生相应的网页文件，在public文件夹下  \n\thexo s      //启动一个本地服务器，一般是http://localhost:4000，可查看生成的网页情况。\n```    \n\n**注意**：有时会存在4000端口被占用的情况，此时可以使用hexo s -p 端口号&emsp;来指定端口号。其实如果你有使用linux的经验，应该知道这些命令一般都可以在命令的后面加上-h或者--help来查看它的用法。hexo中的命令可以连写，如hexo g与hexo s可合写成hexo s -g  \n\n#### 2.3 将博客部署到github上  \n&emsp;&emsp;要想将博客部署到github上，你需要先有一个github账号，并且将你本地的git（计算机）与github关联起来。本文已认为你已经有了自己的github账号并已关联本地，如果没有请移步我的另一篇博客TODO  \n其次你需要了解一下hexo的配置文件_config.yml：  \n站点配置\n``` bash\n# Site\ntitle: ZHENGRUI'BLOG\nsubtitle: 今日之果，皆因曾经之因\ndescription:\nauthor: zhengrui\nlanguage: zh-CN\ntimezone:\n``` \n将博客部署到github上  \n``` bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: git@github.com:zhezaoyizhuding/zhezaoyizhuding.github.io.git\n  branch: master\n```  \n你需要执行以下命令，安装hexo的git插件  \n\n```bash\nnpm install hexo-deployer-git --save\n```    \n\n后面要加--save否则无法将依赖写入hexo的package.json中，执行以下命令即可将网站部署到github上。  \n\n```bash\nhexo d\n```  \n\n至此你一讲将博客部署到github上了，在浏览器输入https://你的github用户名.github.io即可访问。","source":"_posts/hexo搭建博客指南（一）-建站.md","raw":"---\ntitle: hexo搭建博客指南（一）--建站\ndate: 2017-02-16 15:08:29\ncategories: hexo\ntags:\n- hexo\n---\n### 一 hexo简介   \n\n> hexo是一款快速，高效，简洁的博客框架。\n\n### 二 搭建博客   \n\n#### 2.1 安装环境\n\n&emsp;&emsp;hexo是基于node.js的，因此要想使用hexo，必须安装node环境，同时还需要git，用于将hexo部署到github上。所需软件：  \nnode.js &emsp;&emsp;下载链接：[http://nodejs.cn/download/](http://nodejs.cn/download/)  \ngit &emsp;&emsp;&emsp;&emsp;下载链接：[https://git-for-windows.github.io/](https://git-for-windows.github.io/)  \n\n\n下载后直接安装，完成后打开windows的cmd，输入以下命令：  \n\n``` bash\nnode -v    \nnpm -v \n```        \n\n当出现以下信息时，则说明安装成功。    \n   \n``` bash\nzhengrui-ds@ZHENGRUI-DS MINGW64 ~\n$ node -v\nv6.9.4\n\nzhengrui-ds@ZHENGRUI-DS MINGW64 ~\n$ npm -v\n3.10.10\n```\n\n\n#### 2.2 安装hexo    \n\n安装客户端   \n\n```bash\nnpm install -g hexo-cli    \n```   \n\n安装服务端  \n\n```bash\nnpm install hexo --save   \n```   \n\n新建一个用于装在hexo的文件夹，如hexo  \n切换到该文件夹，执行以下命令：   \n\n```bash\n hexo init  //初始化该文件夹  \n npm install  //安装相应的依赖包\n```    \n\n此时hexo搭建博客已基本完成。可执行以下命令来查看博客的初始效果：  \n\n```bash\n\thexo clean   //清空public文件夹下面的内容，该文件夹用于存放生成的网页文件。  \n\thexo g       //该命令用于产生相应的网页文件，在public文件夹下  \n\thexo s      //启动一个本地服务器，一般是http://localhost:4000，可查看生成的网页情况。\n```    \n\n**注意**：有时会存在4000端口被占用的情况，此时可以使用hexo s -p 端口号&emsp;来指定端口号。其实如果你有使用linux的经验，应该知道这些命令一般都可以在命令的后面加上-h或者--help来查看它的用法。hexo中的命令可以连写，如hexo g与hexo s可合写成hexo s -g  \n\n#### 2.3 将博客部署到github上  \n&emsp;&emsp;要想将博客部署到github上，你需要先有一个github账号，并且将你本地的git（计算机）与github关联起来。本文已认为你已经有了自己的github账号并已关联本地，如果没有请移步我的另一篇博客TODO  \n其次你需要了解一下hexo的配置文件_config.yml：  \n站点配置\n``` bash\n# Site\ntitle: ZHENGRUI'BLOG\nsubtitle: 今日之果，皆因曾经之因\ndescription:\nauthor: zhengrui\nlanguage: zh-CN\ntimezone:\n``` \n将博客部署到github上  \n``` bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: git@github.com:zhezaoyizhuding/zhezaoyizhuding.github.io.git\n  branch: master\n```  \n你需要执行以下命令，安装hexo的git插件  \n\n```bash\nnpm install hexo-deployer-git --save\n```    \n\n后面要加--save否则无法将依赖写入hexo的package.json中，执行以下命令即可将网站部署到github上。  \n\n```bash\nhexo d\n```  \n\n至此你一讲将博客部署到github上了，在浏览器输入https://你的github用户名.github.io即可访问。","slug":"hexo搭建博客指南（一）-建站","published":1,"updated":"2017-02-23T08:34:12.388Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizz09fu8000paonzr93nn5ng","content":"<h3 id=\"一-hexo简介\"><a href=\"#一-hexo简介\" class=\"headerlink\" title=\"一 hexo简介\"></a>一 hexo简介</h3><blockquote>\n<p>hexo是一款快速，高效，简洁的博客框架。</p>\n</blockquote>\n<h3 id=\"二-搭建博客\"><a href=\"#二-搭建博客\" class=\"headerlink\" title=\"二 搭建博客\"></a>二 搭建博客</h3><h4 id=\"2-1-安装环境\"><a href=\"#2-1-安装环境\" class=\"headerlink\" title=\"2.1 安装环境\"></a>2.1 安装环境</h4><p>&emsp;&emsp;hexo是基于node.js的，因此要想使用hexo，必须安装node环境，同时还需要git，用于将hexo部署到github上。所需软件：<br>node.js &emsp;&emsp;下载链接：<a href=\"http://nodejs.cn/download/\" target=\"_blank\" rel=\"external\">http://nodejs.cn/download/</a><br>git &emsp;&emsp;&emsp;&emsp;下载链接：<a href=\"https://git-for-windows.github.io/\" target=\"_blank\" rel=\"external\">https://git-for-windows.github.io/</a>  </p>\n<p>下载后直接安装，完成后打开windows的cmd，输入以下命令：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">node -v    </div><div class=\"line\">npm -v </div><div class=\"line\">```        </div><div class=\"line\"></div><div class=\"line\">当出现以下信息时，则说明安装成功。    </div><div class=\"line\">   </div><div class=\"line\">``` bash</div><div class=\"line\">zhengrui-ds@ZHENGRUI-DS MINGW64 ~</div><div class=\"line\">$ node -v</div><div class=\"line\">v6.9.4</div><div class=\"line\"></div><div class=\"line\">zhengrui-ds@ZHENGRUI-DS MINGW64 ~</div><div class=\"line\">$ npm -v</div><div class=\"line\">3.10.10</div></pre></td></tr></table></figure>\n<h4 id=\"2-2-安装hexo\"><a href=\"#2-2-安装hexo\" class=\"headerlink\" title=\"2.2 安装hexo\"></a>2.2 安装hexo</h4><p>安装客户端   </p>\n<pre><code class=\"bash\">npm install -g hexo-cli\n</code></pre>\n<p>安装服务端  </p>\n<pre><code class=\"bash\">npm install hexo --save\n</code></pre>\n<p>新建一个用于装在hexo的文件夹，如hexo<br>切换到该文件夹，执行以下命令：   </p>\n<pre><code class=\"bash\">hexo init  //初始化该文件夹  \nnpm install  //安装相应的依赖包\n</code></pre>\n<p>此时hexo搭建博客已基本完成。可执行以下命令来查看博客的初始效果：  </p>\n<pre><code class=\"bash\">hexo clean   //清空public文件夹下面的内容，该文件夹用于存放生成的网页文件。  \nhexo g       //该命令用于产生相应的网页文件，在public文件夹下  \nhexo s      //启动一个本地服务器，一般是http://localhost:4000，可查看生成的网页情况。\n</code></pre>\n<p><strong>注意</strong>：有时会存在4000端口被占用的情况，此时可以使用hexo s -p 端口号&emsp;来指定端口号。其实如果你有使用linux的经验，应该知道这些命令一般都可以在命令的后面加上-h或者–help来查看它的用法。hexo中的命令可以连写，如hexo g与hexo s可合写成hexo s -g  </p>\n<h4 id=\"2-3-将博客部署到github上\"><a href=\"#2-3-将博客部署到github上\" class=\"headerlink\" title=\"2.3 将博客部署到github上\"></a>2.3 将博客部署到github上</h4><p>&emsp;&emsp;要想将博客部署到github上，你需要先有一个github账号，并且将你本地的git（计算机）与github关联起来。本文已认为你已经有了自己的github账号并已关联本地，如果没有请移步我的另一篇博客TODO<br>其次你需要了解一下hexo的配置文件_config.yml：<br>站点配置</p>\n<pre><code class=\"bash\"><span class=\"comment\"># Site</span>\ntitle: ZHENGRUI<span class=\"string\">'BLOG\nsubtitle: 今日之果，皆因曾经之因\ndescription:\nauthor: zhengrui\nlanguage: zh-CN\ntimezone:</span>\n</code></pre>\n<p>将博客部署到github上  </p>\n<pre><code class=\"bash\"><span class=\"comment\"># Deployment</span>\n<span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span>\ndeploy:\n  <span class=\"built_in\">type</span>: git\n  repo: git@github.com:zhezaoyizhuding/zhezaoyizhuding.github.io.git\n  branch: master\n</code></pre>\n<p>你需要执行以下命令，安装hexo的git插件  </p>\n<pre><code class=\"bash\">npm install hexo-deployer-git --save\n</code></pre>\n<p>后面要加–save否则无法将依赖写入hexo的package.json中，执行以下命令即可将网站部署到github上。  </p>\n<pre><code class=\"bash\">hexo d\n</code></pre>\n<p>至此你一讲将博客部署到github上了，在浏览器输入<a href=\"https://你的github用户名.github.io即可访问。\" target=\"_blank\" rel=\"external\">https://你的github用户名.github.io即可访问。</a></p>\n","excerpt":"","more":"<h3 id=\"一-hexo简介\"><a href=\"#一-hexo简介\" class=\"headerlink\" title=\"一 hexo简介\"></a>一 hexo简介</h3><blockquote>\n<p>hexo是一款快速，高效，简洁的博客框架。</p>\n</blockquote>\n<h3 id=\"二-搭建博客\"><a href=\"#二-搭建博客\" class=\"headerlink\" title=\"二 搭建博客\"></a>二 搭建博客</h3><h4 id=\"2-1-安装环境\"><a href=\"#2-1-安装环境\" class=\"headerlink\" title=\"2.1 安装环境\"></a>2.1 安装环境</h4><p>&emsp;&emsp;hexo是基于node.js的，因此要想使用hexo，必须安装node环境，同时还需要git，用于将hexo部署到github上。所需软件：<br>node.js &emsp;&emsp;下载链接：<a href=\"http://nodejs.cn/download/\">http://nodejs.cn/download/</a><br>git &emsp;&emsp;&emsp;&emsp;下载链接：<a href=\"https://git-for-windows.github.io/\">https://git-for-windows.github.io/</a>  </p>\n<p>下载后直接安装，完成后打开windows的cmd，输入以下命令：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">node -v    </div><div class=\"line\">npm -v </div><div class=\"line\">```        </div><div class=\"line\"></div><div class=\"line\">当出现以下信息时，则说明安装成功。    </div><div class=\"line\">   </div><div class=\"line\">``` bash</div><div class=\"line\">zhengrui-ds@ZHENGRUI-DS MINGW64 ~</div><div class=\"line\">$ node -v</div><div class=\"line\">v6.9.4</div><div class=\"line\"></div><div class=\"line\">zhengrui-ds@ZHENGRUI-DS MINGW64 ~</div><div class=\"line\">$ npm -v</div><div class=\"line\">3.10.10</div></pre></td></tr></table></figure>\n<h4 id=\"2-2-安装hexo\"><a href=\"#2-2-安装hexo\" class=\"headerlink\" title=\"2.2 安装hexo\"></a>2.2 安装hexo</h4><p>安装客户端   </p>\n<pre><code class=\"bash\">npm install -g hexo-cli\n</code></pre>\n<p>安装服务端  </p>\n<pre><code class=\"bash\">npm install hexo --save\n</code></pre>\n<p>新建一个用于装在hexo的文件夹，如hexo<br>切换到该文件夹，执行以下命令：   </p>\n<pre><code class=\"bash\">hexo init  //初始化该文件夹  \nnpm install  //安装相应的依赖包\n</code></pre>\n<p>此时hexo搭建博客已基本完成。可执行以下命令来查看博客的初始效果：  </p>\n<pre><code class=\"bash\">hexo clean   //清空public文件夹下面的内容，该文件夹用于存放生成的网页文件。  \nhexo g       //该命令用于产生相应的网页文件，在public文件夹下  \nhexo s      //启动一个本地服务器，一般是http://localhost:4000，可查看生成的网页情况。\n</code></pre>\n<p><strong>注意</strong>：有时会存在4000端口被占用的情况，此时可以使用hexo s -p 端口号&emsp;来指定端口号。其实如果你有使用linux的经验，应该知道这些命令一般都可以在命令的后面加上-h或者–help来查看它的用法。hexo中的命令可以连写，如hexo g与hexo s可合写成hexo s -g  </p>\n<h4 id=\"2-3-将博客部署到github上\"><a href=\"#2-3-将博客部署到github上\" class=\"headerlink\" title=\"2.3 将博客部署到github上\"></a>2.3 将博客部署到github上</h4><p>&emsp;&emsp;要想将博客部署到github上，你需要先有一个github账号，并且将你本地的git（计算机）与github关联起来。本文已认为你已经有了自己的github账号并已关联本地，如果没有请移步我的另一篇博客TODO<br>其次你需要了解一下hexo的配置文件_config.yml：<br>站点配置</p>\n<pre><code class=\"bash\"><span class=\"comment\"># Site</span>\ntitle: ZHENGRUI<span class=\"string\">'BLOG\nsubtitle: 今日之果，皆因曾经之因\ndescription:\nauthor: zhengrui\nlanguage: zh-CN\ntimezone:</span>\n</code></pre>\n<p>将博客部署到github上  </p>\n<pre><code class=\"bash\"><span class=\"comment\"># Deployment</span>\n<span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span>\ndeploy:\n  <span class=\"built_in\">type</span>: git\n  repo: git@github.com:zhezaoyizhuding/zhezaoyizhuding.github.io.git\n  branch: master\n</code></pre>\n<p>你需要执行以下命令，安装hexo的git插件  </p>\n<pre><code class=\"bash\">npm install hexo-deployer-git --save\n</code></pre>\n<p>后面要加–save否则无法将依赖写入hexo的package.json中，执行以下命令即可将网站部署到github上。  </p>\n<pre><code class=\"bash\">hexo d\n</code></pre>\n<p>至此你一讲将博客部署到github上了，在浏览器输入<a href=\"https://你的github用户名.github.io即可访问。\">https://你的github用户名.github.io即可访问。</a></p>\n"},{"title":"hexo搭建博客指南（二）--主题配置","date":"2017-02-18T07:09:07.000Z","_content":"### 一 主题选择  \n\n&emsp;&emsp;由于hexo默认的主题并不让人满意，因此要想搭建一个让自己心仪的博客你还需要一款好看的主题。hexo的主题你可以冲一下两个网站中获取：  \n[https://github.com/hexojs/hexo/wiki/Themes](https://github.com/hexojs/hexo/wiki/Themes)  \n[https://hexo.io/zh-cn/docs/themes.html](https://hexo.io/zh-cn/docs/themes.html)  \n\n\n### 二 主题配置  \n\n#### 2.1 安装主题\n\n&emsp;&emsp;你可以选择自己心仪的主题，然后改一下hexo的配置文件_config.yml文件。  \n``` bash\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: hexo-theme-air\n``` \n你只需要将它改成你的主题名字  \n\n\n#### 2.2 配置主题  \n&emsp;&emsp;你需要了解一下hexo的主题配置文件_config.yml(注意与hexo根目录下的配置文件不是一个文件)的一些配置:\n``` bash\nmenu:\n  首页: /\n  项目: /项目/\n  职业生涯: /职业生涯/\n  随感: /随感/\n  归档: /archives\n  关于我: /about\n\nwidgets:\n- search\n- category\n- recent_posts\n- tagcloud\n\n```  \n##### **menu**\n&emsp;&emsp;下面的是你想要为你的网站划分的版块。前面是版块名称，后面是相应的路径。你可通过如下命令来新建新的版块页面：  \n``` bash\nhexo new page 版块名\n```  \nhexo会自动在source文件下建立相应的文件夹。   \n**注意：**这里有坑。  \n\n- 我曾新建完一个新的页面后却无法访问，究其原因是当我访问这个页面是浏览器的协议自动从https换成了http，结果找不到资源。原因未知，解决办法：将hexo中的东西都删掉，重搭。。。。。   \n- 又遇一坑，当我将我的版块页面所在的文件夹取名为中文时，我需要在主题配置文件中的menu下相应的版块路径后面多家一个“/”，否则报错，而英文的就不需要，原因未知。\n- 坑3，当使用md写博客时，网站默认quote是居中的，可通过修改主题下的source/css/_partial/article.styl文件中blockquote解决。  \n这些估计都是我选择的light主题中的坑。  \n\n##### **widget**  \n&emsp;&emsp;这下面的是一些网站侧边的一些小部件，比如我的网站右边的分类和标签云。你可以在你的主题下面的/layout/_widget下面找到你的主题支持哪些小部件，你只需要将这些部件名依照格式放在widget下即可显示在网站中。  \n\n##### **categories 和 tags**\n&emsp;&emsp;categories和tags是hexo内置的标签，你只需要在编写博客时加入以下配置：  \n``` bash\n---\ntitle: hexo搭建博客指南（二）--主题配置\ndate: 2017-02-18 15:09:07\ncategories: hexo\ntags:\n- hexo\n---\n``` \n即可在widget中的category和tag中显示你的分类与标签，categories一般用于文章分类，你也可用它来生成你的版块页；tags一般则是用于为搜索引擎提供你这篇博文的关键字。  \n\n### 三 总结\n\n&emsp;&emsp;文章到这里也差不多说完了，hexo的其他知识点你可以通过google搜索或者研究hexo的官方文档[https://hexo.io/zh-cn/docs/asset-folders.html](https://hexo.io/zh-cn/docs/asset-folders.html)来获得。下篇我将介绍hexo的相关插件使用。","source":"_posts/hexo搭建博客指南（二）-主题配置.md","raw":"---\ntitle: hexo搭建博客指南（二）--主题配置\ndate: 2017-02-18 15:09:07\ncategories: hexo\ntags:\n- hexo\n---\n### 一 主题选择  \n\n&emsp;&emsp;由于hexo默认的主题并不让人满意，因此要想搭建一个让自己心仪的博客你还需要一款好看的主题。hexo的主题你可以冲一下两个网站中获取：  \n[https://github.com/hexojs/hexo/wiki/Themes](https://github.com/hexojs/hexo/wiki/Themes)  \n[https://hexo.io/zh-cn/docs/themes.html](https://hexo.io/zh-cn/docs/themes.html)  \n\n\n### 二 主题配置  \n\n#### 2.1 安装主题\n\n&emsp;&emsp;你可以选择自己心仪的主题，然后改一下hexo的配置文件_config.yml文件。  \n``` bash\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: hexo-theme-air\n``` \n你只需要将它改成你的主题名字  \n\n\n#### 2.2 配置主题  \n&emsp;&emsp;你需要了解一下hexo的主题配置文件_config.yml(注意与hexo根目录下的配置文件不是一个文件)的一些配置:\n``` bash\nmenu:\n  首页: /\n  项目: /项目/\n  职业生涯: /职业生涯/\n  随感: /随感/\n  归档: /archives\n  关于我: /about\n\nwidgets:\n- search\n- category\n- recent_posts\n- tagcloud\n\n```  \n##### **menu**\n&emsp;&emsp;下面的是你想要为你的网站划分的版块。前面是版块名称，后面是相应的路径。你可通过如下命令来新建新的版块页面：  \n``` bash\nhexo new page 版块名\n```  \nhexo会自动在source文件下建立相应的文件夹。   \n**注意：**这里有坑。  \n\n- 我曾新建完一个新的页面后却无法访问，究其原因是当我访问这个页面是浏览器的协议自动从https换成了http，结果找不到资源。原因未知，解决办法：将hexo中的东西都删掉，重搭。。。。。   \n- 又遇一坑，当我将我的版块页面所在的文件夹取名为中文时，我需要在主题配置文件中的menu下相应的版块路径后面多家一个“/”，否则报错，而英文的就不需要，原因未知。\n- 坑3，当使用md写博客时，网站默认quote是居中的，可通过修改主题下的source/css/_partial/article.styl文件中blockquote解决。  \n这些估计都是我选择的light主题中的坑。  \n\n##### **widget**  \n&emsp;&emsp;这下面的是一些网站侧边的一些小部件，比如我的网站右边的分类和标签云。你可以在你的主题下面的/layout/_widget下面找到你的主题支持哪些小部件，你只需要将这些部件名依照格式放在widget下即可显示在网站中。  \n\n##### **categories 和 tags**\n&emsp;&emsp;categories和tags是hexo内置的标签，你只需要在编写博客时加入以下配置：  \n``` bash\n---\ntitle: hexo搭建博客指南（二）--主题配置\ndate: 2017-02-18 15:09:07\ncategories: hexo\ntags:\n- hexo\n---\n``` \n即可在widget中的category和tag中显示你的分类与标签，categories一般用于文章分类，你也可用它来生成你的版块页；tags一般则是用于为搜索引擎提供你这篇博文的关键字。  \n\n### 三 总结\n\n&emsp;&emsp;文章到这里也差不多说完了，hexo的其他知识点你可以通过google搜索或者研究hexo的官方文档[https://hexo.io/zh-cn/docs/asset-folders.html](https://hexo.io/zh-cn/docs/asset-folders.html)来获得。下篇我将介绍hexo的相关插件使用。","slug":"hexo搭建博客指南（二）-主题配置","published":1,"updated":"2017-02-23T10:55:17.467Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizz09fu9000raonz9rp6qshw","content":"<h3 id=\"一-主题选择\"><a href=\"#一-主题选择\" class=\"headerlink\" title=\"一 主题选择\"></a>一 主题选择</h3><p>&emsp;&emsp;由于hexo默认的主题并不让人满意，因此要想搭建一个让自己心仪的博客你还需要一款好看的主题。hexo的主题你可以冲一下两个网站中获取：<br><a href=\"https://github.com/hexojs/hexo/wiki/Themes\" target=\"_blank\" rel=\"external\">https://github.com/hexojs/hexo/wiki/Themes</a><br><a href=\"https://hexo.io/zh-cn/docs/themes.html\" target=\"_blank\" rel=\"external\">https://hexo.io/zh-cn/docs/themes.html</a>  </p>\n<h3 id=\"二-主题配置\"><a href=\"#二-主题配置\" class=\"headerlink\" title=\"二 主题配置\"></a>二 主题配置</h3><h4 id=\"2-1-安装主题\"><a href=\"#2-1-安装主题\" class=\"headerlink\" title=\"2.1 安装主题\"></a>2.1 安装主题</h4><p>&emsp;&emsp;你可以选择自己心仪的主题，然后改一下hexo的配置文件_config.yml文件。  </p>\n<pre><code class=\"bash\"><span class=\"comment\"># Extensions</span>\n<span class=\"comment\">## Plugins: https://hexo.io/plugins/</span>\n<span class=\"comment\">## Themes: https://hexo.io/themes/</span>\ntheme: hexo-theme-air\n</code></pre>\n<p>你只需要将它改成你的主题名字  </p>\n<h4 id=\"2-2-配置主题\"><a href=\"#2-2-配置主题\" class=\"headerlink\" title=\"2.2 配置主题\"></a>2.2 配置主题</h4><p>&emsp;&emsp;你需要了解一下hexo的主题配置文件_config.yml(注意与hexo根目录下的配置文件不是一个文件)的一些配置:</p>\n<pre><code class=\"bash\">menu:\n  首页: /\n  项目: /项目/\n  职业生涯: /职业生涯/\n  随感: /随感/\n  归档: /archives\n  关于我: /about\n\nwidgets:\n- search\n- category\n- recent_posts\n- tagcloud\n</code></pre>\n<h5 id=\"menu\"><a href=\"#menu\" class=\"headerlink\" title=\"menu\"></a><strong>menu</strong></h5><p>&emsp;&emsp;下面的是你想要为你的网站划分的版块。前面是版块名称，后面是相应的路径。你可通过如下命令来新建新的版块页面：  </p>\n<pre><code class=\"bash\">hexo new page 版块名\n</code></pre>\n<p>hexo会自动在source文件下建立相应的文件夹。<br><strong>注意：</strong>这里有坑。  </p>\n<ul>\n<li>我曾新建完一个新的页面后却无法访问，究其原因是当我访问这个页面是浏览器的协议自动从https换成了http，结果找不到资源。原因未知，解决办法：将hexo中的东西都删掉，重搭。。。。。   </li>\n<li>又遇一坑，当我将我的版块页面所在的文件夹取名为中文时，我需要在主题配置文件中的menu下相应的版块路径后面多家一个“/”，否则报错，而英文的就不需要，原因未知。</li>\n<li>坑3，当使用md写博客时，网站默认quote是居中的，可通过修改主题下的source/css/_partial/article.styl文件中blockquote解决。<br>这些估计都是我选择的light主题中的坑。  </li>\n</ul>\n<h5 id=\"widget\"><a href=\"#widget\" class=\"headerlink\" title=\"widget\"></a><strong>widget</strong></h5><p>&emsp;&emsp;这下面的是一些网站侧边的一些小部件，比如我的网站右边的分类和标签云。你可以在你的主题下面的/layout/_widget下面找到你的主题支持哪些小部件，你只需要将这些部件名依照格式放在widget下即可显示在网站中。  </p>\n<h5 id=\"categories-和-tags\"><a href=\"#categories-和-tags\" class=\"headerlink\" title=\"categories 和 tags\"></a><strong>categories 和 tags</strong></h5><p>&emsp;&emsp;categories和tags是hexo内置的标签，你只需要在编写博客时加入以下配置：  </p>\n<pre><code class=\"bash\">---\ntitle: hexo搭建博客指南（二）--主题配置\ndate: 2017-02-18 15:09:07\ncategories: hexo\ntags:\n- hexo\n---\n</code></pre>\n<p>即可在widget中的category和tag中显示你的分类与标签，categories一般用于文章分类，你也可用它来生成你的版块页；tags一般则是用于为搜索引擎提供你这篇博文的关键字。  </p>\n<h3 id=\"三-总结\"><a href=\"#三-总结\" class=\"headerlink\" title=\"三 总结\"></a>三 总结</h3><p>&emsp;&emsp;文章到这里也差不多说完了，hexo的其他知识点你可以通过google搜索或者研究hexo的官方文档<a href=\"https://hexo.io/zh-cn/docs/asset-folders.html\" target=\"_blank\" rel=\"external\">https://hexo.io/zh-cn/docs/asset-folders.html</a>来获得。下篇我将介绍hexo的相关插件使用。</p>\n","excerpt":"","more":"<h3 id=\"一-主题选择\"><a href=\"#一-主题选择\" class=\"headerlink\" title=\"一 主题选择\"></a>一 主题选择</h3><p>&emsp;&emsp;由于hexo默认的主题并不让人满意，因此要想搭建一个让自己心仪的博客你还需要一款好看的主题。hexo的主题你可以冲一下两个网站中获取：<br><a href=\"https://github.com/hexojs/hexo/wiki/Themes\">https://github.com/hexojs/hexo/wiki/Themes</a><br><a href=\"https://hexo.io/zh-cn/docs/themes.html\">https://hexo.io/zh-cn/docs/themes.html</a>  </p>\n<h3 id=\"二-主题配置\"><a href=\"#二-主题配置\" class=\"headerlink\" title=\"二 主题配置\"></a>二 主题配置</h3><h4 id=\"2-1-安装主题\"><a href=\"#2-1-安装主题\" class=\"headerlink\" title=\"2.1 安装主题\"></a>2.1 安装主题</h4><p>&emsp;&emsp;你可以选择自己心仪的主题，然后改一下hexo的配置文件_config.yml文件。  </p>\n<pre><code class=\"bash\"><span class=\"comment\"># Extensions</span>\n<span class=\"comment\">## Plugins: https://hexo.io/plugins/</span>\n<span class=\"comment\">## Themes: https://hexo.io/themes/</span>\ntheme: hexo-theme-air\n</code></pre>\n<p>你只需要将它改成你的主题名字  </p>\n<h4 id=\"2-2-配置主题\"><a href=\"#2-2-配置主题\" class=\"headerlink\" title=\"2.2 配置主题\"></a>2.2 配置主题</h4><p>&emsp;&emsp;你需要了解一下hexo的主题配置文件_config.yml(注意与hexo根目录下的配置文件不是一个文件)的一些配置:</p>\n<pre><code class=\"bash\">menu:\n  首页: /\n  项目: /项目/\n  职业生涯: /职业生涯/\n  随感: /随感/\n  归档: /archives\n  关于我: /about\n\nwidgets:\n- search\n- category\n- recent_posts\n- tagcloud\n</code></pre>\n<h5 id=\"menu\"><a href=\"#menu\" class=\"headerlink\" title=\"menu\"></a><strong>menu</strong></h5><p>&emsp;&emsp;下面的是你想要为你的网站划分的版块。前面是版块名称，后面是相应的路径。你可通过如下命令来新建新的版块页面：  </p>\n<pre><code class=\"bash\">hexo new page 版块名\n</code></pre>\n<p>hexo会自动在source文件下建立相应的文件夹。<br><strong>注意：</strong>这里有坑。  </p>\n<ul>\n<li>我曾新建完一个新的页面后却无法访问，究其原因是当我访问这个页面是浏览器的协议自动从https换成了http，结果找不到资源。原因未知，解决办法：将hexo中的东西都删掉，重搭。。。。。   </li>\n<li>又遇一坑，当我将我的版块页面所在的文件夹取名为中文时，我需要在主题配置文件中的menu下相应的版块路径后面多家一个“/”，否则报错，而英文的就不需要，原因未知。</li>\n<li>坑3，当使用md写博客时，网站默认quote是居中的，可通过修改主题下的source/css/_partial/article.styl文件中blockquote解决。<br>这些估计都是我选择的light主题中的坑。  </li>\n</ul>\n<h5 id=\"widget\"><a href=\"#widget\" class=\"headerlink\" title=\"widget\"></a><strong>widget</strong></h5><p>&emsp;&emsp;这下面的是一些网站侧边的一些小部件，比如我的网站右边的分类和标签云。你可以在你的主题下面的/layout/_widget下面找到你的主题支持哪些小部件，你只需要将这些部件名依照格式放在widget下即可显示在网站中。  </p>\n<h5 id=\"categories-和-tags\"><a href=\"#categories-和-tags\" class=\"headerlink\" title=\"categories 和 tags\"></a><strong>categories 和 tags</strong></h5><p>&emsp;&emsp;categories和tags是hexo内置的标签，你只需要在编写博客时加入以下配置：  </p>\n<pre><code class=\"bash\">---\ntitle: hexo搭建博客指南（二）--主题配置\ndate: 2017-02-18 15:09:07\ncategories: hexo\ntags:\n- hexo\n---\n</code></pre>\n<p>即可在widget中的category和tag中显示你的分类与标签，categories一般用于文章分类，你也可用它来生成你的版块页；tags一般则是用于为搜索引擎提供你这篇博文的关键字。  </p>\n<h3 id=\"三-总结\"><a href=\"#三-总结\" class=\"headerlink\" title=\"三 总结\"></a>三 总结</h3><p>&emsp;&emsp;文章到这里也差不多说完了，hexo的其他知识点你可以通过google搜索或者研究hexo的官方文档<a href=\"https://hexo.io/zh-cn/docs/asset-folders.html\">https://hexo.io/zh-cn/docs/asset-folders.html</a>来获得。下篇我将介绍hexo的相关插件使用。</p>\n"},{"title":"android基础之Fragments","date":"2017-02-27T06:31:31.000Z","_content":"\n### 一 概述   \nFragment表现Activity中用户界面的一个行为或者是一部分。你可以在一个单独的activity上把多个fragment组合成为一个多区域的UI，并且可以在多个activity中再使用。你可以认为fragment是activity的一个模块零件，它有自己的生命周期，接收它自己的输入事件，并且可以在activity运行时添加或者删除。\n\nFragment必须总是被嵌入到一个activity之中，并且fragment的生命周期直接受其宿主activity的生命周期的影响。例如，一旦activity被暂停，它里面所有的fragment也被暂停，一旦activity被销毁，它里面所有的fragment也被销毁。然而，当activity正在运行时（处于resumed的生命周期状态），你可以单独的操控每个fragment，比如添加或者删除。当你执行这样一项事务时，可以将它添加到后台的一个栈中，这个栈由activity管理着——activity里面的每个后台栈内容实体是fragment发生过的一条事务记录。这个后台栈允许用户通过按BACK键回退一项fragment事务（往后导航）。\n\n当你添加一个fragment作为某个activity布局的一部分时，它就存在于这个activity视图体系内部的ViewGroup之中，并且定义了它自己的视图布局。你可以通过在activity布局文件中声明fragment，用<fragment>元素把fragment插入到activity的布局中，或者是用应用程序源码将它添加到一个存在的ViewGroup中。然而，fragment并不是一个定要作为activity布局的一部分；fragment也可以为activity隐身工作。   \n\n### 二 Fragment的继承结构   \n继承 Object\n实现 ComponentCallbacks2 View.OnCreateContextMenuListener \n      \n```java \njava.lang.Object\n   ↳ \tandroid.app.Fragment\n```\n直接子类：\nDialogFragment, ListFragment, PreferenceFragment, WebViewFragment      \n\n### 三 Fragment设计哲学  \nFragment被设计出来主要为了适应平板等大屏幕移动设备。有了fragment，你可以不必去管理视图体系的复杂变化。通过将activity的布局分割成若干个fragment，可以在运行时编辑activity的呈现，并且那些变化会被保存在由activity管理的后台栈里面。  \n如下图所示，一个Activity中的两个Fragment分别在手机和平板的显示情况：    \n{% asset_img Fragment显示图.png Fragment显示图 %}     \n\n### 四 Fragment的生命周期   \n下面是Activity的生命周期：     \n{% asset_img Fragment生命周期图.png Fragment生命周期图 %}    \n管理fragment生命周期与管理activity生命周期很相像。像activity一样，fragment也有三种状态：    \n- Resumed    \nfragment在运行中的activity可见。    \n- Paused    \n 另一个activity处于前台且得到焦点，但是这个fragment所在的activity仍然可见（前台activity部分透明，或者没有覆盖全屏）。   \n- Stopped   \nfragment不可见。要么宿主activity已经停止，要么fragment已经从activity上移除，但已被添加到后台栈中。一个停止的fragment仍然活着（所有状态和成员信息仍然由系统保留着）。但是，它对用户来讲已经不再可见，并且如果activity被杀掉，它也将被杀掉。     \n同activity类似的还有，你也可以用Bundle保存fragment状态，万一activity的进程被杀掉了，并且在activity被重新创建时，你需要恢复fragment状态。在回调执行fragment的onSaveInstanceState()期间可以保存状态，在onCreate()，onCreateView()，或者onActvityCreate()中可以恢复状态。      \n在生命周期方面,activity与fragment之间一个很重要的不同，就是在各自的后台栈中是如何存储的。当activity停止时，默认情况下，activity被安置在由系统管理的activity后台栈中（因此用户可以按BACK键回退导航，就像在Tasks和后台栈中讨论的那样）。但是，仅当你在一个事务被移除时，通过显式调用addToBackStack()请求保存的实例，该fragment才被置于由宿主activity管理的后台栈。     \n除此之外，管理fragment的生命周期与管理activity的生命周期非常相似。所以，管理activity生命周期的实践同样也适用于fragment。你需要了解的，仅仅是activity的生命周期如何影响fragment的的。    \n\n### 五 与Activity生命周期协调合作 \n下面是Activity与Fragment生命周期图对比：    \n{% asset_img Fragment与Activity生命周期对比.png Fragment与Activity生命周期对比 %}      \nfragment所生存的activity生命周期直接影响着fragment的生命周期，由此针对activity的每一个生命周期回调都会引发一个fragment类似的回调。例如，当activity接收到onPause()时，这个activity之中的每个fragment都会接收到onPause()。     \nFragment有一些额外的生命周期回调方法，然而，为了处理像是创建和销毁fragment界面，它与activity进行独特的交互。这些额外的回调方法是：     \n- onAttach()     \n 当fragment被绑定到activity时调用（Activity会被传入）。 \n-  onCreateView()    \n创建与fragment相关的视图体系时被调用。     \n- onActivityCreated()     \n当activity的onCreate()函数返回时被调用。     \n- onDestroyView()     \n当与fragment关联的视图体系正被移除时被调用。     \n- onDetach()    \n当fragment正与activity解除关联时被调用。      \n\nfragment的生命周期流程实际上是受其宿主activity影响，如上图所示。在这张图中，可以看到activity的每个连续状态是如何决定fragment可能接收到哪个回调函数的。例如，当activity接收到它的onCreate()回调时，activity之中的fragment接收到的仅仅是onActivityCreated()回调。\n\n一旦activity处于resumed状态，则可以在activity中自由的添加或者移除fragment。因此，只有当activity处于resumed状态时，fragment的生命周期才可以独立变化。\n\n然而，当activity离开恢复状态时，fragment再一次被activity推入它的生命周期中。\n\n### 六 向Fragment中添加用户界面    \nfragment常被用作activity用户界面的一部分，并且将本身的布局构建到activity中去。     \n为了给fragment提供一个布局，你必须实现onCreateView()回调函数，在绘制fragment布局时Android系统会调用它。实现这个函数时需要返回fragment所属的根View。     \n\n> 注意：如果你的fragment时ListFragment的子类，默认实现从onCreateView()返回一个ListView，所以你不需要实现它。    \n   \n为了从onCreateView()返回一个布局，你可以从layout resource定义的XML文件inflate它。为了便于你这样做，onCreateView()提供一个LayoutInflater对象。   \n例如，下面是一个fragment子类，它的布局从example_fragment.xml载入的：    \n\n```java  \npublic static class ExampleFragment extends Fragment {\n\t\t@Override\n\t\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container,\n\t\t\t\t\t\t\t\t Bundle savedInstanceState) {\n\t\t\t// Inflate the layout for this fragment\n\t\t\treturn inflater.inflate(R.layout.example_fragment, container, false);\n\t\t}\n\t}\n```\n\n传入onCreateView()的参数container 是你的frament布局将要被插入的父ViewGroup（来自activity的布局）。如果fragment处于resumed状态（恢复状态在操纵fragment生命周期一节中将作更多讨论），参数savedInstanceState是属于Bundle类，它提供了fragment之前实例的相关数据。     \n\ninflate()函数需要以下三个参数：     \n- 要inflate的布局的资源ID。      \n- 被inflate的布局的父ViewGroup。传入container很重要，这是为了让系统将布局参数应用到被inflate的布局的根view中去，由其将要嵌入的父view指定。    \n- 一个布尔值，表明在inflate期间被infalte的布局是否应该附上ViewGroup（第二个参数）。（在这个例子中传入的是false，因为系统已经将被inflate的布局插入到容器中（container）——传入true会在最终的布局里创建一个多余的ViewGroup。）       \n\n现在你已经知道了如何创建一个有布局的fragment。下一步，则需要将fragment添加到activity中。      \n\n### 七 将Fragment添加到Activity中    \n通常，fragment构建了其宿主activity的部分界面，它被作为activity全部视图层次体系的一部分被嵌入进去。在acitivity布局中添加fragment有两种方法：     \n\n##### 在activity的布局文件里声明fragment\n\n像这样，你可以像为view一样为fragment指定布局属性。例如，下面含有两个fragment的布局文件：\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t\tandroid:orientation=\"horizontal\"\n\t\tandroid:layout_width=\"match_parent\"\n\t\tandroid:layout_height=\"match_parent\">\n\t\t<fragment android:name=\"com.example.news.ArticleListFragment\"\n\t\t\t\tandroid:id=\"@+id/list\"\n\t\t\t\tandroid:layout_weight=\"1\"\n\t\t\t\tandroid:layout_width=\"0dp\"\n\t\t\t\tandroid:layout_height=\"match_parent\" />\n\t\t<fragment android:name=\"com.example.news.ArticleReaderFragment\"\n\t\t\t\tandroid:id=\"@+id/viewer\"\n\t\t\t\tandroid:layout_weight=\"2\"\n\t\t\t\tandroid:layout_width=\"0dp\"\n\t\t\t\tandroid:layout_height=\"match_parent\" />\n\t</LinearLayout>\n```\n\n<fragment>中的android:name 属性指定了布局中实例化的Fragment类。\n\n当系统创建activity布局时，它实例化了布局文件中指定的每一个fragment，并为它们调用onCreateView()函数，以获取每一个fragment的布局。系统直接在<fragment>元素的位置插入fragment返回的View。\n\n> 注意：每个fragment都需要一个唯一的标识，如果重启activity，系统可用来恢复fragment（并且可用来捕捉fragment的事务处理，例如移除）。为fragment提供ID有三种方法：   \n- 用android:id属性提供一个唯一的标识。   \n- 用android:tag属性提供一个唯一的字符串。   \n- 如果上述两个属性都没有，系统会使用其容器视图（view）的ID。 \n\n##### 通过java代码将fragment添加到已存在的ViewGroup中\n\n在activity运行的任何时候，你都可以将fragment添加到activity布局中。你仅需要简单指定用来放置fragment的ViewGroup。\n\n你应当使用FragmentTransaction的API来对activity中的fragment进行操作（例如添加，移除，或者替换fragment）。你可以像下面这样从Activity中取得FragmentTransaction的实例：\n\n```java\nFragmentManager fragmentManager = getFragmentManager()\n\tFragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n```\n\n可以用add()函数添加fragment，并指定要添加的fragment以及要将其插入到哪个视图（view）之中：\n\n```java\nExampleFragment fragment = new ExampleFragment();\n\tfragmentTransaction.add(R.id.fragment_container, fragment);\n\tfragmentTransaction.commit();\n```\n\n传入add()函数的第一个参数是fragment被放置的ViewGroup，它由资源ID（resource ID）指定，第二个参数就是要添加的fragment。一旦通过FragmentTransaction 做了更改，都应当使用commit()使变化生效。\n\n##### 添加无界面的Fragment\n\n上面的例子是如何将fragment添加到activity中去，目的是提供一个用户界面。然而，也可以使用fragment为activity提供后台动作，却不呈现多余的用户界面。\n\n想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。\n\n想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。  \n\n\n### 八 Fragment事务后台栈     \n\n在activity中使用fragment的一大特点是具有添加、删除、替换，和执行其它动作的能力，以响应用户的互动。提交给activity的每一系列变化被称为事务，并且可以用FragmentTransaction 中的APIs处理。你也可以将每一个事务保存在由activity管理的后台栈中，并且允许用户导航回退fragment变更（类似于activity的导航回退）。  \n\n你可以从FragmentManager中获取FragmentTransaction实例，像这样：\n\n```java\nFragmentManager fragmentManager = getFragmentManager();\n FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n```\n\n每项事务是在同一时间内要执行的一系列的变更。你可以为一个给定的事务用相关方法设置想要执行的所有变化，例如add()，remove()，和replace()。然后，用commit()将事务提交给activity。然而，在调用commit()之前，为了将事务添加到fragment事务后台栈中，你可能会想调用addToBackStatck()。这个后台栈由activity管理，并且允许用户通过按BACK键回退到前一个fragment状态。   \n举个例子，下面的代码是如何使用另一个fragment代替一个fragment，并且将之前的状态保留在后台栈中：\n\n```java\n// Create new fragment and transaction\n Fragment newFragment = new ExampleFragment();\n FragmentTransaction transaction = getFragmentManager().beginTransaction();\n\n // Replace whatever is in the fragment_container view with this fragment,\n // and add the transaction to the back stack\n transaction.replace(R.id.fragment_container, newFragment);\n transaction.addToBackStack(null);\n\n // Commit the transaction\n transaction.commit();\n```\n\n在这个例子中，newFragment替换了当前在布局容器中用R.id.fragment_container标识的所有的fragment（如果有的话），替代的事务被保存在后台栈中，因此用户可以回退该事务，可通过按BACK键还原之前的fragment。如果添加多个变更事务（例如另一个add()或者remove()）并调用addToBackStack()，那么在调用commit()之前的所有应用的变更被作为一个单独的事务添加到后台栈中，并且BACK键可以将它们一起回退。\n\n将变更添加到FragmentTransaction中的顺序注意以下两点：     \n- 必须要在最后调用commit()   \n- 如果你正将多个fragment添加到同一个容器中，那么添加顺序决定了它们在视图层次（view hierarchy）里显示的顺序。 \n\n在执行删除fragment事务时，如果没有调用addToBackStack()，那么事务一提交fragment就会被销毁，而且用户也无法回退它。然而，当移除一个fragment时，如果调用了addToBackStack()，那么之后fragment会被停止，如果用户回退，它将被恢复过来。     \n> 提示：对于每一个fragment事务，在提交之前通过调用setTransition()来应用一系列事务动作。     \n\n调用commit()并不立刻执行事务，相反，而是采取预约方式，一旦activity的界面线程（主线程）准备好便可运行起来。然而，如果有必要的话，你可以从界面线程调用executePendingTransations()立即执行由commit()提交的事务。但这样做，通常是没有必要的，除非其它线程的工作依赖与该项事务。\n\n> 警告：只能在activity保存状态（当用户离开activity时）之前用commit()提交事务。如果你尝试在那时之后提交，会抛出一个异常。这是因为如果activity需要被恢复，提交后的状态会被丢失。对于这类丢失提交的情况，可使用commitAllowingStateLoss() \n\n\n### 九 与Activity交互      \n##### 1.Fragment可以得到宿主Activity的引用\n尽管Fragment被实现为一个对象，它独立于Activity并可以在多个Activity中使用，一个给定的fragment实例直接被捆绑在包含它的Activity中。特别是，fragment可以通过getActivity()函数访问Activity，并且很容易的执行类似于查找activity布局中的视图的任务：\n\n```java\nView listView = getActivity().findViewById(R.id.list);\n```\n\n##### 2.Activity获取Fragment的引用\n同样的，activity能够调用fragment的函数findFragmentById()或者findFragmentByTag()，从FragmentManager中获取Fragment的索引，例如：\n\n```java\nExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);\n```\n\n##### 3.创建Activity时间回调函数\n\n在一些情况下，你可能需要fragment与activity共享事件。这样做的一个好方法是在fragment内部定义一个回调接口，并需要宿主activity实现它。当activity通过接口接收到回调时，可以在必要时与布局中的其它fragment共享信息。    \n举个例子，如果新闻应用的actvity中有两个fragment——一个显示文章列表（fragment A），另一个显示一篇文章（fragment B）——然后fragment A 必须要告诉activity列表项何时被选种，这样，activity可以通知fragment B显示这篇文章。这种情况下，在fragment A内部声明接口OnArticleSelectedListener：\n\n```java\npublic static class FragmentA extends ListFragment {\n    ...\n    // Container Activity must implement this interface\n    public interface OnArticleSelectedListener {\n        public void onArticleSelected(Uri articleUri);\n    }\n    ...\n}\n```\n\n然后fragment的宿主activity实现了OnArticleSelectedListener接口，并且重写onArticleSelected()以通知fragment B来自于fragment A的事件。为了确保宿主activity实现了这个接口，fragment A的onAttach()回调函数（当添加fragment到activity中时系统会调用它）通过作为参数传入onAttach()的activity的类型转换来实例化一个OnArticleSelectedListener实例。\n\n```java\npublic static class FragmentA extends ListFragment {\n    OnArticleSelectedListener mListener;\n    ...\n    @Override\n    public void onAttach(Activity activity) {\n        super.onAttach(activity);\n        try {\n            mListener = (OnArticleSelectedListener) activity;\n        } catch (ClassCastException e) {\n            throw new ClassCastException(activity.toString() + \" must implement OnArticleSelectedListener\");\n        }\n    }\n    ...\n}\n```\n\n如果activity没有实现这个接口，那么fragment会抛出一个ClassCaseException异常。一旦成功，mListener成员会保留一个activity的OnArticleSelectedListener实现的引用，由此fragment A可以通过调用由OnArticleSelectedListener接口定义的方法与activity共享事件。例如，如果fragment A是ListFragment的子类，每次用户点击列表项时，系统都会调用fragment的onListItemClick()事件，然后fragment调用onArticleSelected()来与activity共享事件。\n\n```java\npublic static class FragmentA extends ListFragment {\n    OnArticleSelectedListener mListener;\n    ...\n    @Override\n    public void onListItemClick(ListView l, View v, int position, long id) {\n        // Append the clicked item's row ID with the content provider Uri\n        Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);\n        // Send the event and Uri to the host activity\n        mListener.onArticleSelected(noteUri);\n    }\n    ...\n}\n```\n\n传递给onListItemClick()的参数id是点击的列表项行id，activity（或者其它fragment）用以从应用的ContentProvider获取文章。\n\n#####　添加items到Action Bar\n\n你的fragments可以通过实现onCreateOptionsMenu()来构建菜单项到activity的Options Menu（因此Action Bar也一样）。为了使用这个方法接收到调用，不管怎样，你必须在onCreate()期间调用setHasOptionsMenu()，来指明想要添加项目到Options Menu的那个fragment（否则，fragment将接收不到onCreateOptionsMenu()的调用）。     \n任何想要在fragment中的Options Menu添加的项目都追加到已有的菜单项后面。当菜单项被选中时，fragment也会接收到对onOptionsItemSelected()的回调。    \n你也可以通过调用registerForContextMenu()在fragment布局中注册一个view以提供一个context menu。当用户打开context menu时，fragment接收到对onCreateContextMenu()的回调。当用户选中一个项目时，fragment接收到对onContextItemSelected()的回调。\n\n> 注意：尽管你的fragment会接收到为添加到每个菜单项被选择菜单项的回调，但当用户选择一个菜单项时，activity会首先接收到对应的回调。如果activity的选择菜单项回调的实现没有处理被选中的项目，那么该事件被传递给fragment的回调。这同样适用于Options Menu和context menu。\n\n### 十 总结\n\n\n\n","source":"_posts/android基础之Fragments.md","raw":"---\ntitle: android基础之Fragments\ndate: 2017-02-27 14:31:31\ncategories: android\ntags:\n- android\n- java\n- Fragment\n---\n\n### 一 概述   \nFragment表现Activity中用户界面的一个行为或者是一部分。你可以在一个单独的activity上把多个fragment组合成为一个多区域的UI，并且可以在多个activity中再使用。你可以认为fragment是activity的一个模块零件，它有自己的生命周期，接收它自己的输入事件，并且可以在activity运行时添加或者删除。\n\nFragment必须总是被嵌入到一个activity之中，并且fragment的生命周期直接受其宿主activity的生命周期的影响。例如，一旦activity被暂停，它里面所有的fragment也被暂停，一旦activity被销毁，它里面所有的fragment也被销毁。然而，当activity正在运行时（处于resumed的生命周期状态），你可以单独的操控每个fragment，比如添加或者删除。当你执行这样一项事务时，可以将它添加到后台的一个栈中，这个栈由activity管理着——activity里面的每个后台栈内容实体是fragment发生过的一条事务记录。这个后台栈允许用户通过按BACK键回退一项fragment事务（往后导航）。\n\n当你添加一个fragment作为某个activity布局的一部分时，它就存在于这个activity视图体系内部的ViewGroup之中，并且定义了它自己的视图布局。你可以通过在activity布局文件中声明fragment，用<fragment>元素把fragment插入到activity的布局中，或者是用应用程序源码将它添加到一个存在的ViewGroup中。然而，fragment并不是一个定要作为activity布局的一部分；fragment也可以为activity隐身工作。   \n\n### 二 Fragment的继承结构   \n继承 Object\n实现 ComponentCallbacks2 View.OnCreateContextMenuListener \n      \n```java \njava.lang.Object\n   ↳ \tandroid.app.Fragment\n```\n直接子类：\nDialogFragment, ListFragment, PreferenceFragment, WebViewFragment      \n\n### 三 Fragment设计哲学  \nFragment被设计出来主要为了适应平板等大屏幕移动设备。有了fragment，你可以不必去管理视图体系的复杂变化。通过将activity的布局分割成若干个fragment，可以在运行时编辑activity的呈现，并且那些变化会被保存在由activity管理的后台栈里面。  \n如下图所示，一个Activity中的两个Fragment分别在手机和平板的显示情况：    \n{% asset_img Fragment显示图.png Fragment显示图 %}     \n\n### 四 Fragment的生命周期   \n下面是Activity的生命周期：     \n{% asset_img Fragment生命周期图.png Fragment生命周期图 %}    \n管理fragment生命周期与管理activity生命周期很相像。像activity一样，fragment也有三种状态：    \n- Resumed    \nfragment在运行中的activity可见。    \n- Paused    \n 另一个activity处于前台且得到焦点，但是这个fragment所在的activity仍然可见（前台activity部分透明，或者没有覆盖全屏）。   \n- Stopped   \nfragment不可见。要么宿主activity已经停止，要么fragment已经从activity上移除，但已被添加到后台栈中。一个停止的fragment仍然活着（所有状态和成员信息仍然由系统保留着）。但是，它对用户来讲已经不再可见，并且如果activity被杀掉，它也将被杀掉。     \n同activity类似的还有，你也可以用Bundle保存fragment状态，万一activity的进程被杀掉了，并且在activity被重新创建时，你需要恢复fragment状态。在回调执行fragment的onSaveInstanceState()期间可以保存状态，在onCreate()，onCreateView()，或者onActvityCreate()中可以恢复状态。      \n在生命周期方面,activity与fragment之间一个很重要的不同，就是在各自的后台栈中是如何存储的。当activity停止时，默认情况下，activity被安置在由系统管理的activity后台栈中（因此用户可以按BACK键回退导航，就像在Tasks和后台栈中讨论的那样）。但是，仅当你在一个事务被移除时，通过显式调用addToBackStack()请求保存的实例，该fragment才被置于由宿主activity管理的后台栈。     \n除此之外，管理fragment的生命周期与管理activity的生命周期非常相似。所以，管理activity生命周期的实践同样也适用于fragment。你需要了解的，仅仅是activity的生命周期如何影响fragment的的。    \n\n### 五 与Activity生命周期协调合作 \n下面是Activity与Fragment生命周期图对比：    \n{% asset_img Fragment与Activity生命周期对比.png Fragment与Activity生命周期对比 %}      \nfragment所生存的activity生命周期直接影响着fragment的生命周期，由此针对activity的每一个生命周期回调都会引发一个fragment类似的回调。例如，当activity接收到onPause()时，这个activity之中的每个fragment都会接收到onPause()。     \nFragment有一些额外的生命周期回调方法，然而，为了处理像是创建和销毁fragment界面，它与activity进行独特的交互。这些额外的回调方法是：     \n- onAttach()     \n 当fragment被绑定到activity时调用（Activity会被传入）。 \n-  onCreateView()    \n创建与fragment相关的视图体系时被调用。     \n- onActivityCreated()     \n当activity的onCreate()函数返回时被调用。     \n- onDestroyView()     \n当与fragment关联的视图体系正被移除时被调用。     \n- onDetach()    \n当fragment正与activity解除关联时被调用。      \n\nfragment的生命周期流程实际上是受其宿主activity影响，如上图所示。在这张图中，可以看到activity的每个连续状态是如何决定fragment可能接收到哪个回调函数的。例如，当activity接收到它的onCreate()回调时，activity之中的fragment接收到的仅仅是onActivityCreated()回调。\n\n一旦activity处于resumed状态，则可以在activity中自由的添加或者移除fragment。因此，只有当activity处于resumed状态时，fragment的生命周期才可以独立变化。\n\n然而，当activity离开恢复状态时，fragment再一次被activity推入它的生命周期中。\n\n### 六 向Fragment中添加用户界面    \nfragment常被用作activity用户界面的一部分，并且将本身的布局构建到activity中去。     \n为了给fragment提供一个布局，你必须实现onCreateView()回调函数，在绘制fragment布局时Android系统会调用它。实现这个函数时需要返回fragment所属的根View。     \n\n> 注意：如果你的fragment时ListFragment的子类，默认实现从onCreateView()返回一个ListView，所以你不需要实现它。    \n   \n为了从onCreateView()返回一个布局，你可以从layout resource定义的XML文件inflate它。为了便于你这样做，onCreateView()提供一个LayoutInflater对象。   \n例如，下面是一个fragment子类，它的布局从example_fragment.xml载入的：    \n\n```java  \npublic static class ExampleFragment extends Fragment {\n\t\t@Override\n\t\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container,\n\t\t\t\t\t\t\t\t Bundle savedInstanceState) {\n\t\t\t// Inflate the layout for this fragment\n\t\t\treturn inflater.inflate(R.layout.example_fragment, container, false);\n\t\t}\n\t}\n```\n\n传入onCreateView()的参数container 是你的frament布局将要被插入的父ViewGroup（来自activity的布局）。如果fragment处于resumed状态（恢复状态在操纵fragment生命周期一节中将作更多讨论），参数savedInstanceState是属于Bundle类，它提供了fragment之前实例的相关数据。     \n\ninflate()函数需要以下三个参数：     \n- 要inflate的布局的资源ID。      \n- 被inflate的布局的父ViewGroup。传入container很重要，这是为了让系统将布局参数应用到被inflate的布局的根view中去，由其将要嵌入的父view指定。    \n- 一个布尔值，表明在inflate期间被infalte的布局是否应该附上ViewGroup（第二个参数）。（在这个例子中传入的是false，因为系统已经将被inflate的布局插入到容器中（container）——传入true会在最终的布局里创建一个多余的ViewGroup。）       \n\n现在你已经知道了如何创建一个有布局的fragment。下一步，则需要将fragment添加到activity中。      \n\n### 七 将Fragment添加到Activity中    \n通常，fragment构建了其宿主activity的部分界面，它被作为activity全部视图层次体系的一部分被嵌入进去。在acitivity布局中添加fragment有两种方法：     \n\n##### 在activity的布局文件里声明fragment\n\n像这样，你可以像为view一样为fragment指定布局属性。例如，下面含有两个fragment的布局文件：\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t\tandroid:orientation=\"horizontal\"\n\t\tandroid:layout_width=\"match_parent\"\n\t\tandroid:layout_height=\"match_parent\">\n\t\t<fragment android:name=\"com.example.news.ArticleListFragment\"\n\t\t\t\tandroid:id=\"@+id/list\"\n\t\t\t\tandroid:layout_weight=\"1\"\n\t\t\t\tandroid:layout_width=\"0dp\"\n\t\t\t\tandroid:layout_height=\"match_parent\" />\n\t\t<fragment android:name=\"com.example.news.ArticleReaderFragment\"\n\t\t\t\tandroid:id=\"@+id/viewer\"\n\t\t\t\tandroid:layout_weight=\"2\"\n\t\t\t\tandroid:layout_width=\"0dp\"\n\t\t\t\tandroid:layout_height=\"match_parent\" />\n\t</LinearLayout>\n```\n\n<fragment>中的android:name 属性指定了布局中实例化的Fragment类。\n\n当系统创建activity布局时，它实例化了布局文件中指定的每一个fragment，并为它们调用onCreateView()函数，以获取每一个fragment的布局。系统直接在<fragment>元素的位置插入fragment返回的View。\n\n> 注意：每个fragment都需要一个唯一的标识，如果重启activity，系统可用来恢复fragment（并且可用来捕捉fragment的事务处理，例如移除）。为fragment提供ID有三种方法：   \n- 用android:id属性提供一个唯一的标识。   \n- 用android:tag属性提供一个唯一的字符串。   \n- 如果上述两个属性都没有，系统会使用其容器视图（view）的ID。 \n\n##### 通过java代码将fragment添加到已存在的ViewGroup中\n\n在activity运行的任何时候，你都可以将fragment添加到activity布局中。你仅需要简单指定用来放置fragment的ViewGroup。\n\n你应当使用FragmentTransaction的API来对activity中的fragment进行操作（例如添加，移除，或者替换fragment）。你可以像下面这样从Activity中取得FragmentTransaction的实例：\n\n```java\nFragmentManager fragmentManager = getFragmentManager()\n\tFragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n```\n\n可以用add()函数添加fragment，并指定要添加的fragment以及要将其插入到哪个视图（view）之中：\n\n```java\nExampleFragment fragment = new ExampleFragment();\n\tfragmentTransaction.add(R.id.fragment_container, fragment);\n\tfragmentTransaction.commit();\n```\n\n传入add()函数的第一个参数是fragment被放置的ViewGroup，它由资源ID（resource ID）指定，第二个参数就是要添加的fragment。一旦通过FragmentTransaction 做了更改，都应当使用commit()使变化生效。\n\n##### 添加无界面的Fragment\n\n上面的例子是如何将fragment添加到activity中去，目的是提供一个用户界面。然而，也可以使用fragment为activity提供后台动作，却不呈现多余的用户界面。\n\n想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。\n\n想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。  \n\n\n### 八 Fragment事务后台栈     \n\n在activity中使用fragment的一大特点是具有添加、删除、替换，和执行其它动作的能力，以响应用户的互动。提交给activity的每一系列变化被称为事务，并且可以用FragmentTransaction 中的APIs处理。你也可以将每一个事务保存在由activity管理的后台栈中，并且允许用户导航回退fragment变更（类似于activity的导航回退）。  \n\n你可以从FragmentManager中获取FragmentTransaction实例，像这样：\n\n```java\nFragmentManager fragmentManager = getFragmentManager();\n FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n```\n\n每项事务是在同一时间内要执行的一系列的变更。你可以为一个给定的事务用相关方法设置想要执行的所有变化，例如add()，remove()，和replace()。然后，用commit()将事务提交给activity。然而，在调用commit()之前，为了将事务添加到fragment事务后台栈中，你可能会想调用addToBackStatck()。这个后台栈由activity管理，并且允许用户通过按BACK键回退到前一个fragment状态。   \n举个例子，下面的代码是如何使用另一个fragment代替一个fragment，并且将之前的状态保留在后台栈中：\n\n```java\n// Create new fragment and transaction\n Fragment newFragment = new ExampleFragment();\n FragmentTransaction transaction = getFragmentManager().beginTransaction();\n\n // Replace whatever is in the fragment_container view with this fragment,\n // and add the transaction to the back stack\n transaction.replace(R.id.fragment_container, newFragment);\n transaction.addToBackStack(null);\n\n // Commit the transaction\n transaction.commit();\n```\n\n在这个例子中，newFragment替换了当前在布局容器中用R.id.fragment_container标识的所有的fragment（如果有的话），替代的事务被保存在后台栈中，因此用户可以回退该事务，可通过按BACK键还原之前的fragment。如果添加多个变更事务（例如另一个add()或者remove()）并调用addToBackStack()，那么在调用commit()之前的所有应用的变更被作为一个单独的事务添加到后台栈中，并且BACK键可以将它们一起回退。\n\n将变更添加到FragmentTransaction中的顺序注意以下两点：     \n- 必须要在最后调用commit()   \n- 如果你正将多个fragment添加到同一个容器中，那么添加顺序决定了它们在视图层次（view hierarchy）里显示的顺序。 \n\n在执行删除fragment事务时，如果没有调用addToBackStack()，那么事务一提交fragment就会被销毁，而且用户也无法回退它。然而，当移除一个fragment时，如果调用了addToBackStack()，那么之后fragment会被停止，如果用户回退，它将被恢复过来。     \n> 提示：对于每一个fragment事务，在提交之前通过调用setTransition()来应用一系列事务动作。     \n\n调用commit()并不立刻执行事务，相反，而是采取预约方式，一旦activity的界面线程（主线程）准备好便可运行起来。然而，如果有必要的话，你可以从界面线程调用executePendingTransations()立即执行由commit()提交的事务。但这样做，通常是没有必要的，除非其它线程的工作依赖与该项事务。\n\n> 警告：只能在activity保存状态（当用户离开activity时）之前用commit()提交事务。如果你尝试在那时之后提交，会抛出一个异常。这是因为如果activity需要被恢复，提交后的状态会被丢失。对于这类丢失提交的情况，可使用commitAllowingStateLoss() \n\n\n### 九 与Activity交互      \n##### 1.Fragment可以得到宿主Activity的引用\n尽管Fragment被实现为一个对象，它独立于Activity并可以在多个Activity中使用，一个给定的fragment实例直接被捆绑在包含它的Activity中。特别是，fragment可以通过getActivity()函数访问Activity，并且很容易的执行类似于查找activity布局中的视图的任务：\n\n```java\nView listView = getActivity().findViewById(R.id.list);\n```\n\n##### 2.Activity获取Fragment的引用\n同样的，activity能够调用fragment的函数findFragmentById()或者findFragmentByTag()，从FragmentManager中获取Fragment的索引，例如：\n\n```java\nExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);\n```\n\n##### 3.创建Activity时间回调函数\n\n在一些情况下，你可能需要fragment与activity共享事件。这样做的一个好方法是在fragment内部定义一个回调接口，并需要宿主activity实现它。当activity通过接口接收到回调时，可以在必要时与布局中的其它fragment共享信息。    \n举个例子，如果新闻应用的actvity中有两个fragment——一个显示文章列表（fragment A），另一个显示一篇文章（fragment B）——然后fragment A 必须要告诉activity列表项何时被选种，这样，activity可以通知fragment B显示这篇文章。这种情况下，在fragment A内部声明接口OnArticleSelectedListener：\n\n```java\npublic static class FragmentA extends ListFragment {\n    ...\n    // Container Activity must implement this interface\n    public interface OnArticleSelectedListener {\n        public void onArticleSelected(Uri articleUri);\n    }\n    ...\n}\n```\n\n然后fragment的宿主activity实现了OnArticleSelectedListener接口，并且重写onArticleSelected()以通知fragment B来自于fragment A的事件。为了确保宿主activity实现了这个接口，fragment A的onAttach()回调函数（当添加fragment到activity中时系统会调用它）通过作为参数传入onAttach()的activity的类型转换来实例化一个OnArticleSelectedListener实例。\n\n```java\npublic static class FragmentA extends ListFragment {\n    OnArticleSelectedListener mListener;\n    ...\n    @Override\n    public void onAttach(Activity activity) {\n        super.onAttach(activity);\n        try {\n            mListener = (OnArticleSelectedListener) activity;\n        } catch (ClassCastException e) {\n            throw new ClassCastException(activity.toString() + \" must implement OnArticleSelectedListener\");\n        }\n    }\n    ...\n}\n```\n\n如果activity没有实现这个接口，那么fragment会抛出一个ClassCaseException异常。一旦成功，mListener成员会保留一个activity的OnArticleSelectedListener实现的引用，由此fragment A可以通过调用由OnArticleSelectedListener接口定义的方法与activity共享事件。例如，如果fragment A是ListFragment的子类，每次用户点击列表项时，系统都会调用fragment的onListItemClick()事件，然后fragment调用onArticleSelected()来与activity共享事件。\n\n```java\npublic static class FragmentA extends ListFragment {\n    OnArticleSelectedListener mListener;\n    ...\n    @Override\n    public void onListItemClick(ListView l, View v, int position, long id) {\n        // Append the clicked item's row ID with the content provider Uri\n        Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);\n        // Send the event and Uri to the host activity\n        mListener.onArticleSelected(noteUri);\n    }\n    ...\n}\n```\n\n传递给onListItemClick()的参数id是点击的列表项行id，activity（或者其它fragment）用以从应用的ContentProvider获取文章。\n\n#####　添加items到Action Bar\n\n你的fragments可以通过实现onCreateOptionsMenu()来构建菜单项到activity的Options Menu（因此Action Bar也一样）。为了使用这个方法接收到调用，不管怎样，你必须在onCreate()期间调用setHasOptionsMenu()，来指明想要添加项目到Options Menu的那个fragment（否则，fragment将接收不到onCreateOptionsMenu()的调用）。     \n任何想要在fragment中的Options Menu添加的项目都追加到已有的菜单项后面。当菜单项被选中时，fragment也会接收到对onOptionsItemSelected()的回调。    \n你也可以通过调用registerForContextMenu()在fragment布局中注册一个view以提供一个context menu。当用户打开context menu时，fragment接收到对onCreateContextMenu()的回调。当用户选中一个项目时，fragment接收到对onContextItemSelected()的回调。\n\n> 注意：尽管你的fragment会接收到为添加到每个菜单项被选择菜单项的回调，但当用户选择一个菜单项时，activity会首先接收到对应的回调。如果activity的选择菜单项回调的实现没有处理被选中的项目，那么该事件被传递给fragment的回调。这同样适用于Options Menu和context menu。\n\n### 十 总结\n\n\n\n","slug":"android基础之Fragments","published":1,"updated":"2017-03-07T04:00:35.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizz0cpnc00004wnz7u9sr090","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Fragment表现Activity中用户界面的一个行为或者是一部分。你可以在一个单独的activity上把多个fragment组合成为一个多区域的UI，并且可以在多个activity中再使用。你可以认为fragment是activity的一个模块零件，它有自己的生命周期，接收它自己的输入事件，并且可以在activity运行时添加或者删除。</p>\n<p>Fragment必须总是被嵌入到一个activity之中，并且fragment的生命周期直接受其宿主activity的生命周期的影响。例如，一旦activity被暂停，它里面所有的fragment也被暂停，一旦activity被销毁，它里面所有的fragment也被销毁。然而，当activity正在运行时（处于resumed的生命周期状态），你可以单独的操控每个fragment，比如添加或者删除。当你执行这样一项事务时，可以将它添加到后台的一个栈中，这个栈由activity管理着——activity里面的每个后台栈内容实体是fragment发生过的一条事务记录。这个后台栈允许用户通过按BACK键回退一项fragment事务（往后导航）。</p>\n<p>当你添加一个fragment作为某个activity布局的一部分时，它就存在于这个activity视图体系内部的ViewGroup之中，并且定义了它自己的视图布局。你可以通过在activity布局文件中声明fragment，用<fragment>元素把fragment插入到activity的布局中，或者是用应用程序源码将它添加到一个存在的ViewGroup中。然而，fragment并不是一个定要作为activity布局的一部分；fragment也可以为activity隐身工作。   </fragment></p>\n<h3 id=\"二-Fragment的继承结构\"><a href=\"#二-Fragment的继承结构\" class=\"headerlink\" title=\"二 Fragment的继承结构\"></a>二 Fragment的继承结构</h3><p>继承 Object<br>实现 ComponentCallbacks2 View.OnCreateContextMenuListener </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.lang.Object</div><div class=\"line\">   ↳ \tandroid.app.Fragment</div></pre></td></tr></table></figure>\n<p>直接子类：<br>DialogFragment, ListFragment, PreferenceFragment, WebViewFragment      </p>\n<h3 id=\"三-Fragment设计哲学\"><a href=\"#三-Fragment设计哲学\" class=\"headerlink\" title=\"三 Fragment设计哲学\"></a>三 Fragment设计哲学</h3><p>Fragment被设计出来主要为了适应平板等大屏幕移动设备。有了fragment，你可以不必去管理视图体系的复杂变化。通过将activity的布局分割成若干个fragment，可以在运行时编辑activity的呈现，并且那些变化会被保存在由activity管理的后台栈里面。<br>如下图所示，一个Activity中的两个Fragment分别在手机和平板的显示情况：<br><img src=\"/2017/02/27/android基础之Fragments/Fragment显示图.png\" alt=\"Fragment显示图\" title=\"Fragment显示图\">     </p>\n<h3 id=\"四-Fragment的生命周期\"><a href=\"#四-Fragment的生命周期\" class=\"headerlink\" title=\"四 Fragment的生命周期\"></a>四 Fragment的生命周期</h3><p>下面是Activity的生命周期：<br><img src=\"/2017/02/27/android基础之Fragments/Fragment生命周期图.png\" alt=\"Fragment生命周期图\" title=\"Fragment生命周期图\"><br>管理fragment生命周期与管理activity生命周期很相像。像activity一样，fragment也有三种状态：    </p>\n<ul>\n<li>Resumed<br>fragment在运行中的activity可见。    </li>\n<li>Paused<br>另一个activity处于前台且得到焦点，但是这个fragment所在的activity仍然可见（前台activity部分透明，或者没有覆盖全屏）。   </li>\n<li>Stopped<br>fragment不可见。要么宿主activity已经停止，要么fragment已经从activity上移除，但已被添加到后台栈中。一个停止的fragment仍然活着（所有状态和成员信息仍然由系统保留着）。但是，它对用户来讲已经不再可见，并且如果activity被杀掉，它也将被杀掉。<br>同activity类似的还有，你也可以用Bundle保存fragment状态，万一activity的进程被杀掉了，并且在activity被重新创建时，你需要恢复fragment状态。在回调执行fragment的onSaveInstanceState()期间可以保存状态，在onCreate()，onCreateView()，或者onActvityCreate()中可以恢复状态。<br>在生命周期方面,activity与fragment之间一个很重要的不同，就是在各自的后台栈中是如何存储的。当activity停止时，默认情况下，activity被安置在由系统管理的activity后台栈中（因此用户可以按BACK键回退导航，就像在Tasks和后台栈中讨论的那样）。但是，仅当你在一个事务被移除时，通过显式调用addToBackStack()请求保存的实例，该fragment才被置于由宿主activity管理的后台栈。<br>除此之外，管理fragment的生命周期与管理activity的生命周期非常相似。所以，管理activity生命周期的实践同样也适用于fragment。你需要了解的，仅仅是activity的生命周期如何影响fragment的的。    </li>\n</ul>\n<h3 id=\"五-与Activity生命周期协调合作\"><a href=\"#五-与Activity生命周期协调合作\" class=\"headerlink\" title=\"五 与Activity生命周期协调合作\"></a>五 与Activity生命周期协调合作</h3><p>下面是Activity与Fragment生命周期图对比：<br><img src=\"/2017/02/27/android基础之Fragments/Fragment与Activity生命周期对比.png\" alt=\"Fragment与Activity生命周期对比\" title=\"Fragment与Activity生命周期对比\"><br>fragment所生存的activity生命周期直接影响着fragment的生命周期，由此针对activity的每一个生命周期回调都会引发一个fragment类似的回调。例如，当activity接收到onPause()时，这个activity之中的每个fragment都会接收到onPause()。<br>Fragment有一些额外的生命周期回调方法，然而，为了处理像是创建和销毁fragment界面，它与activity进行独特的交互。这些额外的回调方法是：     </p>\n<ul>\n<li>onAttach()<br>当fragment被绑定到activity时调用（Activity会被传入）。 </li>\n<li>onCreateView()<br>创建与fragment相关的视图体系时被调用。     </li>\n<li>onActivityCreated()<br>当activity的onCreate()函数返回时被调用。     </li>\n<li>onDestroyView()<br>当与fragment关联的视图体系正被移除时被调用。     </li>\n<li>onDetach()<br>当fragment正与activity解除关联时被调用。      </li>\n</ul>\n<p>fragment的生命周期流程实际上是受其宿主activity影响，如上图所示。在这张图中，可以看到activity的每个连续状态是如何决定fragment可能接收到哪个回调函数的。例如，当activity接收到它的onCreate()回调时，activity之中的fragment接收到的仅仅是onActivityCreated()回调。</p>\n<p>一旦activity处于resumed状态，则可以在activity中自由的添加或者移除fragment。因此，只有当activity处于resumed状态时，fragment的生命周期才可以独立变化。</p>\n<p>然而，当activity离开恢复状态时，fragment再一次被activity推入它的生命周期中。</p>\n<h3 id=\"六-向Fragment中添加用户界面\"><a href=\"#六-向Fragment中添加用户界面\" class=\"headerlink\" title=\"六 向Fragment中添加用户界面\"></a>六 向Fragment中添加用户界面</h3><p>fragment常被用作activity用户界面的一部分，并且将本身的布局构建到activity中去。<br>为了给fragment提供一个布局，你必须实现onCreateView()回调函数，在绘制fragment布局时Android系统会调用它。实现这个函数时需要返回fragment所属的根View。     </p>\n<blockquote>\n<p>注意：如果你的fragment时ListFragment的子类，默认实现从onCreateView()返回一个ListView，所以你不需要实现它。    </p>\n</blockquote>\n<p>为了从onCreateView()返回一个布局，你可以从layout resource定义的XML文件inflate它。为了便于你这样做，onCreateView()提供一个LayoutInflater对象。<br>例如，下面是一个fragment子类，它的布局从example_fragment.xml载入的：    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">onCreateView</span><span class=\"params\">(LayoutInflater inflater, ViewGroup container,</span></span></div><div class=\"line\">\t\t\t\t\t\t\t\t Bundle savedInstanceState) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// Inflate the layout for this fragment</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> inflater.inflate(R.layout.example_fragment, container, <span class=\"keyword\">false</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>传入onCreateView()的参数container 是你的frament布局将要被插入的父ViewGroup（来自activity的布局）。如果fragment处于resumed状态（恢复状态在操纵fragment生命周期一节中将作更多讨论），参数savedInstanceState是属于Bundle类，它提供了fragment之前实例的相关数据。     </p>\n<p>inflate()函数需要以下三个参数：     </p>\n<ul>\n<li>要inflate的布局的资源ID。      </li>\n<li>被inflate的布局的父ViewGroup。传入container很重要，这是为了让系统将布局参数应用到被inflate的布局的根view中去，由其将要嵌入的父view指定。    </li>\n<li>一个布尔值，表明在inflate期间被infalte的布局是否应该附上ViewGroup（第二个参数）。（在这个例子中传入的是false，因为系统已经将被inflate的布局插入到容器中（container）——传入true会在最终的布局里创建一个多余的ViewGroup。）       </li>\n</ul>\n<p>现在你已经知道了如何创建一个有布局的fragment。下一步，则需要将fragment添加到activity中。      </p>\n<h3 id=\"七-将Fragment添加到Activity中\"><a href=\"#七-将Fragment添加到Activity中\" class=\"headerlink\" title=\"七 将Fragment添加到Activity中\"></a>七 将Fragment添加到Activity中</h3><p>通常，fragment构建了其宿主activity的部分界面，它被作为activity全部视图层次体系的一部分被嵌入进去。在acitivity布局中添加fragment有两种方法：     </p>\n<h5 id=\"在activity的布局文件里声明fragment\"><a href=\"#在activity的布局文件里声明fragment\" class=\"headerlink\" title=\"在activity的布局文件里声明fragment\"></a>在activity的布局文件里声明fragment</h5><p>像这样，你可以像为view一样为fragment指定布局属性。例如，下面含有两个fragment的布局文件：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\">\t&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"</div><div class=\"line\">\t\tandroid:orientation=\"horizontal\"</div><div class=\"line\">\t\tandroid:layout_width=\"match_parent\"</div><div class=\"line\">\t\tandroid:layout_height=\"match_parent\"&gt;</div><div class=\"line\">\t\t&lt;fragment android:name=\"com.example.news.ArticleListFragment\"</div><div class=\"line\">\t\t\t\tandroid:id=\"@+id/list\"</div><div class=\"line\">\t\t\t\tandroid:layout_weight=\"1\"</div><div class=\"line\">\t\t\t\tandroid:layout_width=\"0dp\"</div><div class=\"line\">\t\t\t\tandroid:layout_height=\"match_parent\" /&gt;</div><div class=\"line\">\t\t&lt;fragment android:name=\"com.example.news.ArticleReaderFragment\"</div><div class=\"line\">\t\t\t\tandroid:id=\"@+id/viewer\"</div><div class=\"line\">\t\t\t\tandroid:layout_weight=\"2\"</div><div class=\"line\">\t\t\t\tandroid:layout_width=\"0dp\"</div><div class=\"line\">\t\t\t\tandroid:layout_height=\"match_parent\" /&gt;</div><div class=\"line\">\t&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>\n<p><fragment>中的android:name 属性指定了布局中实例化的Fragment类。</fragment></p>\n<p>当系统创建activity布局时，它实例化了布局文件中指定的每一个fragment，并为它们调用onCreateView()函数，以获取每一个fragment的布局。系统直接在<fragment>元素的位置插入fragment返回的View。</fragment></p>\n<blockquote>\n<p>注意：每个fragment都需要一个唯一的标识，如果重启activity，系统可用来恢复fragment（并且可用来捕捉fragment的事务处理，例如移除）。为fragment提供ID有三种方法：   </p>\n<ul>\n<li>用android:id属性提供一个唯一的标识。   </li>\n<li>用android:tag属性提供一个唯一的字符串。   </li>\n<li>如果上述两个属性都没有，系统会使用其容器视图（view）的ID。 </li>\n</ul>\n</blockquote>\n<h5 id=\"通过java代码将fragment添加到已存在的ViewGroup中\"><a href=\"#通过java代码将fragment添加到已存在的ViewGroup中\" class=\"headerlink\" title=\"通过java代码将fragment添加到已存在的ViewGroup中\"></a>通过java代码将fragment添加到已存在的ViewGroup中</h5><p>在activity运行的任何时候，你都可以将fragment添加到activity布局中。你仅需要简单指定用来放置fragment的ViewGroup。</p>\n<p>你应当使用FragmentTransaction的API来对activity中的fragment进行操作（例如添加，移除，或者替换fragment）。你可以像下面这样从Activity中取得FragmentTransaction的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">FragmentManager fragmentManager = getFragmentManager()</div><div class=\"line\">\tFragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</div></pre></td></tr></table></figure>\n<p>可以用add()函数添加fragment，并指定要添加的fragment以及要将其插入到哪个视图（view）之中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ExampleFragment fragment = <span class=\"keyword\">new</span> ExampleFragment();</div><div class=\"line\">\tfragmentTransaction.add(R.id.fragment_container, fragment);</div><div class=\"line\">\tfragmentTransaction.commit();</div></pre></td></tr></table></figure>\n<p>传入add()函数的第一个参数是fragment被放置的ViewGroup，它由资源ID（resource ID）指定，第二个参数就是要添加的fragment。一旦通过FragmentTransaction 做了更改，都应当使用commit()使变化生效。</p>\n<h5 id=\"添加无界面的Fragment\"><a href=\"#添加无界面的Fragment\" class=\"headerlink\" title=\"添加无界面的Fragment\"></a>添加无界面的Fragment</h5><p>上面的例子是如何将fragment添加到activity中去，目的是提供一个用户界面。然而，也可以使用fragment为activity提供后台动作，却不呈现多余的用户界面。</p>\n<p>想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。</p>\n<p>想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。  </p>\n<h3 id=\"八-Fragment事务后台栈\"><a href=\"#八-Fragment事务后台栈\" class=\"headerlink\" title=\"八 Fragment事务后台栈\"></a>八 Fragment事务后台栈</h3><p>在activity中使用fragment的一大特点是具有添加、删除、替换，和执行其它动作的能力，以响应用户的互动。提交给activity的每一系列变化被称为事务，并且可以用FragmentTransaction 中的APIs处理。你也可以将每一个事务保存在由activity管理的后台栈中，并且允许用户导航回退fragment变更（类似于activity的导航回退）。  </p>\n<p>你可以从FragmentManager中获取FragmentTransaction实例，像这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">FragmentManager fragmentManager = getFragmentManager();</div><div class=\"line\"> FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</div></pre></td></tr></table></figure>\n<p>每项事务是在同一时间内要执行的一系列的变更。你可以为一个给定的事务用相关方法设置想要执行的所有变化，例如add()，remove()，和replace()。然后，用commit()将事务提交给activity。然而，在调用commit()之前，为了将事务添加到fragment事务后台栈中，你可能会想调用addToBackStatck()。这个后台栈由activity管理，并且允许用户通过按BACK键回退到前一个fragment状态。<br>举个例子，下面的代码是如何使用另一个fragment代替一个fragment，并且将之前的状态保留在后台栈中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Create new fragment and transaction</span></div><div class=\"line\"> Fragment newFragment = <span class=\"keyword\">new</span> ExampleFragment();</div><div class=\"line\"> FragmentTransaction transaction = getFragmentManager().beginTransaction();</div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">// Replace whatever is in the fragment_container view with this fragment,</span></div><div class=\"line\"> <span class=\"comment\">// and add the transaction to the back stack</span></div><div class=\"line\"> transaction.replace(R.id.fragment_container, newFragment);</div><div class=\"line\"> transaction.addToBackStack(<span class=\"keyword\">null</span>);</div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">// Commit the transaction</span></div><div class=\"line\"> transaction.commit();</div></pre></td></tr></table></figure>\n<p>在这个例子中，newFragment替换了当前在布局容器中用R.id.fragment_container标识的所有的fragment（如果有的话），替代的事务被保存在后台栈中，因此用户可以回退该事务，可通过按BACK键还原之前的fragment。如果添加多个变更事务（例如另一个add()或者remove()）并调用addToBackStack()，那么在调用commit()之前的所有应用的变更被作为一个单独的事务添加到后台栈中，并且BACK键可以将它们一起回退。</p>\n<p>将变更添加到FragmentTransaction中的顺序注意以下两点：     </p>\n<ul>\n<li>必须要在最后调用commit()   </li>\n<li>如果你正将多个fragment添加到同一个容器中，那么添加顺序决定了它们在视图层次（view hierarchy）里显示的顺序。 </li>\n</ul>\n<p>在执行删除fragment事务时，如果没有调用addToBackStack()，那么事务一提交fragment就会被销毁，而且用户也无法回退它。然而，当移除一个fragment时，如果调用了addToBackStack()，那么之后fragment会被停止，如果用户回退，它将被恢复过来。     </p>\n<blockquote>\n<p>提示：对于每一个fragment事务，在提交之前通过调用setTransition()来应用一系列事务动作。     </p>\n</blockquote>\n<p>调用commit()并不立刻执行事务，相反，而是采取预约方式，一旦activity的界面线程（主线程）准备好便可运行起来。然而，如果有必要的话，你可以从界面线程调用executePendingTransations()立即执行由commit()提交的事务。但这样做，通常是没有必要的，除非其它线程的工作依赖与该项事务。</p>\n<blockquote>\n<p>警告：只能在activity保存状态（当用户离开activity时）之前用commit()提交事务。如果你尝试在那时之后提交，会抛出一个异常。这是因为如果activity需要被恢复，提交后的状态会被丢失。对于这类丢失提交的情况，可使用commitAllowingStateLoss() </p>\n</blockquote>\n<h3 id=\"九-与Activity交互\"><a href=\"#九-与Activity交互\" class=\"headerlink\" title=\"九 与Activity交互\"></a>九 与Activity交互</h3><h5 id=\"1-Fragment可以得到宿主Activity的引用\"><a href=\"#1-Fragment可以得到宿主Activity的引用\" class=\"headerlink\" title=\"1.Fragment可以得到宿主Activity的引用\"></a>1.Fragment可以得到宿主Activity的引用</h5><p>尽管Fragment被实现为一个对象，它独立于Activity并可以在多个Activity中使用，一个给定的fragment实例直接被捆绑在包含它的Activity中。特别是，fragment可以通过getActivity()函数访问Activity，并且很容易的执行类似于查找activity布局中的视图的任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">View listView = getActivity().findViewById(R.id.list);</div></pre></td></tr></table></figure>\n<h5 id=\"2-Activity获取Fragment的引用\"><a href=\"#2-Activity获取Fragment的引用\" class=\"headerlink\" title=\"2.Activity获取Fragment的引用\"></a>2.Activity获取Fragment的引用</h5><p>同样的，activity能够调用fragment的函数findFragmentById()或者findFragmentByTag()，从FragmentManager中获取Fragment的索引，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);</div></pre></td></tr></table></figure>\n<h5 id=\"3-创建Activity时间回调函数\"><a href=\"#3-创建Activity时间回调函数\" class=\"headerlink\" title=\"3.创建Activity时间回调函数\"></a>3.创建Activity时间回调函数</h5><p>在一些情况下，你可能需要fragment与activity共享事件。这样做的一个好方法是在fragment内部定义一个回调接口，并需要宿主activity实现它。当activity通过接口接收到回调时，可以在必要时与布局中的其它fragment共享信息。<br>举个例子，如果新闻应用的actvity中有两个fragment——一个显示文章列表（fragment A），另一个显示一篇文章（fragment B）——然后fragment A 必须要告诉activity列表项何时被选种，这样，activity可以通知fragment B显示这篇文章。这种情况下，在fragment A内部声明接口OnArticleSelectedListener：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentA</span> <span class=\"keyword\">extends</span> <span class=\"title\">ListFragment</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"comment\">// Container Activity must implement this interface</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnArticleSelectedListener</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onArticleSelected</span><span class=\"params\">(Uri articleUri)</span></span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后fragment的宿主activity实现了OnArticleSelectedListener接口，并且重写onArticleSelected()以通知fragment B来自于fragment A的事件。为了确保宿主activity实现了这个接口，fragment A的onAttach()回调函数（当添加fragment到activity中时系统会调用它）通过作为参数传入onAttach()的activity的类型转换来实例化一个OnArticleSelectedListener实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentA</span> <span class=\"keyword\">extends</span> <span class=\"title\">ListFragment</span> </span>&#123;</div><div class=\"line\">    OnArticleSelectedListener mListener;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAttach</span><span class=\"params\">(Activity activity)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onAttach(activity);</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            mListener = (OnArticleSelectedListener) activity;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassCastException e) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassCastException(activity.toString() + <span class=\"string\">\" must implement OnArticleSelectedListener\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果activity没有实现这个接口，那么fragment会抛出一个ClassCaseException异常。一旦成功，mListener成员会保留一个activity的OnArticleSelectedListener实现的引用，由此fragment A可以通过调用由OnArticleSelectedListener接口定义的方法与activity共享事件。例如，如果fragment A是ListFragment的子类，每次用户点击列表项时，系统都会调用fragment的onListItemClick()事件，然后fragment调用onArticleSelected()来与activity共享事件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentA</span> <span class=\"keyword\">extends</span> <span class=\"title\">ListFragment</span> </span>&#123;</div><div class=\"line\">    OnArticleSelectedListener mListener;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onListItemClick</span><span class=\"params\">(ListView l, View v, <span class=\"keyword\">int</span> position, <span class=\"keyword\">long</span> id)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Append the clicked item's row ID with the content provider Uri</span></div><div class=\"line\">        Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);</div><div class=\"line\">        <span class=\"comment\">// Send the event and Uri to the host activity</span></div><div class=\"line\">        mListener.onArticleSelected(noteUri);</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>传递给onListItemClick()的参数id是点击的列表项行id，activity（或者其它fragment）用以从应用的ContentProvider获取文章。</p>\n<p>#####　添加items到Action Bar</p>\n<p>你的fragments可以通过实现onCreateOptionsMenu()来构建菜单项到activity的Options Menu（因此Action Bar也一样）。为了使用这个方法接收到调用，不管怎样，你必须在onCreate()期间调用setHasOptionsMenu()，来指明想要添加项目到Options Menu的那个fragment（否则，fragment将接收不到onCreateOptionsMenu()的调用）。<br>任何想要在fragment中的Options Menu添加的项目都追加到已有的菜单项后面。当菜单项被选中时，fragment也会接收到对onOptionsItemSelected()的回调。<br>你也可以通过调用registerForContextMenu()在fragment布局中注册一个view以提供一个context menu。当用户打开context menu时，fragment接收到对onCreateContextMenu()的回调。当用户选中一个项目时，fragment接收到对onContextItemSelected()的回调。</p>\n<blockquote>\n<p>注意：尽管你的fragment会接收到为添加到每个菜单项被选择菜单项的回调，但当用户选择一个菜单项时，activity会首先接收到对应的回调。如果activity的选择菜单项回调的实现没有处理被选中的项目，那么该事件被传递给fragment的回调。这同样适用于Options Menu和context menu。</p>\n</blockquote>\n<h3 id=\"十-总结\"><a href=\"#十-总结\" class=\"headerlink\" title=\"十 总结\"></a>十 总结</h3>","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Fragment表现Activity中用户界面的一个行为或者是一部分。你可以在一个单独的activity上把多个fragment组合成为一个多区域的UI，并且可以在多个activity中再使用。你可以认为fragment是activity的一个模块零件，它有自己的生命周期，接收它自己的输入事件，并且可以在activity运行时添加或者删除。</p>\n<p>Fragment必须总是被嵌入到一个activity之中，并且fragment的生命周期直接受其宿主activity的生命周期的影响。例如，一旦activity被暂停，它里面所有的fragment也被暂停，一旦activity被销毁，它里面所有的fragment也被销毁。然而，当activity正在运行时（处于resumed的生命周期状态），你可以单独的操控每个fragment，比如添加或者删除。当你执行这样一项事务时，可以将它添加到后台的一个栈中，这个栈由activity管理着——activity里面的每个后台栈内容实体是fragment发生过的一条事务记录。这个后台栈允许用户通过按BACK键回退一项fragment事务（往后导航）。</p>\n<p>当你添加一个fragment作为某个activity布局的一部分时，它就存在于这个activity视图体系内部的ViewGroup之中，并且定义了它自己的视图布局。你可以通过在activity布局文件中声明fragment，用<fragment>元素把fragment插入到activity的布局中，或者是用应用程序源码将它添加到一个存在的ViewGroup中。然而，fragment并不是一个定要作为activity布局的一部分；fragment也可以为activity隐身工作。   </p>\n<h3 id=\"二-Fragment的继承结构\"><a href=\"#二-Fragment的继承结构\" class=\"headerlink\" title=\"二 Fragment的继承结构\"></a>二 Fragment的继承结构</h3><p>继承 Object<br>实现 ComponentCallbacks2 View.OnCreateContextMenuListener </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.lang.Object</div><div class=\"line\">   ↳ \tandroid.app.Fragment</div></pre></td></tr></table></figure>\n<p>直接子类：<br>DialogFragment, ListFragment, PreferenceFragment, WebViewFragment      </p>\n<h3 id=\"三-Fragment设计哲学\"><a href=\"#三-Fragment设计哲学\" class=\"headerlink\" title=\"三 Fragment设计哲学\"></a>三 Fragment设计哲学</h3><p>Fragment被设计出来主要为了适应平板等大屏幕移动设备。有了fragment，你可以不必去管理视图体系的复杂变化。通过将activity的布局分割成若干个fragment，可以在运行时编辑activity的呈现，并且那些变化会被保存在由activity管理的后台栈里面。<br>如下图所示，一个Activity中的两个Fragment分别在手机和平板的显示情况：<br><img src=\"/2017/02/27/android基础之Fragments/Fragment显示图.png\" alt=\"Fragment显示图\" title=\"Fragment显示图\">     </p>\n<h3 id=\"四-Fragment的生命周期\"><a href=\"#四-Fragment的生命周期\" class=\"headerlink\" title=\"四 Fragment的生命周期\"></a>四 Fragment的生命周期</h3><p>下面是Activity的生命周期：<br><img src=\"/2017/02/27/android基础之Fragments/Fragment生命周期图.png\" alt=\"Fragment生命周期图\" title=\"Fragment生命周期图\"><br>管理fragment生命周期与管理activity生命周期很相像。像activity一样，fragment也有三种状态：    </p>\n<ul>\n<li>Resumed<br>fragment在运行中的activity可见。    </li>\n<li>Paused<br>另一个activity处于前台且得到焦点，但是这个fragment所在的activity仍然可见（前台activity部分透明，或者没有覆盖全屏）。   </li>\n<li>Stopped<br>fragment不可见。要么宿主activity已经停止，要么fragment已经从activity上移除，但已被添加到后台栈中。一个停止的fragment仍然活着（所有状态和成员信息仍然由系统保留着）。但是，它对用户来讲已经不再可见，并且如果activity被杀掉，它也将被杀掉。<br>同activity类似的还有，你也可以用Bundle保存fragment状态，万一activity的进程被杀掉了，并且在activity被重新创建时，你需要恢复fragment状态。在回调执行fragment的onSaveInstanceState()期间可以保存状态，在onCreate()，onCreateView()，或者onActvityCreate()中可以恢复状态。<br>在生命周期方面,activity与fragment之间一个很重要的不同，就是在各自的后台栈中是如何存储的。当activity停止时，默认情况下，activity被安置在由系统管理的activity后台栈中（因此用户可以按BACK键回退导航，就像在Tasks和后台栈中讨论的那样）。但是，仅当你在一个事务被移除时，通过显式调用addToBackStack()请求保存的实例，该fragment才被置于由宿主activity管理的后台栈。<br>除此之外，管理fragment的生命周期与管理activity的生命周期非常相似。所以，管理activity生命周期的实践同样也适用于fragment。你需要了解的，仅仅是activity的生命周期如何影响fragment的的。    </li>\n</ul>\n<h3 id=\"五-与Activity生命周期协调合作\"><a href=\"#五-与Activity生命周期协调合作\" class=\"headerlink\" title=\"五 与Activity生命周期协调合作\"></a>五 与Activity生命周期协调合作</h3><p>下面是Activity与Fragment生命周期图对比：<br><img src=\"/2017/02/27/android基础之Fragments/Fragment与Activity生命周期对比.png\" alt=\"Fragment与Activity生命周期对比\" title=\"Fragment与Activity生命周期对比\"><br>fragment所生存的activity生命周期直接影响着fragment的生命周期，由此针对activity的每一个生命周期回调都会引发一个fragment类似的回调。例如，当activity接收到onPause()时，这个activity之中的每个fragment都会接收到onPause()。<br>Fragment有一些额外的生命周期回调方法，然而，为了处理像是创建和销毁fragment界面，它与activity进行独特的交互。这些额外的回调方法是：     </p>\n<ul>\n<li>onAttach()<br>当fragment被绑定到activity时调用（Activity会被传入）。 </li>\n<li>onCreateView()<br>创建与fragment相关的视图体系时被调用。     </li>\n<li>onActivityCreated()<br>当activity的onCreate()函数返回时被调用。     </li>\n<li>onDestroyView()<br>当与fragment关联的视图体系正被移除时被调用。     </li>\n<li>onDetach()<br>当fragment正与activity解除关联时被调用。      </li>\n</ul>\n<p>fragment的生命周期流程实际上是受其宿主activity影响，如上图所示。在这张图中，可以看到activity的每个连续状态是如何决定fragment可能接收到哪个回调函数的。例如，当activity接收到它的onCreate()回调时，activity之中的fragment接收到的仅仅是onActivityCreated()回调。</p>\n<p>一旦activity处于resumed状态，则可以在activity中自由的添加或者移除fragment。因此，只有当activity处于resumed状态时，fragment的生命周期才可以独立变化。</p>\n<p>然而，当activity离开恢复状态时，fragment再一次被activity推入它的生命周期中。</p>\n<h3 id=\"六-向Fragment中添加用户界面\"><a href=\"#六-向Fragment中添加用户界面\" class=\"headerlink\" title=\"六 向Fragment中添加用户界面\"></a>六 向Fragment中添加用户界面</h3><p>fragment常被用作activity用户界面的一部分，并且将本身的布局构建到activity中去。<br>为了给fragment提供一个布局，你必须实现onCreateView()回调函数，在绘制fragment布局时Android系统会调用它。实现这个函数时需要返回fragment所属的根View。     </p>\n<blockquote>\n<p>注意：如果你的fragment时ListFragment的子类，默认实现从onCreateView()返回一个ListView，所以你不需要实现它。    </p>\n</blockquote>\n<p>为了从onCreateView()返回一个布局，你可以从layout resource定义的XML文件inflate它。为了便于你这样做，onCreateView()提供一个LayoutInflater对象。<br>例如，下面是一个fragment子类，它的布局从example_fragment.xml载入的：    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">onCreateView</span><span class=\"params\">(LayoutInflater inflater, ViewGroup container,</div><div class=\"line\">\t\t\t\t\t\t\t\t Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// Inflate the layout for this fragment</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> inflater.inflate(R.layout.example_fragment, container, <span class=\"keyword\">false</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>传入onCreateView()的参数container 是你的frament布局将要被插入的父ViewGroup（来自activity的布局）。如果fragment处于resumed状态（恢复状态在操纵fragment生命周期一节中将作更多讨论），参数savedInstanceState是属于Bundle类，它提供了fragment之前实例的相关数据。     </p>\n<p>inflate()函数需要以下三个参数：     </p>\n<ul>\n<li>要inflate的布局的资源ID。      </li>\n<li>被inflate的布局的父ViewGroup。传入container很重要，这是为了让系统将布局参数应用到被inflate的布局的根view中去，由其将要嵌入的父view指定。    </li>\n<li>一个布尔值，表明在inflate期间被infalte的布局是否应该附上ViewGroup（第二个参数）。（在这个例子中传入的是false，因为系统已经将被inflate的布局插入到容器中（container）——传入true会在最终的布局里创建一个多余的ViewGroup。）       </li>\n</ul>\n<p>现在你已经知道了如何创建一个有布局的fragment。下一步，则需要将fragment添加到activity中。      </p>\n<h3 id=\"七-将Fragment添加到Activity中\"><a href=\"#七-将Fragment添加到Activity中\" class=\"headerlink\" title=\"七 将Fragment添加到Activity中\"></a>七 将Fragment添加到Activity中</h3><p>通常，fragment构建了其宿主activity的部分界面，它被作为activity全部视图层次体系的一部分被嵌入进去。在acitivity布局中添加fragment有两种方法：     </p>\n<h5 id=\"在activity的布局文件里声明fragment\"><a href=\"#在activity的布局文件里声明fragment\" class=\"headerlink\" title=\"在activity的布局文件里声明fragment\"></a>在activity的布局文件里声明fragment</h5><p>像这样，你可以像为view一样为fragment指定布局属性。例如，下面含有两个fragment的布局文件：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\">\t&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"</div><div class=\"line\">\t\tandroid:orientation=\"horizontal\"</div><div class=\"line\">\t\tandroid:layout_width=\"match_parent\"</div><div class=\"line\">\t\tandroid:layout_height=\"match_parent\"&gt;</div><div class=\"line\">\t\t&lt;fragment android:name=\"com.example.news.ArticleListFragment\"</div><div class=\"line\">\t\t\t\tandroid:id=\"@+id/list\"</div><div class=\"line\">\t\t\t\tandroid:layout_weight=\"1\"</div><div class=\"line\">\t\t\t\tandroid:layout_width=\"0dp\"</div><div class=\"line\">\t\t\t\tandroid:layout_height=\"match_parent\" /&gt;</div><div class=\"line\">\t\t&lt;fragment android:name=\"com.example.news.ArticleReaderFragment\"</div><div class=\"line\">\t\t\t\tandroid:id=\"@+id/viewer\"</div><div class=\"line\">\t\t\t\tandroid:layout_weight=\"2\"</div><div class=\"line\">\t\t\t\tandroid:layout_width=\"0dp\"</div><div class=\"line\">\t\t\t\tandroid:layout_height=\"match_parent\" /&gt;</div><div class=\"line\">\t&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>\n<p><fragment>中的android:name 属性指定了布局中实例化的Fragment类。</p>\n<p>当系统创建activity布局时，它实例化了布局文件中指定的每一个fragment，并为它们调用onCreateView()函数，以获取每一个fragment的布局。系统直接在<fragment>元素的位置插入fragment返回的View。</p>\n<blockquote>\n<p>注意：每个fragment都需要一个唯一的标识，如果重启activity，系统可用来恢复fragment（并且可用来捕捉fragment的事务处理，例如移除）。为fragment提供ID有三种方法：   </p>\n<ul>\n<li>用android:id属性提供一个唯一的标识。   </li>\n<li>用android:tag属性提供一个唯一的字符串。   </li>\n<li>如果上述两个属性都没有，系统会使用其容器视图（view）的ID。 </li>\n</ul>\n</blockquote>\n<h5 id=\"通过java代码将fragment添加到已存在的ViewGroup中\"><a href=\"#通过java代码将fragment添加到已存在的ViewGroup中\" class=\"headerlink\" title=\"通过java代码将fragment添加到已存在的ViewGroup中\"></a>通过java代码将fragment添加到已存在的ViewGroup中</h5><p>在activity运行的任何时候，你都可以将fragment添加到activity布局中。你仅需要简单指定用来放置fragment的ViewGroup。</p>\n<p>你应当使用FragmentTransaction的API来对activity中的fragment进行操作（例如添加，移除，或者替换fragment）。你可以像下面这样从Activity中取得FragmentTransaction的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">FragmentManager fragmentManager = getFragmentManager()</div><div class=\"line\">\tFragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</div></pre></td></tr></table></figure>\n<p>可以用add()函数添加fragment，并指定要添加的fragment以及要将其插入到哪个视图（view）之中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ExampleFragment fragment = <span class=\"keyword\">new</span> ExampleFragment();</div><div class=\"line\">\tfragmentTransaction.add(R.id.fragment_container, fragment);</div><div class=\"line\">\tfragmentTransaction.commit();</div></pre></td></tr></table></figure>\n<p>传入add()函数的第一个参数是fragment被放置的ViewGroup，它由资源ID（resource ID）指定，第二个参数就是要添加的fragment。一旦通过FragmentTransaction 做了更改，都应当使用commit()使变化生效。</p>\n<h5 id=\"添加无界面的Fragment\"><a href=\"#添加无界面的Fragment\" class=\"headerlink\" title=\"添加无界面的Fragment\"></a>添加无界面的Fragment</h5><p>上面的例子是如何将fragment添加到activity中去，目的是提供一个用户界面。然而，也可以使用fragment为activity提供后台动作，却不呈现多余的用户界面。</p>\n<p>想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。</p>\n<p>想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。  </p>\n<h3 id=\"八-Fragment事务后台栈\"><a href=\"#八-Fragment事务后台栈\" class=\"headerlink\" title=\"八 Fragment事务后台栈\"></a>八 Fragment事务后台栈</h3><p>在activity中使用fragment的一大特点是具有添加、删除、替换，和执行其它动作的能力，以响应用户的互动。提交给activity的每一系列变化被称为事务，并且可以用FragmentTransaction 中的APIs处理。你也可以将每一个事务保存在由activity管理的后台栈中，并且允许用户导航回退fragment变更（类似于activity的导航回退）。  </p>\n<p>你可以从FragmentManager中获取FragmentTransaction实例，像这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">FragmentManager fragmentManager = getFragmentManager();</div><div class=\"line\"> FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</div></pre></td></tr></table></figure>\n<p>每项事务是在同一时间内要执行的一系列的变更。你可以为一个给定的事务用相关方法设置想要执行的所有变化，例如add()，remove()，和replace()。然后，用commit()将事务提交给activity。然而，在调用commit()之前，为了将事务添加到fragment事务后台栈中，你可能会想调用addToBackStatck()。这个后台栈由activity管理，并且允许用户通过按BACK键回退到前一个fragment状态。<br>举个例子，下面的代码是如何使用另一个fragment代替一个fragment，并且将之前的状态保留在后台栈中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Create new fragment and transaction</span></div><div class=\"line\"> Fragment newFragment = <span class=\"keyword\">new</span> ExampleFragment();</div><div class=\"line\"> FragmentTransaction transaction = getFragmentManager().beginTransaction();</div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">// Replace whatever is in the fragment_container view with this fragment,</span></div><div class=\"line\"> <span class=\"comment\">// and add the transaction to the back stack</span></div><div class=\"line\"> transaction.replace(R.id.fragment_container, newFragment);</div><div class=\"line\"> transaction.addToBackStack(<span class=\"keyword\">null</span>);</div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">// Commit the transaction</span></div><div class=\"line\"> transaction.commit();</div></pre></td></tr></table></figure>\n<p>在这个例子中，newFragment替换了当前在布局容器中用R.id.fragment_container标识的所有的fragment（如果有的话），替代的事务被保存在后台栈中，因此用户可以回退该事务，可通过按BACK键还原之前的fragment。如果添加多个变更事务（例如另一个add()或者remove()）并调用addToBackStack()，那么在调用commit()之前的所有应用的变更被作为一个单独的事务添加到后台栈中，并且BACK键可以将它们一起回退。</p>\n<p>将变更添加到FragmentTransaction中的顺序注意以下两点：     </p>\n<ul>\n<li>必须要在最后调用commit()   </li>\n<li>如果你正将多个fragment添加到同一个容器中，那么添加顺序决定了它们在视图层次（view hierarchy）里显示的顺序。 </li>\n</ul>\n<p>在执行删除fragment事务时，如果没有调用addToBackStack()，那么事务一提交fragment就会被销毁，而且用户也无法回退它。然而，当移除一个fragment时，如果调用了addToBackStack()，那么之后fragment会被停止，如果用户回退，它将被恢复过来。     </p>\n<blockquote>\n<p>提示：对于每一个fragment事务，在提交之前通过调用setTransition()来应用一系列事务动作。     </p>\n</blockquote>\n<p>调用commit()并不立刻执行事务，相反，而是采取预约方式，一旦activity的界面线程（主线程）准备好便可运行起来。然而，如果有必要的话，你可以从界面线程调用executePendingTransations()立即执行由commit()提交的事务。但这样做，通常是没有必要的，除非其它线程的工作依赖与该项事务。</p>\n<blockquote>\n<p>警告：只能在activity保存状态（当用户离开activity时）之前用commit()提交事务。如果你尝试在那时之后提交，会抛出一个异常。这是因为如果activity需要被恢复，提交后的状态会被丢失。对于这类丢失提交的情况，可使用commitAllowingStateLoss() </p>\n</blockquote>\n<h3 id=\"九-与Activity交互\"><a href=\"#九-与Activity交互\" class=\"headerlink\" title=\"九 与Activity交互\"></a>九 与Activity交互</h3><h5 id=\"1-Fragment可以得到宿主Activity的引用\"><a href=\"#1-Fragment可以得到宿主Activity的引用\" class=\"headerlink\" title=\"1.Fragment可以得到宿主Activity的引用\"></a>1.Fragment可以得到宿主Activity的引用</h5><p>尽管Fragment被实现为一个对象，它独立于Activity并可以在多个Activity中使用，一个给定的fragment实例直接被捆绑在包含它的Activity中。特别是，fragment可以通过getActivity()函数访问Activity，并且很容易的执行类似于查找activity布局中的视图的任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">View listView = getActivity().findViewById(R.id.list);</div></pre></td></tr></table></figure>\n<h5 id=\"2-Activity获取Fragment的引用\"><a href=\"#2-Activity获取Fragment的引用\" class=\"headerlink\" title=\"2.Activity获取Fragment的引用\"></a>2.Activity获取Fragment的引用</h5><p>同样的，activity能够调用fragment的函数findFragmentById()或者findFragmentByTag()，从FragmentManager中获取Fragment的索引，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);</div></pre></td></tr></table></figure>\n<h5 id=\"3-创建Activity时间回调函数\"><a href=\"#3-创建Activity时间回调函数\" class=\"headerlink\" title=\"3.创建Activity时间回调函数\"></a>3.创建Activity时间回调函数</h5><p>在一些情况下，你可能需要fragment与activity共享事件。这样做的一个好方法是在fragment内部定义一个回调接口，并需要宿主activity实现它。当activity通过接口接收到回调时，可以在必要时与布局中的其它fragment共享信息。<br>举个例子，如果新闻应用的actvity中有两个fragment——一个显示文章列表（fragment A），另一个显示一篇文章（fragment B）——然后fragment A 必须要告诉activity列表项何时被选种，这样，activity可以通知fragment B显示这篇文章。这种情况下，在fragment A内部声明接口OnArticleSelectedListener：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentA</span> <span class=\"keyword\">extends</span> <span class=\"title\">ListFragment</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"comment\">// Container Activity must implement this interface</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnArticleSelectedListener</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onArticleSelected</span><span class=\"params\">(Uri articleUri)</span></span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后fragment的宿主activity实现了OnArticleSelectedListener接口，并且重写onArticleSelected()以通知fragment B来自于fragment A的事件。为了确保宿主activity实现了这个接口，fragment A的onAttach()回调函数（当添加fragment到activity中时系统会调用它）通过作为参数传入onAttach()的activity的类型转换来实例化一个OnArticleSelectedListener实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentA</span> <span class=\"keyword\">extends</span> <span class=\"title\">ListFragment</span> </span>&#123;</div><div class=\"line\">    OnArticleSelectedListener mListener;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAttach</span><span class=\"params\">(Activity activity)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onAttach(activity);</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            mListener = (OnArticleSelectedListener) activity;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassCastException e) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassCastException(activity.toString() + <span class=\"string\">\" must implement OnArticleSelectedListener\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果activity没有实现这个接口，那么fragment会抛出一个ClassCaseException异常。一旦成功，mListener成员会保留一个activity的OnArticleSelectedListener实现的引用，由此fragment A可以通过调用由OnArticleSelectedListener接口定义的方法与activity共享事件。例如，如果fragment A是ListFragment的子类，每次用户点击列表项时，系统都会调用fragment的onListItemClick()事件，然后fragment调用onArticleSelected()来与activity共享事件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentA</span> <span class=\"keyword\">extends</span> <span class=\"title\">ListFragment</span> </span>&#123;</div><div class=\"line\">    OnArticleSelectedListener mListener;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onListItemClick</span><span class=\"params\">(ListView l, View v, <span class=\"keyword\">int</span> position, <span class=\"keyword\">long</span> id)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Append the clicked item's row ID with the content provider Uri</span></div><div class=\"line\">        Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);</div><div class=\"line\">        <span class=\"comment\">// Send the event and Uri to the host activity</span></div><div class=\"line\">        mListener.onArticleSelected(noteUri);</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>传递给onListItemClick()的参数id是点击的列表项行id，activity（或者其它fragment）用以从应用的ContentProvider获取文章。</p>\n<p>#####　添加items到Action Bar</p>\n<p>你的fragments可以通过实现onCreateOptionsMenu()来构建菜单项到activity的Options Menu（因此Action Bar也一样）。为了使用这个方法接收到调用，不管怎样，你必须在onCreate()期间调用setHasOptionsMenu()，来指明想要添加项目到Options Menu的那个fragment（否则，fragment将接收不到onCreateOptionsMenu()的调用）。<br>任何想要在fragment中的Options Menu添加的项目都追加到已有的菜单项后面。当菜单项被选中时，fragment也会接收到对onOptionsItemSelected()的回调。<br>你也可以通过调用registerForContextMenu()在fragment布局中注册一个view以提供一个context menu。当用户打开context menu时，fragment接收到对onCreateContextMenu()的回调。当用户选中一个项目时，fragment接收到对onContextItemSelected()的回调。</p>\n<blockquote>\n<p>注意：尽管你的fragment会接收到为添加到每个菜单项被选择菜单项的回调，但当用户选择一个菜单项时，activity会首先接收到对应的回调。如果activity的选择菜单项回调的实现没有处理被选中的项目，那么该事件被传递给fragment的回调。这同样适用于Options Menu和context menu。</p>\n</blockquote>\n<h3 id=\"十-总结\"><a href=\"#十-总结\" class=\"headerlink\" title=\"十 总结\"></a>十 总结</h3>"}],"PostAsset":[{"_id":"source/_posts/android基础之Service/Service生命周期图.png","slug":"Service生命周期图.png","post":"cizz09fte0003aonza5029hwx","modified":0,"renderable":0},{"_id":"source/_posts/android基础之activity/Activity状态保存示意图.png","slug":"Activity状态保存示意图.png","post":"cizz09fte0004aonzxdrgabhp","modified":0,"renderable":0},{"_id":"source/_posts/android基础之activity/activity回调方法汇总.png","slug":"activity回调方法汇总.png","post":"cizz09fte0004aonzxdrgabhp","modified":0,"renderable":0},{"_id":"source/_posts/android基础之activity/activity生命周期图.png","slug":"activity生命周期图.png","post":"cizz09fte0004aonzxdrgabhp","modified":0,"renderable":0},{"_id":"source/_posts/android基础之Fragments/Fragment与Activity生命周期对比.png","slug":"Fragment与Activity生命周期对比.png","post":"cizz0cpnc00004wnz7u9sr090","modified":0,"renderable":0},{"_id":"source/_posts/android基础之Fragments/Fragment显示图.png","slug":"Fragment显示图.png","post":"cizz0cpnc00004wnz7u9sr090","modified":0,"renderable":0},{"_id":"source/_posts/android基础之Fragments/Fragment生命周期图.png","slug":"Fragment生命周期图.png","post":"cizz0cpnc00004wnz7u9sr090","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cizz09fte0003aonza5029hwx","category_id":"cizz09ftg0005aonznymvtcu0","_id":"cizz09ftx000daonz6zjatvio"},{"post_id":"cizz09fte0004aonzxdrgabhp","category_id":"cizz09ftg0005aonznymvtcu0","_id":"cizz09fu2000haonza3yr2gjl"},{"post_id":"cizz09fu8000paonzr93nn5ng","category_id":"cizz09fua000taonzczca9cbw","_id":"cizz09fub000yaonzik78f92b"},{"post_id":"cizz09fu9000raonz9rp6qshw","category_id":"cizz09fua000taonzczca9cbw","_id":"cizz09fuc0012aonzrmn9u3h8"},{"post_id":"cizz0cpnc00004wnz7u9sr090","category_id":"cizz09ftg0005aonznymvtcu0","_id":"cizz0cpnj00024wnzf2jszqp3"},{"post_id":"cizz09ft60000aonzbu39zxst","category_id":"cizz09ftg0005aonznymvtcu0","_id":"cizzdtg530001xgnzpu85hypl"},{"post_id":"cizz09fta0001aonz46fftrf2","category_id":"cizz09ftg0005aonznymvtcu0","_id":"cizzdtg530002xgnzychjtdmr"},{"post_id":"cizz09ftd0002aonz04754wf9","category_id":"cizz09ftg0005aonznymvtcu0","_id":"cj00gcdzd0001t8nz4ednz9q9"}],"PostTag":[{"post_id":"cizz09fte0003aonza5029hwx","tag_id":"cizz09fto0006aonzcd7mri0b","_id":"cizz09fu6000laonzdr40c6an"},{"post_id":"cizz09fte0003aonza5029hwx","tag_id":"cizz09ftt000baonzvtf1zi4y","_id":"cizz09fu8000naonztih8upkb"},{"post_id":"cizz09fte0003aonza5029hwx","tag_id":"cizz09ftz000faonz10yone86","_id":"cizz09fu9000qaonz3zy1gdw1"},{"post_id":"cizz09fte0004aonzxdrgabhp","tag_id":"cizz09ftt000baonzvtf1zi4y","_id":"cizz09fub000waonzkkcuvs2i"},{"post_id":"cizz09fte0004aonzxdrgabhp","tag_id":"cizz09fto0006aonzcd7mri0b","_id":"cizz09fub000xaonzhyngqofl"},{"post_id":"cizz09fte0004aonzxdrgabhp","tag_id":"cizz09fua000saonzqpjxn9c8","_id":"cizz09fuc0010aonzxerj872d"},{"post_id":"cizz09fu8000paonzr93nn5ng","tag_id":"cizz09fub000uaonz3bwvvjjt","_id":"cizz09fuc0011aonz7i5tpmyq"},{"post_id":"cizz09fu9000raonz9rp6qshw","tag_id":"cizz09fub000uaonz3bwvvjjt","_id":"cizz09fud0013aonzuzwtxhcm"},{"post_id":"cizz0cpnc00004wnz7u9sr090","tag_id":"cizz09fto0006aonzcd7mri0b","_id":"cizz0cpnk00034wnzmyv4v9b4"},{"post_id":"cizz0cpnc00004wnz7u9sr090","tag_id":"cizz09ftt000baonzvtf1zi4y","_id":"cizz0cpnl00044wnz1cz73owy"},{"post_id":"cizz0cpnc00004wnz7u9sr090","tag_id":"cizz0cpnf00014wnzsnoh53ou","_id":"cizz0cpnl00054wnzvxgdnlub"},{"post_id":"cizz09ft60000aonzbu39zxst","tag_id":"cizz09fto0006aonzcd7mri0b","_id":"cizzdtg540004xgnzrp4j68ss"},{"post_id":"cizz09ft60000aonzbu39zxst","tag_id":"cizz09ftt000baonzvtf1zi4y","_id":"cizzdtg540005xgnzejsl2nxn"},{"post_id":"cizz09ft60000aonzbu39zxst","tag_id":"cizzdtg4y0000xgnzfdj43x33","_id":"cizzdtg550006xgnzopidrl7a"},{"post_id":"cizz09fta0001aonz46fftrf2","tag_id":"cizz09fto0006aonzcd7mri0b","_id":"cizzdtg550007xgnzkz71hjeo"},{"post_id":"cizz09fta0001aonz46fftrf2","tag_id":"cizz09ftt000baonzvtf1zi4y","_id":"cizzdtg560008xgnzu7cziqgo"},{"post_id":"cizz09fta0001aonz46fftrf2","tag_id":"cizzdtg540003xgnzcar8p7mh","_id":"cizzdtg560009xgnzbhjq6va1"},{"post_id":"cizz09ftd0002aonz04754wf9","tag_id":"cizz09fto0006aonzcd7mri0b","_id":"cj00gcdze0003t8nzucf6avct"},{"post_id":"cizz09ftd0002aonz04754wf9","tag_id":"cizz09ftt000baonzvtf1zi4y","_id":"cj00gcdze0004t8nz5qdwl2g1"},{"post_id":"cizz09ftd0002aonz04754wf9","tag_id":"cj00gcdz80000t8nzrpxx16eg","_id":"cj00gcdze0005t8nz6rf1hzi0"},{"post_id":"cizz09ftd0002aonz04754wf9","tag_id":"cj00gcdze0002t8nz1na15533","_id":"cj00gcdze0006t8nzaa0liyut"}],"Tag":[{"name":"android","_id":"cizz09fto0006aonzcd7mri0b"},{"name":"java","_id":"cizz09ftt000baonzvtf1zi4y"},{"name":"service","_id":"cizz09ftz000faonz10yone86"},{"name":"activity","_id":"cizz09fua000saonzqpjxn9c8"},{"name":"hexo","_id":"cizz09fub000uaonz3bwvvjjt"},{"name":"Fragment","_id":"cizz0cpnf00014wnzsnoh53ou"},{"name":"BroadcastReceiver","_id":"cizzdtg4y0000xgnzfdj43x33"},{"name":"Content Provider","_id":"cizzdtg540003xgnzcar8p7mh"},{"name":"Intent","_id":"cj00gcdz80000t8nzrpxx16eg"},{"name":"IntentFilter","_id":"cj00gcdze0002t8nz1na15533"}]}}