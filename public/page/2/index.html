<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ZHENGRUI&#39;BLOG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="ZHENGRUI'BLOG">
<meta property="og:url" content="https://zhezaoyizhuding.github.io/page/2/index.html">
<meta property="og:site_name" content="ZHENGRUI'BLOG">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZHENGRUI'BLOG">
  
  
    <link rel="icon" href="/favicon.png">
  
  <!-- <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'> -->
  <!-- <link href="//fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <link href="//fonts.useso.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css">
  <link href='//fonts.useso.com/css?family=Open+Sans:300,600' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <a href="/" class="logo">ZHENGRUI&#39;BLOG</a>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about/index.html">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://zhezaoyizhuding.github.io"></form>
        </div>
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
        
        
      </nav>
    </div>
  </div>
</header>
      <nav id="mobile-nav" class="off">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about/index.html" class="mobile-nav-link">About</a>
  
  <div id="search-form-wrap-mobile">
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://zhezaoyizhuding.github.io"></form>
  </div>
</nav>
      <div class="outer">
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">16</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/19/Java基础之内存管理/">Java基础之内存管理</a>
          </li>
        
          <li>
            <a href="/2017/03/19/Java基础之反射与类加载器/">Java基础之反射与类加载器</a>
          </li>
        
          <li>
            <a href="/2017/03/17/Java基础之流/">Java基础之流</a>
          </li>
        
          <li>
            <a href="/2017/03/17/Java基础之异常/">Java基础之异常</a>
          </li>
        
          <li>
            <a href="/2017/03/17/Java基础语法/">Java基础语法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AsycTask/">AsycTask</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BroadcastReceiver/">BroadcastReceiver</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Content-Provider/">Content Provider</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fragment/">Fragment</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Handler/">Handler</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Intent/">Intent</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IntentFilter/">IntentFilter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/List/">List</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Map/">Map</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLite/">SQLite</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Set/">Set</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/View/">View</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ViewGroup/">ViewGroup</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/activity/">activity</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/loader/">loader</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pull/">pull</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/push/">push</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/service/">service</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/view/">view</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事件分发/">事件分发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存管理/">内存管理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/垃圾回收/">垃圾回收</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异常/">异常</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/推送/">推送</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据存储/">数据存储</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/泛型/">泛型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/注解/">注解</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/注释/">注释</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程/">线程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/缓存/">缓存</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/长连接/">长连接</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/集合/">集合</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AsycTask/" style="font-size: 10px;">AsycTask</a> <a href="/tags/BroadcastReceiver/" style="font-size: 10px;">BroadcastReceiver</a> <a href="/tags/Content-Provider/" style="font-size: 10px;">Content Provider</a> <a href="/tags/Fragment/" style="font-size: 10px;">Fragment</a> <a href="/tags/Handler/" style="font-size: 10px;">Handler</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/Intent/" style="font-size: 10px;">Intent</a> <a href="/tags/IntentFilter/" style="font-size: 10px;">IntentFilter</a> <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/List/" style="font-size: 10px;">List</a> <a href="/tags/Map/" style="font-size: 10px;">Map</a> <a href="/tags/SQLite/" style="font-size: 10px;">SQLite</a> <a href="/tags/Set/" style="font-size: 10px;">Set</a> <a href="/tags/View/" style="font-size: 10px;">View</a> <a href="/tags/ViewGroup/" style="font-size: 10px;">ViewGroup</a> <a href="/tags/activity/" style="font-size: 10px;">activity</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/hexo/" style="font-size: 13.33px;">hexo</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/loader/" style="font-size: 10px;">loader</a> <a href="/tags/pull/" style="font-size: 10px;">pull</a> <a href="/tags/push/" style="font-size: 10px;">push</a> <a href="/tags/service/" style="font-size: 10px;">service</a> <a href="/tags/view/" style="font-size: 10px;">view</a> <a href="/tags/事件分发/" style="font-size: 10px;">事件分发</a> <a href="/tags/内存管理/" style="font-size: 10px;">内存管理</a> <a href="/tags/垃圾回收/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/异常/" style="font-size: 10px;">异常</a> <a href="/tags/推送/" style="font-size: 10px;">推送</a> <a href="/tags/数据存储/" style="font-size: 10px;">数据存储</a> <a href="/tags/泛型/" style="font-size: 10px;">泛型</a> <a href="/tags/注解/" style="font-size: 10px;">注解</a> <a href="/tags/注释/" style="font-size: 10px;">注释</a> <a href="/tags/线程/" style="font-size: 10px;">线程</a> <a href="/tags/缓存/" style="font-size: 10px;">缓存</a> <a href="/tags/长连接/" style="font-size: 10px;">长连接</a> <a href="/tags/集合/" style="font-size: 10px;">集合</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">links</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://hexo.io">Hexo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
        <section id="main">
  
    <article id="post-android基础之事件分发机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/28/android基础之事件分发机制/" class="article-date">
  <time datetime="2017-02-28T10:25:28.000Z" itemprop="datePublished">2017-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/28/android基础之事件分发机制/">android基础之事件分发机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>在android开发中会经常遇到滑动冲突（比如ScrollView或是SliddingMenu与ListView的嵌套）的问题，需要我们深入的了解android事件响应机制才能解决，事件响应机制已经是android开发者必不可少的知识。</p>
<h3 id="二-涉及到事件响应的常用方法构成"><a href="#二-涉及到事件响应的常用方法构成" class="headerlink" title="二 涉及到事件响应的常用方法构成"></a>二 涉及到事件响应的常用方法构成</h3><p>用户在手指与屏幕接触过程中通过MotionEvent对象产生一系列事件，它有四种状态： </p>
<ul>
<li>MotionEvent.ACTION_DOWN　：手指按下屏幕的瞬间（一切事件的开始）</li>
<li>MotionEvent.ACTION_MOVE　：手指在屏幕上移动</li>
<li>MotionEvent.ACTION_UP　：手指离开屏幕瞬间</li>
<li>MotionEvent.ACTION_CANCEL 　：取消手势，一般由程序产生，不会由用户产生</li>
</ul>
<p>Android中的事件onClick, onLongClick，onScroll, onFling等等，都是由许多个Touch事件构成的（一个ACTION_DOWN， n个ACTION_MOVE，1个ACTION_UP）。</p>
<p>android 事件响应机制是先分发（先由外部的View接收，然后依次传递给其内层的最小View）再处理 （从最小View单元（事件源）开始依次向外层传递。）的形式实现的。</p>
<p>复杂性表现在：可以控制每层事件是否继续传递（分发和拦截协同实现），以及事件的具体消费（事件分发也具有事件消费能力）。</p>
<h3 id="三-android事件处理涉及到的三个重要函数"><a href="#三-android事件处理涉及到的三个重要函数" class="headerlink" title="三 android事件处理涉及到的三个重要函数"></a>三 android事件处理涉及到的三个重要函数</h3><h5 id="1-事件分发：public-boolean-dispatchTouchEvent-MotionEvent-ev"><a href="#1-事件分发：public-boolean-dispatchTouchEvent-MotionEvent-ev" class="headerlink" title="1.事件分发：public boolean dispatchTouchEvent(MotionEvent ev)"></a>1.事件分发：public boolean dispatchTouchEvent(MotionEvent ev)</h5><p>当有监听到事件时，首先由Activity进行捕获，进入事件分发处理流程。（因为activity没有事件拦截，View和ViewGroup有）会将事件传递给最外层View的dispatchTouchEvent(MotionEvent ev)方法，该方法对事件进行分发。 </p>
<ul>
<li><p>return true ：表示该View内部消化掉了所有事件。</p>
</li>
<li><p>return false ：事件在本层不再继续进行分发，并交由上层控件的onTouchEvent方法进行消费（如果本层控件已经是Activity，那么事件将被系统消费或处理）。　</p>
</li>
<li><p>如果事件分发返回系统默认的 super.dispatchTouchEvent(ev)，事件将分发给本层的事件拦截onInterceptTouchEvent 方法进行处理</p>
</li>
</ul>
<h5 id="2-事件拦截：public-boolean-onInterceptTouchEvent-MotionEvent-ev"><a href="#2-事件拦截：public-boolean-onInterceptTouchEvent-MotionEvent-ev" class="headerlink" title="2.事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)"></a>2.事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)</h5><ul>
<li><p>return true ：表示将事件进行拦截，并将拦截到的事件交由本层控件 的 onTouchEvent 进行处理；</p>
</li>
<li><p>return false ：则表示不对事件进行拦截，事件得以成功分发到子View。并由子View的dispatchTouchEvent进行处理。　</p>
</li>
<li><p>如果返回super.onInterceptTouchEvent(ev)，默认表示拦截该事件，并将事件传递给当前View的onTouchEvent方法，和return true一样。</p>
</li>
</ul>
<h5 id="3-事件响应：public-boolean-onTouchEvent-MotionEvent-ev"><a href="#3-事件响应：public-boolean-onTouchEvent-MotionEvent-ev" class="headerlink" title="3.事件响应：public boolean onTouchEvent(MotionEvent ev)"></a>3.事件响应：public boolean onTouchEvent(MotionEvent ev)</h5><p>在dispatchTouchEvent（事件分发）返回super.dispatchTouchEvent(ev)并且onInterceptTouchEvent（事件拦截返回true或super.onInterceptTouchEvent(ev)的情况下，那么事件会传递到onTouchEvent方法，该方法对事件进行响应。</p>
<ul>
<li><p>如果return true，表示onTouchEvent处理完事件后消费了此次事件。此时事件终结；</p>
</li>
<li><p>如果return fasle，则表示不响应事件，那么该事件将会不断向上层View的onTouchEvent方法传递，直到某个View的onTouchEvent方法返回true，如果到了最顶层View还是返回false，那么认为该事件不消耗，则在同一个事件系列中，当前View无法再次接收到事件，该事件会交由Activity的onTouchEvent进行处理；　　</p>
</li>
<li><p>如果return super.dispatchTouchEvent(ev)，则表示不响应事件，结果与return false一样。</p>
</li>
</ul>
<p>从以上过程中可以看出，dispatchTouchEvent无论返回true还是false，事件都不再进行分发，只有当其返回super.dispatchTouchEvent(ev)，才表明其具有向下层分发的愿望，但是是否能够分发成功，则需要经过事件拦截onInterceptTouchEvent的审核。事件是否向上传递处理是由onTouchEvent的返回值决定的。</p>
<p>下面是Touch事件传递机制流程图：</p>
<img src="/2017/02/28/android基础之事件分发机制/Touch事件分发机制流程图.png" alt="Touch事件分发机制流程图" title="Touch事件分发机制流程图">
<h3 id="四-View源码分析"><a href="#四-View源码分析" class="headerlink" title="四 View源码分析"></a>四 View源码分析</h3><p>Android中ImageView、textView、Button等继承于View但没有重写的dispatchTouchEvent方法，所以都用的View的该方法进行事件分发。</p>
<p>看View重要函数部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line"><span class="comment">//返回true,表示该View内部消化掉了所有事件。返回false，表示View内部只处理了ACTION_DOWN事件，事件继续传递，向上级View(ViewGroup)传递。</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mOnTouchListener != <span class="keyword">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;</div><div class="line">            mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</div><div class="line">  <span class="comment">//此处的onTouch方式就是回调的我们注册OnTouchListener时重写的onTouch()方法</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> onTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先进行三个条件的判断：</p>
<ul>
<li>查看是否给button设置了OnTouchListener()事件；</li>
<li>控件是否Enable；（控件默认都是enable的）</li>
<li>button里面实现的OnTouchListener监听里的onTouch()方法是否返回true；</li>
</ul>
<p>如果条件都满足，则该事件被消耗掉，不再进入onTouchEvent中处理。否则将事件将交给onTouchEvent方法处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">   /＊ 当前onTouch的组件必须是可点击的比如Button，ImageButton等等，此处CLICKABLE为<span class="keyword">true</span>，才会进入<span class="keyword">if</span>方法，最后返回<span class="keyword">true</span>。</div><div class="line"> 如果是ImageView、TexitView这些默认为不可点击的View,此处CLICKABLE为<span class="keyword">false</span>，最后返回<span class="keyword">false</span>。当然会有特殊情况，如果给这些View设置了onClick监听器，此处CLICKABLE也将为<span class="keyword">true</span>　　＊／</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  </div><div class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;</div><div class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">                ...</div><div class="line">                            <span class="keyword">if</span> (!post(mPerformClick)) &#123;</div><div class="line">                                performClick();<span class="comment">// 实际就是回调了我们注册的OnClickListener中重新的onClick()方法</span></div><div class="line">                            &#125;</div><div class="line">                 ...</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">               ...</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</div><div class="line">                ...</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">               ...</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</div><div class="line">    ...</div><div class="line"> ／／</div><div class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</div><div class="line">        ...</div><div class="line">        li.mOnClickListener.onClick(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(OnClickListener l)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!isClickable()) &#123;</div><div class="line">        setClickable(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    getListenerInfo().mOnClickListener = l;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只有我们注册OnTouchListener时重写的 onTouch()方法中:</p>
<ul>
<li>返回false —&gt; 执行onTouchEvent方法 —&gt; 导致onClick()回调方法执行　</li>
<li>返回true —&gt; onTouchEvent方法不执行 —&gt; 导致onClick()回调方法不会执行</li>
</ul>
<h3 id="五-ViewGroup源码分析"><a href="#五-ViewGroup源码分析" class="headerlink" title="五 ViewGroup源码分析"></a>五 ViewGroup源码分析</h3><p>Android中诸如LinearLayout等的五大布局控件，都是继承自ViewGroup，而ViewGroup本身是继承自View，所以ViewGroup的事件处理机制对这些控件都有效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;  </div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();  </div><div class="line">       <span class="keyword">final</span> <span class="keyword">float</span> xf = ev.getX();  </div><div class="line">       <span class="keyword">final</span> <span class="keyword">float</span> yf = ev.getY();  </div><div class="line">       <span class="keyword">final</span> <span class="keyword">float</span> scrolledXFloat = xf + mScrollX;  </div><div class="line">       <span class="keyword">final</span> <span class="keyword">float</span> scrolledYFloat = yf + mScrollY;  </div><div class="line">       <span class="keyword">final</span> Rect frame = mTempRect;  </div><div class="line"></div><div class="line">       <span class="comment">//这个值默认是false, 然后我们可以通过requestDisallowInterceptTouchEvent(boolean disallowIntercept)方法  </span></div><div class="line">       <span class="comment">//来改变disallowIntercept的值  </span></div><div class="line">       <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;  </div><div class="line"></div><div class="line">       <span class="comment">//这里是ACTION_DOWN的处理逻辑  </span></div><div class="line">       <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;  </div><div class="line">        <span class="comment">//清除mMotionTarget, 每次ACTION_DOWN都很设置mMotionTarget为null  </span></div><div class="line">           <span class="keyword">if</span> (mMotionTarget != <span class="keyword">null</span>) &#123;  </div><div class="line">               mMotionTarget = <span class="keyword">null</span>;  </div><div class="line">           &#125;  </div><div class="line"></div><div class="line">           <span class="comment">//disallowIntercept默认是false, 就看ViewGroup的onInterceptTouchEvent()方法  </span></div><div class="line">           <span class="keyword">if</span> (disallowIntercept || !onInterceptTouchEvent(ev)) &#123;  <span class="comment">//第一点</span></div><div class="line">               ev.setAction(MotionEvent.ACTION_DOWN);  </div><div class="line">               <span class="keyword">final</span> <span class="keyword">int</span> scrolledXInt = (<span class="keyword">int</span>) scrolledXFloat;  </div><div class="line">               <span class="keyword">final</span> <span class="keyword">int</span> scrolledYInt = (<span class="keyword">int</span>) scrolledYFloat;  </div><div class="line">               <span class="keyword">final</span> View[] children = mChildren;  </div><div class="line">               <span class="keyword">final</span> <span class="keyword">int</span> count = mChildrenCount;  </div><div class="line">               <span class="comment">//遍历其子View  </span></div><div class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  <span class="comment">//第二点</span></div><div class="line">                   <span class="keyword">final</span> View child = children[i];  </div><div class="line"></div><div class="line">                   <span class="comment">//如果该子View是VISIBLE或者该子View正在执行动画, 表示该View才  </span></div><div class="line">                   <span class="comment">//可以接受到Touch事件  </span></div><div class="line">                   <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE  </div><div class="line">                           || child.getAnimation() != <span class="keyword">null</span>) &#123;  </div><div class="line">                    <span class="comment">//获取子View的位置范围  </span></div><div class="line">                       child.getHitRect(frame);  </div><div class="line"></div><div class="line">                       <span class="comment">//如Touch到屏幕上的点在该子View上面  </span></div><div class="line">                       <span class="keyword">if</span> (frame.contains(scrolledXInt, scrolledYInt)) &#123;  </div><div class="line">                           <span class="comment">// offset the event to the view's coordinate system  </span></div><div class="line">                           <span class="keyword">final</span> <span class="keyword">float</span> xc = scrolledXFloat - child.mLeft;  </div><div class="line">                           <span class="keyword">final</span> <span class="keyword">float</span> yc = scrolledYFloat - child.mTop;  </div><div class="line">                           ev.setLocation(xc, yc);  </div><div class="line">                           child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class="line"></div><div class="line">                           <span class="comment">//调用该子View的dispatchTouchEvent()方法  </span></div><div class="line">                           <span class="keyword">if</span> (child.dispatchTouchEvent(ev))  &#123;  </div><div class="line">                               <span class="comment">// 如果child.dispatchTouchEvent(ev)返回true表示  </span></div><div class="line">                            <span class="comment">//该事件被消费了，设置mMotionTarget为该子View  </span></div><div class="line">                               mMotionTarget = child;  </div><div class="line">                               <span class="comment">//直接返回true  </span></div><div class="line">                               <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">                           &#125;  </div><div class="line">                           <span class="comment">// The event didn't get handled, try the next view.  </span></div><div class="line">                           <span class="comment">// Don't reset the event's location, it's not  </span></div><div class="line">                           <span class="comment">// necessary here.  </span></div><div class="line">                       &#125;  </div><div class="line">                   &#125;  </div><div class="line">               &#125;  </div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line"></div><div class="line">       <span class="comment">//判断是否为ACTION_UP或者ACTION_CANCEL  </span></div><div class="line">       <span class="keyword">boolean</span> isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  </div><div class="line">               (action == MotionEvent.ACTION_CANCEL);  </div><div class="line"></div><div class="line">       <span class="keyword">if</span> (isUpOrCancel) &#123;  </div><div class="line">           <span class="comment">//如果是ACTION_UP或者ACTION_CANCEL, 将disallowIntercept设置为默认的false  </span></div><div class="line">        <span class="comment">//假如我们调用了requestDisallowInterceptTouchEvent()方法来设置disallowIntercept为true  </span></div><div class="line">        <span class="comment">//当我们抬起手指或者取消Touch事件的时候要将disallowIntercept重置为false  </span></div><div class="line">        <span class="comment">//所以说上面的disallowIntercept默认在我们每次ACTION_DOWN的时候都是false  </span></div><div class="line">           mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;  </div><div class="line">       &#125;  </div><div class="line"></div><div class="line">       <span class="comment">// The event wasn't an ACTION_DOWN, dispatch it to our target if  </span></div><div class="line">       <span class="comment">// we have one.  </span></div><div class="line">       <span class="keyword">final</span> View target = mMotionTarget;  </div><div class="line">       <span class="comment">//mMotionTarget为null意味着没有找到消费Touch事件的View, 所以我们需要调用ViewGroup父类的  </span></div><div class="line">       <span class="comment">//dispatchTouchEvent()方法，也就是View的dispatchTouchEvent()方法  </span></div><div class="line">       <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;  </div><div class="line">           <span class="comment">// We don't have a target, this means we're handling the  </span></div><div class="line">           <span class="comment">// event as a regular view.  </span></div><div class="line">           ev.setLocation(xf, yf);  </div><div class="line">           <span class="keyword">if</span> ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != <span class="number">0</span>) &#123;  </div><div class="line">               ev.setAction(MotionEvent.ACTION_CANCEL);  </div><div class="line">               mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class="line">           &#125;  </div><div class="line">           <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);  </div><div class="line">       &#125;  </div><div class="line"></div><div class="line">       <span class="comment">//这个if里面的代码ACTION_DOWN不会执行，只有ACTION_MOVE  </span></div><div class="line">       <span class="comment">//ACTION_UP才会走到这里, 假如在ACTION_MOVE或者ACTION_UP拦截的  </span></div><div class="line">       <span class="comment">//Touch事件, 将ACTION_CANCEL派发给target，然后直接返回true  </span></div><div class="line">       <span class="comment">//表示消费了此Touch事件  </span></div><div class="line">       <span class="keyword">if</span> (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) &#123;  </div><div class="line">           <span class="keyword">final</span> <span class="keyword">float</span> xc = scrolledXFloat - (<span class="keyword">float</span>) target.mLeft;  </div><div class="line">           <span class="keyword">final</span> <span class="keyword">float</span> yc = scrolledYFloat - (<span class="keyword">float</span>) target.mTop;  </div><div class="line">           mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class="line">           ev.setAction(MotionEvent.ACTION_CANCEL);  </div><div class="line">           ev.setLocation(xc, yc);  </div><div class="line"></div><div class="line">           <span class="keyword">if</span> (!target.dispatchTouchEvent(ev)) &#123;  </div><div class="line">           &#125;  </div><div class="line">           <span class="comment">// clear the target  </span></div><div class="line">           mMotionTarget = <span class="keyword">null</span>;  </div><div class="line">           <span class="comment">// Don't dispatch this event to our own view, because we already  </span></div><div class="line">           <span class="comment">// saw it when intercepting; we just want to give the following  </span></div><div class="line">           <span class="comment">// event to the normal onTouchEvent().  </span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">       &#125;  </div><div class="line"></div><div class="line">       <span class="keyword">if</span> (isUpOrCancel) &#123;  </div><div class="line">           mMotionTarget = <span class="keyword">null</span>;  </div><div class="line">       &#125;  </div><div class="line"></div><div class="line">       <span class="comment">// finally offset the event to the target's coordinate system and  </span></div><div class="line">       <span class="comment">// dispatch the event.  </span></div><div class="line">       <span class="keyword">final</span> <span class="keyword">float</span> xc = scrolledXFloat - (<span class="keyword">float</span>) target.mLeft;  </div><div class="line">       <span class="keyword">final</span> <span class="keyword">float</span> yc = scrolledYFloat - (<span class="keyword">float</span>) target.mTop;  </div><div class="line">       ev.setLocation(xc, yc);  </div><div class="line"></div><div class="line">       <span class="keyword">if</span> ((target.mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != <span class="number">0</span>) &#123;  </div><div class="line">           ev.setAction(MotionEvent.ACTION_CANCEL);  </div><div class="line">           target.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class="line">           mMotionTarget = <span class="keyword">null</span>;  </div><div class="line">       &#125;  </div><div class="line"></div><div class="line">       <span class="comment">//如果没有拦截ACTION_MOVE, ACTION_DOWN的话，直接将Touch事件派发给target  </span></div><div class="line">       <span class="keyword">return</span> target.dispatchTouchEvent(ev);  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>dispatchTouchEvent作用：决定事件是否由onInterceptTouchEvent来拦截处理。 返回super.dispatchTouchEvent时，由onInterceptTouchEvent来决定事件的流向 返回false时，会继续分发事件，自己内部只处理了ACTION_DOWN 返回true时，不会继续分发事件，自己内部处理了所有事件（ACTION_DOWN,ACTION_MOVE,ACTION_UP）</p>
</li>
<li><p>onInterceptTouchEvent作用：拦截事件，用来决定事件是否传向子View 返回true时，拦截后交给自己的onTouchEvent处理 返回false时，拦截后交给子View来处理</p>
</li>
<li><p>onTouchEvent作用：事件最终到达这个方法 返回true时，内部处理所有的事件，换句话说，后续事件将继续传递给该view的onTouchEvent()处理 返回false时，事件会向上传递，由onToucEvent来接受，如果最上面View中的onTouchEvent也返回false的话，那么事件就会消失</p>
</li>
</ul>
<h3 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h3><ul>
<li><p>如果ViewGroup找到了能够处理该事件的View，则直接交给子View处理，自己的onTouchEvent不会被触发；　</p>
</li>
<li><p>可以通过复写onInterceptTouchEvent(ev)方法，拦截子View的事件（即return true），把事件交给自己处理，则会执行自己对应的onTouchEvent方法。</p>
</li>
<li><p>子View可以通过调用getParent().requestDisallowInterceptTouchEvent(true); 阻止ViewGroup对其MOVE或者UP事件进行拦截；　　</p>
</li>
<li><p>一个点击事件产生后，它的传递过程如下： Activity-&gt;Window-&gt;View。顶级View接收到事件之后，就会按相应规则去分发事件。如果一个View的onTouchEvent方法返回false，那么将会交给父容器的onTouchEvent方法进行处理，逐级往上，如果所有的View都不处理该事件，则交由Activity的onTouchEvent进行处理。　</p>
</li>
<li><p>如果某一个View开始处理事件，如果他不消耗ACTION_DOWN事件（也就是onTouchEvent返回false），则同一事件序列比如接下来进行ACTION_MOVE，则不会再交给该View处理。</p>
</li>
<li><p>ViewGroup默认不拦截任何事件。　</p>
</li>
<li><p>诸如TextView、ImageView这些不作为容器的View，一旦接受到事件，就调用onTouchEvent方法，它们本身没有onInterceptTouchEvent方法。正常情况下，它们都会消耗事件（返回true），除非它们是不可点击的（clickable和longClickable都为false），那么就会交由父容器的onTouchEvent处理。　</p>
</li>
<li><p>点击事件分发过程如下 dispatchTouchEvent—-&gt;OnTouchListener的onTouch方法—-&gt;onTouchEvent–&gt;OnClickListener的onClick方法。也就是说，我们平时调用的setOnClickListener，优先级是最低的，所以，onTouchEvent或OnTouchListener的onTouch方法如果返回true，则不响应onClick方法…</p>
</li>
</ul>
<img src="/2017/02/28/android基础之事件分发机制/android事件分发.png" alt="一个据说很牛的图" title="一个据说很牛的图">

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/02/28/android基础之事件分发机制/" data-id="cj0m73bhe001dm0nzke6kstk5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/View/">View</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/事件分发/">事件分发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android基础之SQLite" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/28/android基础之SQLite/" class="article-date">
  <time datetime="2017-02-28T10:03:32.000Z" itemprop="datePublished">2017-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/28/android基础之SQLite/">android基础之SQLite</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的SQL数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。从Android1.5开始，Android就自带SQLite数据库了。</p>
<h3 id="二-特性"><a href="#二-特性" class="headerlink" title="二 特性"></a>二 特性</h3><ol>
<li>ACID事务 　</li>
<li>零配置 – 无需安装和管理配置 </li>
<li>储存在单一磁盘文件中的一个完整的数据库</li>
<li>数据库文件可以在不同字节顺序的机器间自由的共享</li>
<li>支持数据库大小至2TB</li>
<li>足够小, 大致3万行C代码, 250K</li>
<li>比一些流行的数据库在大部分普通数据库操作要快</li>
<li>简单, 轻松的API</li>
<li>包含TCL绑定, 同时通过Wrapper支持其他语言的绑定</li>
<li>良好注释的源代码, 并且有着90%以上的测试覆盖率  </li>
<li>独立: 没有额外依赖</li>
<li>Source完全的Open, 你可以用于任何用途, 包括出售它</li>
<li>支持多种开发语言，C，PHP，Perl，Java，ASP.NET，Python　　</li>
</ol>
<h3 id="在Android中使用SQLite"><a href="#在Android中使用SQLite" class="headerlink" title="在Android中使用SQLite"></a>在Android中使用SQLite</h3><p>Activites 可以通过 Content Provider 或者 Service 访问一个数据库。</p>
<h5 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1.创建数据库"></a>1.创建数据库</h5><p>Android 不自动提供数据库。在 Android 应用程序中使用 SQLite，必须自己创建数据库，然后创建表、索引，填充数据。Android 提供了 SQLiteOpenHelper 帮助你创建一个数据库，你只要继承 SQLiteOpenHelper 类根据开发应用程序的需要，封装创建和更新数据库使用的逻辑就行了。　 </p>
<p>SQLiteOpenHelper 的子类，至少需要实现三个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> context  上下文环境（例如，一个 Activity）</div><div class="line">     * <span class="doctag">@param</span> name   数据库名字</div><div class="line">     * <span class="doctag">@param</span> factory  一个可选的游标工厂（通常是 Null）</div><div class="line">     * <span class="doctag">@param</span> version  数据库模型版本的整数</div><div class="line">     * </div><div class="line">     * 会调用父类 SQLiteOpenHelper的构造函数</div><div class="line">     */ </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DatabaseHelper</span><span class="params">(Context context, String name, CursorFactory factory, <span class="keyword">int</span> version)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, name, factory, version);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  在数据库第一次创建的时候会调用这个方法</div><div class="line">     *  </div><div class="line">     *根据需要对传入的SQLiteDatabase 对象填充表和初始化数据。</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 当数据库需要修改的时候（两个数据库版本不同），Android系统会主动的调用这个方法。</div><div class="line">     * 一般我们在这个方法里边删除数据库表，并建立新的数据库表.</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</div><div class="line">        <span class="comment">//三个参数，一个 SQLiteDatabase 对象，一个旧的版本号和一个新的版本号</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</div><div class="line">        <span class="comment">// 每次成功打开数据库后首先被执行</span></div><div class="line">        <span class="keyword">super</span>.onOpen(db);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继承SQLiteOpenHelper之后就拥有了以下两个方法：</p>
<ul>
<li>getReadableDatabase() 　创建或者打开一个查询数据库</li>
<li>getWritableDatabase()　创建或者打开一个可写数据库</li>
</ul>
<p>创建一个数据库代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">DatabaseHelper database = <span class="keyword">new</span> DatabaseHelper(context);<span class="comment">//传入一个上下文参数</span></div><div class="line">SQLiteDatabase db = <span class="keyword">null</span>;</div><div class="line">db = database.getWritableDatabase();</div></pre></td></tr></table></figure>
<p>上面这段代码会返回一个 SQLiteDatabase 类的实例，使用这个对象，你就可以查询或者修改数据库。SQLiteDatabase类为我们提供了很多种方法，而较常用的方法如下：</p>
<p>删除数据行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">int</span>) delete(String table,String whereClause,String[] whereArgs)</div></pre></td></tr></table></figure>
<p>添加数据行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">long</span>) insert(String table,String nullColumnHack,ContentValues values)</div></pre></td></tr></table></figure>
<p>更新数据行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">int</span>) update(String table, ContentValues values, String whereClause, String[] whereArgs)</div></pre></td></tr></table></figure>
<p>执行一个SQL语句，可以是一个select或其他的sql语句(没有返回值的sql语句)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">void</span>) execSQL(String sql)</div></pre></td></tr></table></figure>
<p>关闭数据库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">void</span>) close()</div></pre></td></tr></table></figure>
<p>查询指定的数据表返回一个带游标的数据集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*各参数说明： table：表名称 colums：列名称数组 selection：条件子句，相当于where selectionArgs：条件//*语句的参数数组 groupBy：分组 having：分组条件 orderBy：排序类 limit：分页查询的限制 Cursor：返回值，相*当于结果集ResultSet*/</span></div><div class="line">(Cursor) query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit)</div></pre></td></tr></table></figure>
<p>运行一个预置的SQL语句，返回带游标的数据集（与上面的语句最大的区别就是防止SQL注入）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(Cursor) rawQuery(String sql, String[] selectionArgs)</div></pre></td></tr></table></figure>
<p>当你完成了对数据库的操作（例如你的 Activity 已经关闭），需要调用 SQLiteDatabase 的 Close() 方法来释放掉数据库连接。</p>
<h5 id="2-创建表和索引"><a href="#2-创建表和索引" class="headerlink" title="2.创建表和索引"></a>2.创建表和索引</h5><p>为了创建表和索引，需要调用 SQLiteDatabase 的 execSQL() 方法来执行 DDL 语句。如果没有异常，这个方法没有返回值。 　　</p>
<p>例如，你可以执行如下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">db.execSQL("CREATE TABLE user(_id INTEGER PRIMARY KEY   </div><div class="line">       AUTOINCREMENT, username TEXT, password TEXT);");</div></pre></td></tr></table></figure>
<p>这条语句会创建一个名为 user的表，表有一个列名为 _id，并且是主键，这列的值是会自动增长的整数。另外还有两列：username( 字符 ) 和 password( 字符 )。 SQLite 会自动为主键列创建索引。 　　</p>
<p>通常情况下，第一次创建数据库时创建了表和索引。要 删除表和索引，需要使用 execSQL() 方法调用 DROP INDEX 和 DROP TABLE 语句。</p>
<h5 id="3-添加数据"><a href="#3-添加数据" class="headerlink" title="3.添加数据"></a>3.添加数据</h5><p>有两种方法可以给表添加数据。</p>
<p>a. 可以使用 execSQL() 方法执行 INSERT, UPDATE, DELETE 等语句来更新表的数据。execSQL() 方法适用于所有不返回结果的 SQL 语句。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String sql = "insert into user(username,password) values ('finch','123456');//插入操作的SQL语句</div><div class="line">db.execSQL(sql);//执行SQL语句</div></pre></td></tr></table></figure>
<p>b. 使用 SQLiteDatabase 对象的 insert()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ContentValues cv = <span class="keyword">new</span> ContentValues();</div><div class="line">cv.put(<span class="string">"username"</span>,<span class="string">"finch"</span>);<span class="comment">//添加用户名</span></div><div class="line">cv.put(<span class="string">"password"</span>,<span class="string">"123456"</span>); <span class="comment">//添加密码</span></div><div class="line">db.insert(<span class="string">"user"</span>,<span class="keyword">null</span>,cv);<span class="comment">//执行插入操作</span></div></pre></td></tr></table></figure>
<h5 id="4-更新数据"><a href="#4-更新数据" class="headerlink" title="4.更新数据"></a>4.更新数据</h5><p>a. 使用execSQL方式的实现</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String sql = "update [user] set password = '654321' where username="finch";//修改的SQL语句</div><div class="line">db.execSQL(sql);//执行修改</div></pre></td></tr></table></figure>
<p>b.使用SQLiteDatabase 对象的 update()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ContentValues cv = <span class="keyword">new</span> ContentValues();</div><div class="line">cv.put(<span class="string">"password"</span>,<span class="string">"654321"</span>);<span class="comment">//添加要更改的字段及内容</span></div><div class="line">String whereClause = <span class="string">"username=?"</span>;<span class="comment">//修改条件</span></div><div class="line">String[] whereArgs = &#123;<span class="string">"finch"</span>&#125;;<span class="comment">//修改条件的参数</span></div><div class="line">db.update(<span class="string">"user"</span>,cv,whereClause,whereArgs);<span class="comment">//执行修改</span></div></pre></td></tr></table></figure>
<p>该方法有四个参数：表名、列名和值的 ContentValues 对象、可选的 WHERE 条件、可选的填充 WHERE 语句的字符串，这些字符串会替换 WHERE 条件中的“？”标记，update() 根据条件，更新指定列的值。</p>
<h5 id="5-删除数据"><a href="#5-删除数据" class="headerlink" title="5.删除数据"></a>5.删除数据</h5><p>使用execSQL方式的实现</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String sql = "delete from user where username="finch";//删除操作的SQL语句</div><div class="line">db.execSQL(sql);//执行删除操作</div></pre></td></tr></table></figure>
<p>使用SQLiteDatabase 对象的delete()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String whereClause = <span class="string">"username=?"</span>;<span class="comment">//删除的条件</span></div><div class="line">String[] whereArgs = &#123;<span class="string">"finch"</span>&#125;;<span class="comment">//删除的条件参数</span></div><div class="line">db.delete(<span class="string">"user"</span>,whereClause,whereArgs);<span class="comment">//执行删除</span></div></pre></td></tr></table></figure>
<h5 id="6-查询数据"><a href="#6-查询数据" class="headerlink" title="6.查询数据"></a>6.查询数据</h5><p>使用 rawQuery() 直接调用 SELECT 语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Cursor c = db.rawQuery(<span class="string">"select * from user where username=?"</span>,<span class="keyword">new</span> Stirng[]&#123;<span class="string">"finch"</span>&#125;);</div><div class="line"></div><div class="line"><span class="keyword">if</span>(cursor.moveToFirst()) &#123;</div><div class="line">    String password = c.getString(c.getColumnIndex(<span class="string">"password"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回值是一个 cursor 对象，这个对象的方法可以迭代查询结果。 如果查询是动态的，使用这个方法就会非常复杂。例如，当你需要查询的列在程序编译的时候不能确定，这时候使用 query() 方法会方便很多。</p>
<p>通过query实现查询</p>
<p>query() 方法用 SELECT 语句段构建查询。 　　SELECT 语句内容作为 query() 方法的参数，比如：要查询的表名，要获取的字段名，WHERE 条件，包含可选的位置参数，去替代 WHERE 条件中位置参数的值，GROUP BY 条件，HAVING 条件。 　　除了表名，其他参数可以是 null。所以代码可写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Cursor c = db.query(<span class="string">"user"</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);<span class="comment">//查询并获得游标</span></div><div class="line"><span class="keyword">if</span>(c.moveToFirst())&#123;<span class="comment">//判断游标是否为空</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c.getCount();i++)&#123;　</div><div class="line">c.move(i);<span class="comment">//移动到指定记录</span></div><div class="line">String username = c.getString(c.getColumnIndex(<span class="string">"username"</span>);</div><div class="line">String password = c.getString(c.getColumnIndex(<span class="string">"password"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="7-使用游标"><a href="#7-使用游标" class="headerlink" title="7.使用游标"></a>7.使用游标</h5><p>不管你如何执行查询，都会返回一个 Cursor，这是 Android 的 SQLite 数据库游标，使用游标，你可以：</p>
<ul>
<li>通过使用 getCount() 方法得到结果集中有多少记录；　</li>
<li>通过 moveToFirst(), moveToNext(), 和 isAfterLast() 方法遍历所有记录；</li>
<li>通过 getColumnNames() 得到字段名；</li>
<li>通过 getColumnIndex() 转换成字段号；</li>
<li>通过 getString()，getInt() 等方法得到给定字段当前记录的值；</li>
<li>通过 requery() 方法重新执行查询得到游标；</li>
<li>通过 close() 方法释放游标资源；</li>
</ul>
<p>例如，下面代码遍历 user表:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Cursor result=db.rawQuery(<span class="string">"SELECT _id, username, password FROM user"</span>); </div><div class="line">    result.moveToFirst(); </div><div class="line">    <span class="keyword">while</span> (!result.isAfterLast()) &#123; </div><div class="line">        <span class="keyword">int</span> id=result.getInt(<span class="number">0</span>); </div><div class="line">        String name=result.getString(<span class="number">1</span>); </div><div class="line">        String password =result.getString(<span class="number">2</span>); </div><div class="line">        <span class="comment">// do something useful with these </span></div><div class="line">        result.moveToNext(); </div><div class="line">      &#125; </div><div class="line">      result.close();</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/02/28/android基础之SQLite/" data-id="cj0m73bh40010m0nzjif7kvic" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQLite/">SQLite</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android基础之进程间通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/28/android基础之进程间通信/" class="article-date">
  <time datetime="2017-02-28T10:00:00.000Z" itemprop="datePublished">2017-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/28/android基础之进程间通信/">android基础之进程间通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/02/28/android基础之进程间通信/" data-id="cj0m73bhu001sm0nz7k7iiny0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-android基础之数据存储" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/28/android基础之数据存储/" class="article-date">
  <time datetime="2017-02-28T09:42:52.000Z" itemprop="datePublished">2017-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/28/android基础之数据存储/">android基础之数据存储</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>Android提供了5种方式来让用户保存持久化应用程序数据。根据自己的需求来做选择，比如数据是否是应用程序私有的，是否能被其他程序访问，需要多少数据存储空间等。这五种数据存储方式分别是：</p>
<ul>
<li>使用SharedPreferences存储数据　</li>
<li>文件存储数据</li>
<li>SQLite数据库存储数据</li>
<li>使用ContentProvider存储数据</li>
<li>网络存储数据</li>
</ul>
<h3 id="二-五种存储方式介绍"><a href="#二-五种存储方式介绍" class="headerlink" title="二 五种存储方式介绍"></a>二 五种存储方式介绍</h3><h5 id="1-SharePreferences"><a href="#1-SharePreferences" class="headerlink" title="1. SharePreferences"></a>1. SharePreferences</h5><p>SharedPreference类提供了一个总体框架，使您可以保存和检索任何基本数据类型（ boolean, float, int, long, string）的持久键-值对（基于XML文件存储的“key-value”键值对数据）。将其以XML文件的形式保存起来。通常其存储在“data/data/程序包名/shared_prefs目录下。</p>
<h6 id="获取SharedPreferences对象（通过Context）"><a href="#获取SharedPreferences对象（通过Context）" class="headerlink" title="获取SharedPreferences对象（通过Context）"></a>获取SharedPreferences对象（通过Context）</h6><ul>
<li><p>getSharedPreferences (String name, int mode)<br>当我们有多个SharedPreferences的时候，根据第一个参数name获得相应的SharedPreferences对象。    </p>
</li>
<li><p>getPreferences (int mode)<br>如果你的Activity中只需要一个SharedPreferences的时候使用。</p>
</li>
</ul>
<p>这里的mode有四个选项：</p>
<ul>
<li><p>Context.MODE_PRIVAT<br>该SharedPreferences数据只能被本应用程序读、写。</p>
</li>
<li><p>Context.MODE_WORLD_READABLE<br>该SharedPreferences数据能被其他应用程序读，但不能写。</p>
</li>
<li><p>Context.MODE_WORLD_WRITEABLE<br>该SharedPreferences数据能被其他应用程序读和写。</p>
</li>
<li><p>Context.MODE_MULTI_PROCESS<br>sdk2.3后添加的选项，当多个进程同时读写同一个SharedPreferences时它会检查文件是否修改。</p>
</li>
</ul>
<h6 id="向Shared-Preferences中写入值"><a href="#向Shared-Preferences中写入值" class="headerlink" title="向Shared Preferences中写入值"></a>向Shared Preferences中写入值</h6><p>主要步骤：</p>
<ul>
<li>首先要通过 SharedPreferences.Editor获取到Editor对象；</li>
<li>然后通过Editor的putBoolean() 或 putString()等方法存入值；</li>
<li>最后调用Editor的commit()方法提交；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Use 0 or MODE_PRIVATE for the default operation </span></div><div class="line">SharedPreferences settings = getSharedPreferences(<span class="string">"fanrunqi"</span>, <span class="number">0</span>);</div><div class="line">SharedPreferences.Editor editor = settings.edit();</div><div class="line">editor.putBoolean(<span class="string">"isAmazing"</span>, <span class="keyword">true</span>); </div><div class="line"></div><div class="line"><span class="comment">// 提交本次编辑</span></div><div class="line">editor.commit();</div></pre></td></tr></table></figure>
<p>同时Edit还有两个常用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">editor.remove(String key) ：下一次commit的时候会移除key对应的键值对</div><div class="line"></div><div class="line">editor.clear()：移除所有键值对</div></pre></td></tr></table></figure>
<h6 id="从Shared-Preferences中读取值"><a href="#从Shared-Preferences中读取值" class="headerlink" title="从Shared Preferences中读取值"></a>从Shared Preferences中读取值</h6><p>读取值使用 SharedPreference对象的getBoolean()或getString()等方法就行了,如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SharedPreferences settings = getSharedPreferences(<span class="string">"fanrunqi"</span>, <span class="number">0</span>);</div><div class="line"><span class="keyword">boolean</span> isAmazing= settings.getBoolean(<span class="string">"isAmazing"</span>,<span class="keyword">true</span>);</div></pre></td></tr></table></figure>
<h6 id="Shared-Preferences的优缺点"><a href="#Shared-Preferences的优缺点" class="headerlink" title="Shared Preferences的优缺点"></a>Shared Preferences的优缺点</h6><p>可以看出来Preferences是很轻量级的应用，使用起来也很方便，简洁。但存储数据类型比较单一（只有基本数据类型），无法进行条件查询，只能在不复杂的存储需求下使用，比如保存配置信息等。</p>
<h5 id="2-文件存储"><a href="#2-文件存储" class="headerlink" title="2.文件存储"></a>2.文件存储</h5><h6 id="文件的内部存储（存储在手机中）"><a href="#文件的内部存储（存储在手机中）" class="headerlink" title="文件的内部存储（存储在手机中）"></a>文件的内部存储（存储在手机中）</h6><p>当文件被保存在内部存储中时，默认情况下，文件是应用程序私有的，其他应用不能访问。当用户卸载应用程序时这些文件也跟着被删除。文件默认存储位置：/data/data/包名/files/文件名。</p>
<p><strong>a. 创建和写入一个内部存储的私有文件</strong> </p>
<ul>
<li>调用Context的openFileOutput()函数，填入文件名和操作模式，它会返回一个FileOutputStream对象。</li>
<li>通过FileOutputStream对象的write()函数写入数据。</li>
<li>FileOutputStream对象的close ()函数关闭流</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">String FILENAME = <span class="string">"a.txt"</span>;</div><div class="line">String string = <span class="string">"fanrunqi"</span>;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);</div><div class="line">    fos.write(string.getBytes());</div><div class="line">    fos.close();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 openFileOutput(String name, int mode)方法中:</p>
<p>name参数:　用于指定文件名称，不能包含路径分隔符“/” ，如果文件不存在，Android 会自动创建它。<br>mode参数：用于指定操作模式，分为四种：</p>
<ul>
<li><p>Context.MODE_PRIVATE = 0<br>为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容。</p>
</li>
<li><p>Context.MODE_APPEND = 32768<br>该模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。　</p>
</li>
<li><p>Context.MODE_WORLD_READABLE = 1<br>表示当前文件可以被其他应用读取。</p>
</li>
<li><p>MODE_WORLD_WRITEABLE<br>表示当前文件可以被其他应用写入。</p>
</li>
</ul>
<p><strong>b. 读取一个内部存储的私有文件</strong></p>
<p>步骤：</p>
<ul>
<li>调用openFileInput( )，参数中填入文件名，会返回一个FileInputStream对象。</li>
<li>使用流对象的 read()方法读取字节</li>
<li>调用流的close()方法关闭流</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">String FILENAME = <span class="string">"a.txt"</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            FileInputStream inStream = openFileInput(FILENAME);</div><div class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">            <span class="keyword">while</span> ((len = inStream.read(buf)) != -<span class="number">1</span>) &#123;</div><div class="line">                sb.append(<span class="keyword">new</span> String(buf, <span class="number">0</span>, len));</div><div class="line">            &#125;</div><div class="line">            inStream.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>其他一些经常用到的方法：</p>
<ul>
<li>getFilesDir()：　得到内存储文件的绝对路径</li>
<li>getDir()：　在内存储空间中创建或打开一个已经存在的目录</li>
<li>deleteFile()：　删除保存在内部存储的文件。　 </li>
<li>fileList()：　返回当前由应用程序保存的文件的数组（内存储目录下的全部文件）。</li>
</ul>
<p><strong>c.获取编译时的静态文件</strong></p>
<p>如果你想在应用编译时保存静态文件，应该把文件保存在项目的　res/raw/　目录下，你可以通过 openRawResource()方法去打开它（传入参数R.raw.filename），这个方法返回一个 InputStream流对象你可以读取文件但是不能修改原始文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">InputStream is = <span class="keyword">this</span>.getResources().openRawResource(R.raw.filename);</div></pre></td></tr></table></figure>
<p><strong>d. 获取内存缓存文件</strong></p>
<p>有时候我们只想缓存一些数据而不是持久化保存，可以使用getCacheDir（）去打开一个文件，文件的存储目录（ /data/data/包名/cache ）是一个应用专门来保存临时缓存文件的内存目录。当设备的内部存储空间比较低的时候，Android可能会删除这些缓存文件来恢复空间，但是你不应该依赖系统来回收，要自己维护这些缓存文件把它们的大小限制在一个合理的范围内，比如1ＭＢ．当你卸载应用的时候这些缓存文件也会被移除。</p>
<h6 id="文件的外部存储（sdcard）"><a href="#文件的外部存储（sdcard）" class="headerlink" title="文件的外部存储（sdcard）"></a>文件的外部存储（sdcard）</h6><p>因为内部存储容量限制，有时候需要存储数据比较大的时候需要用到外部存储，使用外部存储分为以下几个步骤：</p>
<p><strong>a. 添加外部存储访问限权</strong></p>
<p>首先，要在AndroidManifest.xml中加入访问SDCard的权限，如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 在SDCard中创建与删除文件权限 --&gt; </div><div class="line">   &lt;uses-permission android:name=<span class="string">"android.permission.MOUNT_UNMOUNT_FILESYSTEMS"</span>/&gt; </div><div class="line"></div><div class="line">   &lt;!-- 往SDCard写入数据权限 --&gt; </div><div class="line">   &lt;uses-permission android:name=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</div></pre></td></tr></table></figure>
<p><strong>b. 检测外部存储的可用性</strong></p>
<p>在使用外部存储时我们需要检测其状态，它可能被连接到计算机、丢失或者只读等。下面代码将说明如何检查状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取外存储的状态</span></div><div class="line">String state = Environment.getExternalStorageState();</div><div class="line"><span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(state)) &#123;</div><div class="line">    <span class="comment">// 可读可写</span></div><div class="line">    mExternalStorageAvailable = mExternalStorageWriteable = <span class="keyword">true</span>;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123;</div><div class="line">    <span class="comment">// 可读</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 可能有很多其他的状态，但是我们只需要知道，不能读也不能写  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>c. 访问外部存储器中的文件</strong></p>
<p>1) 如果 API 版本大于或等于８，使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getExternalFilesDir (String type)</div></pre></td></tr></table></figure>
<p>该方法打开一个外存储目录，此方法需要一个类型，指定你想要的子目录，如类型参数DIRECTORY_MUSIC和 DIRECTORY_RINGTONES（传null就是你应用程序的文件目录的根目录）。通过指定目录的类型，确保Android的媒体扫描仪将扫描分类系统中的文件（例如，铃声被确定为铃声）。如果用户卸载应用程序，这个目录及其所有内容将被删除。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">File file = <span class="keyword">new</span> File(getExternalFilesDir(<span class="keyword">null</span>), <span class="string">"fanrunqi.jpg"</span>);</div></pre></td></tr></table></figure>
<p>2) 如果API 版本小于 8 （7或者更低）,使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getExternalStorageDirectory ()</div></pre></td></tr></table></figure>
<p>通过该方法打开外存储的根目录，你应该在以下目录下写入你的应用数据，这样当卸载应用程序时该目录及其所有内容也将被删除。目录：/Android/data/<package_name>/files/</package_name></p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))&#123;  </div><div class="line">            File sdCardDir = Environment.getExternalStorageDirectory();<span class="comment">//获取SDCard目录  "/sdcard"        </span></div><div class="line"></div><div class="line">               File saveFile = <span class="keyword">new</span> File(sdCardDir,<span class="string">"a.txt"</span>); </div><div class="line"></div><div class="line">               <span class="comment">//写数据</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    FileOutputStream fos= <span class="keyword">new</span> FileOutputStream(saveFile); </div><div class="line">                    fos.write(<span class="string">"fanrunqi"</span>.getBytes()); </div><div class="line">                    fos.close();</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; </div><div class="line"></div><div class="line">                <span class="comment">//读数据</span></div><div class="line">                 <span class="keyword">try</span> &#123;</div><div class="line">                    FileInputStream fis= <span class="keyword">new</span> FileInputStream(saveFile); </div><div class="line">                    <span class="keyword">int</span> len =<span class="number">0</span>;</div><div class="line">                    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">                    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line">                    <span class="keyword">while</span>((len=fis.read(buf))!=-<span class="number">1</span>)&#123;</div><div class="line">                        sb.append(<span class="keyword">new</span> String(buf, <span class="number">0</span>, len));</div><div class="line">                    &#125;</div><div class="line">                    fis.close();</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;  </div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>我们也可以在　/Android/data/package_name/cache/目录下做外部缓存。</p>
<h5 id="3-网路存储"><a href="#3-网路存储" class="headerlink" title="3. 网路存储"></a>3. 网路存储</h5><p>网路存储即是通过HttpUrlConnection或者HttpClint或者okhttp等http框架从服务器中获取数据。</p>
<h5 id="4-SQLite存储"><a href="#4-SQLite存储" class="headerlink" title="4.SQLite存储"></a>4.SQLite存储</h5><p>请看我的另一篇博客《android基础之SQLite》</p>
<h5 id="5-ContentProvider存储"><a href="#5-ContentProvider存储" class="headerlink" title="5.ContentProvider存储"></a>5.ContentProvider存储</h5><p>看我的另一篇博客《android基础之Content Provider》</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三 总结"></a>三 总结</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/02/28/android基础之数据存储/" data-id="cj0m73bhy0020m0nz7efrvaxw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据存储/">数据存储</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android基础之缓存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/28/android基础之缓存/" class="article-date">
  <time datetime="2017-02-28T09:10:22.000Z" itemprop="datePublished">2017-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/28/android基础之缓存/">android基础之缓存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>移动开发本质上就是手机和服务器之间进行通信，需要从服务端获取数据。反复通过网络获取数据是比较耗时的，特别是访问比较多的时候，会极大影响了性能，Android中可通过缓存机制来减少频繁的网络操作，减少流量、提升性能。android中缓存分为一级缓存，二级缓存和图片的三级缓存(就是网络)。</p>
<p>Android缓存分为内存缓存（一级缓存）和文件缓存（二级缓存）。在早期，各大图片缓存框架流行之前，常用的内存缓存方式是软引用（SoftReference）和弱引用（WeakReference），如大部分的使用方式：HashMap<string url,="" softreference<drawable="">&gt; imageCache;这种形式。从Android 2.3（Level 9）开始，垃圾回收器更倾向于回收SoftReference或WeakReference对象，这使得SoftReference和WeakReference变得不是那么实用有效。同时，到了Android 3.0（Level 11）之后，图片数据Bitmap被放置到了内存的堆区域，而堆区域的内存是由GC管理的，开发者也就不需要进行图片资源的释放工作，但这也使得图片数据的释放无法预知，增加了造成OOM的可能。因此，在Android3.1以后，Android推出了LruCache这个内存缓存类和DiskLruCache这个磁盘缓存类。</string></p>
<p>当Android端需要获得数据时比如获取网络中的图片，我们首先从内存中查找（按键查找），内存中没有的再从磁盘文件或sqlite中去查找，若磁盘中也没有才通过网络获取（图片的3级缓存策略）；当获得来自网络的数据，就以key-value对的方式先缓存到内存（一级缓存），同时缓存到文件或sqlite中（二级缓存）。注意：内存缓存会造成堆内存泄露，所有一级缓存通常要严格控制缓存的大小，一般控制在系统内存的1/4。</p>
<h3 id="二-内存缓存（一级缓存）"><a href="#二-内存缓存（一级缓存）" class="headerlink" title="二 内存缓存（一级缓存）"></a>二 内存缓存（一级缓存）</h3><p>android中使用LruCache做内存缓存。在介绍这个类之前先了解一下LRU算法。</p>
<h5 id="1-LRU算法"><a href="#1-LRU算法" class="headerlink" title="1.LRU算法"></a>1.LRU算法</h5><p>LRU，全称Least Rencetly Used，即最近最少使用，是一种非常常用的置换算法，也即淘汰最长时间未使用的对象。LRU在操作系统中的页面置换算法中广泛使用，我们的内存或缓存空间是有限的，当新加入一个对象时，造成我们的缓存空间不足了，此时就需要根据某种算法对缓存中原有数据进行淘汰货删除，而LRU选择的是将最长时间未使用的对象进行淘汰。</p>
<h5 id="2-LruCache实现原理"><a href="#2-LruCache实现原理" class="headerlink" title="2.LruCache实现原理"></a>2.LruCache实现原理</h5><p>根据LRU算法的思想，要实现LRU最核心的是要有一种数据结构能够基于访问顺序来保存缓存中的对象，这样我们就能够很方便的知道哪个对象是最近访问的，哪个对象是最长时间未访问的。LruCache选择的是LinkedHashMap这个数据结构，LinkedHashMap是一个双向循环链表，在构造LinkedHashMap时，通过一个boolean值来指定LinkedHashMap中保存数据的方式，LinkedHashMap的一个构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line">     * 初始化LinkedHashMap </div><div class="line">     * 第一个参数：initialCapacity，初始大小 </div><div class="line">     * 第二个参数：loadFactor，负载因子=0.75f </div><div class="line">     * 第三个参数：accessOrder=true，基于访问顺序；accessOrder=false，基于插入顺序 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);  </div><div class="line">        init();  </div><div class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>显然，在LruCache中选择的是accessOrder = true；此时，当accessOrder 设置为 true时，每当我们更新（即调用put方法）或访问（即调用get方法）map中的结点时，LinkedHashMap内部都会将这个结点移动到链表的尾部，因此，在链表的尾部是最近刚刚使用的结点，在链表的头部是是最近最少使用的结点，当我们的缓存空间不足时，就应该持续把链表头部结点移除掉，直到有剩余空间放置新结点。<br>可以看到，LinkedHashMap完成了LruCache中的核心功能，那LruCache中剩下要做的就是定义缓存空间总容量，当前保存数据已使用的容量，对外提供put、get方法。</p>
<h5 id="3-LruCache源码分析"><a href="#3-LruCache源码分析" class="headerlink" title="3.LruCache源码分析"></a>3.LruCache源码分析</h5><p>在了解了LruCache的核心原理之后，就可以开始分析LruCache的源码了。</p>
<h6 id="3-1关键字段"><a href="#3-1关键字段" class="headerlink" title="3.1关键字段"></a>3.1关键字段</h6><p>根据上面的分析，首先要有总容量、已使用容量、linkedHashMap这几个关键字段，LruCache中提供了下面三个关键字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//核心数据结构  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;K, V&gt; map;  </div><div class="line">    <span class="comment">// 当前缓存数据所占的大小  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;  </div><div class="line">    <span class="comment">//缓存空间总容量  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</div></pre></td></tr></table></figure>
<p>要注意的是size字段，因为map中可以存放各种类型的数据，这些数据的大小测量方式也是不一样的，比如Bitmap类型的数据和String类型的数据计算他们的大小方式肯定不同，因此，LruCache中在计算放入数据大小的方法sizeOf中，只是简单的返回了1，需要我们重写这个方法，自己去定义数据的测量方式。因此，我们在使用LruCache的时候，经常会看到这种方式： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_SIZE = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;<span class="comment">//4Mib  </span></div><div class="line">    LruCache&lt;String,Bitmap&gt; bitmapCache = <span class="keyword">new</span> LruCache&lt;String,Bitmap&gt;(CACHE_SIZE)&#123;  </div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;  </div><div class="line">            <span class="keyword">return</span> value.getByteCount();<span class="comment">//自定义Bitmap数据大小的计算方式  </span></div><div class="line">        &#125;  </div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<h6 id="3-2-构造方法"><a href="#3-2-构造方法" class="headerlink" title="3.2 构造方法"></a>3.2 构造方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.maxSize = maxSize;</div><div class="line">    <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LruCache只有一个唯一的构造方法，在构造方法中，给定了缓存空间的总大小，初始化了LinkedHashMap核心数据结构，在LinkedHashMap中的第三个参数指定为true，也就设置了accessOrder=true，表示这个LinkedHashMap将是基于数据的访问顺序进行排序。</p>
<h6 id="3-3-sizeOf-和safeSizeOf-方法测量数据类型大小"><a href="#3-3-sizeOf-和safeSizeOf-方法测量数据类型大小" class="headerlink" title="3.3 sizeOf()和safeSizeOf()方法测量数据类型大小"></a>3.3 sizeOf()和safeSizeOf()方法测量数据类型大小</h6><p>根据上面的解释，由于各种数据类型大小测量的标准不统一，具体测量的方法应该由使用者来实现，如上面给出的一个在实现LruCache时重写sizeOf的一种常用实现方式。通过多态的性质，再具体调用sizeOf时会调用我们重写的方法进行测量，LruCache对sizeOf()的调用进行一层封装，如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">safeSizeOf</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = sizeOf(key, value);</div><div class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Negative size: "</span> + key + <span class="string">"="</span> + value);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>里面其实就是调用sizeOf()方法，返回sizeOf计算的大小。<br>上面就是LruCache的基本内容，下面就需要提供LruCache的核心功能了。</p>
<h6 id="3-4-put方法缓存数据"><a href="#3-4-put方法缓存数据" class="headerlink" title="3.4 put方法缓存数据"></a>3.4 put方法缓存数据</h6><p>首先看一下它的源码实现：    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * 给对应key缓存value，并且将该value移动到链表的尾部。</div><div class="line">   */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null || value == null"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">      V previous;</div><div class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="comment">// 记录 put 的次数</span></div><div class="line">        putCount++;</div><div class="line">        <span class="comment">// 通过键值对，计算出要保存对象value的大小，并更新当前缓存大小</span></div><div class="line">        size += safeSizeOf(key, value);</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 如果 之前存在key，用新的value覆盖原来的数据， 并返回 之前key 的value</div><div class="line">         * 记录在 previous</div><div class="line">         */</div><div class="line">        previous = map.put(key, value);</div><div class="line">        <span class="comment">// 如果之前存在key，并且之前的value不为null</span></div><div class="line">        <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 计算出 之前value的大小，因为前面size已经加上了新的value数据的大小，此时，需要再次更新size，减去原来value的大小</span></div><div class="line">            size -= safeSizeOf(key, previous);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果之前存在key，并且之前的value不为null</span></div><div class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * previous值被剔除了，此次添加的 value 已经作为key的 新值</div><div class="line">         * 告诉 自定义 的 entryRemoved 方法</div><div class="line">         */</div><div class="line">        entryRemoved(<span class="keyword">false</span>, key, previous, value);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//裁剪缓存容量（在当前缓存数据大小超过了总容量maxSize时，才会真正去执行LRU）</span></div><div class="line">    trimToSize(maxSize);</div><div class="line">      <span class="keyword">return</span> previous;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，put()方法主要有以下几步：<br>1）key和value判空，说明LruCache中不允许key和value为null；<br>2）通过safeSizeOf()获取要加入对象数据的大小，并更新当前缓存数据的大小；<br>3）将新的对象数据放入到缓存中，即调用LinkedHashMap的put方法，如果原来存在该key时，直接替换掉原来的value值，并返回之前的value值，得到之前value的大小，更新当前缓存数据的size大小；如果原来不存在该key，则直接加入缓存即可；<br>4）清理缓存空间</p>
<h6 id="3-5-trimToSize-清理缓存空间"><a href="#3-5-trimToSize-清理缓存空间" class="headerlink" title="3.5 trimToSize()清理缓存空间"></a>3.5 trimToSize()清理缓存空间</h6><p>当我们加入一个数据时（put），为了保证当前数据的缓存所占大小没有超过我们指定的总大小，通过调用trimToSize()来对缓存空间进行管理控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 循环进行LRU，直到当前所占容量大小没有超过指定的总容量大小</div><div class="line">     */</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        K key;</div><div class="line">        V value;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="comment">// 一些异常情况的处理</span></div><div class="line">            <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="number">0</span>)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                        getClass().getName() + <span class="string">".sizeOf() is reporting inconsistent results!"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 首先判断当前缓存数据大小是否超过了指定的缓存空间总大小。如果没有超过，即缓存中还可以存入数据，直接跳出循环，清理完毕</span></div><div class="line">            <span class="keyword">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/**</span></div><div class="line">             * 执行到这，表示当前缓存数据已超过了总容量，需要执行LRU，即将最近最少使用的数据清除掉，直到数据所占缓存空间没有超标;</div><div class="line">             * 根据前面的原理分析，知道，在链表中，链表的头结点是最近最少使用的数据，因此，最先清除掉链表前面的结点</div><div class="line">             */</div><div class="line">            Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</div><div class="line">            key = toEvict.getKey();</div><div class="line">            value = toEvict.getValue();</div><div class="line">            map.remove(key);</div><div class="line">            <span class="comment">// 移除掉后，更新当前数据缓存的大小</span></div><div class="line">            size -= safeSizeOf(key, value);</div><div class="line">            <span class="comment">// 更新移除的结点数量</span></div><div class="line">            evictionCount++;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 通知某个结点被移除，类似于回调</div><div class="line">         */</div><div class="line">        entryRemoved(<span class="keyword">true</span>, key, value, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>trimToSize()方法的作用就是为了保证当前数据的缓存大小不能超过我们指定的缓存总大小，如果超过了，就会开始移除最近最少使用的数据，直到size符合要求。trimToSize()方法在put()的时候一定会调用，在get()的时候有可能会调用。</p>
<h6 id="3-6-get方法获取缓存数据"><a href="#3-6-get方法获取缓存数据" class="headerlink" title="3.6 get方法获取缓存数据"></a>3.6 get方法获取缓存数据</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 根据key查询缓存，如果该key对应的value存在于缓存，直接返回value；</div><div class="line">* 访问到这个结点时，LinkHashMap会将它移动到双向循环链表的的尾部。</div><div class="line">* 如果如果没有缓存的值，则返回null。（如果开发者重写了create()的话，返回创建的value）</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    V mapValue;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="comment">// LinkHashMap 如果设置按照访问顺序的话，这里每次get都会重整数据顺序</span></div><div class="line">        mapValue = map.get(key);</div><div class="line">        <span class="comment">// 计算 命中次数</span></div><div class="line">        <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</div><div class="line">            hitCount++;</div><div class="line">            <span class="keyword">return</span> mapValue;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 计算 丢失次数</span></div><div class="line">        missCount++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 官方解释：</div><div class="line">     * 尝试创建一个值，这可能需要很长时间，并且Map可能在create()返回的值时有所不同。如果在create()执行的时</div><div class="line">     * 候，用这个key执行了put方法，那么此时就发生了冲突，我们在Map中删除这个创建的值，释放被创建的值，保留put进去的值。</div><div class="line">     */</div><div class="line">    V createdValue = create(key);</div><div class="line">    <span class="keyword">if</span> (createdValue == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/***************************</span></div><div class="line">     * 不覆写create方法走不到下面 *</div><div class="line">     ***************************/</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 正常情况走不到这里</div><div class="line">     * 走到这里的话 说明 实现了自定义的 create(K key) 逻辑</div><div class="line">     * 因为默认的 create(K key) 逻辑为null</div><div class="line">     */</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="comment">// 记录 create 的次数</span></div><div class="line">        createCount++;</div><div class="line">        <span class="comment">// 将自定义create创建的值，放入LinkedHashMap中，如果key已经存在，会返回 之前相同key 的值</span></div><div class="line">        mapValue = map.put(key, createdValue);</div><div class="line"></div><div class="line">        <span class="comment">// 如果之前存在相同key的value，即有冲突。</span></div><div class="line">        <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line">             * 有冲突</div><div class="line">             * 所以 撤销 刚才的 操作</div><div class="line">             * 将 之前相同key 的值 重新放回去</div><div class="line">             */</div><div class="line">            map.put(key, mapValue);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 拿到键值对，计算出在容量中的相对长度，然后加上</span></div><div class="line">            size += safeSizeOf(key, createdValue);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果上面 判断出了 将要放入的值发生冲突</span></div><div class="line">    <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 刚才create的值被删除了，原来的 之前相同key 的值被重新添加回去了</div><div class="line">         * 告诉 自定义 的 entryRemoved 方法</div><div class="line">         */</div><div class="line">        entryRemoved(<span class="keyword">false</span>, key, createdValue, mapValue);</div><div class="line">        <span class="keyword">return</span> mapValue;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 上面 进行了 size += 操作 所以这里要重整长度</span></div><div class="line">        trimToSize(maxSize);</div><div class="line">        <span class="keyword">return</span> createdValue;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get()方法的思路就是：<br>   1）先尝试从map缓存中获取value，即mapVaule = map.get(key);如果mapVaule != null，说明缓存中存在该对象，直接返回即可；<br>   2）如果mapVaule == null，说明缓存中不存在该对象，大多数情况下会直接返回null；但是如果我们重写了create()方法，在缓存没有该数据的时候自己去创建一个，则会继续往下走，中间可能会出现冲突，看注释；<br>   3）注意：在我们通过LinkedHashMap进行get(key)或put(key,value)时都会对链表进行调整，即将刚刚访问get或加入put的结点放入到链表尾部。</p>
<h6 id="3-7-entryRemoved"><a href="#3-7-entryRemoved" class="headerlink" title="3.7 entryRemoved()"></a>3.7 entryRemoved()</h6><p>entryRemoved的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 1.当被回收或者删掉时调用。该方法当value被回收释放存储空间时被remove调用</div><div class="line">* 或者替换条目值时put调用，默认实现什么都没做。</div><div class="line">* 2.该方法没用同步调用，如果其他线程访问缓存时，该方法也会执行。</div><div class="line">* 3.evicted=true：如果该条目被删除空间 （表示 进行了trimToSize or remove）  evicted=false：put冲突后 或 get里成功create后</div><div class="line">* 导致</div><div class="line">* 4.newValue!=null，那么则被put()或get()调用。</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">entryRemoved</span><span class="params">(<span class="keyword">boolean</span> evicted, K key, V oldValue, V newValue)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>entryRemoved方法是一个空方法，说明这个也是让开发者自己根据需求去重写的。entryRemoved()主要作用就是在结点数据value需要被删除或回收的时候，给开发者的回调。开发者就可以在这个方法里面实现一些自己的逻辑：<br>（1）可以进行资源的回收；<br>（2）可以实现二级内存缓存，可以进一步提高性能，<br>思路如下：重写LruCache的entryRemoved()函数，把删除掉的item，再次存入另外一个LinkedHashMap<string, softweakreference<bitmap="">&gt;中，这个数据结构当做二级缓存，每次获得图片的时候，先判断LruCache中是否缓存，没有的话，再判断这个二级缓存中是否有，如果都没有再从sdcard上获取。sdcard上也没有的话，就从网络服务器上拉取。entryRemoved()在LruCache中有四个地方进行了调用：put()、get()、trimToSize()、remove()中进行了调用。</string,></p>
<h6 id="3-8-LruCache的线程安全性"><a href="#3-8-LruCache的线程安全性" class="headerlink" title="3.8 LruCache的线程安全性"></a>3.8 LruCache的线程安全性</h6><p>LruCache是线程安全的，因为在put、get、trimToSize、remove的方法中都加入synchronized进行同步控制。</p>
<h5 id="4-LruCache代码示例"><a href="#4-LruCache代码示例" class="headerlink" title="4.LruCache代码示例"></a>4.LruCache代码示例</h5><p>使用步骤：</p>
<ul>
<li>在构造LruCache时提供一个总的缓存大小；</li>
<li>重写sizeOf方法，对存入map的数据大小进行自定义测量；</li>
<li>根据需要，决定是否要重写entryRemoved()方法；</li>
<li>使用LruCache提供的put和get方法进行数据的缓存</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> LruCache&lt;String, Bitmap&gt; mMemoryCache;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 获得虚拟机能提供的最大内存，超过这个大小会抛出OutOfMemory的异常</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">1024</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 用１／８的内存大小作为内存缓存</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> cacheSize = maxMemory / <span class="number">8</span>;</div><div class="line"></div><div class="line">    mMemoryCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap bitmap)</span> </span>&#123;</div><div class="line">            <span class="comment">// 这里返回的不是item的个数，是cache的size（单位1024个字节）</span></div><div class="line">            <span class="keyword">return</span> bitmap.getByteCount() / <span class="number">1024</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBitmapToMemoryCache</span><span class="params">(String key, Bitmap bitmap)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (getBitmapFromMemCache(key) == <span class="keyword">null</span>) &#123;</div><div class="line">        mMemoryCache.put(key, bitmap);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmapFromMemCache</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mMemoryCache.get(key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当为ImageView加载一张图片时，会先在LruCache 中看看有没有缓存这张图片，如果有的话直接更新到ImageView中，如果没有的话，一个后台线程会被触发来加载这张图片。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBitmap</span><span class="params">(<span class="keyword">int</span> resId, ImageView imageView)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> String imageKey = String.valueOf(resId);</div><div class="line"></div><div class="line">    <span class="comment">// 查看下内存缓存中是否缓存了这张图片</span></div><div class="line">    <span class="keyword">final</span> Bitmap bitmap = getBitmapFromMemCache(imageKey);</div><div class="line">    <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">        mImageView.setImageBitmap(bitmap);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mImageView.setImageResource(R.drawable.image_placeholder);</div><div class="line">BitmapWorkerTask task = <span class="keyword">new</span> BitmapWorkerTask(mImageView);</div><div class="line">        task.execute(resId);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在图片加载的Task中，需要把加载好的图片加入到内存缓存中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapWorkerTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Integer</span>, <span class="title">Void</span>, <span class="title">Bitmap</span>&gt; </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 在后台完成</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">doInBackground</span><span class="params">(Integer... params)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Bitmap bitmap = decodeSampledBitmapFromResource(</div><div class="line">                getResources(), params[<span class="number">0</span>], <span class="number">100</span>, <span class="number">100</span>));</div><div class="line">    addBitmapToMemoryCache(String.valueOf(params[<span class="number">0</span>]), bitmap);</div><div class="line">        <span class="keyword">return</span> bitmap;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h5><ul>
<li>LruCache 自身并没有释放内存，只是 LinkedHashMap中将数据移除了，如果数据还在别的地方被引用了，还是有泄漏问题，还需要手动释放内存；</li>
<li>覆写 entryRemoved 方法能知道 LruCache 数据移除是是否发生了冲突（冲突是指在map.put()的时候，对应的key中是否存在原来的值），也可以去手动释放资源；</li>
</ul>
<h3 id="三-磁盘缓存（二级缓存）"><a href="#三-磁盘缓存（二级缓存）" class="headerlink" title="三 磁盘缓存（二级缓存）"></a>三 磁盘缓存（二级缓存）</h3><p>LruCache是一种内存缓存策略，但是当存在大量图片的时候，我们指定的缓存内存空间可能很快就会用完，这个时候，LruCache就会频繁的进行trimToSize()操作，不断的将最近最少使用的数据移除，当再次需要该数据时，又得从网络上重新加载，这样就有可能造成OOM。为此，Google提供了一种磁盘缓存的解决方案——DiskLruCache（DiskLruCache并没有集成到Android源码中，在Android Doc的例子中有讲解）。</p>
<h5 id="1-DiskLruCache实现原理"><a href="#1-DiskLruCache实现原理" class="headerlink" title="1. DiskLruCache实现原理"></a>1. DiskLruCache实现原理</h5><p>我们可以先来直观看一下，使用了DiskLruCache缓存策略的APP，缓存目录中是什么样子，如下图：</p>
<img src="/2017/02/28/android基础之缓存/文件缓存结果图.png" alt="文件缓存结果图" title="文件缓存结果图">
<p>可以看到，缓存目录中有一堆文件名很长的文件，这些文件就是我们缓存的一张张图片数据，在最后有一个文件名journal的文件，这个journal文件是DiskLruCache的一个日志文件，即保存着每张缓存图片的操作记录，journal文件正是实现DiskLruCache的核心。看到出现了journal文件，基本可以说明这个APP使用了DiskLruCache缓存策略。</p>
<p>根据对LruCache的分析，要实现LRU，最重要的是要有一种数据结构能够基于访问顺序来保存缓存中的对象，LinkedHashMap是一种非常合适的数据结构，为此，DiskLruCache也选择了LinkedHashMap作为维护访问顺序的数据结构，但是，对于DiskLruCache来说，单单LinkedHashMap是不够的，因为我们不能像LruCache一样，直接将数据放置到LinkedHashMap的value中，也就是处于内存当中，在DiskLruCache中，数据是缓存到了本地文件，这里的LinkedHashMap中的value只是保存的是value的一些简要信息Entry，如唯一的文件名称、大小、是否可读等信息，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</div><div class="line">    <span class="comment">/** Lengths of this entry's files. */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] lengths;</div><div class="line">    <span class="comment">/** True if this entry has ever been published */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> readable;</div><div class="line">    <span class="comment">/** The ongoing edit or null if this entry is not being edited. */</span></div><div class="line">    <span class="keyword">private</span> Editor currentEditor;</div><div class="line">    <span class="comment">/** The sequence number of the most recently committed edit to this entry. */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequenceNumber;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Entry</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.key = key;</div><div class="line">        <span class="keyword">this</span>.lengths = <span class="keyword">new</span> <span class="keyword">long</span>[valueCount];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLengths</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> size : lengths) &#123;</div><div class="line">            result.append(<span class="string">' '</span>).append(size);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result.toString();</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Set lengths using decimal numbers like "10123".</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setLengths</span><span class="params">(String[] strings)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (strings.length != valueCount) &#123;</div><div class="line">            <span class="keyword">throw</span> invalidLengths(strings);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++) &#123;</div><div class="line">                lengths[i] = Long.parseLong(strings[i]);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</div><div class="line">            <span class="keyword">throw</span> invalidLengths(strings);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> IOException <span class="title">invalidLengths</span><span class="params">(String[] strings)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal line: "</span> + Arrays.toString(strings));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">getCleanFile</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> File(directory, key + <span class="string">"."</span> + i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">getDirtyFile</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> File(directory, key + <span class="string">"."</span> + i + <span class="string">".tmp"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DiskLruCache中对于LinkedHashMap定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;String, Entry&gt; lruEntries</div><div class="line">	= <span class="keyword">new</span> LinkedHashMap&lt;String, Entry&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</div></pre></td></tr></table></figure>
<p>在LruCache中，由于数据是直接缓存中内存中，map中数据的建立是在使用LruCache缓存的过程中逐步建立的，而对于DiskLruCache，由于数据是缓存在本地文件，相当于是持久保存下来的一个文件，即使程序退出文件还在，因此，map中数据的建立，除了在使用DiskLruCache过程中建立外，map还应该包括之前已经存在的缓存文件，因此，在获取DiskLruCache的实例时，DiskLruCache会去读取journal这个日志文件，根据这个日志文件中的信息，建立map的初始数据，同时，会根据journal这个日志文件，维护本地的缓存文件。构造DiskLruCache的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskLruCache <span class="title">open</span><span class="params">(File directory, <span class="keyword">int</span> appVersion, <span class="keyword">int</span> valueCount, <span class="keyword">long</span> maxSize)</span></span></div><div class="line">    <span class="keyword">throws</span> IOException &#123;</div><div class="line">    <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (valueCount &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"valueCount &lt;= 0"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// prefer to pick up where we left off</span></div><div class="line">    DiskLruCache cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</div><div class="line">    <span class="keyword">if</span> (cache.journalFile.exists()) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        cache.readJournal();</div><div class="line">        cache.processJournal();</div><div class="line">        cache.journalWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(cache.journalFile, <span class="keyword">true</span>),IO_BUFFER_SIZE);</div><div class="line">                <span class="keyword">return</span> cache;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException journalIsCorrupt) &#123;</div><div class="line">            <span class="comment">//                System.logW("DiskLruCache " + directory + " is corrupt: "</span></div><div class="line">            <span class="comment">//                        + journalIsCorrupt.getMessage() + ", removing");</span></div><div class="line">            cache.delete();</div><div class="line">        &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    <span class="comment">// create a new empty cache</span></div><div class="line">    directory.mkdirs();</div><div class="line">    cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</div><div class="line">    cache.rebuildJournal();</div><div class="line">    <span class="keyword">return</span> cache;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<br>cache.readJournal();<br>cache.processJournal();<br>正是去读取journal日志文件，建立起map中的初始数据，同时维护缓存文件。</p>
<h5 id="2-journal日志文件"><a href="#2-journal日志文件" class="headerlink" title="2.journal日志文件"></a>2.journal日志文件</h5><p>journal日志文件到底保存了什么信息呢，一个标准的journal日志文件信息如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">libcore.io.DiskLruCache    //第一行，固定内容，声明</div><div class="line">1                                        //第二行，cache的版本号，恒为1</div><div class="line">1                                        //第三行，APP的版本号</div><div class="line">2                                        //第四行，一个key，可以存放多少条数据valueCount    </div><div class="line">                                           //第五行，空行分割行</div><div class="line">DIRTY 335c4c6028171cfddfbaae1a9c313c52</div><div class="line">CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934</div><div class="line">REMOVE 335c4c6028171cfddfbaae1a9c313c52</div><div class="line">DIRTY 1ab96a171faeeee38496d8b330771a7a</div><div class="line">CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234</div><div class="line">READ 335c4c6028171cfddfbaae1a9c313c52</div><div class="line">READ 3400330d1dfc7f3f7f4b8d4d803dfcf6</div></pre></td></tr></table></figure>
<p>前五行称为journal日志文件的头，下面部分的每一行会以四种前缀之一开始：DIRTY、CLEAN、REMOVE、READ。</p>
<p>以一个DIRTY前缀开始的，后面紧跟着缓存图片的key。以DIRTY这个这个前缀开头，意味着这是一条脏数据。每当我们调用一次DiskLruCache的edit()方法时，都会向journal文件中写入一条DIRTY记录，表示我们正准备写入一条缓存数据，但不知结果如何。然后调用commit()方法表示写入缓存成功，这时会向journal中写入一条CLEAN记录，意味着这条“脏”数据被“洗干净了”，调用abort()方法表示写入缓存失败，这时会向journal中写入一条REMOVE记录。也就是说，每一行DIRTY的key，后面都应该有一行对应的CLEAN或者REMOVE的记录，否则这条数据就是“脏”的，会被自动删除掉。</p>
<p>在CLEAN前缀和key后面还有一个数值，代表的是该条缓存数据的大小。</p>
<h5 id="3-DiskLruCache中的工作流程"><a href="#3-DiskLruCache中的工作流程" class="headerlink" title="3.DiskLruCache中的工作流程"></a>3.DiskLruCache中的工作流程</h5><p><strong>1.</strong>初始化：通过open()方法，获取DiskLruCache的实例，在open方法中通过readJournal(); 方法读取journal日志文件，根据journal日志文件信息建立map中的初始数据；然后再调用processJournal();方法对刚刚建立起的map数据进行分析，分析的工作，一个是计算当前有效缓存文件（即被CLEAN的）的大小，一个是清理无用缓存文件；</p>
<p><strong>2.</strong>数据缓存与获取缓存：上面的初始化工作完成后，我们就可以在程序中进行数据的缓存功能和获取缓存的功能了；缓存数据的操作是借助DiskLruCache.Editor这个类完成的，这个类也是不能new的，需要调用DiskLruCache的edit()方法来获取实例，如：public Editor edit(String key) throws IOException。在写入完成后，需要进行commit()。</p>
<p>如下一个简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;    </div><div class="line">    <span class="meta">@Override</span>    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    </div><div class="line">        <span class="keyword">try</span> &#123;    </div><div class="line">            String imageUrl = <span class="string">"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg"</span>;    </div><div class="line">            String key = hashKeyForDisk(imageUrl);  <span class="comment">//MD5对url进行加密，这个主要是为了获得统一的16位字符  </span></div><div class="line">            DiskLruCache.Editor editor = mDiskLruCache.edit(key);  <span class="comment">//拿到Editor，往journal日志中写入DIRTY记录  </span></div><div class="line">            <span class="keyword">if</span> (editor != <span class="keyword">null</span>) &#123;    </div><div class="line">                OutputStream outputStream = editor.newOutputStream(<span class="number">0</span>);    </div><div class="line">                <span class="keyword">if</span> (downloadUrlToStream(imageUrl, outputStream)) &#123;  <span class="comment">//downloadUrlToStream方法为下载图片的方法，并且将输出流放到outputStream  </span></div><div class="line">                    editor.commit();  <span class="comment">//完成后记得commit()，成功后，再往journal日志中写入CLEAN记录  </span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;    </div><div class="line">                    editor.abort();  <span class="comment">//失败后，要remove缓存文件，往journal文件中写入REMOVE记录  </span></div><div class="line">                &#125;    </div><div class="line">            &#125;    </div><div class="line">            mDiskLruCache.flush();  <span class="comment">//将缓存操作同步到journal日志文件，不一定要在这里就调用  </span></div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;    </div><div class="line">            e.printStackTrace();    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<p><strong>注意</strong>每次调用edit()时，会向journal日志文件写入DIRTY为前缀的一条记录；文件保存成功后，调用commit()时，也会向journal日志中写入一条CLEAN为前缀的一条记录，如果失败，需要调用abort()，abort()里面会向journal文件写入一条REMOVE为前缀的记录。</p>
<p>获取缓存数据是通过get()方法实现的，如下一个简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;    </div><div class="line">    String imageUrl = <span class="string">"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg"</span>;    </div><div class="line">    String key = hashKeyForDisk(imageUrl);  <span class="comment">//MD5对url进行加密，这个主要是为了获得统一的16位字符  </span></div><div class="line">     <span class="comment">//通过get拿到value的Snapshot，里面封装了输入流、key等信息，调用get会向journal文件写入READ为前缀的记录  </span></div><div class="line">    DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key);   </div><div class="line">    <span class="keyword">if</span> (snapShot != <span class="keyword">null</span>) &#123;    </div><div class="line">        InputStream is = snapShot.getInputStream(<span class="number">0</span>);    </div><div class="line">        Bitmap bitmap = BitmapFactory.decodeStream(is);    </div><div class="line">        mImage.setImageBitmap(bitmap);    </div><div class="line">    &#125;    </div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;    </div><div class="line">    e.printStackTrace();    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>3.</strong>合适的地方进行flush()</p>
<p>在上面进行数据缓存或获取缓存的时候，调用不同的方法会往journal中写入不同前缀的一行记录，记录写入是通过IO下的Writer写入的，要真正生效，还需要调用writer的flush()方法，而DiskLruCache中的flush()方法中封装了writer.flush()的操作，因此，我们只需要在合适地方调用DiskLruCache中的flush()方法即可。其作用也就是将操作记录同步到journal文件中，这是一个消耗效率的IO操作，我们不用每次一往journal中写数据后就调用flush，这样对效率影响较大，可以在Activity的onPause()中调用一下即可。</p>
<h5 id="4-DiskLruCache总结"><a href="#4-DiskLruCache总结" class="headerlink" title="4.DiskLruCache总结"></a>4.DiskLruCache总结</h5><ul>
<li>我们可以在在UI线程中检测内存缓存，即主线程中可以直接使用LruCache；</li>
<li>使用DiskLruCache时，由于缓存或获取都需要对本地文件进行操作，因此需要另开一个线程，在子线程中检测磁盘缓存、保存缓存数据，磁盘操作从来不应该在UI线程中实现；</li>
<li>LruCache内存缓存的核心是LinkedHashMap，而DiskLruCache的核心是LinkedHashMap和journal日志文件，相当于把journal看作是一块“内存”，LinkedHashMap的value只保存文件的简要信息，对缓存文件的所有操作都会记录在journal日志文件中。</li>
</ul>
<h5 id="5-DiskLruCache优化"><a href="#5-DiskLruCache优化" class="headerlink" title="5.DiskLruCache优化"></a>5.DiskLruCache优化</h5><p>DiskLruCache是基于日志文件journal的，这就决定了每次对缓存文件的操作都需要进行日志文件的记录，我们可以不用journal文件，在第一次构造DiskLruCache的时候，直接从程序访问缓存目录下的缓存文件，并将每个缓存文件的访问时间作为初始值记录在map的value中，每次访问或保存缓存都更新相应key对应的缓存文件的访问时间，这样就避免了频繁的IO操作，这种情况下就需要使用单例模式对DiskLruCache进行构造了，下面要说的Acache轻量级的数据缓存类就是这种实现方式。</p>
<h3 id="四-一个轻量级缓存框架——ACache"><a href="#四-一个轻量级缓存框架——ACache" class="headerlink" title="四 一个轻量级缓存框架——ACache"></a>四 一个轻量级缓存框架——ACache</h3><p>ACache是一个轻量级的开源cache框架，实际上就是一个叫ACache的java类。已经在商业项目中使用，运行效果不错。</p>
<p>ACache类似于SharedPreferences，但是比SharedPreferences功能更加强大，SharedPreferences只能保存一些基本数据类型、Serializable、Bundle等数据。而Acache可以缓存如下数据：普通的字符串、JsonObject、JsonArray、Bitmap、Drawable、序列化的java对象，和 byte数据。</p>
<p>主要特色：</p>
<ul>
<li>轻，轻到只有一个JAVA文件。</li>
<li>可配置，可以配置缓存路径，缓存大小，缓存数量等。</li>
<li>可以设置缓存超时时间，缓存超时自动失效，并被删除。</li>
<li>支持多进程</li>
</ul>
<p>应用场景：</p>
<ul>
<li>替换SharePreference当做配置文件</li>
<li>可以缓存网络请求数据，比如oschina的android客户端可以缓存http请求的新闻内容，缓存时间假设为1个小时，超时后自动失效，让客户端重新请求新的数据，减少客户端流量，同时减少服务器并发量。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsListActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> List&lt;News&gt; list;</div><div class="line">  <span class="keyword">private</span> ListView listView;</div><div class="line">  <span class="keyword">private</span> LoadImageAdapter adapter;<span class="comment">//适配器</span></div><div class="line">  <span class="keyword">private</span> ACache acache;<span class="comment">//缓存框架</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    <span class="keyword">super</span>.setContentView(R.layout.load_img_listview_activity);</div><div class="line">    acache=ACache.get(<span class="keyword">this</span>);<span class="comment">//创建ACache组件</span></div><div class="line">    initView();<span class="comment">//初始化界面，代码不贴了</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span></span>&#123;</div><div class="line">   String cacheData=acache.getAsString(<span class="string">"newsList"</span>);<span class="comment">//从缓存中取数据</span></div><div class="line">   <span class="keyword">if</span>(cacheData!=<span class="keyword">null</span>)&#123;<span class="comment">//如果缓存中有，就不访问网络</span></div><div class="line">   List&lt;News&gt; newsList=gson.fromJson(cacheData, <span class="keyword">new</span> TypeToken&lt;List&lt;News&gt;&gt;()&#123;&#125;.getType());<span class="comment">//将json转为List</span></div><div class="line">      list.addAll(newsList);</div><div class="line">      adapter.notifyDataSetChanged();</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">     <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">       SystemClock.sleep(<span class="number">2000</span>);<span class="comment">//模拟网络耗时</span></div><div class="line">       String json=request();<span class="comment">//模拟从网络中获取json数据</span></div><div class="line">       acache.put(<span class="string">"newslist"</span>, json, <span class="number">60</span>*<span class="number">60</span>*<span class="number">1</span>);<span class="comment">//将数据存入缓存中，有效时间设置为1小时</span></div><div class="line">       List&lt;News&gt; newsList=gson.fromJson(json, <span class="keyword">new</span> TypeToken&lt;List&lt;News&gt;&gt;()&#123;&#125;.getType());</div><div class="line">       list.addAll(newsList);</div><div class="line">       handler.sendEmptyMessage(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">         </div><div class="line">  &#125;).start();</div><div class="line">&#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 模拟网络请求方法</div><div class="line">     * <span class="doctag">@return</span> json数据</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">request</span><span class="params">()</span></span>&#123;</div><div class="line">   News news=<span class="keyword">null</span>;</div><div class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">       news=<span class="keyword">new</span> News();</div><div class="line">       news.setId(i);</div><div class="line">       news.setImgUrl(<span class="string">"course/img/face_"</span>+i+<span class="string">".png"</span>);</div><div class="line">       news.setTitle(<span class="string">"新闻标题"</span>+i);</div><div class="line">       news.setSummary(<span class="string">"测试"</span>+i);</div><div class="line">       list.add(news);</div><div class="line">   &#125;</div><div class="line">   Gson gson=<span class="keyword">new</span> Gson();</div><div class="line">   <span class="keyword">return</span> gson.toJson(list);    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> Handler handler=<span class="keyword">new</span> Handler()</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">       <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">       <span class="keyword">switch</span>(msg.what)&#123;</div><div class="line">           <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">             notify_layout.setVisibility(View.GONE);</div><div class="line">             adapter.notifyDataSetChanged();</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/02/28/android基础之缓存/" data-id="cj0m73bhk001km0nzsbnavcot" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/缓存/">缓存</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android基础之自定义View与ViewGroup" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/28/android基础之自定义View与ViewGroup/" class="article-date">
  <time datetime="2017-02-28T08:02:37.000Z" itemprop="datePublished">2017-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/28/android基础之自定义View与ViewGroup/">android基础之自定义View与ViewGroup</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>在android应用开发过程中，固定的一些控件和属性可能满足不了开发的需求，所以在一些特殊情况下，我们需要自定义控件与属性。ViewGroup亦继承于View，下面看View的绘制过程：</p>
<img src="/2017/02/28/android基础之自定义View与ViewGroup/View绘制过程.png" alt="View绘制过程" title="View绘制过程">
<h3 id="二-自定义View"><a href="#二-自定义View" class="headerlink" title="二 自定义View"></a>二 自定义View</h3><h5 id="1-实现步骤"><a href="#1-实现步骤" class="headerlink" title="1. 实现步骤"></a>1. 实现步骤</h5><ol>
<li>继承View类或其子类　</li>
<li>复写view中的一些函数</li>
<li>为自定义View类增加属性（两种方式）</li>
<li>绘制控件（导入布局）</li>
<li>响应用户事件</li>
<li>定义回调函数（根据自己需求来选择）</li>
</ol>
<h5 id="2-哪些方法需要被重写"><a href="#2-哪些方法需要被重写" class="headerlink" title="2.哪些方法需要被重写"></a>2.哪些方法需要被重写</h5><ul>
<li><p>onDraw()<br>view中onDraw()是个空函数，也就是说具体的视图都要覆写该函数来实现自己的绘制。对于ViewGroup则不需要实现该函数，因为作为容器是“没有内容“的（但必须实现dispatchDraw()函数，告诉子view绘制自己）。</p>
</li>
<li><p>onLayout()<br>主要是为viewGroup类型布局子视图用的，在View中这个函数为空函数。</p>
</li>
<li><p>onMeasure()<br>用于计算视图大小（即长和宽）的方式，并通过setMeasuredDimension(width, height)保存计算结果。</p>
</li>
<li><p>onTouchEvent<br>定义触屏事件来响应用户操作。</p>
</li>
</ul>
<p>还有一些不常用的方法：</p>
<ul>
<li>onKeyDown  当按下某个键盘时 　</li>
<li>onKeyUp 当松开某个键盘时 　 　　 　　</li>
<li>onTrackballEvent 当发生轨迹球事件时 　 　　 　　</li>
<li>onSizeChange() 当该组件的大小被改变时 　 　　 　　</li>
<li>onFinishInflate() 回调方法，当应用从XML加载该组件并用它构建界面之后调用的方法 　 　　 　　</li>
<li>onWindowFocusChanged(boolean) 当该组件得到、失去焦点时 　 　　</li>
<li>onAttachedToWindow() 当把该组件放入到某个窗口时 　 　　 　　</li>
<li>onDetachedFromWindow() 当把该组件从某个窗口上分离时触发的方法 　 　　 　　</li>
<li>onWindowVisibilityChanged(int): 当包含该组件的窗口的可见性发生改变时触发的方法 　</li>
</ul>
<h5 id="3-自定义控件的三种方式"><a href="#3-自定义控件的三种方式" class="headerlink" title="3. 自定义控件的三种方式"></a>3. 自定义控件的三种方式</h5><ul>
<li><p>继承已有的控件<br>当要实现的控件和已有的控件在很多方面比较类似, 通过对已有控件的扩展来满足要求。</p>
</li>
<li><p>继承一个布局文件<br>一般用于自定义组合控件，在构造函数中通过inflater和addView()方法加载自定义控件的布局文件形成图形界面（不需要onDraw方法）。</p>
</li>
<li><p>继承view<br>通过onDraw方法来绘制出组件界面。</p>
</li>
</ul>
<h5 id="4-自定义属性的两种方法"><a href="#4-自定义属性的两种方法" class="headerlink" title="4. 自定义属性的两种方法"></a>4. 自定义属性的两种方法</h5><ul>
<li>在布局文件中直接加入属性，在构造函数中去获得。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"</div><div class="line">    android:layout_width="match_parent"</div><div class="line">    android:layout_height="match_parent"</div><div class="line">    &gt;</div><div class="line">     &lt;com.example.demo.myView</div><div class="line">         android:layout_width="wrap_content"</div><div class="line">         android:layout_height="wrap_content" </div><div class="line">         Text="@string/hello_world"</div><div class="line">         /&gt;</div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>
<p>获取属性值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">myView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line"><span class="keyword">int</span> textId = attrs.getAttributeResourceValue(<span class="keyword">null</span>, <span class="string">"Text"</span>, <span class="number">0</span>);</div><div class="line">String text = context.getResources().getText(textId).toString();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>在res/values/ 下建立一个attrs.xml 来声明自定义view的属性。</li>
</ul>
<p>可以定义的属性有：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name = "名称"&gt; </div><div class="line">//参考某一资源ID (name可以随便命名)</div><div class="line">&lt;attr name = "background" format = "reference" /&gt; </div><div class="line">//颜色值 </div><div class="line">&lt;attr name = "textColor" format = "color" /&gt; </div><div class="line">//布尔值</div><div class="line">&lt;attr name = "focusable" format = "boolean" /&gt; </div><div class="line">//尺寸值 </div><div class="line">&lt;attr name = "layout_width" format = "dimension" /&gt; </div><div class="line">//浮点值 </div><div class="line">&lt;attr name = "fromAlpha" format = "float" /&gt; </div><div class="line">//整型值 </div><div class="line">&lt;attr name = "frameDuration" format="integer" /&gt; </div><div class="line">//字符串 </div><div class="line">&lt;attr name = "text" format = "string" /&gt; </div><div class="line">//百分数 </div><div class="line">&lt;attr name = "pivotX" format = "fraction" /&gt; </div><div class="line"></div><div class="line">//枚举值 </div><div class="line">&lt;attr name="orientation"&gt; </div><div class="line">&lt;enum name="horizontal" value="0" /&gt; </div><div class="line">&lt;enum name="vertical" value="1" /&gt; </div><div class="line">&lt;/attr&gt; </div><div class="line"></div><div class="line">//位或运算 </div><div class="line">&lt;attr name="windowSoftInputMode"&gt; </div><div class="line">&lt;flag name = "stateUnspecified" value = "0" /&gt; </div><div class="line">&lt;flag name = "stateUnchanged" value = "1" /&gt; </div><div class="line">&lt;/attr&gt; </div><div class="line"></div><div class="line">//多类型</div><div class="line">&lt;attr name = "background" format = "reference|color" /&gt; </div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure>
<p>attrs.xml进行属性声明</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;declare-styleable name="myView"&gt;</div><div class="line">        &lt;attr name="text" format="string"/&gt;</div><div class="line">        &lt;attr name="textColor" format="color"/&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<p>添加到布局文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"</div><div class="line">    android:layout_width="match_parent"</div><div class="line">    android:layout_height="match_parent"</div><div class="line">    xmlns:myview="http://schemas.android.com/apk/com.example.demo"</div><div class="line">    &gt;</div><div class="line">     &lt;com.example.demo.myView</div><div class="line">         android:layout_width="wrap_content"</div><div class="line">         android:layout_height="wrap_content" </div><div class="line">         myview:text = "test"</div><div class="line">         myview:textColor ="#ff0000"</div><div class="line">         /&gt;</div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>
<p>这里注意命名空间： xmlns:前缀=”<a href="http://schemas.android.com/apk/res/包名（或res-auto）”" target="_blank" rel="external">http://schemas.android.com/apk/res/包名（或res-auto）”</a>.</p>
<p>在构造函数中获取属性值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">myView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.myView); </div><div class="line">        String text = a.getString(R.styleable.myView_text); </div><div class="line">        <span class="keyword">int</span> textColor = a.getColor(R.styleable.myView_textColor, Color.WHITE); </div><div class="line"></div><div class="line">        a.recycle();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">myView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.myView); </div><div class="line">        <span class="keyword">int</span> n = a.getIndexCount();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">            <span class="keyword">int</span> attr = a.getIndex(i);</div><div class="line">            <span class="keyword">switch</span> (attr) &#123;</div><div class="line">            <span class="keyword">case</span> R.styleable.myView_text:</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> R.styleable.myView_textColor:</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">       a.recycle();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="5-代码示例"><a href="#5-代码示例" class="headerlink" title="5.代码示例"></a>5.代码示例</h5><p>实现一个随手指移动的小球。具体步骤：</p>
<ul>
<li>在res/values/ 下建立一个attrs.xml 来声明自定义view的属性</li>
<li>一个继承View并复写部分函数的自定义view的类</li>
<li>一个展示自定义view 的容器界面</li>
</ul>
<p>a .自定义view命名为myView，它有一个属性值，格式为color</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;declare-styleable name="myView"&gt;</div><div class="line">        &lt;attr name="TextColor" format="color"/&gt;</div><div class="line">    &lt;/declare-styleable&gt;        </div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<p>b. 在构造函数获取获得view的属性配置和复写onDraw和onTouchEvent函数实现绘制界面和用户事件响应</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myView</span> <span class="keyword">extends</span> <span class="title">View</span></span>&#123;</div><div class="line">    <span class="comment">//定义画笔和初始位置</span></div><div class="line">    Paint p = <span class="keyword">new</span> Paint();</div><div class="line">    <span class="keyword">public</span> <span class="keyword">float</span> currentX = <span class="number">50</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">float</span> currentY = <span class="number">50</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> textColor;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">myView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        <span class="comment">//获取资源文件里面的属性，由于这里只有一个属性值，不用遍历数组，直接通过R文件拿出color值</span></div><div class="line">        <span class="comment">//把属性放在资源文件里，方便设置和复用</span></div><div class="line">        TypedArray array = context.obtainStyledAttributes(attrs,R.styleable.myView);</div><div class="line">        textColor = array.getColor(R.styleable.myView_TextColor,Color.BLACK);</div><div class="line">        array.recycle();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">        <span class="comment">//画一个蓝色的圆形</span></div><div class="line">        p.setColor(Color.BLUE);</div><div class="line">        canvas.drawCircle(currentX,currentY,<span class="number">30</span>,p);</div><div class="line">        <span class="comment">//设置文字和颜色，这里的颜色是资源文件values里面的值</span></div><div class="line">        p.setColor(textColor);</div><div class="line">        canvas.drawText(<span class="string">"BY finch"</span>,currentX-<span class="number">30</span>,currentY+<span class="number">50</span>,p);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">        currentX = event.getX();</div><div class="line">        currentY = event.getY();</div><div class="line">        invalidate();<span class="comment">//重新绘制图形</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里通过不断的更新当前位置坐标和重新绘制图形实现效果，要注意的是使用TypedArray后一定要记得recycle(). 否则会对下次调用产生影响。</p>
<p>c. 把myView加入到activity_main.xml布局里面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"</div><div class="line">    xmlns:tools="http://schemas.android.com/tools"</div><div class="line">    android:layout_width="match_parent"</div><div class="line">    android:layout_height="match_parent"</div><div class="line">    xmlns:myview="http://schemas.android.com/apk/res-auto"</div><div class="line">    android:paddingBottom="@dimen/activity_vertical_margin"</div><div class="line">    android:paddingLeft="@dimen/activity_horizontal_margin"</div><div class="line">    android:paddingRight="@dimen/activity_horizontal_margin"</div><div class="line">    android:paddingTop="@dimen/activity_vertical_margin"</div><div class="line">    tools:context="finch.scu.cn.myview.MainActivity"&gt;</div><div class="line"></div><div class="line"></div><div class="line">    &lt;finch.scu.cn.myview.myView</div><div class="line">        android:layout_width="match_parent"</div><div class="line">        android:layout_height="match_parent"</div><div class="line">        myview:TextColor="#ff0000"</div><div class="line">        /&gt;</div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>
<p>d. 最后是MainActivity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注：具体的view要根据具体的需求来，比如我们要侧滑删除的listview我们可以继承listview，监听侧滑事件，显示删除按钮实现功能。</p>
<h3 id="三-自定义ViewGroup"><a href="#三-自定义ViewGroup" class="headerlink" title="三 自定义ViewGroup"></a>三 自定义ViewGroup</h3><p>自定义ViewGroup比自定义View要麻烦一些，因为ViewGroup需要去计算子View的大小以此来改变ViewGroup的大小，同时我们还要知道子View的摆放顺序。</p>
<h5 id="1-源码分析"><a href="#1-源码分析" class="headerlink" title="1.源码分析"></a>1.源码分析</h5><p>等我看了再说</p>
<p>自定义ViewGroup的时候一般复写：</p>
<ul>
<li>onMeasure()方法：<br>计算childView的测量值以及模式，以及设置自己的宽和高　 　　 </li>
<li>onLayout()方法<br>对其所有childView的位置进行定位</li>
</ul>
<h5 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2.代码示例"></a>2.代码示例</h5><ul>
<li>onMeasure方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 获得它的父容器为它设置的测量模式和大小</span></div><div class="line">        <span class="keyword">int</span> sizeWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        <span class="keyword">int</span> modeWidth = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        <span class="keyword">int</span> sizeHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">        <span class="keyword">int</span> modeHeight = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">        <span class="comment">// 用于warp_content情况下，来记录父view宽和高</span></div><div class="line">        <span class="keyword">int</span> width = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 取每一行宽度的最大值</span></div><div class="line">        <span class="keyword">int</span> lineWidth = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 每一行的高度累加</span></div><div class="line">        <span class="keyword">int</span> lineHeight = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 获得子view的个数</span></div><div class="line">        <span class="keyword">int</span> cCount = getChildCount();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cCount; i++)</div><div class="line">        &#123;</div><div class="line">            View child = getChildAt(i);</div><div class="line">            <span class="comment">// 测量子View的宽和高（子view在布局文件中是wrap_content）</span></div><div class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">            <span class="comment">// 得到LayoutParams</span></div><div class="line">            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">            <span class="comment">// 根据测量宽度加上Margin值算出子view的实际宽度（上文中有说明）</span></div><div class="line">            <span class="keyword">int</span> childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</div><div class="line">            <span class="comment">// 根据测量高度加上Margin值算出子view的实际高度</span></div><div class="line">            <span class="keyword">int</span> childHeight = child.getMeasuredHeight() + lp.topMargin+ lp.bottomMargin;</div><div class="line"></div><div class="line">            <span class="comment">// 这里的父view是有padding值的，如果再添加一个元素就超出最大宽度就换行</span></div><div class="line">            <span class="keyword">if</span> (lineWidth + childWidth &gt; sizeWidth - getPaddingLeft() - getPaddingRight())</div><div class="line">            &#123;</div><div class="line">                <span class="comment">// 父view宽度=以前父view宽度、当前行宽的最大值</span></div><div class="line">                width = Math.max(width, lineWidth);</div><div class="line">                <span class="comment">// 换行了，当前行宽=第一个view的宽度</span></div><div class="line">                lineWidth = childWidth;</div><div class="line">                <span class="comment">// 父view的高度=各行高度之和</span></div><div class="line">                height += lineHeight;</div><div class="line">                <span class="comment">//换行了，当前行高=第一个view的高度</span></div><div class="line">                lineHeight = childHeight;</div><div class="line">            &#125; <span class="keyword">else</span>&#123;</div><div class="line">                <span class="comment">// 叠加行宽</span></div><div class="line">                lineWidth += childWidth;</div><div class="line">                <span class="comment">// 得到当前行最大的高度</span></div><div class="line">                lineHeight = Math.max(lineHeight, childHeight);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 最后一个控件</span></div><div class="line">            <span class="keyword">if</span> (i == cCount - <span class="number">1</span>)</div><div class="line">            &#123;</div><div class="line">                width = Math.max(lineWidth, width);</div><div class="line">                height += lineHeight;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * EXACTLY对应match_parent 或具体值</div><div class="line">         * AT_MOST对应wrap_content</div><div class="line">         * 在FlowLayout布局文件中</div><div class="line">         * android:layout_width="fill_parent"</div><div class="line">         * android:layout_height="wrap_content"</div><div class="line">         *</div><div class="line">         * 如果是MeasureSpec.EXACTLY则直接使用父ViewGroup传入的宽和高，否则设置为自己计算的宽和高。</div><div class="line">         */</div><div class="line">        setMeasuredDimension(</div><div class="line">                modeWidth == MeasureSpec.EXACTLY ? sizeWidth : width + getPaddingLeft() + getPaddingRight(),</div><div class="line">                modeHeight == MeasureSpec.EXACTLY ? sizeHeight : height + getPaddingTop()+ getPaddingBottom()</div><div class="line">        );</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>onLayout方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//存储所有的View</span></div><div class="line">    <span class="keyword">private</span> List&lt;List&lt;View&gt;&gt; mAllViews = <span class="keyword">new</span> ArrayList&lt;List&lt;View&gt;&gt;();</div><div class="line">    <span class="comment">//存储每一行的高度</span></div><div class="line">    <span class="keyword">private</span> List&lt;Integer&gt; mLineHeight = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span></div><div class="line">    &#123;</div><div class="line">        mAllViews.clear();</div><div class="line">        mLineHeight.clear();</div><div class="line"></div><div class="line">        <span class="comment">// 当前ViewGroup的宽度</span></div><div class="line">        <span class="keyword">int</span> width = getWidth();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> lineWidth = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> lineHeight = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 存储每一行所有的childView</span></div><div class="line">        List&lt;View&gt; lineViews = <span class="keyword">new</span> ArrayList&lt;View&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> cCount = getChildCount();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cCount; i++)</div><div class="line">        &#123;</div><div class="line">            View child = getChildAt(i);</div><div class="line">            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">            <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</div><div class="line">            <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</div><div class="line"></div><div class="line">            lineWidth += childWidth + lp.leftMargin + lp.rightMargin;</div><div class="line">            lineHeight = Math.max(lineHeight, childHeight + lp.topMargin+ lp.bottomMargin);</div><div class="line">            lineViews.add(child);</div><div class="line"></div><div class="line">            <span class="comment">// 换行，在onMeasure中childWidth是加上Margin值的</span></div><div class="line">            <span class="keyword">if</span> (childWidth + lineWidth + lp.leftMargin + lp.rightMargin &gt; width - getPaddingLeft() - getPaddingRight())</div><div class="line">            &#123;</div><div class="line">                <span class="comment">// 记录行高</span></div><div class="line">                mLineHeight.add(lineHeight);</div><div class="line">                <span class="comment">// 记录当前行的Views</span></div><div class="line">                mAllViews.add(lineViews);</div><div class="line"></div><div class="line">                <span class="comment">// 新行的行宽和行高</span></div><div class="line">                lineWidth = <span class="number">0</span>;</div><div class="line">                lineHeight = childHeight + lp.topMargin + lp.bottomMargin;</div><div class="line">                <span class="comment">// 新行的View集合</span></div><div class="line">                lineViews = <span class="keyword">new</span> ArrayList&lt;View&gt;();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 处理最后一行</span></div><div class="line">        mLineHeight.add(lineHeight);</div><div class="line">        mAllViews.add(lineViews);</div><div class="line"></div><div class="line">        <span class="comment">// 设置子View的位置</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> left = getPaddingLeft();</div><div class="line">        <span class="keyword">int</span> top = getPaddingTop();</div><div class="line"></div><div class="line">        <span class="comment">// 行数</span></div><div class="line">        <span class="keyword">int</span> lineNum = mAllViews.size();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lineNum; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 当前行的所有的View</span></div><div class="line">            lineViews = mAllViews.get(i);</div><div class="line">            lineHeight = mLineHeight.get(i);</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lineViews.size(); j++)</div><div class="line">            &#123;</div><div class="line">                View child = lineViews.get(j);</div><div class="line">                <span class="comment">// 判断child的状态</span></div><div class="line">                <span class="keyword">if</span> (child.getVisibility() == View.GONE)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">                <span class="keyword">int</span> lc = left + lp.leftMargin;</div><div class="line">                <span class="keyword">int</span> tc = top + lp.topMargin;</div><div class="line">                <span class="keyword">int</span> rc = lc + child.getMeasuredWidth();</div><div class="line">                <span class="keyword">int</span> bc = tc + child.getMeasuredHeight();</div><div class="line"></div><div class="line">                <span class="comment">// 为子View进行布局</span></div><div class="line">                child.layout(lc, tc, rc, bc);</div><div class="line"></div><div class="line">                left += child.getMeasuredWidth() + lp.leftMargin+ lp.rightMargin;</div><div class="line">            &#125;</div><div class="line">            left = getPaddingLeft() ;</div><div class="line">            top += lineHeight ;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 因为我们只需要支持margin，所以直接使用系统的MarginLayoutParams</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MarginLayoutParams(getContext(), attrs);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>MainActivity.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">    LayoutInflater mInflater;</div><div class="line">    <span class="meta">@InjectView</span>(R.id.id_flowlayout1)</div><div class="line">    FlowLayout idFlowlayout1;</div><div class="line">    <span class="meta">@InjectView</span>(R.id.id_flowlayout2)</div><div class="line">    FlowLayout idFlowlayout2;</div><div class="line">    <span class="keyword">private</span> String[] mVals = <span class="keyword">new</span> String[]</div><div class="line">            &#123;<span class="string">"Do"</span>, <span class="string">"one thing"</span>, <span class="string">"at a time"</span>, <span class="string">"and do well."</span>, <span class="string">"Never"</span>, <span class="string">"forget"</span>,</div><div class="line">                    <span class="string">"to say"</span>, <span class="string">"thanks."</span>, <span class="string">"Keep on"</span>, <span class="string">"going "</span>, <span class="string">"never give up."</span>&#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        ButterKnife.inject(<span class="keyword">this</span>);</div><div class="line">        mInflater = LayoutInflater.from(<span class="keyword">this</span>);</div><div class="line">        initFlowlayout2();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initFlowlayout2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mVals.length; i++) &#123;</div><div class="line">            <span class="keyword">final</span> RelativeLayout rl2 = (RelativeLayout) mInflater.inflate(R.layout.flow_layout, idFlowlayout2, <span class="keyword">false</span>);</div><div class="line">            TextView tv2 = (TextView) rl2.findViewById(R.id.tv);</div><div class="line">            tv2.setText(mVals[i]);</div><div class="line">            rl2.setTag(i);</div><div class="line">            idFlowlayout2.addView(rl2);</div><div class="line">            rl2.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                    <span class="keyword">int</span> i = (<span class="keyword">int</span>) v.getTag();</div><div class="line">                    addViewToFlowlayout1(i);</div><div class="line">                    rl2.setBackgroundResource(R.drawable.flow_layout_disable_bg);</div><div class="line">                    rl2.setClickable(<span class="keyword">false</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewToFlowlayout1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">        RelativeLayout rl1 = (RelativeLayout) mInflater.inflate(R.layout.flow_layout, idFlowlayout1, <span class="keyword">false</span>);</div><div class="line">        ImageView iv = (ImageView) rl1.findViewById(R.id.iv);</div><div class="line">        iv.setVisibility(View.VISIBLE);</div><div class="line">        TextView tv1 = (TextView) rl1.findViewById(R.id.tv);</div><div class="line">        tv1.setText(mVals[i]);</div><div class="line">        rl1.setTag(i);</div><div class="line">        idFlowlayout1.addView(rl1);</div><div class="line">        rl1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                <span class="keyword">int</span> i = (<span class="keyword">int</span>) v.getTag();</div><div class="line">                idFlowlayout1.removeView(v);</div><div class="line">                View view = idFlowlayout2.getChildAt(i);</div><div class="line">                view.setClickable(<span class="keyword">true</span>);</div><div class="line">                view.setBackgroundResource(R.drawable.flow_layout_bg);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/02/28/android基础之自定义View与ViewGroup/" data-id="cj0m73bhn001mm0nzs0heo7m4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ViewGroup/">ViewGroup</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/view/">view</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android基础之BroadcastReceiver" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/27/android基础之BroadcastReceiver/" class="article-date">
  <time datetime="2017-02-27T06:48:31.000Z" itemprop="datePublished">2017-02-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/27/android基础之BroadcastReceiver/">android基础之BroadcastReceiver</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-BroadcastReceiver简介"><a href="#一-BroadcastReceiver简介" class="headerlink" title="一 BroadcastReceiver简介"></a>一 BroadcastReceiver简介</h3><p>广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。如：在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。</p>
<p>BroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。</p>
<p>当系统或应用发出广播时，将会扫描系统中的所有广播接收者，通过action匹配将广播发送给相应的接收者，接收者收到广播后将会产生一个广播接收者的实例，执行其中的onReceiver()这个方法；特别需要注意的是这个实例的生命周期只有10秒，如果10秒内没执行结束onReceiver()，系统将会报错。在onReceiver()执行完毕之后，该实例将会被销毁，所以不要在onReceiver()中执行耗时操作，也不要在里面创建子线程处理业务（因为可能子线程没处理完，接收者就被回收了，那么子线程也会跟着被回收掉）；正确的处理方法就是通过in调用activity或者service处理业务。</p>
<h3 id="二-BroadcastReceiver的两种注册方式"><a href="#二-BroadcastReceiver的两种注册方式" class="headerlink" title="二 BroadcastReceiver的两种注册方式"></a>二 BroadcastReceiver的两种注册方式</h3><h5 id="1-静态注册（推荐）"><a href="#1-静态注册（推荐）" class="headerlink" title="1.静态注册（推荐）"></a>1.静态注册（推荐）</h5><p>静态注册的广播接收者是一个常驻在系统中的全局监听器，当你在应用中配置了一个静态的BroadcastReceiver，安装了应用后而无论应用是否处于运行状态，广播接收者都是已经常驻在系统中了。同时应用里的所有receiver都在清单文件里面，方便查看。　 　　 　　要销毁掉静态注册的广播接收者，可以通过调用PackageManager将Receiver禁用。</p>
<p>在AndroidManifest.xml的application里面定义receiver并设置要接收的action。下面是代码示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt; receiver android:name = ".MyBroadcastReceiver" &gt; </div><div class="line"></div><div class="line"> &lt; intent-filter android:priority = "777" &gt;             </div><div class="line">&lt;action android:name = "android.provider.Telephony.SMS_RECEIVED" /&gt;</div><div class="line">&lt;/ intent-filter &gt; </div><div class="line"></div><div class="line">&lt;/ receiver &gt;</div></pre></td></tr></table></figure>
<p>这里的priority取值是　-1000到1000，值越大优先级越高，同时注意加上系统接收短信的限权。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt; uses-permission android:name =<span class="string">"android.permission.RECEIVE_SMS"</span> /&gt;</div></pre></td></tr></table></figure>
<h5 id="2-动态注册"><a href="#2-动态注册" class="headerlink" title="2.动态注册"></a>2.动态注册</h5><p>在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    MyBroadcastReceiver receiver;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 动态注册广播 (代码执行到这才会开始监听广播消息，并对广播消息作为相应的处理)</span></div><div class="line">        receiver = <span class="keyword">new</span> MyBroadcastReceiver();</div><div class="line">        IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter( <span class="string">"android.provider.Telephony.SMS_RECEIVED"</span> );</div><div class="line">        registerReceiver( receiver , intentFilter);</div><div class="line"></div><div class="line">        <span class="keyword">super</span>.onResume();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="comment">// 撤销注册 (撤销注册后广播接收者将不会再监听系统的广播消息)</span></div><div class="line">        unregisterReceiver(receiver);</div><div class="line">        <span class="keyword">super</span>.onPause();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接收广播示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">// action 名称</span></div><div class="line">String SMS_RECEIVED = <span class="string">"android.provider.Telephony.SMS_RECEIVED"</span> ;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (intent.getAction().equals( SMS_RECEIVED )) &#123;</div><div class="line">           <span class="comment">// 一个receiver可以接收多个action的，即可以有多个intent-filter，需要在onReceive里面对intent.getAction(action name)进行判断。</span></div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-静态注册和动态注册的区别"><a href="#3-静态注册和动态注册的区别" class="headerlink" title="3.静态注册和动态注册的区别"></a>3.静态注册和动态注册的区别</h5><ol>
<li>静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者； 　　动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。</li>
<li>当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。　 　　动态注册的广播接收者将会导致应用报错 　　而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。</li>
</ol>
<h3 id="三-发送广播"><a href="#三-发送广播" class="headerlink" title="三 发送广播"></a>三 发送广播</h3><p>发送广播主要有两种类型：</p>
<h5 id="1-普通广播"><a href="#1-普通广播" class="headerlink" title="1.普通广播"></a>1.普通广播</h5><p>应用在需要通知各个广播接收者的情况下使用，如 开机启动，使用方法：sendBroadcast()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"android.provider.Telephony.SMS_RECEIVED"</span>); </div><div class="line"><span class="comment">//通过intent传递少量数据</span></div><div class="line">intent.putExtra(<span class="string">"data"</span>, <span class="string">"finch"</span>); </div><div class="line"><span class="comment">// 发送普通广播</span></div><div class="line">sendBroadcast(Intent);</div></pre></td></tr></table></figure>
<p>普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，所有满足条件的 BroadcastReceiver 都会随机地执行其 onReceive() 方法。 　　同级别接收是先后是随机的；级别低的收到广播； 　　消息传递的效率比较高，并且无法中断广播的传播。</p>
<h5 id="有序广播"><a href="#有序广播" class="headerlink" title="有序广播"></a>有序广播</h5><p>应用在需要有特定拦截的场景下使用，如黑名单短信、电话拦截。</p>
<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sendOrderedBroadcast(intent, receiverPermission);</div></pre></td></tr></table></figure>
<p>receiverPermission ：一个接收器必须持以接收您的广播。如果为 null ，不经许可的要求（一般都为null）,如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//发送有序广播</span></div><div class="line">sendOrderedBroadcast(intent, <span class="keyword">null</span>);</div></pre></td></tr></table></figure>
<p>在有序广播中，我们可以在前一个广播接收者将处理好的数据传送给后面的广播接收者，也可以调用abortBroadcast()来终结广播的传播。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context arg0, Intent intent)</span> </span>&#123;</div><div class="line">　　<span class="comment">//获取上一个广播的bundle数据</span></div><div class="line">　　Bundle bundle = getResultExtras(<span class="keyword">true</span>);<span class="comment">//true：前一个广播没有结果时创建新的Bundle；false：不创建Bundle</span></div><div class="line">　　bundle.putString(<span class="string">"key"</span>, <span class="string">"777"</span>);</div><div class="line">　　<span class="comment">//将bundle数据放入广播中传给下一个广播接收者</span></div><div class="line">　　setResultExtras(bundle);　</div><div class="line">　　</div><div class="line">　　<span class="comment">//终止广播传给下一个广播接收者</span></div><div class="line">　　abortBroadcast();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>高级别的广播收到该广播后，可以决定把该广播是否截断掉。 　　同级别接收是先后是随机的，如果先接收到的把广播截断了，同级别的例外的接收者是无法收到该广播。 　</p>
<h5 id="异步广播"><a href="#异步广播" class="headerlink" title="异步广播"></a>异步广播</h5><p>使用方法：sendStickyBroadcast() ：</p>
<p>发出的Intent当接收Activity（动态注册）重新处于onResume状态之后就能重新接受到其Intent.（the Intent will be held to be re-broadcast to future receivers）。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Activity处于活跃的时候又会接受到它</p>
<p>发这个广播需要权限：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.BROADCAST_STICKY"</span> /&gt;</div></pre></td></tr></table></figure>
<p>卸载该广播：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">removeStickyBroadcast(intent);</div></pre></td></tr></table></figure>
<p>在卸载之前该intent会保留，接收者在可接收状态都能获得。</p>
<h5 id="异步有序广播"><a href="#异步有序广播" class="headerlink" title="异步有序广播"></a>异步有序广播</h5><p>使用方法：sendStickyOrderedBroadcast(intent, resultReceiver, scheduler, initialCode, initialData, initialExtras)：</p>
<p>这个方法具有有序广播的特性也有异步广播的特性；同时需要限权：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.BROADCAST_STICKY"</span> /&gt;</div></pre></td></tr></table></figure>
<h3 id="四-安全性"><a href="#四-安全性" class="headerlink" title="四 安全性"></a>四 安全性</h3><p>BroadcastReceiver的设计初衷就是从全局考虑的，可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言BroadcastReceiver是存在安全性问题的，相应问题及解决如下：   </p>
<ul>
<li>当应用程序发送某个广播时系统会将发送的Intent与系统中所有注册的BroadcastReceiver的IntentFilter进行匹配，若匹配成功则执行相应的onReceive函数。可以通过类似sendBroadcast(Intent, String)的接口在发送广播时指定接收者必须具备的permission。或通过Intent.setPackage设置广播仅对某个程序有效。</li>
<li>当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。对于动态注册的广播可以通过类似registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)的接口指定发送者必须具备的permission，对于静态注册的广播可以通过android:exported=”false”属性表示接收者对外部应用程序不可用，即不接受来自外部的广播。</li>
<li>上面两个问题其实都可以通过LocalBroadcastManager来解决，LocalBroadcastManager只会将广播限定在当前应用程序中。</li>
<li>使用android:protectionLevel</li>
</ul>
<p>android引入了LocalBroadcastManager解决在第4部分安全性介绍的一些问题，LocalBroadcastManager除了能解决BroadcastReceiver进程间安全性问题外，相对Context操作的BroadcastReceiver而言还具有更高的运行效率。使用LocalBroadcastManager需要引入Android Support Library，如何引入见Add Support Package。<br>本地广播通过LocalBroadcastManager.getInstance(context).sendBroadcast(intent)发送广播，LocalBroadcastManager.getInstance(context).registerReceiver注册服务，通过LocalBroadcastManager.getInstance(context).unregisterReceiver取消注册服务，其他同普通广播.</p>
<h3 id="五-一些常用的系统广播的action-和permission"><a href="#五-一些常用的系统广播的action-和permission" class="headerlink" title="五 一些常用的系统广播的action 和permission"></a>五 一些常用的系统广播的action 和permission</h3><h5 id="1-开机启动"><a href="#1-开机启动" class="headerlink" title="1.开机启动"></a>1.开机启动</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;action android:name=<span class="string">"android.intent.action.BOOT_COMPLETED"</span>/&gt; </div><div class="line"></div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.RECEIVE_BOOT_COMPLETED"</span> /&gt;</div></pre></td></tr></table></figure>
<h5 id="2-网络状态"><a href="#2-网络状态" class="headerlink" title="2.网络状态"></a>2.网络状态</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;action android:name=<span class="string">"android.net.conn.CONNECTIVITY_CHANGE"</span>/&gt;  </div><div class="line"></div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span>/&gt;</div></pre></td></tr></table></figure>
<p>网络是否可用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNetworkAvailable</span><span class="params">(Context context)</span> </span>&#123;  </div><div class="line">        ConnectivityManager mgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);  </div><div class="line">        NetworkInfo[] info = mgr.getAllNetworkInfo();  </div><div class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; info.length; i++) &#123;  </div><div class="line">      <span class="keyword">if</span> (info[i].getState() == NetworkInfo.State.CONNECTED) &#123;  </div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="3-电量变化"><a href="#3-电量变化" class="headerlink" title="3.电量变化"></a>3.电量变化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;action android:name=<span class="string">"android.intent.action.BATTERY_CHANGED"</span>/&gt;</div></pre></td></tr></table></figure>
<p>BroadcastReceiver 的onReceive方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;  </div><div class="line">        <span class="keyword">int</span> currLevel = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, <span class="number">0</span>);  <span class="comment">//当前电量  　</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> total = intent.getIntExtra(BatteryManager.EXTRA_SCALE, <span class="number">1</span>);    <span class="comment">//总电量  </span></div><div class="line">        <span class="keyword">int</span> percent = currLevel * <span class="number">100</span> / total;  </div><div class="line">        Log.i(TAG, <span class="string">"battery: "</span> + percent + <span class="string">"%"</span>);  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h3><ul>
<li>静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。</li>
<li>动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：1)这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。2)这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。</li>
<li>广播发出的时候，广播接收者接收的顺序如下：<br>1)当广播为普通广播时，有如下的接收顺序：  </li>
</ul>
<p>a、无视优先级<br>b、动态优先于静态<br>c、同优先级的动态广播接收器，先注册的大于后注册的<br>d、同优先级的静态广播接收器，先扫描的大于后扫描的　   </p>
<p>2）如果广播为有序广播，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：　<br>   　　 　　<br>a、优先级高的先接收　 　<br>b、同优先级的动静态广播接收器，动态优先于静态 　　<br>c、同优先级的动态广播接收器，先注册的大于后注册的 　　<br>d、同优先级的静态广播接收器，先扫描的大于后扫描的　   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/02/27/android基础之BroadcastReceiver/" data-id="cj0m73bgv000rm0nz2u9avhpu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BroadcastReceiver/">BroadcastReceiver</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android基础之Handler与AsycTask" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/27/android基础之Handler与AsycTask/" class="article-date">
  <time datetime="2017-02-27T06:47:53.000Z" itemprop="datePublished">2017-02-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/27/android基础之Handler与AsycTask/">android基础之Handler与AsycTask</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>Handler是Android中用于线程间通信的机制。</p>
<p>当程序第一次启动的时候，Android会同时启动一条主线程（ Main Thread）来负责处理与UI相关的事件，我们叫做UI线程。Android的UI操作并不是线程安全的（出于性能优化考虑），意味着如果多个线程并发操作UI线程，可能导致线程安全问题。为了解决Android应用多线程问题—Android平台只允许UI线程修改Activity里的UI，这样如果在主线程中执行耗时操作就会导致UI阻塞，若超过5秒就会造成ANR。</p>
<p>因此我们需要另开线程来处理这些耗时操作，而处理的结果我们可能需要传给主线程用于UI更新，这是就需要线程间的通信。Handler即是Android中用于线程间通信的机制，现在市场一些android的线程通信框架基本上都是基于Handler实现的，如下文将要介绍的已经置于android源码中AsycTask，和现在比较流行的EventBus。</p>
<h3 id="二-Handler的主要作用"><a href="#二-Handler的主要作用" class="headerlink" title="二 Handler的主要作用"></a>二 Handler的主要作用</h3><p>通过翻看的Handler的源码可知，Handler主要有两个作用。</p>
<h5 id="1-线程延时"><a href="#1-线程延时" class="headerlink" title="1.线程延时"></a>1.线程延时</h5><p>Handler中内置了线程延时的方法：</p>
<ul>
<li>final boolean postAtTime(Runnable r, long uptimeMillis)</li>
<li>final boolean postDelayed(Runnable r, long delayMillis)</li>
</ul>
<h5 id="2-线程通信"><a href="#2-线程通信" class="headerlink" title="2.线程通信"></a>2.线程通信</h5><p>主要步骤：</p>
<ul>
<li><p>在新启动的线程中发送消息<br>使用Handler对象的sendMessage()方法或者SendEmptyMessage()方法发送消息。   </p>
</li>
<li><p>在主线程中获取处理消息<br>重写Handler类中处理消息的方法（void handleMessage(Message msg)），当新启动的线程发送消息时，消息发送到与之关联的MessageQueue。而Hanlder不断地从MessageQueue中获取并处理消息。</p>
</li>
</ul>
<h3 id="三-Handler与UI线程通信示例"><a href="#三-Handler与UI线程通信示例" class="headerlink" title="三 Handler与UI线程通信示例"></a>三 Handler与UI线程通信示例</h3><ul>
<li>首先要进行Handler 申明，复写handleMessage方法( 放在主线程中)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler() &#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            <span class="comment">// TODO 接收消息并且去更新UI线程上的控件内容</span></div><div class="line">            <span class="keyword">if</span> (msg.what == UPDATE) &#123;</div><div class="line">                <span class="comment">// 更新界面上的textview</span></div><div class="line">                tv.setText(String.valueOf(msg.obj));</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<ul>
<li>子线程发送Message给ui线程表示自己任务已经执行完成，主线程可以做相应的操作了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">// TODO 子线程中通过handler发送消息给handler接收，由handler去更新TextView的值</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                       <span class="comment">//do something</span></div><div class="line"></div><div class="line">                        Message msg = <span class="keyword">new</span> Message();</div><div class="line">                        msg.what = UPDATE;                  </div><div class="line">                        msg.obj = <span class="string">"更新后的值"</span> ;</div><div class="line">                        handler.sendMessage(msg);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div></pre></td></tr></table></figure>
<h3 id="四-Handler原理分析"><a href="#四-Handler原理分析" class="headerlink" title="四 Handler原理分析"></a>四 Handler原理分析</h3><h5 id="1-Handler的构造函数"><a href="#1-Handler的构造函数" class="headerlink" title="1.Handler的构造函数"></a>1.Handler的构造函数</h5><ol>
<li>public　Handler() </li>
<li>public　Handler(Callbackcallback)</li>
<li>public　Handler(Looperlooper)</li>
<li>public　Handler(Looperlooper, Callbackcallback) </li>
</ol>
<ul>
<li>第1个和第2个构造函数都没有传递Looper，这两个构造函数都将通过调用Looper.myLooper()获取当前线程绑定的Looper对象，然后将该Looper对象保存到名为mLooper的成员字段中。 　<br>下面来看1,2个函数源码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(callback, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//他们会调用Handler的内部构造方法</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">  <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">  <span class="keyword">if</span> ((klass.isAnonymousClass() ||klass.isMemberClass()</div><div class="line">     || klass.isLocalClass()) &amp;&amp;</div><div class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</div><div class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</div><div class="line">                klass.getCanonicalName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> <span class="comment">/************************************</span></div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    if (mLooper == null) &#123;</div><div class="line">        throw new RuntimeException(</div><div class="line">            "Can't create handler inside thread that has not called Looper.prepare()");</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过Looper.myLooper()获取了当前线程保存的Looper实例，又通过这个Looper实例获取了其中保存的MessageQueue（消息队列）。每个Handler 对应一个Looper对象，产生一个MessageQueue</p>
<ul>
<li>第3个和第4个构造函数传递了Looper对象，这两个构造函数会将该Looper保存到名为mLooper的成员字段中。 　<br>下面来看3、4个函数源码： </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">     <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line"> &#125;　</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback)</span> </span>&#123;</div><div class="line">     <span class="keyword">this</span>(looper, callback, <span class="keyword">false</span>);</div><div class="line"> &#125;</div><div class="line"><span class="comment">//他们会调用Handler的内部构造方法</span></div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">     mLooper = looper;</div><div class="line">     mQueue = looper.mQueue;</div><div class="line">     mCallback = callback;</div><div class="line">     mAsynchronous = async;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li>第2个和第4个构造函数还传递了Callback对象，Callback是Handler中的内部接口，需要实现其内部的handleMessage方法，Callback代码如下:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> More ...handleMessage(Message msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Handler.Callback是用来处理Message的一种手段，如果没有传递该参数，那么就应该重写Handler的handleMessage方法，也就是说为了使得Handler能够处理Message，我们有两种办法： 　　 </p>
<p>　</p>
<ol>
<li>向Hanlder的构造函数传入一个Handler.Callback对象，并实现Handler.Callback的handleMessage方法  　    </li>
<li>无需向Hanlder的构造函数传入Handler.Callback对象，但是需要重写Handler本身的handleMessage方法 　</li>
</ol>
<p>也就是说无论哪种方式，我们都得通过某种方式实现handleMessage方法，这点与Java中对Thread的设计有异曲同工之处。</p>
<h5 id="Handler发送消息的几个方法的源码"><a href="#Handler发送消息的几个方法的源码" class="headerlink" title="Handler发送消息的几个方法的源码"></a>Handler发送消息的几个方法的源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span></div><div class="line">   &#123;</div><div class="line">       <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</div><div class="line">       Message msg = Message.obtain();</div><div class="line">       msg.what = what;</div><div class="line">       <span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></div><div class="line">   &#123;</div><div class="line">       <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</div><div class="line">           delayMillis = <span class="number">0</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">       MessageQueue queue = mQueue;</div><div class="line">       <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">           RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                   <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">           Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>我们可以看出他们最后都调用了sendMessageAtTime（），然后返回了enqueueMessage方法，下面看一下此方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">　　　　　　<span class="comment">//把当前的handler作为msg的target属性</span></div><div class="line">    msg.target = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在该方法中有两件事需要注意： </p>
<ul>
<li>msg.target = this<br>该代码将Message的target绑定为当前的Handler</li>
<li>queue.enqueueMessage<br>变量queue表示的是Handler所绑定的消息队列MessageQueue，通过调用queue.enqueueMessage(msg, uptimeMillis)我们将Message放入到消息队列中。</li>
</ul>
<h3 id="五-Looper原理分析"><a href="#五-Looper原理分析" class="headerlink" title="五 Looper原理分析"></a>五 Looper原理分析</h3><p>我们一般在主线程申明Handler，有时我们需要继承Thread类实现自己的线程功能，当我们在里面申明Handler的时候会报错。其原因是主线程中已经实现了两个重要的Looper方法，下面看一看ActivityThread.java中main方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">            <span class="comment">//......省略</span></div><div class="line">        Looper.prepareMainLooper();<span class="comment">//&gt;</span></div><div class="line"></div><div class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</div><div class="line">        thread.attach(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</div><div class="line">            sMainThreadHandler = thread.getHandler();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        AsyncTask.init();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</div><div class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span></div><div class="line">   LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Looper.loop();<span class="comment">//&gt;</span></div><div class="line"></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先看prepare()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">　　　　　<span class="comment">//证了一个线程中只有一个Looper实例</span></div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法会调用Looper构造函数同时实例化出MessageQueue和当前thread.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</div><div class="line">    mThread = Thread.currentThread();</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MessageQueue <span class="title">myQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> myLooper().mQueue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>prepare()方法中通过ThreadLocal对象实现Looper实例与线程的绑定。</p>
<p>再看loop()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">           </div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Printer logging = me.mLogging;</div><div class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</div><div class="line">                    msg.callback + <span class="string">": "</span> + msg.what);</div><div class="line">        &#125;</div><div class="line">   <span class="comment">//重点****</span></div><div class="line">        msg.target.dispatchMessage(msg);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// identity of the thread wasn't corrupted.</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</div><div class="line">            Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></div><div class="line">                    + Long.toHexString(ident) + <span class="string">" to 0x"</span></div><div class="line">                    + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></div><div class="line">                    + msg.target.getClass().getName() + <span class="string">" "</span></div><div class="line">                    + msg.callback + <span class="string">" what="</span> + msg.what);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        msg.recycleUnchecked();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先looper对象不能为空，就是说loop()方法调用必须在prepare()方法的后面。</p>
<p>Looper一直在不断的从消息队列中通过MessageQueue的next方法获取Message，然后通过代码msg.target.dispatchMessage(msg)让该msg所绑定的Handler（Message.target）执行dispatchMessage方法以实现对Message的处理。 </p>
<p>Handler的dispatchMessage的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">         handleCallback(msg);</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">             <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                 <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到Handler提供了三种途径处理Message，而且处理有前后优先级之分：首先尝试让postXXX中传递的Runnable执行，其次尝试让Handler构造函数中传入的Callback的handleMessage方法处理，最后才是让Handler自身的handleMessage方法处理Message。</p>
<h3 id="六-如何在子线程中使用Handler"><a href="#六-如何在子线程中使用Handler" class="headerlink" title="六 如何在子线程中使用Handler"></a>六 如何在子线程中使用Handler</h3><p>Handler本质是从当前的线程中获取到Looper来监听和操作MessageQueue，当其他线程执行完成后回调当前线程。</p>
<p>子线程需要先prepare（）才能获取到Looper的，是因为在子线程只是一个普通的线程，其ThreadLoacl中没有设置过Looper，所以会抛出异常，而在Looper的prepare（）方法中sThreadLocal.set(new Looper())是设置了Looper的。</p>
<p>示例代码：</p>
<p>定义一个类实现Runnable接口或继承Thread类（一般不继承）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rub</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </div><div class="line"></div><div class="line">        <span class="keyword">public</span> Handler myHandler;  </div><div class="line">        <span class="comment">// 实现Runnable接口的线程体 </span></div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line"></div><div class="line">         <span class="comment">/*①、调用Looper的prepare()方法为当前线程创建Looper对象并，</span></div><div class="line">          创建Looper对象时，它的构造器会自动的创建相对应的MessageQueue*/</div><div class="line">            Looper.prepare();  </div><div class="line"></div><div class="line">            <span class="comment">/*.②、创建Handler子类的实例，重写HandleMessage()方法，该方法处理除当前线程以外线程的消息*/</span></div><div class="line">             myHandler = <span class="keyword">new</span> Handler() &#123;  </div><div class="line">                <span class="meta">@Override</span>  </div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;  </div><div class="line">                    String ms = <span class="string">""</span>;  </div><div class="line">                    <span class="keyword">if</span> (msg.what == <span class="number">0x777</span>) &#123;  </div><div class="line"></div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line"></div><div class="line">            &#125;;  </div><div class="line">            <span class="comment">//③、调用Looper的loop()方法来启动Looper让消息队列转动起来</span></div><div class="line">            Looper.loop();  </div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>注意分成三步：</p>
<ul>
<li>调用Looper的prepare()方法为当前线程创建Looper对象，创建Looper对象时，它的构造器会创建与之配套的MessageQueue。 　</li>
<li>有了Looper之后，创建Handler子类实例，重写HanderMessage()方法，该方法负责处理来自于其他线程的消息。</li>
<li>调用Looper的looper()方法启动Looper。然后使用这个handler实例在任何其他线程中发送消息，最终处理消息的代码都会在你创建Handler实例的线程中运行。</li>
</ul>
<h3 id="七-Handler总结"><a href="#七-Handler总结" class="headerlink" title="七 Handler总结"></a>七 Handler总结</h3><ul>
<li><p>Handler：<br>发送和处理消息，它把消息发送给Looper管理的MessageQueue，并负责处理Looper分发给它的消息。</p>
</li>
<li><p>Message：<br>Handler接收和处理的消息对象。</p>
</li>
<li><p>Looper：<br>每个线程只有一个Looper，它负责管理对应的MessageQueue，会不断地从MessageQueue取出消息，并将消息分给对应的Hanlder处理。主线程中，系统已经初始化了一个Looper对象，因此可以直接创建Handler即可，就可以通过Handler来发送消息、处理消息。若是在子线程，必须手动创建一个Looper对象，并启动它，调用Looper.prepare()方法。</p>
</li>
<li><p>prapare()：<br>保证每个线程最多只有一个Looper对象。</p>
</li>
<li><p>looper()：<br>启动Looper，使用一个死循环不断取出MessageQueue中的消息，并将取出的消息分给对应的Handler进行处理。 　</p>
</li>
<li><p>MessageQueue：<br>由Looper负责管理，它采用先进先出的方式来管理Message。Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue想关联。Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。</p>
</li>
</ul>
<h3 id="八-Android中另一个线程通信机制AsycTask"><a href="#八-Android中另一个线程通信机制AsycTask" class="headerlink" title="八 Android中另一个线程通信机制AsycTask"></a>八 Android中另一个线程通信机制AsycTask</h3><h5 id="1-AsycTask简介"><a href="#1-AsycTask简介" class="headerlink" title="1.AsycTask简介"></a>1.AsycTask简介</h5><p>AsycTask是Android中另一个处理异步任务的机制，我们上面说了可以用Handler来处理异步任务，但如果耗时的操作太多，那么我们需要开启太多的子线程，这就会给系统带来巨大的负担，随之也会带来性能方面的问题。在这种情况下我们就可以考虑使用类AsyncTask来异步执行任务，不需要子线程和handler，就可以完成异步操作和刷新UI。</p>
<p>AsyncTask主要有二个部分：一个是与主线程的交互，另一个就是线程的管理调度。虽然可能多个AsyncTask的子类的实例，但是AsyncTask的内部Handler和ThreadPoolExecutor都是进程范围内共享的，其都是static的（所以AsycTask是串行的，不支持并发），也即属于类的，类的属性的作用范围是CLASSPATH，因为一个进程一个VM，所以是AsyncTask控制着进程范围内所有的子类实例。AsyncTask内部会创建一个进程作用域的线程池来管理要运行的任务，也就就是说当你调用了AsyncTask的execute()方法后，AsyncTask会把任务交给线程池，由线程池来管理创建Thread和运行Therad。</p>
<p>Android的AsyncTask比Handler更轻量级一些（只是代码上轻量一些，而实际上要比handler更耗资源），适用于简单的异步处理。</p>
<p>注意：不要随意使用AsyncTask,除非你必须要与UI线程交互.默认情况下使用Thread即可,要注意需要将线程优先级调低.AsyncTask适合处理短时间的操作,长时间的操作,比如下载一个很大的视频,这就需要你使用自己的线程来下载,不管是断点下载还是其它的.</p>
<h5 id="2-AsycTask使用步骤"><a href="#2-AsycTask使用步骤" class="headerlink" title="2.AsycTask使用步骤"></a>2.AsycTask使用步骤</h5><p>AsyncTask对线程间的通讯做了包装，使后台线程和UI线程可以简易通讯。后台线程执行异步任务，将result告知UI线程。</p>
<p>使用AsycTask分为两步：</p>
<ul>
<li>继承AsyncTask类实现自己的类    </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/* Params: 输入参数，对应excute()方法中传递的参数。如果不需要传递参数，则直接设为void即可。</span></div><div class="line"></div><div class="line">    ** Progress：后台任务执行的百分比</div><div class="line"></div><div class="line">    ** Result：返回值类型，和doInBackground（）方法的返回值类型保持一致。*/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>复写方法</li>
</ul>
<p>最少要重写以下这两个方法：</p>
<p><strong>a.</strong>doInBackground(Params…)<br>在子线程（其他方法都在主线程执行）中执行比较耗时的操作，不能更新ＵＩ，可以在该方法中调用publishProgress(Progress…)来更新任务的进度。Progress方法是AsycTask中一个final方法只能调用不能重写。</p>
<p><strong>b.</strong>onPostExecute(Result)<br>使用在doInBackground 得到的结果处理操作UI， 在主线程执行，任务执行的结果作为此方法的参数返回。</p>
<p>有时根据需求还要实现以下三个方法：</p>
<p><strong>c.</strong>onProgressUpdate(Progress…)<br>可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。</p>
<p><strong>d.</strong>onPreExecute()<br>这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。  </p>
<p><strong>e.</strong>onCancelled()<br>用户调用取消时，要做的操作</p>
<h5 id="3-AsycTask使用示例"><a href="#3-AsycTask使用示例" class="headerlink" title="3.AsycTask使用示例"></a>3.AsycTask使用示例</h5><p>按照上面的步骤定义自己的异步类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;  </div><div class="line">    <span class="comment">//执行的第一个方法用于在执行后台任务前做一些UI操作  </span></div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;  </div><div class="line"></div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="comment">//第二个执行方法,在onPreExecute()后执行，用于后台任务,不可在此方法内修改UI</span></div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;  </div><div class="line">         <span class="comment">//处理耗时操作</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"后台任务执行完毕"</span>;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">   <span class="comment">/*这个函数在doInBackground调用publishProgress(int i)时触发，虽然调用时只有一个参数  </span></div><div class="line">    但是这里取到的是一个数组,所以要用progesss[0]来取值  </div><div class="line">    第n个参数就用progress[n]来取值   */</div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... progresses)</span> </span>&#123;  </div><div class="line">        <span class="comment">//"loading..." + progresses[0] + "%"</span></div><div class="line">        <span class="keyword">super</span>.onProgressUpdate(progress);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="comment">/*doInBackground返回时触发，换句话说，就是doInBackground执行完后触发  </span></div><div class="line">    这里的result就是上面doInBackground执行后的返回值，所以这里是"后台任务执行完毕"  */</div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String result)</span> </span>&#123; </div><div class="line"></div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="comment">//onCancelled方法用于在取消执行中的任务时更改UI  </span></div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span><span class="params">()</span> </span>&#123;  </div><div class="line"></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在主线程申明该类的对象，调用对象的execute（）函数开始执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MyTask ｔ= <span class="keyword">new</span> MyTask();</div><div class="line">t.execute();<span class="comment">//这里没有参数</span></div></pre></td></tr></table></figure>
<h5 id="4-使用AsyncTask需要注意的地方"><a href="#4-使用AsyncTask需要注意的地方" class="headerlink" title="4.使用AsyncTask需要注意的地方"></a>4.使用AsyncTask需要注意的地方</h5><ul>
<li><p>AsnycTask内部的Handler需要和主线程交互，所以AsyncTask的实例必须在UI线程中创建</p>
</li>
<li><p>AsyncTaskResult的doInBackground(mParams)方法执行异步任务运行在子线程中，其他方法运行在主线程中，可以操作UI组件。</p>
</li>
<li><p>一个AsyncTask任务只能被执行一次。</p>
</li>
<li><p>运行中可以随时调用AsnycTask对象的cancel(boolean)方法取消任务，如果成功，调用isCancelled()会返回true，并且不会执行 onPostExecute() 方法了，而是执行 onCancelled() 方法。</p>
</li>
<li><p>对于想要立即开始执行的异步任务，要么直接使用Thread，要么单独创建线程池提供给AsyncTask。默认的AsyncTask不一定会立即执行你的任务，除非你提供给他一个单独的线程池。如果不与主线程交互，直接创建一个Thread就可以了。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/02/27/android基础之Handler与AsycTask/" data-id="cj0m73bh60013m0nzzqt1uw2d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AsycTask/">AsycTask</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Handler/">Handler</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android基础之loaders" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/27/android基础之loaders/" class="article-date">
  <time datetime="2017-02-27T06:39:21.000Z" itemprop="datePublished">2017-02-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/27/android基础之loaders/">android基础之loaders</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>Loaders从Android3.0开始引进（Loaders被翻译为装载器，它是一个异步加载数据的框架），它能在Activity或Fragment中异步加载数据；装载器具有如下特性：</p>
<ul>
<li>它们对每个Activity和Fragment都有效</li>
<li>它们支持数据的异步加载</li>
<li>它们监视数据源的改变，并在数据源改变时传送新的结果</li>
<li>当由于配置改变而被重新创建后，它们会自动重连到上一个装载器的游标，所以不必重新查询数据</li>
</ul>
<h3 id="二-loader使用相关简介"><a href="#二-loader使用相关简介" class="headerlink" title="二 loader使用相关简介"></a>二 loader使用相关简介</h3><h5 id="LoaderManager"><a href="#LoaderManager" class="headerlink" title="LoaderManager"></a>LoaderManager</h5><p>一个和Activity或Fragment关联抽象类，管理一个或多个装载器的实例，它帮助应用管理那些与Activity或Fragment生命周期相关的长时间运行的操作。最常见的方式是与一个CursorLoader一起使用，你也可以实现自己的装载器以加载其它类型的数据。 每个Activity或Fragment只有一个LoaderManager，但是一个LoaderManager可以拥有多个装载器。</p>
<h5 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h5><p>一个执行异步数据加载的抽象类，它是加载器的基类。你可以使用典型的CursorLoader，但是你也可以实现你自己的子类。一旦装载器被激活，它们应该监视它们的数据源并且在数据改变时传送新的结果。</p>
<h5 id="AsyncTaskLoader"><a href="#AsyncTaskLoader" class="headerlink" title="AsyncTaskLoader"></a>AsyncTaskLoader</h5><p>一个使用AsyncTask来执行异步加载工作的抽象类。继承于Loader</p>
<h5 id="CursorLoader"><a href="#CursorLoader" class="headerlink" title="CursorLoader"></a>CursorLoader</h5><p>一个AsyncTaskLoader的子类，它查询ContentResolver然后返回一个Cursor。这个装载器类的实现遵循查询游标数据源的标准，它的游标查询是通过AsyncTaskLoader在后台线程中执行，从而不会阻塞UI线程。使用这个装载器是从ContentProvider异步加载数据的最好方式。</p>
<h5 id="LoaderManager-LoaderCallbacks"><a href="#LoaderManager-LoaderCallbacks" class="headerlink" title="LoaderManager.LoaderCallbacks"></a>LoaderManager.LoaderCallbacks</h5><p>一个用于客户端与LoaderManager交互的回调接口。主要有三个回调方法：onCreateLoader()，onLoadFinished()，onLoaderReset()。</p>
<h3 id="三-使用Loader"><a href="#三-使用Loader" class="headerlink" title="三 使用Loader"></a>三 使用Loader</h3><p>一个使用加载器的典型的应用包含以下几个组件：</p>
<ul>
<li>一个Activity或Fragment；</li>
<li>一个LoaderManager的实例；</li>
<li>一个依靠ContentProvider加载数据的CursorLoader；当然，你也可以继承Loader或AsyncTaskLoader实现你自己的装载器来从其它数据源加载数据；</li>
<li>一个LoaderManager.LoaderCallbacks的实现，这是你创建新的装载器以及管理已有装载器的地方；</li>
<li>一个用于展示装载器的返回数据的方式，例如使用一个SimpleCursorAdapter；</li>
<li>一个数据源，例如ContentProvider（使用CursorLoader加载数据）。</li>
</ul>
<p>代码示例：</p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/02/27/android基础之loaders/" data-id="cj0m73bhb001am0nz79sdq7yr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/loader/">loader</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android基础之Content-Providers" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/27/android基础之Content-Providers/" class="article-date">
  <time datetime="2017-02-27T06:32:42.000Z" itemprop="datePublished">2017-02-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/27/android基础之Content-Providers/">android基础之Content Provider</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>ContentProvider（内容提供者）是Android的四大组件之一，通过它可以向其他的应用程序共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。而且Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。</p>
<p>但注意ContentProvider它也只是一个中间人，真正操作的数据源可能是数据库，也可以是文件、xml或网络等其他存储方式。</p>
<h3 id="Uri类简介"><a href="#Uri类简介" class="headerlink" title="Uri类简介"></a>Uri类简介</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Uri uri = Uri.parse(<span class="string">"content://com.changcheng.provider.contactprovider/contact"</span>)</div></pre></td></tr></table></figure>
<p>在Content Provider中使用的查询字符串有别于标准的SQL查询。很多诸如select, add, delete, modify等操作我们都使用一种特殊的URI来进行，这种URI由3个部分组成， “content://”, 代表数据的路径，和一个可选的标识数据的ID。以下是一些示例URI:    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">content:<span class="comment">//media/internal/images  //这个URI将返回设备上存储的所有图片</span></div><div class="line">content:<span class="comment">//contacts/people/  //这个URI将返回设备上的所有联系人信息</span></div><div class="line">content:<span class="comment">//contacts/people/45  //这个URI返回单个结果（联系人信息中ID为45的联系人记录）</span></div></pre></td></tr></table></figure>
<p>尽管这种查询字符串格式很常见，但是它看起来还是有点令人迷惑。为此，Android提供一系列的帮助类（在android.provider包下），里面包含了很多以类变量形式给出的查询字符串，这种方式更容易让我们理解一点，因此，如上面content://contacts/people/45这个URI就可以写成如下形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Uri person = ContentUris.withAppendedId(People.CONTENT_URI,  <span class="number">45</span>);</div></pre></td></tr></table></figure>
<p>然后执行数据查询:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cursor cur = managedQuery(person, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div></pre></td></tr></table></figure>
<p>这个查询返回一个包含所有数据字段的游标，我们可以通过迭代这个游标来获取所有的数据.</p>
<h3 id="三-ContentProvider类简介"><a href="#三-ContentProvider类简介" class="headerlink" title="三 ContentProvider类简介"></a>三 ContentProvider类简介</h3><h5 id="1-主要方法"><a href="#1-主要方法" class="headerlink" title="1.主要方法"></a>1.主要方法</h5><ul>
<li>public boolean onCreate()<br>ContentProvider创建后　或　打开系统后其它应用第一次访问该ContentProvider时调用。      </li>
<li>public Uri insert(Uri uri, ContentValues values)<br>外部应用向ContentProvider中添加数据。    </li>
<li>public int delete(Uri uri, String selection, String[] selectionArgs)<br>外部应用从ContentProvider删除数据。    </li>
<li>public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)<br>外部应用更新ContentProvider中的数据。    </li>
<li>public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)　<br>供外部应用从ContentProvider中获取数据。 　    </li>
<li>public String getType(Uri uri)<br>该方法用于返回当前Url所代表数据的MIME类型  </li>
</ul>
<h5 id="2-创建步骤"><a href="#2-创建步骤" class="headerlink" title="2.创建步骤"></a>2.创建步骤</h5><p>要创建我们自己的Content Provider的话，我们需要遵循以下几步：</p>
<p>1.创建一个继承了ContentProvider父类的类<br>2.定义一个名为CONTENT_URI，并且是public static final的Uri类型的类变量，你必须为其指定一个唯一的字符串值，最好的方案是以类的全名称， 如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri CONTENT_URI = Uri.parse( “content:<span class="comment">//com.google.android.MyContentProvider”);</span></div></pre></td></tr></table></figure>
<p>3.定义你要返回给客户端的数据列名。如果你正在使用Android数据库，必须为其定义一个叫_id的列，它用来表示每条记录的唯一性。<br>4.创建你的数据存储系统。大多数Content Provider使用Android文件系统或SQLite数据库来保持数据，但是你也可以以任何你想要的方式来存储。<br>5.如果你要存储字节型数据，比如位图文件等，数据列其实是一个表示实际保存文件的URI字符串，通过它来读取对应的文件数据。处理这种数据类型的Content Provider需要实现一个名为_data的字段，_data字段列出了该文件在Android文件系统上的精确路径。这个字段不仅是供客户端使用，而且也可以供ContentResolver使用。客户端可以调用ContentResolver.openOutputStream()方法来处理该URI指向的文件资源；如果是ContentResolver本身的话，由于其持有的权限比客户端要高，所以它能直接访问该数据文件。<br>6.声明public static String型的变量，用于指定要从游标处返回的数据列。<br>7.查询返回一个Cursor类型的对象。所有执行写操作的方法如insert(), update() 以及delete()都将被监听。我们可以通过使用ContentResover().notifyChange()方法来通知监听器关于数据更新的信息。<br>8.在AndroidMenifest.xml中使用<provider>标签来设置Content Provider。<br>9.如果你要处理的数据类型是一种比较新的类型，你就必须先定义一个新的MIME类型，以供ContentProvider.geType(url)来返回。MIME类型有两种形式:一种是为指定的单个记录的，还有一种是为多条记录的。这里给出一种常用的格式：   </provider></p>
<ul>
<li>vnd.android.cursor.item/vnd.yourcompanyname.contenttype （单个记录的MIME类型）<br>比如, 一个请求列车信息的URI如content://com.example.transportationprovider/trains/122 可能就会返回typevnd.android.cursor.item/vnd.example.rail这样一个MIME类型。   </li>
<li>vnd.android.cursor.dir/vnd.yourcompanyname.contenttype （多个记录的MIME类型）<br>比如, 一个请求所有列车信息的URI如content://com.example.transportationprovider/trains 可能就会返回vnd.android.cursor.dir/vnd.example.rail这样一个MIME 类型。</li>
</ul>
<p>下面是一个Content Provider代码示例：</p>
<blockquote>
<p>代码</p>
</blockquote>
<p>一个名为MyContentProvider的Content Provider创建完成了，它用于从Sqlite数据库中添加和读取记录。</p>
<h3 id="四-ContentResolver"><a href="#四-ContentResolver" class="headerlink" title="四 ContentResolver"></a>四 ContentResolver</h3><p>一个ContentProvider新建好了之后，我们需要一个ContentResolver类来获取其共享出的数据。</p>
<h5 id="1-ContentResolver的主要方法"><a href="#1-ContentResolver的主要方法" class="headerlink" title="1.ContentResolver的主要方法"></a>1.ContentResolver的主要方法</h5><ul>
<li>public Uri insert(Uri uri, ContentValues values)　//添加</li>
<li>public int delete(Uri uri, String selection, String[] selectionArgs)　//删除</li>
<li>public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)　//更新</li>
<li>public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)//获取</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">ContentResolver resolver =  getContentResolver();</div><div class="line">Uri uri = Uri.parse(<span class="string">"content://cn.scu.myprovider/user"</span>);</div><div class="line"></div><div class="line"><span class="comment">//插入</span></div><div class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</div><div class="line">values.put(<span class="string">"name"</span>, <span class="string">"fanrunqi"</span>);</div><div class="line">values.put(<span class="string">"age"</span>, <span class="number">24</span>);</div><div class="line">resolver.insert(uri, values);  </div><div class="line"></div><div class="line"><span class="comment">//查询</span></div><div class="line">Cursor cursor = resolver.query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"userid desc"</span>);</div><div class="line"><span class="keyword">while</span>(cursor.moveToNext())&#123;</div><div class="line">   <span class="comment">//操作</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//更新</span></div><div class="line">ContentValues updateValues = <span class="keyword">new</span> ContentValues();</div><div class="line">updateValues.put(<span class="string">"name"</span>, <span class="string">"finch"</span>);</div><div class="line">Uri updateIdUri = ContentUris.withAppendedId(uri, <span class="number">1</span>);</div><div class="line">resolver.update(updateIdUri, updateValues, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line"><span class="comment">//删除</span></div><div class="line">Uri deleteIdUri = ContentUris.withAppendedId(uri, <span class="number">2</span>);</div><div class="line">resolver.delete(deleteIdUri, <span class="keyword">null</span>, <span class="keyword">null</span>);</div></pre></td></tr></table></figure>
<h5 id="使用ContentResolver获取数据的步骤"><a href="#使用ContentResolver获取数据的步骤" class="headerlink" title="使用ContentResolver获取数据的步骤"></a>使用ContentResolver获取数据的步骤</h5><ol>
<li>通过getContentResolver()方法得到ContentResol1.ver对象。</li>
<li>调用ContentResolver类的query()方法查询数据，该方法会返回一个Cursor对象。</li>
<li>对得到的Cursor对象进行分析，得到需要的数据。</li>
<li>调用Cursor类的close()方法将Cursor对象关闭。</li>
</ol>
<p>示例代码（与上面ContentProvider处的代码相连）：</p>
<blockquote>
<p>代码</p>
</blockquote>
<h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/02/27/android基础之Content-Providers/" data-id="cj0m73bgl000gm0nzxk1dzdba" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Content-Provider/">Content Provider</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>
</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <a href="/" class="logo">ZHENGRUI&#39;BLOG</a>
      &copy; 2017 zhengrui<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
    </div>
    

<script src="/js/jquery.min.js"></script>
<script src="/js/jquery.scrollLoading.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>