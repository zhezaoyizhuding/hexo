<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ZHENGRUI&#39;BLOG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="ZHENGRUI'BLOG">
<meta property="og:url" content="https://zhezaoyizhuding.github.io/index.html">
<meta property="og:site_name" content="ZHENGRUI'BLOG">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZHENGRUI'BLOG">
  
  
    <link rel="icon" href="/favicon.png">
  
  <!-- <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'> -->
  <!-- <link href="//fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <link href="//fonts.useso.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css">
  <link href='//fonts.useso.com/css?family=Open+Sans:300,600' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <a href="/" class="logo">ZHENGRUI&#39;BLOG</a>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about/index.html">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://zhezaoyizhuding.github.io"></form>
        </div>
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
        
        
      </nav>
    </div>
  </div>
</header>
      <nav id="mobile-nav" class="off">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about/index.html" class="mobile-nav-link">About</a>
  
  <div id="search-form-wrap-mobile">
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://zhezaoyizhuding.github.io"></form>
  </div>
</nav>
      <div class="outer">
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">16</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/19/Java基础之内存管理/">Java基础之内存管理</a>
          </li>
        
          <li>
            <a href="/2017/03/19/Java基础之反射与类加载器/">Java基础之反射与类加载器</a>
          </li>
        
          <li>
            <a href="/2017/03/17/Java基础之流/">Java基础之流</a>
          </li>
        
          <li>
            <a href="/2017/03/17/Java基础之异常/">Java基础之异常</a>
          </li>
        
          <li>
            <a href="/2017/03/17/Java基础语法/">Java基础语法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AsycTask/">AsycTask</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BroadcastReceiver/">BroadcastReceiver</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Content-Provider/">Content Provider</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fragment/">Fragment</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Handler/">Handler</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Intent/">Intent</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IntentFilter/">IntentFilter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/List/">List</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Map/">Map</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLite/">SQLite</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Set/">Set</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/View/">View</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ViewGroup/">ViewGroup</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/activity/">activity</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/loader/">loader</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pull/">pull</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/push/">push</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/service/">service</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/view/">view</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事件分发/">事件分发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存管理/">内存管理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/垃圾回收/">垃圾回收</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异常/">异常</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/推送/">推送</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据存储/">数据存储</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/泛型/">泛型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/注解/">注解</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/注释/">注释</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程/">线程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/缓存/">缓存</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/长连接/">长连接</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/集合/">集合</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AsycTask/" style="font-size: 10px;">AsycTask</a> <a href="/tags/BroadcastReceiver/" style="font-size: 10px;">BroadcastReceiver</a> <a href="/tags/Content-Provider/" style="font-size: 10px;">Content Provider</a> <a href="/tags/Fragment/" style="font-size: 10px;">Fragment</a> <a href="/tags/Handler/" style="font-size: 10px;">Handler</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/Intent/" style="font-size: 10px;">Intent</a> <a href="/tags/IntentFilter/" style="font-size: 10px;">IntentFilter</a> <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/List/" style="font-size: 10px;">List</a> <a href="/tags/Map/" style="font-size: 10px;">Map</a> <a href="/tags/SQLite/" style="font-size: 10px;">SQLite</a> <a href="/tags/Set/" style="font-size: 10px;">Set</a> <a href="/tags/View/" style="font-size: 10px;">View</a> <a href="/tags/ViewGroup/" style="font-size: 10px;">ViewGroup</a> <a href="/tags/activity/" style="font-size: 10px;">activity</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/hexo/" style="font-size: 13.33px;">hexo</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/loader/" style="font-size: 10px;">loader</a> <a href="/tags/pull/" style="font-size: 10px;">pull</a> <a href="/tags/push/" style="font-size: 10px;">push</a> <a href="/tags/service/" style="font-size: 10px;">service</a> <a href="/tags/view/" style="font-size: 10px;">view</a> <a href="/tags/事件分发/" style="font-size: 10px;">事件分发</a> <a href="/tags/内存管理/" style="font-size: 10px;">内存管理</a> <a href="/tags/垃圾回收/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/异常/" style="font-size: 10px;">异常</a> <a href="/tags/推送/" style="font-size: 10px;">推送</a> <a href="/tags/数据存储/" style="font-size: 10px;">数据存储</a> <a href="/tags/泛型/" style="font-size: 10px;">泛型</a> <a href="/tags/注解/" style="font-size: 10px;">注解</a> <a href="/tags/注释/" style="font-size: 10px;">注释</a> <a href="/tags/线程/" style="font-size: 10px;">线程</a> <a href="/tags/缓存/" style="font-size: 10px;">缓存</a> <a href="/tags/长连接/" style="font-size: 10px;">长连接</a> <a href="/tags/集合/" style="font-size: 10px;">集合</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">links</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://hexo.io">Hexo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
        <section id="main">
  
    <article id="post-Java基础之内存管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/19/Java基础之内存管理/" class="article-date">
  <time datetime="2017-03-19T14:48:42.000Z" itemprop="datePublished">2017-03-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/19/Java基础之内存管理/">Java基础之内存管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>对于从事C和C++程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的皇帝，又是从事最基础工作的劳动人民—既拥有每一个对象的“所有权”，又担负着每一个对象生命开始到终结的维护责任。</p>
<p>对于Java程序员来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，而且不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误将会成为一项异常艰难的工作。</p>
<p>Java的内存管理分为分配和回收两部分。</p>
<h3 id="二-内存分配"><a href="#二-内存分配" class="headerlink" title="二 内存分配"></a>二 内存分配</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（第2版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示：</p>
<img src="/2017/03/19/Java基础之内存管理/运行时数据区域.jpg" alt="运行时数据区域" title="运行时数据区域">
<p>上图是较细的划分，可以再将它们划分为栈和堆两个部分。</p>
<h5 id="1-栈与堆"><a href="#1-栈与堆" class="headerlink" title="1.栈与堆"></a>1.栈与堆</h5><p>栈区：（线程私有）</p>
<ul>
<li><p>程序计数器：程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
</li>
<li><p>虚拟机栈：java虚拟机运行的java方法(java字节码方法)构成的栈空间，这个空间在运行时存储这些方法的局部变量表、操作栈、动态链接和方法出口。程序员常说的栈其实主要就是指虚拟机栈，Java中的8种基本类型和对象的引用均存放在该区域中。</p>
</li>
<li><p>本地方法栈：本地方法在运行时存储数据产生的栈区。本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p>
</li>
</ul>
<p>栈区可以自己管理自己，一般不会出现问题；造成内存泄露的主要是堆区。</p>
<p>堆区：（线程共享）</p>
<ul>
<li><p>堆：这个就是我们重点要关心的区域，主要存放Java中new出来的对象，也是GC主要运行的重点。</p>
</li>
<li><p>方法区：堆的一部分（但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来），用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。在有些虚拟机中它也被叫做“永久代”（如HotSpot），很少发生垃圾回收行为，这个区域的回收主要针对常量池的回收和对类型的卸载。</p>
</li>
<li><p>运行时常量池：方法区的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p>
</li>
</ul>
<h5 id="2-Java中的对象访问是如何进行的"><a href="#2-Java中的对象访问是如何进行的" class="headerlink" title="2.Java中的对象访问是如何进行的"></a>2.Java中的对象访问是如何进行的</h5><p>介绍完Java虚拟机的运行时数据区之后，我们就可以来探讨一个问题：在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程</p>
<p>序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object obj = <span class="keyword">new</span> Object();</div></pre></td></tr></table></figure>
<p>假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而“new Object()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。</p>
<p>由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。</p>
<h6 id="使用句柄"><a href="#使用句柄" class="headerlink" title="使用句柄"></a>使用句柄</h6><p>如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示：</p>
<img src="/2017/03/19/Java基础之内存管理/通过句柄访问对象.jpg" alt="通过句柄访问对象" title="通过句柄访问对象">
<h6 id="使用直接指针"><a href="#使用直接指针" class="headerlink" title="使用直接指针"></a>使用直接指针</h6><p>如果使用的是直接指针访问方式，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如下图所示：</p>
<img src="/2017/03/19/Java基础之内存管理/通过直接指针访问对象.jpg" alt="通过直接指针访问对象" title="通过直接指针访问对象">
<p>这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。常见的Sun HotSpot虚拟机就是使用的第二种方式。</p>
<h3 id="三-垃圾回收"><a href="#三-垃圾回收" class="headerlink" title="三 垃圾回收"></a>三 垃圾回收</h3><p>说起垃圾收集（Garbage Collection，GC），大部分人都把这项技术当做Java语言的伴生产物。事实上，GC的历史远远比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。</p>
<p>堆中几乎存放着Java世界中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。下面将详细介绍Java虚拟机是如何判断一个对象是否存活的。</p>
<h5 id="1-程序计数法"><a href="#1-程序计数法" class="headerlink" title="1.程序计数法"></a>1.程序计数法</h5><p>很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。</p>
<p>客观地说，引用计数算法（Reference Counting）的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，也有一些比较著名的应用案例，例如微软的COM（Component Object Model）技术、使用ActionScript 3的FlashPlayer、Python语言以及在游戏脚本领域中被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。<strong>但是，Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题（也就是所谓的隔离岛问题）。</strong>如下面示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        testGC();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB=<span class="number">1024</span>*<span class="number">1024</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过 </div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</div><div class="line">        ReferenceCountingGC objA=<span class="keyword">new</span> ReferenceCountingGC();</div><div class="line">        ReferenceCountingGC objB=<span class="keyword">new</span> ReferenceCountingGC();</div><div class="line">        objA.instance=objB;</div><div class="line">        objB.instance=objA;</div><div class="line">        objA=<span class="keyword">null</span>;</div><div class="line">        objB=<span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 假设在这行发生GC，那么objA和objB是否能被回收？</span></div><div class="line">        System.gc();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序计数法无法回收这一类的对象，但事实上Java可以回收他们，因此Java对象判活使用的不是程序计数法而是根搜索法。</p>
<h5 id="2-根搜索法"><a href="#2-根搜索法" class="headerlink" title="2. 根搜索法"></a>2. 根搜索法</h5><p>在主流的商用程序语言中（Java和C#，甚至包括前面提到的古老的Lisp），都是使用根搜索算法（GC Roots Tracing）判定对象是否存活的。这个算法的基本思路就是通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。如图3-1所示，对象object 5、object 6、object7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。</p>
<p>在Java语言里，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li>
<li>方法区中的类静态属性引用的对象。</li>
<li>方法区中的常量引用的对象。</li>
<li>本地方法栈中JNI（即一般说的Native方法）的引用的对象。</li>
</ul>
<img src="/2017/03/19/Java基础之内存管理/根搜索算法判断对象是否可回收.jpg" alt="根搜索算法判断对象是否可回收" title="根搜索算法判断对象是否可回收">
<p>在根搜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己—只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。</p>
<p>另外一个值得注意的地方任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。 需要特别说明的是，上面关于对象死亡时finalize()方法的描述可能带有悲情的艺术色彩，笔者并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用它，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中提到它适合做“关闭外部资源”之类的工作，这完全是对这种方法的用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或其他方式都可以做得更好、更及时，大家完全可以忘掉Java语言中还有这个方法的存在。</p>
<h5 id="3-Java中的引用"><a href="#3-Java中的引用" class="headerlink" title="3. Java中的引用"></a>3. Java中的引用</h5><p>JDK1.2开始Java将引用分成了四种：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（WeakReference）、虚引用（Phantom Reference），这四种引用强度依次逐渐减弱。</p>
<ul>
<li>强引用：强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>
<li>软引用：软引用用来描述一些还有用，但并非必需的对象。只有在内存不足时，才会回收该对象。在JDK 1.2之后，提供了SoftReference类来实现软引用。</li>
<li>弱引用：弱引用比软引用更弱一些，只要GC线程扫到它，不管内存是否不足，都会回收它。在JDK 1.2之后，提供了WeakReference类来实现弱引用。</li>
<li>虚引用：虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。</li>
</ul>
<h5 id="4-回收方法区"><a href="#4-回收方法区" class="headerlink" title="4. 回收方法区"></a>4. 回收方法区</h5><p>很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。</p>
<p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。 判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class及-XX:+TraceClassLoading、 -XX:+TraceClassUnLoading查看类的加载和卸载信息。</p>
<p>在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
<h5 id="5-垃圾收集算法"><a href="#5-垃圾收集算法" class="headerlink" title="5.垃圾收集算法"></a>5.垃圾收集算法</h5><h5 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1. 标记-清除算法"></a>1. 标记-清除算法</h5><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经基本介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<h5 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2.复制算法"></a>2.复制算法</h5><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。</p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1∶1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p>
<h5 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3.标记-整理算法"></a>3.标记-整理算法</h5><p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，这样就不会造成内存碎片。</p>
<h5 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.分代收集算法"></a>4.分代收集算法</h5><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。因<strong>此现在的垃圾回收器都是同时采用多种算法，以达到更高性能。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/03/19/Java基础之内存管理/" data-id="cj0m800v600005cnzino7dpkq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存管理/">内存管理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/垃圾回收/">垃圾回收</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础之反射与类加载器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/19/Java基础之反射与类加载器/" class="article-date">
  <time datetime="2017-03-19T14:48:27.000Z" itemprop="datePublished">2017-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/19/Java基础之反射与类加载器/">Java基础之反射与类加载器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/03/19/Java基础之反射与类加载器/" data-id="cj0m800vb00025cnz1s2nxq6q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础之流" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/17/Java基础之流/" class="article-date">
  <time datetime="2017-03-17T08:06:59.000Z" itemprop="datePublished">2017-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/17/Java基础之流/">Java基础之流</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>Java在java.io包下提供了相应的类和接口来对IO进行支持。Java中主要包含输入输出两种流，没中输入输出流又分为字节流和字符流两种流。其中字节流以字节为单位处理输入输出操作，字符流以字符来处理输入输出操作。从Java7开始Java在java.nio包下提供了一种全新的API，被称作NIO，它可以更高效的进行输入、输出操作。</p>
<h3 id="二-Java-IO流相关的类"><a href="#二-Java-IO流相关的类" class="headerlink" title="二 Java IO流相关的类"></a>二 Java IO流相关的类</h3><ul>
<li>File类：系统中文件或者目录的实例，里面有很多方法用于获取文件和目录信息，可以通过查看File的源码获知。</li>
<li>字节流：InputStream/OutputStream输入输出字节流的基类</li>
<li>字符流：Reader/Writer 输入输出字符流的基类</li>
<li>处理流：如PrintStream，可以通过传入节点流来简化读写操作。上面的字节流和字符流就叫做节点流。</li>
<li>转换流：如InputStreamReader，字节流转换成字符流，由于字符流比字节流处理方便，所以Java中只有字节流转字符流的类，没有字符流转字节流的类。</li>
<li>缓冲流：如BufferedReader，用于包装字符流。</li>
</ul>
<h3 id="三-RandomAccessFile类"><a href="#三-RandomAccessFile类" class="headerlink" title="三 RandomAccessFile类"></a>三 RandomAccessFile类</h3><p>一个强大的文件内容访问类，可以直接跳转到文件的任意位置读写数据。</p>
<h3 id="四-序列化"><a href="#四-序列化" class="headerlink" title="四 序列化"></a>四 序列化</h3><p>Java中的序列化是将Java对象转化为二进制流，以便写入磁盘或者在网络上传输。要序列化某个对像需要实现Serializable或者Externalizable（一般是实现Serializable），这在JavaEE中非常普遍，因为JavaEE张系统之间要相互远程调用，一般建议将每一个JavaBean都要序列化。</p>
<p>如果一个类中注入了另一个对象，若想这个类可以序列化，则这个对象所在的类也必须序列化。</p>
<h5 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h5><ul>
<li><p>使用transient关键字<br>有时候我们序列化一个对象，却不想它的某个成员变量被序列化，可以使用transient关键字修饰该变量。</p>
</li>
<li><p>实现特殊的签名方法<br>自定义序列化的类要实现这些方法：writeObject，readObject，readObjectNoData</p>
</li>
<li><p>实现Externalizable接口，自定义序列化</p>
</li>
</ul>
<h5 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h5><p>反序列化必须提供对象的class文件，但是随着项目的升级，class文件也会改变，为了保证两个class文件的兼容性，Java要求需要序列化的类要是设置一个private static final变量serialVersionUID。只要改值不变，则被认为是同一个序列化版本。</p>
<h3 id="五-Java-NIO（Java4新增，Java7增强）"><a href="#五-Java-NIO（Java4新增，Java7增强）" class="headerlink" title="五 Java NIO（Java4新增，Java7增强）"></a>五 Java NIO（Java4新增，Java7增强）</h3><p>采用内存映射文件的方式来处理输入/输出，效率很高。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/03/17/Java基础之流/" data-id="cj0m800vj00055cnzfwcc9vj8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IO/">IO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础之异常" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/17/Java基础之异常/" class="article-date">
  <time datetime="2017-03-17T08:06:28.000Z" itemprop="datePublished">2017-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/17/Java基础之异常/">Java基础之异常</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>异常处理已经成为衡量一门语言是否成熟的标准之一，目前主流的C++，C#，Ruby，Python等大都提供了异常处理机制。异常处理可以使正常业务代码与异常代码分离开，使程序具有更好的容错性和健壮性。一个好的程序员不只能做好”对“的事情，“错”的事情也要做好。</p>
<h3 id="二-Java异常继承体系"><a href="#二-Java异常继承体系" class="headerlink" title="二 Java异常继承体系"></a>二 Java异常继承体系</h3><p>Java中的异常皆继承于Exception，Exception与Error共同继承于Throwable。下面是Java的异常继承体系图：</p>
<img src="/2017/03/17/Java基础之异常/Java异常继承体系图.jpg" alt="Java异常继承体系图" title="Java异常继承体系图">
<h3 id="三-Java中的异常处理"><a href="#三-Java中的异常处理" class="headerlink" title="三 Java中的异常处理"></a>三 Java中的异常处理</h3><p>Java中的异常分为Checked（编译时异常）和RuntimeException（运行时异常）两种，同时规定Checked异常必须被处理否则无法通过编译，这虽进一步增强了Java程序的健壮性，但是也使开发者烦不胜烦，是否应该存在该类异常一直是备受争议的问题。</p>
<p>Java定义了5个关键字来处理异常：try，catch，finally，throw，throws。</p>
<h5 id="1-使用try…catch…finally捕获异常"><a href="#1-使用try…catch…finally捕获异常" class="headerlink" title="1.使用try…catch…finally捕获异常"></a>1.使用try…catch…finally捕获异常</h5><p>Java提供了try…catch…finally的方式来捕获异常，在try块中处理业务代码，在catch块中捕获异常并处理异常，在finally块中关闭在try中打开的物理资源，如文件，数据库等。如下面代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">   System.out.println(<span class="string">"try"</span>) ;</div><div class="line">&#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</div><div class="line">   System.out.println(<span class="string">"Exception thrown  :"</span> + e);</div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span>&#123;</div><div class="line">   System.out.println(<span class="string">"The finally statement is executed"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果没有在捕获异常后还需要处理的问题，则可以省略finally块；若有多个异常，可以写多个catch块（但是只能执行一个），在Java7之前一个catch块只能捕获一个异常，同时要注意子异常应该写在父异常前面，否者编译不通过。</p>
<p><strong>注意finally是无论如何都会执行的模块（除非虚拟机崩了），尽量不要再finally中添加return，它会覆盖try的return。</strong></p>
<h5 id="2-访问异常信息"><a href="#2-访问异常信息" class="headerlink" title="2.访问异常信息"></a>2.访问异常信息</h5><p>前面说到Java中的异常最终皆继承于Throwable，而Throwable有以下几个方法在捕获异常后经常用到：</p>
<ul>
<li>getMessage()： 返回该异常的详细描述字符串。</li>
<li>printStackTrace()：将该异常的跟踪栈信息打印出来</li>
<li>printStackTrace(PrintStream s)：将该异常的跟踪栈信息输出到指定输出流</li>
<li>getStackTrace()：返回该异常的跟踪栈信息</li>
</ul>
<h5 id="3-Java中Checked异常和Runtime异常"><a href="#3-Java中Checked异常和Runtime异常" class="headerlink" title="3.Java中Checked异常和Runtime异常"></a>3.Java中Checked异常和Runtime异常</h5><p>Java中增加了一个Checked异常，而其他语言都没有该异常。这些异常必须被显示处理，否则编译不通过。这体现了java<br>设计的哲学–没有完善错误处理的代码根本不会被执行。对checked异常的处理有以下两种：</p>
<ul>
<li>使用try…catch捕获异常</li>
<li>使用throws抛出异常</li>
</ul>
<p>而Runtime异常很灵活，不需要显示声明抛出，当然也可以使用try-catch捕获该异常并处理，而Checked异常就是个老流氓，你要么捕获并处理它，要么抛出它让你的上一层调用者处理它。</p>
<h5 id="4-使用throws声明抛出异常"><a href="#4-使用throws声明抛出异常" class="headerlink" title="4.使用throws声明抛出异常"></a>4.使用throws声明抛出异常</h5><p>throws只能在方法签名后声明抛出异常，可以抛出多个异常类。</p>
<p>使用throws抛出异常的思路是：当前方法不知道如果处理该异常（如果能处理就用try-catch捕获它），将它抛给上层调用者处理，如果上层调用者也无法处理，继续向上抛出，知道main方法，如果main方法也不能处理，抛给JVM虚拟机。JVM对异常的处理方式是：打印异常的跟踪栈信息，并中止程序。</p>
<p>使用throws抛出异常也有限制:子类方法声音抛出的异常应当是父类抛出异常的子类（或者二者想同），子类声明抛出的异常不允许比父类抛出的多。</p>
<p>throws一般用来抛出Checked异常。</p>
<h5 id="5-使用throw抛出异常"><a href="#5-使用throw抛出异常" class="headerlink" title="5.使用throw抛出异常"></a>5.使用throw抛出异常</h5><p>异常这个东西很有哲学性，你可以把它理解为与预想不符的东西，在这个地方它不是异常，而在另一个地方它可能就是异常。所以很多时候，系统是否要抛出异常，可能要根据具体的业务来决定，而这些有具体业务需求而产生的异常，系统无法自动抛出，不需有程序员手动抛出。这时就使用throw。<br>throw抛出的是一个异常实例，可单独成句，自行抛出异常，但每次只能抛出一个异常。示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"你要打开的文件已经存在了"</span>);</div></pre></td></tr></table></figure>
<p>使用throw抛出的异常，在catch中亦可以捕获到。但throw一般不这样是使用，它一般与throws结合使用。因为有时候底层的异常比较敏感，我们不希望程序的调用者或者使用者看到这些异常，这时候我们就可以在catch中捕获这些敏感异常（一般将其输入到日志中），然后再用throw抛出一个新的异常（一般是对发生的异常的描述）给它的调用者，最后通过throws抛给它的调用者。这样我们就对底层进行了很好的封装。</p>
<p>在Java7之前我们通过throw抛出的是什么异常，那方法签名后的throws也要抛出相应异常。Java7之后，系统可以判断出具体发生的异常。比如，如果发生的是FileOutputException，而捕获并throw的是Exception异常，在Java7之前throws必须抛出Exception异常，而Java7之后throws FileOutputException即可。</p>
<h3 id="四-Java7增强的异常"><a href="#四-Java7增强的异常" class="headerlink" title="四 Java7增强的异常"></a>四 Java7增强的异常</h3><h5 id="1-Java7增强功能点一"><a href="#1-Java7增强功能点一" class="headerlink" title="1.Java7增强功能点一"></a>1.Java7增强功能点一</h5><p>在Java7之前一个catch只能捕获一个异常，但Java7新增了一个功能是的一个catch可以捕获多个异常。使用一个catch捕获多个异常应该注意一下两个方面：</p>
<ul>
<li>在捕获多异常时多个异常之间用“|”分隔</li>
<li>捕获多异常时，异常对象有隐式的final属性，无法对它重新赋值（单异常时可以）</li>
</ul>
<h5 id="2-Java7增强功能点二"><a href="#2-Java7增强功能点二" class="headerlink" title="2.Java7增强功能点二"></a>2.Java7增强功能点二</h5><p>在Java7之前如果在try中打开了物理资源，就必须在finally中关闭，Java7新增了一个功能，可以使try中打开的资源自动关闭。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>(</div><div class="line">	BufferedReader br = <span class="keyword">new</span> BufferedReader(</div><div class="line">		<span class="keyword">new</span> FileReader(<span class="string">"test.java"</span>));</div><div class="line">	PrintStream ps = <span class="keyword">new</span> PrintStream(</div><div class="line">		<span class="keyword">new</span> FileOutputStream(<span class="string">"a.txt"</span>))</div><div class="line">)&#123;</div><div class="line">	System.out.println(br.readLine());</div><div class="line">	ps.println(<span class="string">"我若成佛，天下无魔；我若成魔，佛奈我何"</span>);	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要指出的是要想自动关闭资源，这些资源实现类必须实现AutoCloseable或Closeable接口，实现它们的close方法。放心这些工作不需要你来做，Java7基本把所有的资源类进行了改写，使它们实现了AutoCloseable或Closeable接口。</p>
<h3 id="五-自定义异常"><a href="#五-自定义异常" class="headerlink" title="五 自定义异常"></a>五 自定义异常</h3><p>有时候为了抛出明确的异常，我们需要自定义异常类。</p>
<p>自定义异常类继承于Exception类，如果希望自定义Runtime异常，就继承于RuntimeException类。定义自定义异常类需要提供了两个构造器：</p>
<ul>
<li>一个是无参构造器</li>
<li>一个是带一个字符串参数的构造器，该字符串传入该异常对象的描述信息</li>
</ul>
<p>下面是代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CustomException</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">	<span class="function">puvlic <span class="title">CustomException</span><span class="params">(String msg)</span></span>&#123;</div><div class="line">		<span class="keyword">super</span>(msg);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义异常类应该取一个足以描述异常的类名。</p>
<h3 id="六-异常处理规则"><a href="#六-异常处理规则" class="headerlink" title="六 异常处理规则"></a>六 异常处理规则</h3><p>在Java中使用异常应该遵守一定的规则：</p>
<ul>
<li>不要过度使用异常，只对可能发生异常的语句捕获异常</li>
<li>不要使用过大的try块，不要将可能发生异常的代码与正常代码都放在一个try块中</li>
<li>捕获的异常尽量具体，不要捕获的均是Exception</li>
<li>不要忽略捕获的异常</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/03/17/Java基础之异常/" data-id="cj0m800vm00065cnzt4btsawf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异常/">异常</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础语法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/17/Java基础语法/" class="article-date">
  <time datetime="2017-03-17T02:27:13.000Z" itemprop="datePublished">2017-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/17/Java基础语法/">Java基础语法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/03/17/Java基础语法/" data-id="cj0m800w0000h5cnz6kgfigsf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础之注解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/17/Java基础之注解/" class="article-date">
  <time datetime="2017-03-17T02:26:21.000Z" itemprop="datePublished">2017-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/17/Java基础之注解/">Java基础之注解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>从Java5开始，Java增加了对元数据的支持，也就是Annotation（注解）。Annotation其实就是代码中的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用注解，程序开发人员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。代码分析工具，开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</p>
<p>注解在定义时类似一个接口，程序可以通过反射来获取指定程序元素的注解对象，在使用时注解就像修饰符一样，可用于修饰类，方法，变量参数等。这些信息被存储在注解的“name=value”对中。</p>
<h3 id="二-Java中内置注解"><a href="#二-Java中内置注解" class="headerlink" title="二 Java中内置注解"></a>二 Java中内置注解</h3><p>下面是5个Java中内置的注解：</p>
<ul>
<li><p>@Override<br>用于标记重写方法，被标记的方法说明是重写父类或父接口的方法</p>
</li>
<li><p>@Deprecated<br>标记方法已过时，是不推荐使用的方法</p>
</li>
<li><p>SuppressWarning<br>抑制某个编译器警告，被它标记的方法或者类，在执行时编译器将不再显示其表明抑制的警告。如@SuppressWarning（value=“unchecked”），注解后面的是一些可以设置的值，若只有一个value值，可以省略为@SuppressWarning（“unchecked”）</p>
</li>
<li><p>@SafeVarargs<br>Java7新增的注解，它的效果类似于@SuppressWarning（“unchecked”）</p>
</li>
<li><p>@FunctionalInterface<br>该注解标记该接口为函数式接口。Java8规定：如果如果接口中只有一个抽象方法，则该方法为函数式接口（可以包含多个静态方法或者多个默认方法）。函数式接口就是Java8中为Lambda表达式定义的，Lambda表达式可以直接创建函数式接口的实例。默认方法是Java8中新增的特性，使用default关键字修饰，默认方法同static方法一样可以直接在接口中实现，实际上默认方法就是为了解耦接口和它的实现类而设计的（实现了接口就必须实现它的抽象方法，若接口改变，则所有的实现类都要改变）</p>
</li>
</ul>
<h3 id="三-元注解"><a href="#三-元注解" class="headerlink" title="三 元注解"></a>三 元注解</h3><p>元注解即是修饰注解的注解，用在注解定义的地方。Java中内置了以下几个常用的元注解。</p>
<ul>
<li><p>@Retention<br>该注解只能用于修饰注解的定义，说明该注解可以保留多长时间。它定义了一个value变量，可以有3中取值，对应类加载时的3中状态。<br>1.RetentionPolicy.CLASS：该属性是默认值，说明该注解信息被编译在class文件中，但无法在运行时获取注解信息。<br>2.RetentionPolicy.RUNTIME：表明该注解不止被编译在了class文件中，而且可以在程序运行时通过反射获取注解的信息。<br>3.RetentionPolicy.SOURCE：说明该注解信息只放在源文件中，编译时直接丢弃。   </p>
</li>
<li><p>@Target<br>用于指定被修饰的注解能用于修饰哪些程序单元。它也包含一个名为value的成员变量，该变量包含以下几种取值：<br>1.ElementType.ANNOTATION_TYPE：指定该策略的注解只能修饰注解。<br>2.ElementType.CONSTRUCTOR：标记该注解只能修饰构造器<br>3.ElementType.FIELD：标记该注解只能修饰成员变量<br>4.ElementType.LOCAL_VARIABLE：标记该注解只能修饰局部变量<br>5.ElementType.METHOD：标记该注解只能修饰方法<br>6.ElementType.PACKAGE：标记该注解只能修饰包<br>7.ElementType.PARAMETER：标记该注解只能修饰参数<br>8.ElementType.TYPE：标记该注解能修饰类，接口（包括注解），枚举类型    </p>
</li>
<li><p>@Documented<br>表明被该元注解修饰的注解将被javadoc提取为文档，如果一个注解在定义时使用该元注解修饰，那么所有被该注解修饰的程序元素的API文档中将会包含该注解信息。</p>
</li>
<li><p>@Inherited<br>表明被该元注解修饰的注解具有继承性，即若该被修饰的注解修饰了某个类，则它的子类会自动被该注解修饰。</p>
</li>
</ul>
<h3 id="四-自定义注解"><a href="#四-自定义注解" class="headerlink" title="四 自定义注解"></a>四 自定义注解</h3><p>定义注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是注解的定义过程，可以看到它类似一个接口。起方法名和返回值定义了该成员变量的名字和类型，在定义了这些成员变量后，使用注解时，必须给他们赋值；同时它也可以使用default关键字来定义默认值，这样在使用时就不必须给它赋值。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "Tom"</span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "jeri"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@MyAnnotation</span>(name=<span class="string">"someName"</span>,  value = <span class="string">"Hello World"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheClass</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="五-提取注解信息"><a href="#五-提取注解信息" class="headerlink" title="五 提取注解信息"></a>五 提取注解信息</h3><p>在使用注解修饰了类，方法，成员变量后这些注解不会自己生效，必须有开发者提供相应的工具类来提取并处理这些注解信息。</p>
<p>Java为此提供了一个Annotation接口，它是所有注解的父接口，Java同时还在java.lang.reflect包下新增了AnnotatedElement接口，该接口代表了程序中可以接受注解的程序元素，里面定义一些获取相应元素的注解的方法。它有以下几个实现类：</p>
<ul>
<li>Class</li>
<li>Constructor</li>
<li>Field</li>
<li>Method</li>
<li>Package</li>
</ul>
<h3 id="六-Java8新增的重复注解"><a href="#六-Java8新增的重复注解" class="headerlink" title="六 Java8新增的重复注解"></a>六 Java8新增的重复注解</h3><p>从Java8开始为简化两个相同注解修饰同一个程序元素的情况，定义了重复注解，这个注解也是个元注解–@Repeatable。<br>代码示例：</p>
<p>可重复的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Retention</span>(Retention.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Repeatable</span>（examples.class）</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> example&#123;</div><div class="line">	<span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "Tom"</span>;</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>作为父容器的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Retention</span>(Retention.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> examples&#123;</div><div class="line">	example[] value();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@example</span>(age=<span class="number">5</span>)</div><div class="line"><span class="meta">@example</span>(name=<span class="string">"jeri"</span>,age=<span class="number">9</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatTest</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而不必写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@examples</span>(&#123;<span class="meta">@example</span>(age=<span class="number">5</span>),<span class="meta">@example</span>(name=<span class="string">"jeri"</span>,age=<span class="number">9</span>)&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatTest</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上两种情况都对，Java8就是为了简化第二种形式，才设计了重复注解。</p>
<h3 id="七-Java8新增的类型注解"><a href="#七-Java8新增的类型注解" class="headerlink" title="七 Java8新增的类型注解"></a>七 Java8新增的类型注解</h3><p>Java8为ElementType枚举增加了TYPE_PARAMETER和TYPE_USE两个枚举值，这样定义注解时就允许使用@Target(ElementType.TYPE_USE)修饰，这种注解被称为类型注解，类型注解可用在任何使用类型的地方，如：</p>
<ul>
<li>创建对象（用new关键字创建）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object str = <span class="keyword">new</span> <span class="meta">@NotNull</span> Object();</div></pre></td></tr></table></figure>
<ul>
<li>类型转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String str = (<span class="meta">@NotNull</span> String)Object;</div></pre></td></tr></table></figure>
<ul>
<li>使用implement实现接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">puclic <span class="class"><span class="keyword">class</span> <span class="title">example</span> <span class="keyword">implements</span> @<span class="title">NotNull</span> <span class="title">Serializable</span></span>&#123;&#125;</div></pre></td></tr></table></figure>
<ul>
<li>使用throws声明抛出异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">example</span><span class="params">(<span class="keyword">int</span> i)</span>  <span class="keyword">throws</span> @NotNull FlieNotFoundException</span>&#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="八-注解处理工具APT"><a href="#八-注解处理工具APT" class="headerlink" title="八 注解处理工具APT"></a>八 注解处理工具APT</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/03/17/Java基础之注解/" data-id="cj0m800vo00075cnz953edlt1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/注解/">注解</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/注释/">注释</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础之泛型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/17/Java基础之泛型/" class="article-date">
  <time datetime="2017-03-17T02:26:13.000Z" itemprop="datePublished">2017-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/17/Java基础之泛型/">Java基础之泛型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>Java泛型（generics）是JDK 5中引入的一个新特性，允许在定义类和接口的时候使用类型参数（type parameter）。声明的类型参数在使用时用具体的类型来替换。泛型最主要的应用是在JDK 5中的新集合类框架中。对于泛型概念的引入，开发社区的观点是褒贬不一。从好的方面来说，泛型的引入可以解决之前的集合类框架在使用过程中通常会出现的运行时刻类型错误，因为编译器可以在编译时刻就发现很多明显的错误。而从不好的地方来说，为了保证与旧有版本的兼容性，Java泛型的实现上存在着一些不够优雅的地方。当然这也是任何有历史的编程语言所需要承担的历史包袱。后续的版本更新会为早期的设计缺陷所累。</p>
<p>引入泛型要分清两种继承结构：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于 List<string>和List<object>这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。</object></string></p>
<p>开发人员在使用泛型的时候，很容易根据自己的直觉而犯一些错误。比如一个方法如果接收List<object>作为形式参数，那么如果尝试将一个List<string>的对象作为实际参数传进去，却发现无法通过编译。虽然从直觉上来说，Object是String的父类，这种类型转换应该是合理的。但是实际上这会产生隐含的类型转换问题，因此编译器直接就禁止这样的行为。</string></object></p>
<h3 id="二-类型擦除"><a href="#二-类型擦除" class="headerlink" title="二 类型擦除"></a>二 类型擦除</h3><p>正确理解泛型概念的首要前提是理解类型擦除（type erasure）。 Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的List<object>和List<string>等类型，在编译之后都会变成List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。类型擦除也是Java的泛型实现方式与C++模板机制实现方式之间的重要区别。</string></object></p>
<p>很多泛型的奇怪特性都与这个类型擦除的存在有关，包括：</p>
<ul>
<li><p>泛型类并没有自己独有的Class类对象。比如并不存在List<string>.class或是List<integer>.class，而只有List.class。</integer></string></p>
</li>
<li><p>静态变量是被泛型类的所有实例所共享的。对于声明为MyClass<t>的类，访问其中的静态变量的方法仍然是 MyClass.myStaticVar。不管是通过new MyClass<string>还是new MyClass<integer>创建的对象，都是共享一个静态变量。</integer></string></t></p>
</li>
<li><p>泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型MyException<string>和MyException<integer>的。对于JVM来说，它们都是 MyException类型的。也就无法执行与异常对应的catch语句。</integer></string></p>
</li>
</ul>
<p>类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。同时去掉出现的类型声明，即去掉&lt;&gt;的内容。比如T get()方法声明就变成了Object get()；List<string>就变成了List。接下来就可能需要生成一些桥接方法（bridge method）。这是由于擦除了类型之后的类可能缺少某些必须的方法。比如考虑下面的代码：</string></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String str)</span> </span>&#123;        </div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当类型信息被擦除之后，上述类的声明变成了class MyString implements Comparable。但是这样的话，类MyString就会有编译错误，因为没有实现接口Comparable声明的int compareTo(Object)方法。这个时候就由编译器来动态生成这个方法。</p>
<h3 id="三-泛型接口，泛型类与泛型方法"><a href="#三-泛型接口，泛型类与泛型方法" class="headerlink" title="三 泛型接口，泛型类与泛型方法"></a>三 泛型接口，泛型类与泛型方法</h3><h5 id="1-泛型接口"><a href="#1-泛型接口" class="headerlink" title="1. 泛型接口"></a>1. 泛型接口</h5><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后定义一个生成器类来实现这个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> String[]&#123;<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Pear"</span>&#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        Random rand = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-泛型类"><a href="#2-泛型类" class="headerlink" title="2. 泛型类"></a>2. 泛型类</h5><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Container</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> K key;</div><div class="line">    <span class="keyword">private</span> V value;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Container</span><span class="params">(K k, V v)</span> </span>&#123;</div><div class="line">        key = k;</div><div class="line">        value = v;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.key = key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Container&lt;String, String&gt; c1 = <span class="keyword">new</span> Container&lt;String, String&gt;(<span class="string">"name"</span>, <span class="string">"findingsea"</span>);</div><div class="line">   Container&lt;String, Integer&gt; c2 = <span class="keyword">new</span> Container&lt;String, Integer&gt;(<span class="string">"age"</span>, <span class="number">24</span>);</div></pre></td></tr></table></figure>
<h5 id="3-泛型方法"><a href="#3-泛型方法" class="headerlink" title="3.泛型方法"></a>3.泛型方法</h5><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">        System.out.println(t);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="四-通配符与上下界"><a href="#四-通配符与上下界" class="headerlink" title="四 通配符与上下界"></a>四 通配符与上下界</h3><p>Java中泛型可使用通配符“？”来代替任意类型，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; name = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        List&lt;Integer&gt; age = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        List&lt;Number&gt; number = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</div><div class="line">        </div><div class="line">        name.add(<span class="string">"icon"</span>);</div><div class="line">        age.add(<span class="number">18</span>);</div><div class="line">        number.add(<span class="number">314</span>);</div><div class="line"> </div><div class="line">        getData(name);</div><div class="line">        getData(age);</div><div class="line">        getData(number);</div><div class="line">       </div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(List&lt;?&gt; data)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"data :"</span> + data.get(<span class="number">0</span>));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>java中亦可以使用&lt;? extends T&gt;和&lt;? super T&gt;来设置传入类型的上下界（Java中泛型传入的类型都是对象，因此这些其实就是子类和父类的限制） </p>
<p>代码示例：</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/03/17/Java基础之泛型/" data-id="cj0m800vu000c5cnz0twkp5zf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/泛型/">泛型</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础之线程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/16/Java基础之线程/" class="article-date">
  <time datetime="2017-03-16T01:58:21.000Z" itemprop="datePublished">2017-03-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/16/Java基础之线程/">Java基础之线程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>所谓的多线程就是一个程序中存在多个顺序执行流，每个执行流便是一个线程。Java提供了优秀的多线程支持，下面将会详细介绍Java多线程编程的相关知识。</p>
<h3 id="二-线程与进程的比较"><a href="#二-线程与进程的比较" class="headerlink" title="二 线程与进程的比较"></a>二 线程与进程的比较</h3><p>现在的操作系统基本都支持多进程，即可以同时运行多个任务，每个任务通常是一个程序，每个运行的程序便是一个进程。而一个程序运行时往往有多个顺序执行流，这每个顺序执行流便是一个线程。</p>
<p>线程与进程的区别：</p>
<ul>
<li>线程比进程更轻，并发性更高</li>
<li>线程可以共享进程的资源，便于实现相互之间的通信</li>
<li>创建线程的代价比创建进程的代价小得多</li>
<li>java内置了多线程编程支持，可以非常方便的操作线程</li>
</ul>
<p>并发与并行的区别：</p>
<p>并行是某一时刻同时运行，并发是某一时刻只有一个指令运行，但是多个指令之间切换过快，所以看起来像是同时运行。</p>
<h3 id="三-创建线程的三种方式"><a href="#三-创建线程的三种方式" class="headerlink" title="三 创建线程的三种方式"></a>三 创建线程的三种方式</h3><h5 id="1-继承Thread类创建线程"><a href="#1-继承Thread类创建线程" class="headerlink" title="1.继承Thread类创建线程"></a>1.继承Thread类创建线程</h5><p>使用Thread类创建线程的步骤如下：</p>
<ol>
<li>定义Thread的子类并重写它的run方法，run方法的方法体里面就是线程需要完成的任务</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动线程</li>
</ol>
<p>代码示例：</p>
<p>抽空写</p>
<h5 id="2-实现Runnable接口创建线程"><a href="#2-实现Runnable接口创建线程" class="headerlink" title="2.实现Runnable接口创建线程"></a>2.实现Runnable接口创建线程</h5><p>步骤如下：</p>
<ol>
<li>实现接口Runnable接口，并实现它的run方法。</li>
<li>创建Runnable接口实现类的实例，并把它作为参数传给Thread的构造函数，创建Thread对象（即将该实例作为Thread类的Target），并调用它的start方法启动线程。（Runnable接口时函数式接口，可使用Lambda表达式）</li>
</ol>
<p>代码示例：</p>
<ul>
<li>使用Runnable创建线程的一个优势是多个线程之间可以共享线程类中的实例变量。这也是最常用的一种创建线程的方式，但一般都采用匿名内部类的方式简写。</li>
</ul>
<h5 id="3-使用Callable和Future创建线程"><a href="#3-使用Callable和Future创建线程" class="headerlink" title="3. 使用Callable和Future创建线程"></a>3. 使用Callable和Future创建线程</h5><p>从java5开始，java提供了一个Callable接口，接口中提供了一个call()方法来替代run()方法，它比run方法的功能更强大。主要有以下两点：</p>
<ul>
<li>call方法可以有返回值</li>
<li>call方法可以声明抛出异常</li>
</ul>
<p>由于Callable接口没有继承Runnable接口，且call方法有返回值，因此实现Callable接口的类无法作为Target传入Thread类中。为此java5提供了Future接口来包装Callable接口创建线程，该接口有一个FutureTask实现类，该类同时也实现了Runnable接口，因此该类的对象可以作为Target传入Thread类中来创建线程。</p>
<p>创建并启动有返回值的线程的步骤如下：</p>
<ol>
<li>创建Callable接口的实现类，并实现它的call方法。、</li>
<li>创建FutureTask类来包装Callable接口的实现类的对象（Callable是函数式接口，这一步可以是Lambda表达式）</li>
<li>将FutureTask对象作为Target传入Thread类中，创建线程。</li>
<li>使用FutureTask对象的get方法得到call的返回值</li>
</ol>
<p>Callab接口实现线程与Runnable接口类似，因此它也有Runnable接口的优势。</p>
<h5 id="4-创建线程的三种方式对比"><a href="#4-创建线程的三种方式对比" class="headerlink" title="4. 创建线程的三种方式对比"></a>4. 创建线程的三种方式对比</h5><p>使用Runnable和Callable接口创建线程的优势：</p>
<ul>
<li>因为是实现接口，还可以继承其他类，避免由于Java的单继承特性而带来的局限。</li>
<li>这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而将CPU，代码和数据分开，更清晰。</li>
</ul>
<p>劣势：</p>
<ul>
<li>编程稍稍复杂，且要访问当前线程，需要使用Thread.currentThread()方法获取当前线程的实例</li>
</ul>
<p>使用继承Thread类的方式优势：</p>
<ul>
<li>编程简单</li>
</ul>
<p>劣势：</p>
<p>因为已经继承了Thread类，无法再继承其他的类。</p>
<h3 id="三-线程的生命周期"><a href="#三-线程的生命周期" class="headerlink" title="三 线程的生命周期"></a>三 线程的生命周期</h3><p>Java中的线程总结起来可以划分为5个生命周期：</p>
<ul>
<li>新建：创建Thread类或其子类对象</li>
<li>就绪（可运行）：调用Thread类的start方法启动线程，此时线程处于可运行状态，但何时运行取决于JVM线程调度器的调度。一个就绪的线程只有获得CPU时间片才可以进入运行状态。</li>
<li>运行：获得CPU时间片开始运行。现在的操作系统基本上都是抢占式调度策略（当然也有些小型设备是协作式调度策略），即当前时间片用完，即会被其他线程抢占（取决于优先级）。</li>
<li>阻塞：有sleep、join或者IO造成的线程阻塞（调用suspend()也可以使线程挂起，但是该方法容易导致死锁，已不推荐使用）</li>
<li>死亡：run结束或者异常。（调用stop方法也可以结束线程，但该方法容易造成死锁，已不推荐使用）</li>
</ul>
<p>下面是线程状态转换图：</p>
<img src="/2017/03/16/Java基础之线程/Java线程状态转换图.png" alt="Java线程状态转换图" title="Java线程状态转换图">
<h3 id="四-Java中内置的用于线程控制的方法"><a href="#四-Java中内置的用于线程控制的方法" class="headerlink" title="四 Java中内置的用于线程控制的方法"></a>四 Java中内置的用于线程控制的方法</h3><p>常见的有以下几个方法：（详细请查看Thread源码）</p>
<ul>
<li>join：加入一个线程，是当前线程（调用join的线程所处的线程）阻塞，直到调用join的线程执行完。</li>
<li>setDaemon：将一个线程设置为后台线程（守护线程），该方法必须在start方法前调用；isDaemon判断一个线程是否是后台线程。</li>
<li>sleep：是当前正在执行的线程阻塞</li>
<li>yield：使当前正在执行的线程进入就绪状态。将机会让给与它优先级相同或者比它高的线程，如其优先级很高，完全有可能被JVM的线程调度器再次调用</li>
<li>setPriority：设置当前线程的优先级</li>
</ul>
<h3 id="五-线程同步"><a href="#五-线程同步" class="headerlink" title="五 线程同步"></a>五 线程同步</h3><h5 id="1-使用synchronized关键实现同步"><a href="#1-使用synchronized关键实现同步" class="headerlink" title="1. 使用synchronized关键实现同步"></a>1. 使用synchronized关键实现同步</h5><ul>
<li>同步代码块<br>使用synchronized对对象进行加锁，如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>（obj）&#123;</div><div class="line">   </div><div class="line">   <span class="comment">//TODO</span></div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>同步方法<br>使用synchronized对方法进行加锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> lock（Object obj）&#123;</div><div class="line"></div><div class="line">    <span class="comment">//TODO</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>synchronized关键字可以对代码块，方法加锁，但不能修饰构造器，成员变量等。</p>
<p>使用synchronized加锁后，线程什么情况下会释放锁：</p>
<ul>
<li>同步方法，代码块执行完毕</li>
<li>在同步方法，代码块执行中遇到了break，return</li>
<li>出现了未处理的异常和Error</li>
<li>调用wait方法</li>
</ul>
<p>下列情况下不会释放锁：</p>
<ul>
<li>调用sleep，yield方法</li>
<li>调用suspend方法</li>
</ul>
<h5 id="2-同步锁"><a href="#2-同步锁" class="headerlink" title="2. 同步锁"></a>2. 同步锁</h5><p>从java5开始java提供了接口Lock和ReadWriteLock来实现锁同步。Lock接口有个实现类ReentrantLock，ReadWriteLock有个实现类ReentrantReadWriteLock。使用这两个类可以实现锁同步。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">   lock.lock();</div><div class="line">   <span class="keyword">try</span>&#123;</div><div class="line">      <span class="comment">//需要保证线程安全的代码</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">finally</span>&#123;</div><div class="line">      lock.unlock();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java8又新增了一个StampedLock类，在大多数情况下它可以替代ReentrantReadWriteLock。</p>
<h3 id="六-线程通信"><a href="#六-线程通信" class="headerlink" title="六 线程通信"></a>六 线程通信</h3><h5 id="1-传统的线程通信"><a href="#1-传统的线程通信" class="headerlink" title="1.传统的线程通信"></a>1.传统的线程通信</h5><p>使用wait、notify、notifyAll实现线程通信，适用于使用synchronized关键字来保证线程同步的情况下。代码示例：</p>
<h5 id="2-使用Contition实现线程通信"><a href="#2-使用Contition实现线程通信" class="headerlink" title="2.使用Contition实现线程通信"></a>2.使用Contition实现线程通信</h5><p>若是使用Lock对象实现线程同步，则无法使用上述的线程通信的方法，java5提供了一个Condition类来实现线程通信。可通过Lock对象的newCondition()方法获得Condition对象，Condition对象中有await，signal，signalAll方法分别对应传统的wait，notify，notifyAll方法，用于实现线程通信。</p>
<h5 id="3-使用阻塞队列实现线程通信"><a href="#3-使用阻塞队列实现线程通信" class="headerlink" title="3.使用阻塞队列实现线程通信"></a>3.使用阻塞队列实现线程通信</h5><p>java5提供了一个BlockingQueue接口，它有一个特征：当生产者线程试图向BlockingQueue里放入元素时，若队列已满，则该线程被阻塞；当消费者试图从BlockingQueue里取出元素时，若队列为空，这该线程被阻塞。利用此原理可以实现线程通信。</p>
<p>该接口有几个实现类，可用于构造线程池。</p>
<h3 id="七-线程池"><a href="#七-线程池" class="headerlink" title="七 线程池"></a>七 线程池</h3><p>线程池即是一个对象池，传入的都是Runnable对象，底层使用数组或者集合来实现。java中内置了一个Executeors工厂类来实现线程池（它还有一个子类ForkjoinPool）,此外还可以使用其他的第三方框架，如ThreadPoolExecutor。</p>
<h3 id="八-ThreadLocal类"><a href="#八-ThreadLocal类" class="headerlink" title="八 ThreadLocal类"></a>八 ThreadLocal类</h3><p>在处理多线程并发问题上还有一个解决方案，是使用ThreadLocal类将需要并发的资源封装起来，这样当多个线程并发访问这些资源时，ThreadLocal类会为没一个线程均复制一份该资源的副本，从根本上解决了资源的共享冲突问题。但是此方式虽解决了冲突，但多个线程之间也无法共享资源。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/03/16/Java基础之线程/" data-id="cj0m800vr000a5cnzf6dqne4a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程/">线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础之集合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/13/Java基础之集合/" class="article-date">
  <time datetime="2017-03-13T08:42:33.000Z" itemprop="datePublished">2017-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/13/Java基础之集合/">Java基础之集合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>为了保存数量不确定的数据，以及具有映射关心的数据（也被称为关联数组），java从1.2开始提供了集合类。集合与数组不同，数组必须保存有确定数目的数据，且数组即可以保存基本数据也可以保存对象，而集合只能保存对象。集合类主要负责保存，盛装其他数据，因此集合类也被称作容器类。所有的集合都保存在java.util包下，从java1.5开始还在java.util.concurrent下提供了一下线程安全的集合类。</p>
<p>java中的集合类主要由两个接口派生而出：Collection和Map，它们是java集合框架的根接口。其继承结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Collection</div><div class="line">├List</div><div class="line">│├LinkedList</div><div class="line">│├ArrayList</div><div class="line">│└Vector</div><div class="line">│　└Stack</div><div class="line">├Queue</div><div class="line">└Set</div><div class="line">Map</div><div class="line">├Hashtable</div><div class="line">├HashMap</div><div class="line">└WeakHashMap</div></pre></td></tr></table></figure>
<h3 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h3><p>Collection是List，Set，Queue的父接口，因此在Collection中定义的接口在List，Set，Queue中均可使用。对集合的操作除了添加和删除之外，还有一个重要的操作就是遍历集合。下面来看一下集合中多种多样的遍历方法：</p>
<h5 id="1-使用Iterator遍历集合（推荐方法）"><a href="#1-使用Iterator遍历集合（推荐方法）" class="headerlink" title="1.使用Iterator遍历集合（推荐方法）"></a>1.使用Iterator遍历集合（推荐方法）</h5><p>使用Iterator遍历集合是集合遍历的传统方法，也是推荐方法。Iterator也是java集合框架中的一员，但是它不是用来盛装数据，它的作用主要就是用来遍历（迭代访问）Collection中的元素。我们可以通过Collection下的iterator()来获得这个集合的迭代器对象，并使用它的方法对集合进行遍历。Iterator中包含以下方法:</p>
<ul>
<li>boolean hasNext()<br>判断集合中的元素是否已遍历完，返回true，则还没遍历完</li>
<li>E next()<br>获取集合中的下一个元素</li>
<li>void remove()<br>删除集合中上一次next方法返回的元素</li>
<li>void forEachRemaining(Consumer action)<br>Java8新增的方法，可使用Lambda表达式遍历集合</li>
</ul>
<p>Iterator遍历集合代码示例：</p>
<h5 id="2-使用foreach循环迭代集合"><a href="#2-使用foreach循环迭代集合" class="headerlink" title="2.使用foreach循环迭代集合"></a>2.使用foreach循环迭代集合</h5><p>这是Java5新增的用于变异集合和数组的循环。</p>
<p>foreach遍历集合代码示例：</p>
<h5 id="3-使用Lambda表达式遍历集合"><a href="#3-使用Lambda表达式遍历集合" class="headerlink" title="3.使用Lambda表达式遍历集合"></a>3.使用Lambda表达式遍历集合</h5><p>Java从Java8开始新增Lambda表达式，在很多方面都简化了操作。在遍历集合方面就可以使用Lambda表达式，如：</p>
<ul>
<li><p>forEach(Consumer action)<br>Java8在Iterable接口中增加了一个forEach(Consumer action)方法，该方法的参数类型是一个函数式接口。而Iterable接口时Collection接口的父接口，因此可使用该方法遍历集合。</p>
</li>
<li><p>forEachRemaining(Consumer action)<br>Java8中为Iterator新增的方法，可用于遍历集合。</p>
</li>
</ul>
<p>同时我们还可以用Lambda表达式对集合进行其他的操作，比如：</p>
<p>Java8中为Collection新增了一个removeIf（Predicate filter）方法，Predicate也是函数式接口，可用它来过滤集合。</p>
<p>Java8中新增了Stream，IntStream，LongStream，DoubleStream等流式API，这些API中有大量的聚集函数，如求和，去平均值等。而Collection中亦提供了一个stream()，可返回该集合对应的流，然后再通过这些流式API操作集合。</p>
<h3 id="二-List"><a href="#二-List" class="headerlink" title="二 List"></a>二 List</h3><p>List是一个有序的，可重复的集合。List默认以元素的添加顺序来设置元素的索引（从0开始），因此可以通过索引来查找元素，也因此List允许重复的元素（不会无法分辨这两个元素）。</p>
<p>由于存在索引，List可以通过普通的for来迭代，同事List继承于Collection，可以使用Collection中的方法，同事它还有一个额外的方法listIterator用于List的迭代。</p>
<h5 id="1-ArrayList与Vector"><a href="#1-ArrayList与Vector" class="headerlink" title="1. ArrayList与Vector"></a>1. ArrayList与Vector</h5><p>ArrayList和Vector均是基于数组实现的List集合类，皆继承于List。它们的内部封装了一个动态的，允许再分配的Object[]数组，并使用initialCapacity参数来设置数组的长度（initialCapacity参数可以随着元素的增多而自动增长，默认是10），可通过ensureCapacity（int minCapacity）来一次性设置数组的initialCapacity值，减少重新分配内存的次数，提高性能。</p>
<p>Vector是一种古老的集合类，里面有一些命名很长的方法，现在已不推荐使用。它与ArrayList不同的是，它是线程安全的，而ArrayList不是。</p>
<p>Vector还有一个子类Stack，用于模拟栈这种数据结构，它也是线程安全的。但Stack也是一个古老的类，现已不推荐使用，要模拟栈可使用下文中ArrayDeque。</p>
<ul>
<li>固定长度的ArrayList<br>Java中有一个操作数组的工具类：Arrays，这个类中有一个方法asList可以将数组转换为一个List集合，但是这个ArrayList与上述介绍的不同，它不是继承于List，而是Arrays的内部类，这个集合只能遍历，而不能插入，删除。因此不推荐使用该方法将一个数组转换为集合。</li>
</ul>
<h5 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2. LinkedList"></a>2. LinkedList</h5><p>LinkedList也是List的实现类，但它同时还实现了Deque接口，提供额外的get，remove，insert方法在LinkedList的尾部和首部操作数据，因此LinkedList也可以被用作队列，双端队列，栈来使用。</p>
<p>LinkedList底层是用链表实现的，因此的它的访问性能较差，但插入、删除性能较好。一般迭代LinkedList时需要使用迭代器Iterator，而迭代ArrayList使用普通的for循环即可。</p>
<h3 id="三-Set"><a href="#三-Set" class="headerlink" title="三 Set"></a>三 Set</h3><p>Set集合是无序集合。它就像一个罐子，无法记住元素的添加顺序。通时它也不允许出现重复元素（因为Set是无序的，若出现重复元素，则无法区分），若试图将两个相同的元素添加到一个Set中，则添加操作失败，add()方法返回false，元素不会被加入。常见的Set有HashSet，TreeSet，EnumSet，它们均继承于Set。</p>
<h5 id="1-HashSet"><a href="#1-HashSet" class="headerlink" title="1. HashSet"></a>1. HashSet</h5><p>HashSet继承于Set，因此它具有Set的所有特点。同时它是通过Hash算法来计算元素的存储位置，具有很好的存取和查找性能。因为集合中只能存放对象，因此它们的存储位置实际上是通过对象的hashCode方法得到的。</p>
<p>但是HashSet的判重和Set的不同，Set判重是通过equals()方法比较两个元素的值是否相同，HashSet的判重不只用equals比较两个元素的值，还比较这两个对象hashCode方法的返回值是否相等。只有这两者都满足，HashSet才会判断这两个元素重复。如果equals满足二hashCode不满足，则HashSet会在两个不同的hashCode位置存放这两个对象，而不会判定其重复；如果equals不满足而hashCode满足，则两个元素会被计算到同一个存储位置，此时该位置则采取链式结构来存放这两个元素。此时会严重影响HashSet的性能。</p>
<p>因此，如果我们要重写该对象对应类的equals方法，则也应该重写它的hashCode方法，使得：如果两个对象通过equals方法返回为true，则他们的hashCode返回值也应该相同。</p>
<h5 id="2-LinkedHashSet"><a href="#2-LinkedHashSet" class="headerlink" title="2. LinkedHashSet"></a>2. LinkedHashSet</h5><p>LinkedHashSet继承于HashSet，它与HashSet的不同之处在于它以链表来维持元素的插入次序。即当遍历LinkedHashSet时，它会按照元素的添加顺序来访问集合里的元素。</p>
<p>因为LinkedHashSet要维护元素的插入顺序，因此它的性能要低于HashSet,但是当迭代访问集合里的全部元素时它有很好的性能。</p>
<h5 id="3-TreeSet"><a href="#3-TreeSet" class="headerlink" title="3. TreeSet"></a>3. TreeSet</h5><p>TreeSet是SortedSet的实现类（SortedSet是Set的子接口），它的底层实现是红黑树，可以确保集合中的元素一直处于排序状态。TreeSet中的排序分为自然排序和定制排序。</p>
<p>自然排序默认是升序，这也是TreeSet默认的排序方式。这种方式TreeSet中的元素要实现Comparable接口，并重写它的compareTo()方法，TreeSet在放入元素时会自动调用该元素中compareTo方法与集合中的元素比较大小。同时TreeSet中亦不允许重复元素，因此当compareTo返回0时，元素不会被放入集合中（返回正整数则说明a大约b，负整数则相反）。<br>应当注意：当把一个对象放入TreeSet中时，应当保证该对象的equals方法与compareTo方法得到的结果一致，即若equals方法返回true，则compareTo方法应当返回0。</p>
<p>定制排序：要实现定制排序，如降序排列，需要在创建TreeSet时传入一个Comparator对象负责集合元素的排序逻辑，由于Comparator也是函数式接口，因此可以使用Lambda表达式来代替Comparator对象。</p>
<h5 id="4-EnumSet"><a href="#4-EnumSet" class="headerlink" title="4. EnumSet"></a>4. EnumSet</h5><p>EnumSet是一个专门为枚举类设计的集合，其中的元素必须是指定枚举类型的枚举值。EnumSet集合是有序的，它安枚举类中枚举值的定义顺序来决定集合的元素顺序。EnumSet没有暴露任何构造器（即没有公有的构造器），要创建EnumSet需要调用它的类方法（静态方法）。</p>
<p>EnumSet在内部以位向量的方式存储，这种存储方式非常紧凑，高效，占用内存小，运行效率高。</p>
<h5 id="5-各Set实现类的性能分析"><a href="#5-各Set实现类的性能分析" class="headerlink" title="5. 各Set实现类的性能分析"></a>5. 各Set实现类的性能分析</h5><ul>
<li>HashSet和TreeSet是常用实现，HashSet的性能要比TreeSet好一些，因为TreeSet需要额外的红黑树来维持元素的次序。</li>
</ul>
<ul>
<li><p>LinkedHashSet与HashSet相比，在插入、删除方面，HashSet要快一些；但是在遍历时，LinkedHashSet要更快。</p>
</li>
<li><p>EnumSet是所有Set实现类中性能最好的，但它功能有限，只能保存同一个枚举类的枚举值作为集合元素。</p>
</li>
</ul>
<h3 id="四-Queue"><a href="#四-Queue" class="headerlink" title="四 Queue"></a>四 Queue</h3><p>Queue集合用于模拟队列这种数据结构，队列是先进先出（FIFO）的，头部保存存放时间最长的元素，尾部保存存放时间最短的元素，队尾插入，队首出。Queue还有一个子接口Deque，Deque表示一个双端队列，因此既可以模拟队列也可以模拟栈。Deque有ArrayDeque和LinkedList两个实现类。</p>
<h5 id="1-PriorityQueue"><a href="#1-PriorityQueue" class="headerlink" title="1. PriorityQueue"></a>1. PriorityQueue</h5><p>PriorityQueue并不是严格的队列。它的队列中的元素的顺序并不是按插入队列的顺序，而是按照队列中元素的大小排序。PriorityQueue有两种排序方式：自然排序和定制排序。这点和TreeSet基本一致，可参考上文中TreeSet的简介。</p>
<h5 id="2-Deque和ArrayDeque"><a href="#2-Deque和ArrayDeque" class="headerlink" title="2. Deque和ArrayDeque"></a>2. Deque和ArrayDeque</h5><p>上文已经介绍了Deque，它是Queue的子接口，是一个双端队列，里面定义一些可以在队尾和队首操作元素的方法，因此它既可以模拟栈，也可以模拟队列。它主要有两个实现类：ArrayDeque和LinkedList。</p>
<p>ArrayDeque底层结构和ArrayList类似，一般用它来模拟栈，而不用Stack。</p>
<h3 id="五-Map"><a href="#五-Map" class="headerlink" title="五 Map"></a>五 Map</h3><p>Map是一个key-value键值对。它的每个单元包含key和value两个数据，由key可以找到value。key可以为空但不可重复，其实将它们分开来看，key就是一个Set集合，而value可以看做List，事实上Map中也有相应的方法。可以把Map看做value均为空的Set，事实上要想遍历Map，就需要获取key的Set集合。</p>
<h5 id="1-HashMap和HashTable"><a href="#1-HashMap和HashTable" class="headerlink" title="1. HashMap和HashTable"></a>1. HashMap和HashTable</h5><p>HashMap和Hashtable均为Map接口的实现类，它们之间的关系类似于ArrayList和Vector的关系。Hashtable是一个古老的实现类，现在已不推荐使用。</p>
<p>HashMap和Hashtable有两点区别：</p>
<ul>
<li>Hashtable是线程安全的，而HashMap不是</li>
<li>Hashtable中的key和value均不能为空，而HashMap的可以</li>
</ul>
<p>同时放入key中的对象需要被hash，所以key中的元素均要实现equals和hashCode方法，且二者结果应当一致，即若equals结果为true，则这两个元素的hashCode值也要相等。（与HashSet相同，Java的要hash类均要实现hashCode方法）。</p>
<h5 id="2-LinkedHashMap"><a href="#2-LinkedHashMap" class="headerlink" title="2. LinkedHashMap"></a>2. LinkedHashMap</h5><p>LinkedHashMap是HashMap的子类，这俩的关系就像LinkedHashSet和HashSet的关系。使用一个链表来维持key的插入顺序。因此你可以在外部对元素排好序，然后让其顺序进入集合，就可以得到一个有序的HashMap，而不需要再对其进行排序。</p>
<h5 id="3-Properties"><a href="#3-Properties" class="headerlink" title="3. Properties"></a>3. Properties</h5><p>Properties是Hashtable的子类，也是一个古老的集合类，该类在处理属性文件是特别方便（属性文件即“属性名=属性值”的文件，如Windows上的ini文件）。可以把Properties看做一个key和value均为String的Map。该类可以与XML文件交互。</p>
<h5 id="4-SortedMap和TreeMap"><a href="#4-SortedMap和TreeMap" class="headerlink" title="4. SortedMap和TreeMap"></a>4. SortedMap和TreeMap</h5><p>TreeMap,SortedMap和Map的关心可以参照Set。TreeMap的实现与TreeSet类似，只是其中的元素换成了键值对，而所有对Set中元素的约束在TreeMap中均换成对key的约束。事实上在Java源码中Set的实现即是通过value均为null的Map完成的，所有Java中的Set和Map有很多相通之处。</p>
<h5 id="5-WeakHashMap"><a href="#5-WeakHashMap" class="headerlink" title="5. WeakHashMap"></a>5. WeakHashMap</h5><p>WeakHashMap即是key是弱引用的HashMap。若key被回收，则WeakHashMap会自动删除对应的key-value键值对。可使用它来做缓存。</p>
<h5 id="6-IdentityHashMap"><a href="#6-IdentityHashMap" class="headerlink" title="6. IdentityHashMap"></a>6. IdentityHashMap</h5><p>IdentityHashMap与HashMap不同处在于：IdentityHashMap在处理key相等问题的方式是使用“==”，而不是equals。</p>
<h5 id="7-EnumMap"><a href="#7-EnumMap" class="headerlink" title="7. EnumMap"></a>7. EnumMap</h5><p>EnumMap是使用枚举类实现的Map，它的key是枚举类中的枚举值，创建它时必须传入一个枚举类（类的class对象）。它有以下几个特点：</p>
<ul>
<li>内部以数组形式保存，紧凑，高效。</li>
<li>以枚举类中枚举值的定义顺序来维持key的顺序</li>
<li>key不能为空</li>
</ul>
<h3 id="六-线程安全的集合类"><a href="#六-线程安全的集合类" class="headerlink" title="六 线程安全的集合类"></a>六 线程安全的集合类</h3><h5 id="1-集合工具类Collections"><a href="#1-集合工具类Collections" class="headerlink" title="1. 集合工具类Collections"></a>1. 集合工具类Collections</h5><p>Java提供了一个操作集合的工具类：Collections，里面提供了大量的类方法用于对集合元素进行排序，查询，修改，同步，设置集合不可变等。（工具类中一般都是类方法，即静态方法）。</p>
<p>其中就有一种synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从而解决了多线程并发访问集合时的线程安全问题。读者可以通过查看Collections的源码来了解它的用法。</p>
<h5 id="2-线程安全的集合类"><a href="#2-线程安全的集合类" class="headerlink" title="2. 线程安全的集合类"></a>2. 线程安全的集合类</h5><p>从Java5开始，Java在java.util.concurrent包下面提供了大量线程安全的集合类，主要可分为以下两类：</p>
<ul>
<li><p>以Concurrent开头的集合类<br>如ConcurrentHashMap，ConcurrentSkipListMap，ConcurrentSkipListSet，ConcurrentLinkedQueue，ConcurrentLinkedDeque等</p>
</li>
<li><p>以CopyOnWrite开头的集合类<br>如CopyOnWriteArrayList，，CopyOnWriteArraySet等</p>
</li>
</ul>
<h3 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/03/13/Java基础之集合/" data-id="cj0m800vx000f5cnz0nzmse6i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/List/">List</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Map/">Map</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Set/">Set</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/集合/">集合</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android基础之消息推送" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/01/android基础之消息推送/" class="article-date">
  <time datetime="2017-03-01T06:28:10.000Z" itemprop="datePublished">2017-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/01/android基础之消息推送/">android基础之消息推送</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>消息推送现在是需要与服务器进行通信的app的基本需求，因此我们有必要了解一下android消息推送的机制。</p>
<h3 id="二-几种常见的消息推送的方案"><a href="#二-几种常见的消息推送的方案" class="headerlink" title="二 几种常见的消息推送的方案"></a>二 几种常见的消息推送的方案</h3><ul>
<li><p>轮询(Pull)方式：<br>应用程序应当阶段性的与服务器进行连接并查询是否有新的消息到达，你必须自己实现与服务器之间的通信，例如消息排队等。而且你还要考虑轮询的频率，如果太慢可能导致某些消息的延迟，如果太快，则会大量消耗网络带宽和电池。</p>
</li>
<li><p>SMS(Push)方式：<br>在Android平台上，你可以通过拦截SMS消息并且解析消息内容来了解服务器的意图，并获取其显示内容进行处理。但是这种方法需要向移动公司缴纳相应的费用。我们目前很难找到免费的短消息发送网关来实现这种方案。</p>
</li>
<li><p>长连接(Push)方式：<br>这个方案是现在使用较多的方案。下面主要介绍pull和这种消息推送的方案。</p>
</li>
</ul>
<h3 id="三-轮询（pull）原理介绍"><a href="#三-轮询（pull）原理介绍" class="headerlink" title="三 轮询（pull）原理介绍"></a>三 轮询（pull）原理介绍</h3><h5 id="1-原理（即是一个http请求）"><a href="#1-原理（即是一个http请求）" class="headerlink" title="1. 原理（即是一个http请求）"></a>1. 原理（即是一个http请求）</h5><p>其原理在于在android端的程序中，让一个SERVICE一直跑在后台，在规定时间之内调用服务器接口进行数据获取。这里的原理很简单，当然实现起来也不难；然后，这个类之中肯定要做网络数据请求，所以我们在Service中建立一个线程（因为在android系统中网络请求属于长时间操作，不能放主线程，不然会导致异常），在线程中和服务器进行通信。</p>
<p>最后，这个逻辑写完后，我们需要考虑一个问题，如何进行在规定时间内调用该服务器，当然可以用Thread+Handler(这个不是那么稳定),也可以使用AlamManager+Thread（比较稳定），因为我们需要其在后台一直运行，所以可以依靠系统的Alammanager这个类来实现，Alammanager是属于系统的一个闹钟提醒类，通过它我们能实现在规定间隔时间调用，并且也比较稳定，这个service被杀后会自己自动启动服务。</p>
<h5 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2. 代码示例"></a>2. 代码示例</h5><h3 id="四-android长连接（push）消息推送"><a href="#四-android长连接（push）消息推送" class="headerlink" title="四 android长连接（push）消息推送"></a>四 android长连接（push）消息推送</h3><h5 id="1-心跳包机制"><a href="#1-心跳包机制" class="headerlink" title="1. 心跳包机制"></a>1. 心跳包机制</h5><p>所谓的心跳包就是客户端定时放送简单的信息给服务器端，告诉它我还在而已。代码就是每隔几分钟发送一个固定信息给服务器端，服务器端回复一个固定信息。如果服务器端几分钟后没有收到客户端信息则视客户端断开。比如有些通信软件长时间不适用，要想知道它的状态是在线还是离线，就需要心跳包，定时发包收包。　 　</p>
<p>心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活在。事实上这是为了保活长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。 </p>
<p>在TCP机制里面，本身是存在有心跳包机制的，也就是TCP选项:SO_KEEPALIVE. 系统默认是设置的2小时的心跳频率。</p>
<h5 id="2-android系统的推送和iOS的推送的区别"><a href="#2-android系统的推送和iOS的推送的区别" class="headerlink" title="2.android系统的推送和iOS的推送的区别"></a>2.android系统的推送和iOS的推送的区别</h5><p>IOS长连接是由系统来维护的，也就是说苹果的IOS系统在系统级别维护了一个客户端和苹果服务器的长链接，IOS上的所有应用上的推送都是先将消息推送到苹果的服务器然后将苹果服务器通过这个系统级别的长链接推送到手机终端上，这样的的几个好处为：</p>
<ul>
<li>在手机终端始终只要维护一个长连接即可，而且由于这个长链接是系统级别的不会出现被杀死而无法推送的情况　</li>
<li>省电，不会出现每个应用都各自维护一个自己的长连接。</li>
<li>安全，只有在苹果注册的开发者才能够进行推送，等等。　</li>
</ul>
<p>android的长连接是由每个应用各自维护的，但是google也推出了和苹果技术架构相似的推送框架，C2DM,云端推送功能，但是由于google的服务器不在中国境内，其他的原因你懂的。所以导致这个推送无法使用，android的开发者不得不自己去维护一个长链接，于是每个应用如果都24小时在线，那么都得各自维护一个长连接，这种电量和流量的消耗是可想而知的。虽然国内也出现了各种推送平台，但是都无法达到只维护一个长连接这种消耗的级别。　</p>
<h5 id="3-几种基于长连接的消息推送方案"><a href="#3-几种基于长连接的消息推送方案" class="headerlink" title="3.几种基于长连接的消息推送方案"></a>3.几种基于长连接的消息推送方案</h5><ul>
<li>C2DM云端推送功能。</li>
<li>MQTT协议实现Android推送功能。</li>
<li>RSMB实现推送功能。</li>
<li>XMPP协议实现Android推送功能</li>
<li>使用第三方平台。如极光推送</li>
<li>自己搭</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhezaoyizhuding.github.io/2017/03/01/android基础之消息推送/" data-id="cj0m800x0001j5cnz1nfl81dc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pull/">pull</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/push/">push</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/推送/">推送</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/长连接/">长连接</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>
</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <a href="/" class="logo">ZHENGRUI&#39;BLOG</a>
      &copy; 2017 zhengrui<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
    </div>
    

<script src="/js/jquery.min.js"></script>
<script src="/js/jquery.scrollLoading.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>