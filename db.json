{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-alex/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/js/jquery.scrollLoading.js","path":"js/jquery.scrollLoading.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-alex/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/logo.png","path":"css/images/logo.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY.png","path":"css/images/logoDIY.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/logo@2x.png","path":"css/images/logo@2x.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY1.png","path":"css/images/logoDIY1.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY@2x.png","path":"css/images/logoDIY@2x.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/preloader.gif","path":"css/images/preloader.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/images/preloader@2x.gif","path":"css/images/preloader@2x.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-alex/LICENSE","hash":"f0c7cd0dcb6f00b98393878068ff3e6bf5f321f1","modified":1487823302798},{"_id":"themes/hexo-theme-alex/README.md","hash":"31e9ee4a08a89afc067733d6ac32302badbad95d","modified":1487823302798},{"_id":"themes/hexo-theme-alex/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1487823302797},{"_id":"themes/hexo-theme-alex/package.json","hash":"d07f326588fef82f1d23ae3101c9ddfff34c132f","modified":1487823302807},{"_id":"themes/hexo-theme-alex/_config.yml","hash":"1326fcd415c81b47652a6c7b702916dfdcfdbd62","modified":1487823698754},{"_id":"source/about/index.md","hash":"9af335ee28b76585c10e41ea227a32d4314f7901","modified":1490779751381},{"_id":"source/_posts/Java基础之内存管理.md","hash":"bbec40f2e1a8e571c8e4509ac906ebd78ead7688","modified":1490065912824},{"_id":"source/_posts/Java基础之反射与类加载器.md","hash":"e7f788ddebc7eb6a464044723775ebd2e630d9a5","modified":1490697892216},{"_id":"source/_posts/Java基础之异常.md","hash":"f18c9d808725f18a46067e82f1b4de4cb9f1a589","modified":1490240497393},{"_id":"source/_posts/Java基础之泛型.md","hash":"4af0f7aa9dc68820e62d59107bd9f9cc1148ffe4","modified":1489747958426},{"_id":"source/_posts/Java基础之注解.md","hash":"c4606db8ff068d4c006f4eda09e946067381a310","modified":1490261083331},{"_id":"source/_posts/Java基础之流.md","hash":"f48716118622356885e35cc90ada8bfee7b71930","modified":1490259350516},{"_id":"source/_posts/Java基础之线程.md","hash":"7091c1fba690f359bddb161eada10e9547b3d3c1","modified":1489740006930},{"_id":"source/_posts/Java基础之集合.md","hash":"01c13d700480234834c7e113a8a8b7c709fdf82a","modified":1489568039090},{"_id":"source/_posts/Java基础语法.md","hash":"2b5fe51b8501c6c450cc7ac678586fa7d1b6411f","modified":1489717633551},{"_id":"source/_posts/SQL基础.md","hash":"71c974f7807a2689c95428a63a93ceced728c813","modified":1490858012107},{"_id":"source/_posts/TCP协议与UDP协议.md","hash":"a938a2883b526bba5716ca198fdfa6c908d56298","modified":1491036626646},{"_id":"source/_posts/android基础之Content-Providers.md","hash":"0b8aa167e8293834baa15802ca47336573f60cc5","modified":1488882410614},{"_id":"source/_posts/android基础之BroadcastReceiver.md","hash":"61ea20ac43cb867512cdb589569cb4a2ed534af9","modified":1488882328582},{"_id":"source/_posts/android基础之Fragments.md","hash":"7ed1a03b22b8261255d4877a5a92424d534492fd","modified":1488859235804},{"_id":"source/_posts/android基础之Handler与AsycTask.md","hash":"56559d2b902dee7c07e5d0ab822dfb0e1173dd4c","modified":1489043622472},{"_id":"source/_posts/android基础之Intents与Intent-Filters.md","hash":"54c43c29b923fe20a3f319e080570c42d5c5d903","modified":1488945817360},{"_id":"source/_posts/android基础之SQLite.md","hash":"9708fc7a778b810b7f4dee393c9d8cabda77891a","modified":1488960878891},{"_id":"source/_posts/android基础之Service.md","hash":"c3f80664b1aa694144627b4925d7bcd4516c6cd7","modified":1488791842399},{"_id":"source/_posts/android基础之activity.md","hash":"3c896b500f0b1689f733b663c8101f3fbaa6dc3c","modified":1488524968373},{"_id":"source/_posts/android基础之loaders.md","hash":"73dbd60d1d3af969cbaa2bf319b5a6a8d77ba1fe","modified":1488955248863},{"_id":"source/_posts/android基础之事件分发机制.md","hash":"e07177758fcb3515bd38be82bf101362665182c0","modified":1489050423016},{"_id":"source/_posts/android基础之消息推送.md","hash":"f33487d44d1d76efa8989629b5983ac9e6313a86","modified":1489133089150},{"_id":"source/_posts/android基础之缓存.md","hash":"5e05ccb7c346f2a31d1c408891282dc1bd135f9e","modified":1489110973064},{"_id":"source/_posts/android基础之自定义View与ViewGroup.md","hash":"1c3c1cd9bf8b68b5e3a7dd3e00f7c8100a69c436","modified":1489127481932},{"_id":"source/_posts/android基础之进程间通信.md","hash":"cbfc60b60fc51d0401e9ab44a42d3a07f6797ab3","modified":1488276000191},{"_id":"source/_posts/hexo搭建博客指南（二）-主题配置.md","hash":"2c72a279f51933a4b954019e259e6ba9aae8129e","modified":1487847317467},{"_id":"source/_posts/hexo搭建博客指南（一）-建站.md","hash":"843c243de558b7a23e5e929337f739f7ab6ee5ba","modified":1487838852388},{"_id":"source/_posts/http协议与https.md","hash":"9964ce3b8f20fc5f5cda1c89168d54bcf0532c3e","modified":1491037466857},{"_id":"source/_posts/设计模式之单例模式.md","hash":"2aa428fd6e9f07007f192ad02c7a09b21bf2ea11","modified":1490673488346},{"_id":"source/_posts/设计模式之工厂模式.md","hash":"278636db31ea78b423af9ab7be8afcfd6259b5ec","modified":1490687423741},{"_id":"source/_posts/设计模式之观察者模式.md","hash":"ba964f09297edc242a46a00bd0a4646f5d5e2a44","modified":1490673460251},{"_id":"source/_posts/android基础之数据存储.md","hash":"39517acbd54d99a6538b044c0e037661fa8a157e","modified":1489119120785},{"_id":"themes/hexo-theme-alex/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1487823302805},{"_id":"themes/hexo-theme-alex/layout/layout.ejs","hash":"6722d4980da4a8b6ae9ebee5fbb3df625d4cccc0","modified":1487823302805},{"_id":"themes/hexo-theme-alex/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1487823302805},{"_id":"themes/hexo-theme-alex/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1487823302805},{"_id":"themes/hexo-theme-alex/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1487823302807},{"_id":"themes/hexo-theme-alex/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1487823302806},{"_id":"themes/hexo-theme-alex/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1487823302807},{"_id":"themes/hexo-theme-alex/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1487823302808},{"_id":"source/_posts/SQL优化.md","hash":"cc9e48c3ba810955ef1b8fe41ab0a0b1d8bf3aef","modified":1490868883376},{"_id":"source/_posts/Java基础之内存管理/根搜索算法判断对象是否可回收.jpg","hash":"2d7d416bc1afef530fde723b06a527066e9812b2","modified":1489999188931},{"_id":"source/_posts/Java基础之内存管理/Java类从加载到初始化的过程.png","hash":"1df832a846dda94678f8fdce5270271050ec9404","modified":1490691893650},{"_id":"source/_posts/Java基础之内存管理/通过句柄访问对象.jpg","hash":"5601d5f60e201aac9b8cb10325d551468a41fff2","modified":1489996412842},{"_id":"source/_posts/Java基础之内存管理/通过直接指针访问对象.jpg","hash":"99abad52a489593e2a36def1fda29689ded97872","modified":1489996489763},{"_id":"source/_posts/Java基础之内存管理/运行时数据区域.jpg","hash":"c62574d20291c100fc713c39586c1aff790a6d44","modified":1489993748912},{"_id":"source/_posts/Java基础之反射与类加载器/类加载器的层次结构.png","hash":"a714f08ca21d349c057a85f388e955362a15e14f","modified":1490690793556},{"_id":"source/_posts/Java基础之异常/Java异常继承体系图.jpg","hash":"0b38b39758a77dd2f3524134ce3c623a17752e01","modified":1490169962287},{"_id":"source/_posts/Java基础之线程/Java线程状态转换图.png","hash":"59ba065c3885caef210c93173b246fef788e4987","modified":1489719320667},{"_id":"source/_posts/android基础之Fragments/Fragment与Activity生命周期对比.png","hash":"21a7ffdf3a9e7e39f0e4a8856e327d8a18ff21cc","modified":1488855688697},{"_id":"source/_posts/android基础之Fragments/Fragment显示图.png","hash":"690d35d73cede5e01eafba3fdd882ad0757e8009","modified":1488794510187},{"_id":"source/_posts/android基础之activity/startActivityForResult是被调用者的生命周期.png","hash":"e03a9cd03b3aeac0b34f2827f6986ebfd1475379","modified":1489374281012},{"_id":"source/_posts/android基础之事件分发机制/Touch事件分发机制流程图.png","hash":"3975a668af1a68aaf292c4c84932209a98964850","modified":1489045605495},{"_id":"source/_posts/android基础之自定义View与ViewGroup/View绘制过程.png","hash":"27ee344c34d443fc3dbc5b6bc8de86675fbf6c6c","modified":1489126400998},{"_id":"source/_posts/http协议与https/474814076.png","hash":"e11a77c9b06d0050ca625a8304a3c02d5c57a7ab","modified":1443929400000},{"_id":"source/_posts/http协议与https/HTTPS握手图.jpg","hash":"fac84973b05c1aab7debac06a9fd69f3c2b3ff32","modified":1491032695200},{"_id":"source/_posts/http协议与https/1146631942.png","hash":"9b6a3b8842b3b9a892e404ba0d4c71929013d327","modified":1443929400000},{"_id":"source/_posts/设计模式之工厂模式/工厂方法模式类图.jpg","hash":"e2e5a79c19d0fb34e1d087f29828e1e21f24058c","modified":1490681146969},{"_id":"source/_posts/设计模式之工厂模式/抽象工厂模式类图.jpg","hash":"039cb7ed7b67c4f2d5019604ec02a4a6c0852be2","modified":1490685036133},{"_id":"source/_posts/设计模式之工厂模式/简单工厂模式类图.jpg","hash":"b07b626683b3436f9a7b55d98fb431b3665b1aeb","modified":1490679361828},{"_id":"source/_posts/设计模式之观察者模式/观察者模式类图.jpg","hash":"72f4fe8e145bfecffec055340be6c49ac34ae37b","modified":1490670259075},{"_id":"themes/hexo-theme-alex/layout/_partial/after-footer.ejs","hash":"473fd916d73a634865d776ff591860f4680f2a5a","modified":1487823302799},{"_id":"themes/hexo-theme-alex/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1487823302799},{"_id":"themes/hexo-theme-alex/layout/_partial/archive.ejs","hash":"61f37ba0ce1eba08a2bcfe09f8691a7320ee8d10","modified":1487823302799},{"_id":"themes/hexo-theme-alex/layout/_partial/article.ejs","hash":"46e1ab7f03a7d5a8d15e61c5a8d04ca3d0265047","modified":1487823302800},{"_id":"themes/hexo-theme-alex/layout/_partial/footer.ejs","hash":"f4c0fb5d3ac8f3ede1d1a668b362ebadc157c5a9","modified":1487844868700},{"_id":"themes/hexo-theme-alex/layout/_partial/head.ejs","hash":"251ee51d3235684e02ed9bf9bb46e0f6229305cd","modified":1487823302801},{"_id":"themes/hexo-theme-alex/layout/_partial/mobile-nav.ejs","hash":"8692f720b5847458296a052964a455ff7064d554","modified":1487823302801},{"_id":"themes/hexo-theme-alex/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1487823302800},{"_id":"themes/hexo-theme-alex/layout/_partial/header.ejs","hash":"8dc197a5c2dc0ecb37eecd24bd9f4904e4c2a65c","modified":1487832289636},{"_id":"themes/hexo-theme-alex/layout/_widget/archive.ejs","hash":"88e191e3d14541299ed03b9a45be70974df51143","modified":1487823302803},{"_id":"themes/hexo-theme-alex/layout/_widget/category.ejs","hash":"4d3f92e3cd652cb69d71e40d1c64b2369922ca26","modified":1487823302804},{"_id":"themes/hexo-theme-alex/layout/_widget/links.ejs","hash":"50f50a5015bdbcea2f41f071139d68c68c9e6484","modified":1487823302804},{"_id":"themes/hexo-theme-alex/layout/_partial/sidebar.ejs","hash":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1487823302803},{"_id":"themes/hexo-theme-alex/layout/_widget/tag.ejs","hash":"7ba10fbd17b83b9b89eaea99bb78158d318c6d75","modified":1487823302804},{"_id":"themes/hexo-theme-alex/layout/_widget/recent_posts.ejs","hash":"d6591c745402fbc600e682830a343f732e336e4f","modified":1487823302804},{"_id":"themes/hexo-theme-alex/layout/_widget/tagcloud.ejs","hash":"9028129dd2e56813197d0c38db5df8110aaeaabb","modified":1487823302805},{"_id":"themes/hexo-theme-alex/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1487823302821},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1487823302822},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1487823302822},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1487823302822},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1487823302822},{"_id":"themes/hexo-theme-alex/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1487823302823},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1487823302825},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1487823302826},{"_id":"themes/hexo-theme-alex/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1487823302826},{"_id":"themes/hexo-theme-alex/source/css/_extend.styl","hash":"eb83c785ce83c277a6f8de9510805595c5d7aa1f","modified":1487823302809},{"_id":"themes/hexo-theme-alex/source/css/_retina.styl","hash":"1bc8f743af27654ed2353ad36e062e37c27a8681","modified":1487823302813},{"_id":"themes/hexo-theme-alex/source/css/_variables.styl","hash":"a9535d44c526cf3ead70647ad6f023e5299a700d","modified":1491040727996},{"_id":"themes/hexo-theme-alex/source/css/style.styl","hash":"ccebcce09864d0ac529ea4aab7fed9edaba098b1","modified":1487835436052},{"_id":"themes/hexo-theme-alex/source/js/jquery.scrollLoading.js","hash":"d0729cb06dd7eefd789e7b6b01fb9b4b691741fb","modified":1487823302828},{"_id":"themes/hexo-theme-alex/source/js/script.js","hash":"ad9f1a3a3c30c8a6cc9e34631c75c6c8ff0d5963","modified":1491040870709},{"_id":"source/_posts/android基础之Fragments/Fragment生命周期图.png","hash":"f100e3a864b1be55e28bb2ae6f69580c4874dbbc","modified":1488852449132},{"_id":"source/_posts/android基础之Service/Service生命周期图.png","hash":"8f58fa262d06b6ea8e20ca738da45a6c06d42ecb","modified":1488772565467},{"_id":"source/_posts/android基础之activity/Activity状态保存示意图.png","hash":"a3fb8aab955cb5e40f1b18d7e1b5c1c2b5df37f6","modified":1488446350543},{"_id":"source/_posts/android基础之activity/activity回调方法汇总.png","hash":"283ffc1469fb33b9df2501d34328db84f14cdf0f","modified":1488447688722},{"_id":"source/_posts/android基础之activity/activity生命周期图.png","hash":"ca76d44f5128a045a225f3597fad78a811f0c70d","modified":1488166113702},{"_id":"source/_posts/android基础之缓存/文件缓存结果图.png","hash":"f490fa1d6ac2d08af14ab307435069b6753795a6","modified":1489054092910},{"_id":"themes/hexo-theme-alex/source/js/jquery.min.js","hash":"745ab5d6e434cf8d321779da3c527b6d301e2b50","modified":1487823302827},{"_id":"source/_posts/TCP协议与UDP协议/TCP报文结构.png","hash":"1dafa0859e8f49646e1063236d2be873a82f4e8c","modified":1443927276000},{"_id":"themes/hexo-theme-alex/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1487823302802},{"_id":"themes/hexo-theme-alex/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1487823302802},{"_id":"themes/hexo-theme-alex/layout/_partial/post/nav.ejs","hash":"eb000d9d8a9ebd9087046fa019abe1cddae8fd9c","modified":1487823302802},{"_id":"themes/hexo-theme-alex/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1487823302803},{"_id":"themes/hexo-theme-alex/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1487823302803},{"_id":"themes/hexo-theme-alex/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1487823302802},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1487823302823},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1487823302824},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1487823302824},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1487823302824},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1487823302824},{"_id":"themes/hexo-theme-alex/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1487823302825},{"_id":"themes/hexo-theme-alex/source/css/_partial/archive.styl","hash":"781116f363edd4b59ef0af64a780e9de4d2c4958","modified":1487823302809},{"_id":"themes/hexo-theme-alex/source/css/_partial/article.styl","hash":"5b35fc5004a8d55c95f9a66dbf2393432ef4a3af","modified":1491040868615},{"_id":"themes/hexo-theme-alex/source/css/_partial/comment.styl","hash":"3ca87b9b705ff1594aca7c30e3c887fcfb39e385","modified":1487823302810},{"_id":"themes/hexo-theme-alex/source/css/_partial/footer.styl","hash":"60fc6d6184bab3636e1a0fe0cfe56f969507472e","modified":1487823302810},{"_id":"themes/hexo-theme-alex/source/css/_partial/header.styl","hash":"5b8fcd91fe31994a3cf2513a6255242242958a44","modified":1487823302811},{"_id":"themes/hexo-theme-alex/source/css/_partial/highlight.styl","hash":"c125e953fb228d4f0089ea27d1527deca6086016","modified":1487823302811},{"_id":"themes/hexo-theme-alex/source/css/_partial/mobile.styl","hash":"948f0b1f8e8b5959e5def27f9f0329cfe4fb159f","modified":1487823302811},{"_id":"themes/hexo-theme-alex/source/css/_partial/sidebar-aside.styl","hash":"68ca2d9d9459c84c2de530ca9e3965fb63d75a74","modified":1487823302812},{"_id":"themes/hexo-theme-alex/source/css/_partial/sidebar-bottom.styl","hash":"f6023861b2fbd858946e2108438b5f8f17586179","modified":1487823302812},{"_id":"themes/hexo-theme-alex/source/css/_partial/sidebar.styl","hash":"735e2d5898b585a94b0c16f58bd1b46507c752fb","modified":1487823302812},{"_id":"themes/hexo-theme-alex/source/css/_partial/tablet.styl","hash":"60b666c5b134356721dcf8c73fa0162ff904fe7d","modified":1487823302812},{"_id":"themes/hexo-theme-alex/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1487823302813},{"_id":"themes/hexo-theme-alex/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1487823302813},{"_id":"themes/hexo-theme-alex/source/css/images/logo.png","hash":"d1f41cf04419f22cd15b9e36e0658a7654796036","modified":1487823302820},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY.png","hash":"1d8447ba649e78a1b9b30cecf3424f9c29fa23a9","modified":1487837712110},{"_id":"themes/hexo-theme-alex/source/css/images/logo@2x.png","hash":"f02ae098f6676a0e8d945f13d8150965a2f66985","modified":1487823302820},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY1.png","hash":"649ede0e15de250b8c965932c3802a84bea4141d","modified":1487837059798},{"_id":"themes/hexo-theme-alex/source/css/images/logoDIY@2x.png","hash":"82ee4b7dfaf1a57e2ac5c6a6ce4bcc6a1c372b57","modified":1487837743567},{"_id":"themes/hexo-theme-alex/source/css/images/preloader.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1487823302820},{"_id":"themes/hexo-theme-alex/source/css/images/preloader@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1487823302821},{"_id":"themes/hexo-theme-alex/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1487823302815},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1487823302816},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1487823302819},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1487823302818},{"_id":"themes/hexo-theme-alex/source/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1487823302817},{"_id":"source/_posts/android基础之事件分发机制/android事件分发.png","hash":"6d143c8af8c591dced1c1476e1c68cf048129147","modified":1489050286705}],"Category":[{"name":"Java","_id":"cj0z0sk0o0003aknzykiigjsp"},{"name":"数据库","_id":"cj0z0sk1m000oaknzxir5r19p"},{"name":"网络协议","_id":"cj0z0sk1p000waknzifkuhxf1"},{"name":"android","_id":"cj0z0sk1s0012aknzvh0ef27q"},{"name":"hexo","_id":"cj0z0sk2e0022aknz40ikrgh4"},{"name":"设计模式","_id":"cj0z0sk2k002daknz0kz4iy67"}],"Data":[],"Page":[{"title":"about","date":"2017-03-10T10:24:29.000Z","_content":"\n#### 个人简介\n\n- 姓名：郑瑞\n\n- 毕业院校：西北农林科技大学\n\n- 邮箱：zhengrui2012013343@gmail.com/2351857948@qq.com\n\n- 简历：[我的简历2.0.pdf](我的简历2.0.pdf)\n\n#### 分享链接\n\n- 我康军的博客：[https://yk1062008412.github.io](https://yk1062008412.github.io)\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-03-10 18:24:29\n---\n\n#### 个人简介\n\n- 姓名：郑瑞\n\n- 毕业院校：西北农林科技大学\n\n- 邮箱：zhengrui2012013343@gmail.com/2351857948@qq.com\n\n- 简历：[我的简历2.0.pdf](我的简历2.0.pdf)\n\n#### 分享链接\n\n- 我康军的博客：[https://yk1062008412.github.io](https://yk1062008412.github.io)\n","updated":"2017-03-29T09:29:11.381Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj0z0sk0h0000aknzvj9f8lxe","content":"<h4 id=\"个人简介\"><a href=\"#个人简介\" class=\"headerlink\" title=\"个人简介\"></a>个人简介</h4><ul>\n<li><p>姓名：郑瑞</p>\n</li>\n<li><p>毕业院校：西北农林科技大学</p>\n</li>\n<li><p>邮箱：zhengrui2012013343@gmail.com/2351857948@qq.com</p>\n</li>\n<li><p>简历：<a href=\"我的简历2.0.pdf\">我的简历2.0.pdf</a></p>\n</li>\n</ul>\n<h4 id=\"分享链接\"><a href=\"#分享链接\" class=\"headerlink\" title=\"分享链接\"></a>分享链接</h4><ul>\n<li>我康军的博客：<a href=\"https://yk1062008412.github.io\" target=\"_blank\" rel=\"external\">https://yk1062008412.github.io</a></li>\n</ul>\n","excerpt":"","more":"<h4 id=\"个人简介\"><a href=\"#个人简介\" class=\"headerlink\" title=\"个人简介\"></a>个人简介</h4><ul>\n<li><p>姓名：郑瑞</p>\n</li>\n<li><p>毕业院校：西北农林科技大学</p>\n</li>\n<li><p>邮箱：zhengrui2012013343@gmail.com/2351857948@qq.com</p>\n</li>\n<li><p>简历：<a href=\"我的简历2.0.pdf\">我的简历2.0.pdf</a></p>\n</li>\n</ul>\n<h4 id=\"分享链接\"><a href=\"#分享链接\" class=\"headerlink\" title=\"分享链接\"></a>分享链接</h4><ul>\n<li>我康军的博客：<a href=\"https://yk1062008412.github.io\">https://yk1062008412.github.io</a></li>\n</ul>\n"}],"Post":[{"title":"Java基础之反射与类加载器","date":"2017-03-19T14:48:27.000Z","_content":"\n### 一 概述\n\n类加载即是编译好的class文件被加载进Java虚拟机的过程，而这就需要用到Java类加载器java.lang.ClassLoader。class文件被加载进虚拟机后会生成java.lang.Class对象，而这些是发生在Java虚拟机中的，除了类加载过程，其余的我们并不能看到。要想获得这个Class对象，我们就需要通过反射。\n\n### 二 类加载\n\n指将类的class文件读入内存，并为之创建一个java.lang.Class的对象。\n\n类文件来源\n\n- 从本地文件系统加载的class文件\n- 从JAR包加载class文件\n- 从网络加载class文件\n- 把一个Java源文件动态编译，并执行加载\n\n类加载器通常无须等到“首次使用”该类时才加载该类，JVM允许系统预先加载某些类\n\n##### 类加载器的层次结构\n\n下面是Java中类加载器的层次结构（不是继承结构）：\n\n{% asset_img 类加载器的层次结构.png 类加载器的层次结构 %}\n\n- 根类加载器（Bootstrap ClassLoader）：其负责加载Java的核心类，比如String、System这些类\n- 拓展类加载器（Extension ClassLoader）：其负责加载JRE的拓展类库\n- 系统类加载器（System ClassLoader）：其负责加载CLASSPATH环境变量所指定的JAR包和类路径\n- 用户类加载器：用户自定义的加载器，以类加载器为父类\n\n代码示例:\n\n```java\n    public static void main(String[] args) throws IOException {\n        ClassLoader systemLoader = ClassLoader.getSystemClassLoader();\n        System.out.println(\"系统类加载\");\n        Enumeration<URL> em1 = systemLoader.getResources(\"\");\n        while (em1.hasMoreElements()) {\n            System.out.println(em1.nextElement());\n        }\n        ClassLoader extensionLader = systemLoader.getParent();\n        System.out.println(\"拓展类加载器\" + extensionLader);\n        System.out.println(\"拓展类加载器的父\" + extensionLader.getParent());\n```\n\n结果：\n\n```java\n系统类加载\nfile:/E:/gaode/em/bin/\n拓展类加载器sun.misc.Launcher$ExtClassLoader@6d06d69c\n拓展类加载器的父null\n```\n\n**注意**根类加载器并不是Java实现的，而且由于程序通常须访问根加载器，因此访问扩展类加载器的父类加载器时返回NULL\n\n##### JVM类加载机制\n\n- 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入\n\n- 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类\n\n- 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效\n\n##### URLClassLoader类\n\nURLClassLoader为ClassLoader的一个实现类，该类也是系统类加载器和拓展类加载器的父类（继承关系）。它既可以从本地文件系统获取二进制文件来加载类，也可以远程主机获取二进制文件来加载类。\n\n它的两个构造器：\n\n- URLClassLoader(URL[] urls):使用默认的父类加载器创建一个ClassLoader对象，该对象将从urls所指定的路径来查询并加载类\n\n- URLClassLoader(URL[] urls,ClassLoader parent):使用指定的父类加载器创建一个ClassLoader对象，其他功能与前一个构造器相同\n\n代码示例：\n\n```java\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Properties;\n\nimport com.mysql.jdbc.Driver;\n\npublic class GetMysql {\n    private static Connection conn;\n    public static Connection getConn(String url,String user,String pass) throws MalformedURLException, InstantiationException, IllegalAccessException, ClassNotFoundException, SQLException{\n        if(conn==null){\n            URL[]urls={new URL(\"file:mysql-connector-java-5.1.18.jar\")};\n            URLClassLoader myClassLoader=new URLClassLoader(urls);\n            Driver driver=(Driver) myClassLoader.loadClass(\"com.mysql.jdbc.Driver\").newInstance();\n            Properties pros=new Properties();\n            pros.setProperty(\"user\", user);\n            pros.setProperty(\"password\", pass);\n            conn=driver.connect(url, pros);\n        }\n        return conn;\n    }\n    public static method1 getConn() throws MalformedURLException, InstantiationException, IllegalAccessException, ClassNotFoundException, SQLException{\n        \n            URL[]urls={new URL(\"file:com.em\")};\n            URLClassLoader myClassLoader=new URLClassLoader(urls);\n            method1 driver=(method1) myClassLoader.loadClass(\"com.em.method1\").newInstance();\n        \n        return driver;\n    }\n    \n    public static void main(String[] args) throws MalformedURLException, InstantiationException, IllegalAccessException, ClassNotFoundException, SQLException {\n        System.out.println(getConn(\"jdbc:mysql://10.10.16.11:3306/auto?useUnicode=true&characterEncoding=utf8&allowMultiQueries=true\", \"jiji\", \"jiji\"));\n        System.out.println(getConn());\n    }\n}\n```\n\n获得URLClassLoader对象后，调用loanClass()方法来加载指定的类\n\n##### 自定义类加载器\n\nJVM中除了根类加载器之外的所有类的加载器都是ClassLoader子类的实例，通过重写ClassLoader中的方法，实现自定义的类加载器，通常我们会使用以下两个方法中的一个（通常第二个）\n\n- loadClass(String name,boolean resolve):为ClassLoader的入口点，根据指定名称来加载类，系统就是调用ClassLoader的该方法来获取制定累对应的Class对象\n\n- findClass(String name):根据指定名称来查找类\n\n代码示例：\n\n```java\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\n\npublic class CompileClassLoader extends ClassLoader\n\n{\n\n    // 读取一个文件的内容\n\n    @SuppressWarnings(\"resource\")\n    private byte[] getBytes(String filename) throws IOException\n\n    {\n\n        File file = new File(filename);\n\n        long len = file.length();\n\n        byte[] raw = new byte[(int) len];\n\n        FileInputStream fin = new FileInputStream(file);\n\n        // 一次读取class文件的全部二进制数据\n\n        int r = fin.read(raw);\n\n        if (r != len)\n\n            throw new IOException(\"无法读取全部文件\" + r + \"!=\" + len);\n\n        fin.close();\n        return raw;\n\n    }\n\n    // 定义编译指定java文件的方法\n\n    private boolean compile(String javaFile) throws IOException\n\n    {\n\n        System.out.println(\"CompileClassLoader:正在编译\" + javaFile + \"……..\");\n\n        // 调用系统的javac命令\n\n        Process p = Runtime.getRuntime().exec(\"javac\" + javaFile);\n\n        try {\n\n            // 其它线程都等待这个线程完成\n\n            p.waitFor();\n\n        } catch (InterruptedException ie)\n\n        {\n\n            System.out.println(ie);\n\n        }\n\n        // 获取javac 的线程的退出值\n\n        int ret = p.exitValue();\n\n        // 返回编译是否成功\n\n        return ret == 0;\n\n    }\n\n    // 重写Classloader的findCLass方法\n\n    protected Class<?> findClass(String name) throws ClassNotFoundException\n\n    {\n\n        Class clazz = null;\n\n        // 将包路径中的.替换成斜线/\n\n        String fileStub = name.replace(\".\", \"/\");\n\n        String javaFilename = fileStub + \".java\";\n\n        String classFilename = fileStub + \".class\";\n\n        File javaFile = new File(javaFilename);\n\n        File classFile = new File(classFilename);\n\n        // 当指定Java源文件存在，且class文件不存在，或者Java源文件的修改时间比class文件//修改时间晚时，重新编译\n\n        if (javaFile.exists() && (!classFile.exists())\n                || javaFile.lastModified() > classFile.lastModified())\n\n        {\n\n            try {\n\n                // 如果编译失败，或该Class文件不存在\n\n                if (!compile(javaFilename) || !classFile.exists())\n\n                {\n\n                    throw new ClassNotFoundException(\"ClassNotFoundException:\"\n                            + javaFilename);\n\n                }\n\n            } catch (IOException ex)\n\n            {\n\n                ex.printStackTrace();\n\n            }\n\n        }\n\n        // 如果class文件存在，系统负责将该文件转化成class对象\n\n        if (classFile.exists())\n\n        {\n\n            try {\n\n                // 将class文件的二进制数据读入数组\n\n                byte[] raw = getBytes(classFilename);\n\n                // 调用Classloader的defineClass方法将二进制数据转换成class对象\n\n                clazz = defineClass(name, raw, 0, raw.length);\n\n            } catch (IOException ie)\n\n            {\n\n                ie.printStackTrace();\n\n            }\n\n        }\n\n        // 如果claszz为null,表明加载失败，则抛出异常\n\n        if (clazz == null) {\n\n            throw new ClassNotFoundException(name);\n\n        }\n\n        return clazz;\n\n    }\n\n    // 定义一个主方法\n\n    public static void main(String[] args) throws Exception\n\n    {\n\n        // 如果运行该程序时没有参数，即没有目标类\n\n        if (args.length < 1) {\n\n            System.out.println(\"缺少运行的目标类，请按如下格式运行java源文件：\");\n\n            System.out.println(\"java CompileClassLoader ClassName\");\n\n        }\n\n        // 第一个参数是需要运行的类\n\n        String progClass = args[0];\n\n        // 剩下的参数将作为运行目标类时的参数，所以将这些参数复制到一个新数组中\n\n        String progargs[] = new String[args.length - 1];\n\n        System.arraycopy(args, 1, progargs, 0, progargs.length);\n\n        CompileClassLoader cl = new CompileClassLoader();\n\n        // 加载需要运行的类\n\n        Class<?> clazz = cl.loadClass(progClass);\n\n        // 获取需要运行的类的主方法\n\n        Method main = clazz.getMethod(\"main\", (new String[0]).getClass());\n\n        Object argsArray[] = { progargs };\n\n        main.invoke(null, argsArray);\n\n    }\n\n}\n```\n\n##### 类的连接\n\n当类被加载后，系统会为之生成一个Class对象，接着将会进入连接阶段，链接阶段负责把类的二进制数据合并到JRE中。它分为三个阶段：\n\n- 验证：检验被加载的类是否有正确的内部结构，并和其他类协调一致\n- 准备：负责为类的类变量分配内存。并设置默认初始值\n- 解析：将类的二进制数据中的符号引用替换成直接引用\n\n如下图：\n\n{% asset_img Java类从加载到初始化的过程.png Java类从加载到初始化的过程 %}\n\n##### 类的初始化\n\nJVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：\n\n- 声明类变量是指定初始值\n- 使用静态代码块为类变量指定初始值\n\nJVM初始化步骤\n\n- 假如这个类还没有被加载和连接，则程序先加载并连接该类\n- 假如该类的直接父类还没有被初始化，则先初始化其直接父类\n- 假如类中有初始化语句，则系统依次执行这些初始化语句\n\n类初始化时机\n\n- 创建类实例。也就是new的方式\n- 调用某个类的类方法\n- 访问某个类或接口的类变量，或为该类变量赋值\n- 使用反射方式强制创建某个类或接口对应的java.lang.Class对象\n- 初始化某个类的子类，则其父类也会被初始化\n- 直接使用java.exe命令来运行某个主类\n\n### 三 反射\n\n要想获得运行时对象和类的真实信息通常有两种方式：\n\n- 第一种是在编译时和运行时都完全知道类型的具体信息，这种情况下，可以通过instanceof运算符进行判断，再使用强制类型转换将其转化成运行时类型的变量即可\n- 第二种是编译时根本无法获知对象和类的类型信息，这种情况下只能通过反射来获知运行时对象和类的真实信息\n\n##### 获取Class对象\n\n通常有以下3种方法：\n\n- 使用Class类的forName(String name)方法，如Class.forName(\"Person\")获得person的Class对象\n- 使用某个类的class属性，如Person.class\n- 使用某个对象的getClass()方法，如Person.getClass()\n\n通常使用第二种方法。\n\n##### 从Class对象中获取信息\n\nJava的java.lang.Class类提供了大量的实例方法来获得某个类具体信息，如成员变量，方法，构造器等。具体方法请参考java.lang.Class的源码，这里不再赘述。\n\n##### 使用反射生成并操作对象\n\n通过反射来生成对象有两种方式：\n\n- 通过Class对象的newInstance()方法来获取Class对象对应类的实例。但是该方法需要这个对应类有默认构造函数，执行newInstance()方法实际上就是通过默认构造方法获取类的实例。\n- 通过Class对象的获取指定的Constructor对象，在调用Constructor对象的newInstance()来获取Class对应类的实例。\n\nJava的java.lang.reflect包下有对应的Constructor，Field，Method，Array等类，来通过反射获取相应类的具体信息。（Array用来动态的创建数组）\n\n### 四 动态代理\n\n##### JDK动态代理\n\n在Java的java.lang.refect包下有一个Proxy类和一个InvocationHandler接口，可以实现动态代理。\n\nProxy是所有动态代理类的父类，它可以用于动态代理类和动态代理对象。如：\n\n- static Class<?> getProxyClass(ClassLoader loader, Class<?>...interfaces):创建一个动态代理类对应的Class对象该代理类将实现interfaces所指定的多个接口，第一个参数指生成该动态代理类的类加载器。\n- static Object newProxyInstance(ClassLoader loader, Class<?>...interfaces,InvocationHandler h):创建动态代理对象，**执行代理对象的每个方法时都会被替换成执行InvocationHandler的invoke方法**。\n\n实际上即使采用第一种方法创建动态代理类后，如果需要创建动态代理实例，也需要传入一个InvocationHandler对象，每个动态代理实例都有一个与之对应的InvocationHandler对象。\n\n代码示例：\n\n被代理的接口即其实现类\n\n```java\npublic interface Subject\n{\n    public void rent();\n    \n    public void hello(String str);\n}\n\npublic class RealSubject implements Subject\n{\n    @Override\n    public void rent()\n    {\n        System.out.println(\"I want to rent my house\");\n    }\n    \n    @Override\n    public void hello(String str)\n    {\n        System.out.println(\"hello: \" + str);\n    }\n}\n```\n\n代理类：\n\n```java\npublic class DynamicProxy implements InvocationHandler\n{\n    //　这个就是我们要代理的真实对象\n    private Object subject;\n    \n    //    构造方法，给我们要代理的真实对象赋初值\n    public DynamicProxy(Object subject)\n    {\n        this.subject = subject;\n    }\n    \n    @Override\n    public Object invoke(Object object, Method method, Object[] args)\n            throws Throwable\n    {\n        //　　在代理真实对象前我们可以添加一些自己的操作\n        System.out.println(\"before rent house\");\n        \n        System.out.println(\"Method:\" + method);\n        \n        //    当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用\n        method.invoke(subject, args);\n        \n        //　　在代理真实对象后我们也可以添加一些自己的操作\n        System.out.println(\"after rent house\");\n        \n        return null;\n    }\n\n}\n```\n\n主程序：\n\n```java\npublic static void main(String[] args)\n    {\n        //    我们要代理的真实对象\n        Subject realSubject = new RealSubject();\n\n        //    我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的\n        InvocationHandler handler = new DynamicProxy(realSubject);\n\n        /*\n         * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数\n         * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象\n         * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了\n         * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上\n         */\n        Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject\n                .getClass().getInterfaces(), handler);\n        \n        System.out.println(subject.getClass().getName());\n        subject.rent();\n        subject.hello(\"world\");\n    }\n```\n\n##### CGLIB代理\n\nJDK的动态代理只能是面向接口的，要想面向类可以使用CGLIB代理。\n\n\n\n\n  ","source":"_posts/Java基础之反射与类加载器.md","raw":"---\ntitle: Java基础之反射与类加载器\ndate: 2017-03-19 22:48:27\ncategories: Java\ntags:\n- 类加载器\n- 反射\n---\n\n### 一 概述\n\n类加载即是编译好的class文件被加载进Java虚拟机的过程，而这就需要用到Java类加载器java.lang.ClassLoader。class文件被加载进虚拟机后会生成java.lang.Class对象，而这些是发生在Java虚拟机中的，除了类加载过程，其余的我们并不能看到。要想获得这个Class对象，我们就需要通过反射。\n\n### 二 类加载\n\n指将类的class文件读入内存，并为之创建一个java.lang.Class的对象。\n\n类文件来源\n\n- 从本地文件系统加载的class文件\n- 从JAR包加载class文件\n- 从网络加载class文件\n- 把一个Java源文件动态编译，并执行加载\n\n类加载器通常无须等到“首次使用”该类时才加载该类，JVM允许系统预先加载某些类\n\n##### 类加载器的层次结构\n\n下面是Java中类加载器的层次结构（不是继承结构）：\n\n{% asset_img 类加载器的层次结构.png 类加载器的层次结构 %}\n\n- 根类加载器（Bootstrap ClassLoader）：其负责加载Java的核心类，比如String、System这些类\n- 拓展类加载器（Extension ClassLoader）：其负责加载JRE的拓展类库\n- 系统类加载器（System ClassLoader）：其负责加载CLASSPATH环境变量所指定的JAR包和类路径\n- 用户类加载器：用户自定义的加载器，以类加载器为父类\n\n代码示例:\n\n```java\n    public static void main(String[] args) throws IOException {\n        ClassLoader systemLoader = ClassLoader.getSystemClassLoader();\n        System.out.println(\"系统类加载\");\n        Enumeration<URL> em1 = systemLoader.getResources(\"\");\n        while (em1.hasMoreElements()) {\n            System.out.println(em1.nextElement());\n        }\n        ClassLoader extensionLader = systemLoader.getParent();\n        System.out.println(\"拓展类加载器\" + extensionLader);\n        System.out.println(\"拓展类加载器的父\" + extensionLader.getParent());\n```\n\n结果：\n\n```java\n系统类加载\nfile:/E:/gaode/em/bin/\n拓展类加载器sun.misc.Launcher$ExtClassLoader@6d06d69c\n拓展类加载器的父null\n```\n\n**注意**根类加载器并不是Java实现的，而且由于程序通常须访问根加载器，因此访问扩展类加载器的父类加载器时返回NULL\n\n##### JVM类加载机制\n\n- 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入\n\n- 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类\n\n- 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效\n\n##### URLClassLoader类\n\nURLClassLoader为ClassLoader的一个实现类，该类也是系统类加载器和拓展类加载器的父类（继承关系）。它既可以从本地文件系统获取二进制文件来加载类，也可以远程主机获取二进制文件来加载类。\n\n它的两个构造器：\n\n- URLClassLoader(URL[] urls):使用默认的父类加载器创建一个ClassLoader对象，该对象将从urls所指定的路径来查询并加载类\n\n- URLClassLoader(URL[] urls,ClassLoader parent):使用指定的父类加载器创建一个ClassLoader对象，其他功能与前一个构造器相同\n\n代码示例：\n\n```java\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Properties;\n\nimport com.mysql.jdbc.Driver;\n\npublic class GetMysql {\n    private static Connection conn;\n    public static Connection getConn(String url,String user,String pass) throws MalformedURLException, InstantiationException, IllegalAccessException, ClassNotFoundException, SQLException{\n        if(conn==null){\n            URL[]urls={new URL(\"file:mysql-connector-java-5.1.18.jar\")};\n            URLClassLoader myClassLoader=new URLClassLoader(urls);\n            Driver driver=(Driver) myClassLoader.loadClass(\"com.mysql.jdbc.Driver\").newInstance();\n            Properties pros=new Properties();\n            pros.setProperty(\"user\", user);\n            pros.setProperty(\"password\", pass);\n            conn=driver.connect(url, pros);\n        }\n        return conn;\n    }\n    public static method1 getConn() throws MalformedURLException, InstantiationException, IllegalAccessException, ClassNotFoundException, SQLException{\n        \n            URL[]urls={new URL(\"file:com.em\")};\n            URLClassLoader myClassLoader=new URLClassLoader(urls);\n            method1 driver=(method1) myClassLoader.loadClass(\"com.em.method1\").newInstance();\n        \n        return driver;\n    }\n    \n    public static void main(String[] args) throws MalformedURLException, InstantiationException, IllegalAccessException, ClassNotFoundException, SQLException {\n        System.out.println(getConn(\"jdbc:mysql://10.10.16.11:3306/auto?useUnicode=true&characterEncoding=utf8&allowMultiQueries=true\", \"jiji\", \"jiji\"));\n        System.out.println(getConn());\n    }\n}\n```\n\n获得URLClassLoader对象后，调用loanClass()方法来加载指定的类\n\n##### 自定义类加载器\n\nJVM中除了根类加载器之外的所有类的加载器都是ClassLoader子类的实例，通过重写ClassLoader中的方法，实现自定义的类加载器，通常我们会使用以下两个方法中的一个（通常第二个）\n\n- loadClass(String name,boolean resolve):为ClassLoader的入口点，根据指定名称来加载类，系统就是调用ClassLoader的该方法来获取制定累对应的Class对象\n\n- findClass(String name):根据指定名称来查找类\n\n代码示例：\n\n```java\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\n\npublic class CompileClassLoader extends ClassLoader\n\n{\n\n    // 读取一个文件的内容\n\n    @SuppressWarnings(\"resource\")\n    private byte[] getBytes(String filename) throws IOException\n\n    {\n\n        File file = new File(filename);\n\n        long len = file.length();\n\n        byte[] raw = new byte[(int) len];\n\n        FileInputStream fin = new FileInputStream(file);\n\n        // 一次读取class文件的全部二进制数据\n\n        int r = fin.read(raw);\n\n        if (r != len)\n\n            throw new IOException(\"无法读取全部文件\" + r + \"!=\" + len);\n\n        fin.close();\n        return raw;\n\n    }\n\n    // 定义编译指定java文件的方法\n\n    private boolean compile(String javaFile) throws IOException\n\n    {\n\n        System.out.println(\"CompileClassLoader:正在编译\" + javaFile + \"……..\");\n\n        // 调用系统的javac命令\n\n        Process p = Runtime.getRuntime().exec(\"javac\" + javaFile);\n\n        try {\n\n            // 其它线程都等待这个线程完成\n\n            p.waitFor();\n\n        } catch (InterruptedException ie)\n\n        {\n\n            System.out.println(ie);\n\n        }\n\n        // 获取javac 的线程的退出值\n\n        int ret = p.exitValue();\n\n        // 返回编译是否成功\n\n        return ret == 0;\n\n    }\n\n    // 重写Classloader的findCLass方法\n\n    protected Class<?> findClass(String name) throws ClassNotFoundException\n\n    {\n\n        Class clazz = null;\n\n        // 将包路径中的.替换成斜线/\n\n        String fileStub = name.replace(\".\", \"/\");\n\n        String javaFilename = fileStub + \".java\";\n\n        String classFilename = fileStub + \".class\";\n\n        File javaFile = new File(javaFilename);\n\n        File classFile = new File(classFilename);\n\n        // 当指定Java源文件存在，且class文件不存在，或者Java源文件的修改时间比class文件//修改时间晚时，重新编译\n\n        if (javaFile.exists() && (!classFile.exists())\n                || javaFile.lastModified() > classFile.lastModified())\n\n        {\n\n            try {\n\n                // 如果编译失败，或该Class文件不存在\n\n                if (!compile(javaFilename) || !classFile.exists())\n\n                {\n\n                    throw new ClassNotFoundException(\"ClassNotFoundException:\"\n                            + javaFilename);\n\n                }\n\n            } catch (IOException ex)\n\n            {\n\n                ex.printStackTrace();\n\n            }\n\n        }\n\n        // 如果class文件存在，系统负责将该文件转化成class对象\n\n        if (classFile.exists())\n\n        {\n\n            try {\n\n                // 将class文件的二进制数据读入数组\n\n                byte[] raw = getBytes(classFilename);\n\n                // 调用Classloader的defineClass方法将二进制数据转换成class对象\n\n                clazz = defineClass(name, raw, 0, raw.length);\n\n            } catch (IOException ie)\n\n            {\n\n                ie.printStackTrace();\n\n            }\n\n        }\n\n        // 如果claszz为null,表明加载失败，则抛出异常\n\n        if (clazz == null) {\n\n            throw new ClassNotFoundException(name);\n\n        }\n\n        return clazz;\n\n    }\n\n    // 定义一个主方法\n\n    public static void main(String[] args) throws Exception\n\n    {\n\n        // 如果运行该程序时没有参数，即没有目标类\n\n        if (args.length < 1) {\n\n            System.out.println(\"缺少运行的目标类，请按如下格式运行java源文件：\");\n\n            System.out.println(\"java CompileClassLoader ClassName\");\n\n        }\n\n        // 第一个参数是需要运行的类\n\n        String progClass = args[0];\n\n        // 剩下的参数将作为运行目标类时的参数，所以将这些参数复制到一个新数组中\n\n        String progargs[] = new String[args.length - 1];\n\n        System.arraycopy(args, 1, progargs, 0, progargs.length);\n\n        CompileClassLoader cl = new CompileClassLoader();\n\n        // 加载需要运行的类\n\n        Class<?> clazz = cl.loadClass(progClass);\n\n        // 获取需要运行的类的主方法\n\n        Method main = clazz.getMethod(\"main\", (new String[0]).getClass());\n\n        Object argsArray[] = { progargs };\n\n        main.invoke(null, argsArray);\n\n    }\n\n}\n```\n\n##### 类的连接\n\n当类被加载后，系统会为之生成一个Class对象，接着将会进入连接阶段，链接阶段负责把类的二进制数据合并到JRE中。它分为三个阶段：\n\n- 验证：检验被加载的类是否有正确的内部结构，并和其他类协调一致\n- 准备：负责为类的类变量分配内存。并设置默认初始值\n- 解析：将类的二进制数据中的符号引用替换成直接引用\n\n如下图：\n\n{% asset_img Java类从加载到初始化的过程.png Java类从加载到初始化的过程 %}\n\n##### 类的初始化\n\nJVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：\n\n- 声明类变量是指定初始值\n- 使用静态代码块为类变量指定初始值\n\nJVM初始化步骤\n\n- 假如这个类还没有被加载和连接，则程序先加载并连接该类\n- 假如该类的直接父类还没有被初始化，则先初始化其直接父类\n- 假如类中有初始化语句，则系统依次执行这些初始化语句\n\n类初始化时机\n\n- 创建类实例。也就是new的方式\n- 调用某个类的类方法\n- 访问某个类或接口的类变量，或为该类变量赋值\n- 使用反射方式强制创建某个类或接口对应的java.lang.Class对象\n- 初始化某个类的子类，则其父类也会被初始化\n- 直接使用java.exe命令来运行某个主类\n\n### 三 反射\n\n要想获得运行时对象和类的真实信息通常有两种方式：\n\n- 第一种是在编译时和运行时都完全知道类型的具体信息，这种情况下，可以通过instanceof运算符进行判断，再使用强制类型转换将其转化成运行时类型的变量即可\n- 第二种是编译时根本无法获知对象和类的类型信息，这种情况下只能通过反射来获知运行时对象和类的真实信息\n\n##### 获取Class对象\n\n通常有以下3种方法：\n\n- 使用Class类的forName(String name)方法，如Class.forName(\"Person\")获得person的Class对象\n- 使用某个类的class属性，如Person.class\n- 使用某个对象的getClass()方法，如Person.getClass()\n\n通常使用第二种方法。\n\n##### 从Class对象中获取信息\n\nJava的java.lang.Class类提供了大量的实例方法来获得某个类具体信息，如成员变量，方法，构造器等。具体方法请参考java.lang.Class的源码，这里不再赘述。\n\n##### 使用反射生成并操作对象\n\n通过反射来生成对象有两种方式：\n\n- 通过Class对象的newInstance()方法来获取Class对象对应类的实例。但是该方法需要这个对应类有默认构造函数，执行newInstance()方法实际上就是通过默认构造方法获取类的实例。\n- 通过Class对象的获取指定的Constructor对象，在调用Constructor对象的newInstance()来获取Class对应类的实例。\n\nJava的java.lang.reflect包下有对应的Constructor，Field，Method，Array等类，来通过反射获取相应类的具体信息。（Array用来动态的创建数组）\n\n### 四 动态代理\n\n##### JDK动态代理\n\n在Java的java.lang.refect包下有一个Proxy类和一个InvocationHandler接口，可以实现动态代理。\n\nProxy是所有动态代理类的父类，它可以用于动态代理类和动态代理对象。如：\n\n- static Class<?> getProxyClass(ClassLoader loader, Class<?>...interfaces):创建一个动态代理类对应的Class对象该代理类将实现interfaces所指定的多个接口，第一个参数指生成该动态代理类的类加载器。\n- static Object newProxyInstance(ClassLoader loader, Class<?>...interfaces,InvocationHandler h):创建动态代理对象，**执行代理对象的每个方法时都会被替换成执行InvocationHandler的invoke方法**。\n\n实际上即使采用第一种方法创建动态代理类后，如果需要创建动态代理实例，也需要传入一个InvocationHandler对象，每个动态代理实例都有一个与之对应的InvocationHandler对象。\n\n代码示例：\n\n被代理的接口即其实现类\n\n```java\npublic interface Subject\n{\n    public void rent();\n    \n    public void hello(String str);\n}\n\npublic class RealSubject implements Subject\n{\n    @Override\n    public void rent()\n    {\n        System.out.println(\"I want to rent my house\");\n    }\n    \n    @Override\n    public void hello(String str)\n    {\n        System.out.println(\"hello: \" + str);\n    }\n}\n```\n\n代理类：\n\n```java\npublic class DynamicProxy implements InvocationHandler\n{\n    //　这个就是我们要代理的真实对象\n    private Object subject;\n    \n    //    构造方法，给我们要代理的真实对象赋初值\n    public DynamicProxy(Object subject)\n    {\n        this.subject = subject;\n    }\n    \n    @Override\n    public Object invoke(Object object, Method method, Object[] args)\n            throws Throwable\n    {\n        //　　在代理真实对象前我们可以添加一些自己的操作\n        System.out.println(\"before rent house\");\n        \n        System.out.println(\"Method:\" + method);\n        \n        //    当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用\n        method.invoke(subject, args);\n        \n        //　　在代理真实对象后我们也可以添加一些自己的操作\n        System.out.println(\"after rent house\");\n        \n        return null;\n    }\n\n}\n```\n\n主程序：\n\n```java\npublic static void main(String[] args)\n    {\n        //    我们要代理的真实对象\n        Subject realSubject = new RealSubject();\n\n        //    我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的\n        InvocationHandler handler = new DynamicProxy(realSubject);\n\n        /*\n         * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数\n         * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象\n         * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了\n         * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上\n         */\n        Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject\n                .getClass().getInterfaces(), handler);\n        \n        System.out.println(subject.getClass().getName());\n        subject.rent();\n        subject.hello(\"world\");\n    }\n```\n\n##### CGLIB代理\n\nJDK的动态代理只能是面向接口的，要想面向类可以使用CGLIB代理。\n\n\n\n\n  ","slug":"Java基础之反射与类加载器","published":1,"updated":"2017-03-28T10:44:52.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk0j0001aknzyenm8uo6","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>类加载即是编译好的class文件被加载进Java虚拟机的过程，而这就需要用到Java类加载器java.lang.ClassLoader。class文件被加载进虚拟机后会生成java.lang.Class对象，而这些是发生在Java虚拟机中的，除了类加载过程，其余的我们并不能看到。要想获得这个Class对象，我们就需要通过反射。</p>\n<h3 id=\"二-类加载\"><a href=\"#二-类加载\" class=\"headerlink\" title=\"二 类加载\"></a>二 类加载</h3><p>指将类的class文件读入内存，并为之创建一个java.lang.Class的对象。</p>\n<p>类文件来源</p>\n<ul>\n<li>从本地文件系统加载的class文件</li>\n<li>从JAR包加载class文件</li>\n<li>从网络加载class文件</li>\n<li>把一个Java源文件动态编译，并执行加载</li>\n</ul>\n<p>类加载器通常无须等到“首次使用”该类时才加载该类，JVM允许系统预先加载某些类</p>\n<h5 id=\"类加载器的层次结构\"><a href=\"#类加载器的层次结构\" class=\"headerlink\" title=\"类加载器的层次结构\"></a>类加载器的层次结构</h5><p>下面是Java中类加载器的层次结构（不是继承结构）：</p>\n<img src=\"/2017/03/19/Java基础之反射与类加载器/类加载器的层次结构.png\" alt=\"类加载器的层次结构\" title=\"类加载器的层次结构\">\n<ul>\n<li>根类加载器（Bootstrap ClassLoader）：其负责加载Java的核心类，比如String、System这些类</li>\n<li>拓展类加载器（Extension ClassLoader）：其负责加载JRE的拓展类库</li>\n<li>系统类加载器（System ClassLoader）：其负责加载CLASSPATH环境变量所指定的JAR包和类路径</li>\n<li>用户类加载器：用户自定义的加载器，以类加载器为父类</li>\n</ul>\n<p>代码示例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">    ClassLoader systemLoader = ClassLoader.getSystemClassLoader();</div><div class=\"line\">    System.out.println(<span class=\"string\">\"系统类加载\"</span>);</div><div class=\"line\">    Enumeration&lt;URL&gt; em1 = systemLoader.getResources(<span class=\"string\">\"\"</span>);</div><div class=\"line\">    <span class=\"keyword\">while</span> (em1.hasMoreElements()) &#123;</div><div class=\"line\">        System.out.println(em1.nextElement());</div><div class=\"line\">    &#125;</div><div class=\"line\">    ClassLoader extensionLader = systemLoader.getParent();</div><div class=\"line\">    System.out.println(<span class=\"string\">\"拓展类加载器\"</span> + extensionLader);</div><div class=\"line\">    System.out.println(<span class=\"string\">\"拓展类加载器的父\"</span> + extensionLader.getParent());</div></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">系统类加载</div><div class=\"line\">file:/E:/gaode/em/bin/</div><div class=\"line\">拓展类加载器sun.misc.Launcher$ExtClassLoader@<span class=\"number\">6</span>d06d69c</div><div class=\"line\">拓展类加载器的父<span class=\"keyword\">null</span></div></pre></td></tr></table></figure>\n<p><strong>注意</strong>根类加载器并不是Java实现的，而且由于程序通常须访问根加载器，因此访问扩展类加载器的父类加载器时返回NULL</p>\n<h5 id=\"JVM类加载机制\"><a href=\"#JVM类加载机制\" class=\"headerlink\" title=\"JVM类加载机制\"></a>JVM类加载机制</h5><ul>\n<li><p>全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p>\n</li>\n<li><p>父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p>\n</li>\n<li><p>缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p>\n</li>\n</ul>\n<h5 id=\"URLClassLoader类\"><a href=\"#URLClassLoader类\" class=\"headerlink\" title=\"URLClassLoader类\"></a>URLClassLoader类</h5><p>URLClassLoader为ClassLoader的一个实现类，该类也是系统类加载器和拓展类加载器的父类（继承关系）。它既可以从本地文件系统获取二进制文件来加载类，也可以远程主机获取二进制文件来加载类。</p>\n<p>它的两个构造器：</p>\n<ul>\n<li><p>URLClassLoader(URL[] urls):使用默认的父类加载器创建一个ClassLoader对象，该对象将从urls所指定的路径来查询并加载类</p>\n</li>\n<li><p>URLClassLoader(URL[] urls,ClassLoader parent):使用指定的父类加载器创建一个ClassLoader对象，其他功能与前一个构造器相同</p>\n</li>\n</ul>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.net.MalformedURLException;</div><div class=\"line\"><span class=\"keyword\">import</span> java.net.URL;</div><div class=\"line\"><span class=\"keyword\">import</span> java.net.URLClassLoader;</div><div class=\"line\"><span class=\"keyword\">import</span> java.sql.Connection;</div><div class=\"line\"><span class=\"keyword\">import</span> java.sql.SQLException;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.Properties;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.mysql.jdbc.Driver;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GetMysql</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Connection conn;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connection <span class=\"title\">getConn</span><span class=\"params\">(String url,String user,String pass)</span> <span class=\"keyword\">throws</span> MalformedURLException, InstantiationException, IllegalAccessException, ClassNotFoundException, SQLException</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(conn==<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            URL[]urls=&#123;<span class=\"keyword\">new</span> URL(<span class=\"string\">\"file:mysql-connector-java-5.1.18.jar\"</span>)&#125;;</div><div class=\"line\">            URLClassLoader myClassLoader=<span class=\"keyword\">new</span> URLClassLoader(urls);</div><div class=\"line\">            Driver driver=(Driver) myClassLoader.loadClass(<span class=\"string\">\"com.mysql.jdbc.Driver\"</span>).newInstance();</div><div class=\"line\">            Properties pros=<span class=\"keyword\">new</span> Properties();</div><div class=\"line\">            pros.setProperty(<span class=\"string\">\"user\"</span>, user);</div><div class=\"line\">            pros.setProperty(<span class=\"string\">\"password\"</span>, pass);</div><div class=\"line\">            conn=driver.connect(url, pros);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> conn;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> method1 <span class=\"title\">getConn</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> MalformedURLException, InstantiationException, IllegalAccessException, ClassNotFoundException, SQLException</span>&#123;</div><div class=\"line\">        </div><div class=\"line\">            URL[]urls=&#123;<span class=\"keyword\">new</span> URL(<span class=\"string\">\"file:com.em\"</span>)&#125;;</div><div class=\"line\">            URLClassLoader myClassLoader=<span class=\"keyword\">new</span> URLClassLoader(urls);</div><div class=\"line\">            method1 driver=(method1) myClassLoader.loadClass(<span class=\"string\">\"com.em.method1\"</span>).newInstance();</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> driver;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> MalformedURLException, InstantiationException, IllegalAccessException, ClassNotFoundException, SQLException </span>&#123;</div><div class=\"line\">        System.out.println(getConn(<span class=\"string\">\"jdbc:mysql://10.10.16.11:3306/auto?useUnicode=true&amp;characterEncoding=utf8&amp;allowMultiQueries=true\"</span>, <span class=\"string\">\"jiji\"</span>, <span class=\"string\">\"jiji\"</span>));</div><div class=\"line\">        System.out.println(getConn());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>获得URLClassLoader对象后，调用loanClass()方法来加载指定的类</p>\n<h5 id=\"自定义类加载器\"><a href=\"#自定义类加载器\" class=\"headerlink\" title=\"自定义类加载器\"></a>自定义类加载器</h5><p>JVM中除了根类加载器之外的所有类的加载器都是ClassLoader子类的实例，通过重写ClassLoader中的方法，实现自定义的类加载器，通常我们会使用以下两个方法中的一个（通常第二个）</p>\n<ul>\n<li><p>loadClass(String name,boolean resolve):为ClassLoader的入口点，根据指定名称来加载类，系统就是调用ClassLoader的该方法来获取制定累对应的Class对象</p>\n</li>\n<li><p>findClass(String name):根据指定名称来查找类</p>\n</li>\n</ul>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.io.File;</div><div class=\"line\"><span class=\"keyword\">import</span> java.io.FileInputStream;</div><div class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CompileClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span></span></div><div class=\"line\"></div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 读取一个文件的内容</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"resource\"</span>)</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] getBytes(String filename) <span class=\"keyword\">throws</span> IOException</div><div class=\"line\"></div><div class=\"line\">    &#123;</div><div class=\"line\"></div><div class=\"line\">        File file = <span class=\"keyword\">new</span> File(filename);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">long</span> len = file.length();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">byte</span>[] raw = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[(<span class=\"keyword\">int</span>) len];</div><div class=\"line\"></div><div class=\"line\">        FileInputStream fin = <span class=\"keyword\">new</span> FileInputStream(file);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 一次读取class文件的全部二进制数据</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> r = fin.read(raw);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (r != len)</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"无法读取全部文件\"</span> + r + <span class=\"string\">\"!=\"</span> + len);</div><div class=\"line\"></div><div class=\"line\">        fin.close();</div><div class=\"line\">        <span class=\"keyword\">return</span> raw;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 定义编译指定java文件的方法</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compile</span><span class=\"params\">(String javaFile)</span> <span class=\"keyword\">throws</span> IOException</span></div><div class=\"line\"></div><div class=\"line\">    &#123;</div><div class=\"line\"></div><div class=\"line\">        System.out.println(<span class=\"string\">\"CompileClassLoader:正在编译\"</span> + javaFile + <span class=\"string\">\"……..\"</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 调用系统的javac命令</span></div><div class=\"line\"></div><div class=\"line\">        Process p = Runtime.getRuntime().exec(<span class=\"string\">\"javac\"</span> + javaFile);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 其它线程都等待这个线程完成</span></div><div class=\"line\"></div><div class=\"line\">            p.waitFor();</div><div class=\"line\"></div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException ie)</div><div class=\"line\"></div><div class=\"line\">        &#123;</div><div class=\"line\"></div><div class=\"line\">            System.out.println(ie);</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 获取javac 的线程的退出值</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> ret = p.exitValue();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 返回编译是否成功</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> ret == <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 重写Classloader的findCLass方法</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException</div><div class=\"line\"></div><div class=\"line\">    &#123;</div><div class=\"line\"></div><div class=\"line\">        Class clazz = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 将包路径中的.替换成斜线/</span></div><div class=\"line\"></div><div class=\"line\">        String fileStub = name.replace(<span class=\"string\">\".\"</span>, <span class=\"string\">\"/\"</span>);</div><div class=\"line\"></div><div class=\"line\">        String javaFilename = fileStub + <span class=\"string\">\".java\"</span>;</div><div class=\"line\"></div><div class=\"line\">        String classFilename = fileStub + <span class=\"string\">\".class\"</span>;</div><div class=\"line\"></div><div class=\"line\">        File javaFile = <span class=\"keyword\">new</span> File(javaFilename);</div><div class=\"line\"></div><div class=\"line\">        File classFile = <span class=\"keyword\">new</span> File(classFilename);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 当指定Java源文件存在，且class文件不存在，或者Java源文件的修改时间比class文件//修改时间晚时，重新编译</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (javaFile.exists() &amp;&amp; (!classFile.exists())</div><div class=\"line\">                || javaFile.lastModified() &gt; classFile.lastModified())</div><div class=\"line\"></div><div class=\"line\">        &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// 如果编译失败，或该Class文件不存在</span></div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">if</span> (!compile(javaFilename) || !classFile.exists())</div><div class=\"line\"></div><div class=\"line\">                &#123;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException(<span class=\"string\">\"ClassNotFoundException:\"</span></div><div class=\"line\">                            + javaFilename);</div><div class=\"line\"></div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException ex)</div><div class=\"line\"></div><div class=\"line\">            &#123;</div><div class=\"line\"></div><div class=\"line\">                ex.printStackTrace();</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 如果class文件存在，系统负责将该文件转化成class对象</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (classFile.exists())</div><div class=\"line\"></div><div class=\"line\">        &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// 将class文件的二进制数据读入数组</span></div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">byte</span>[] raw = getBytes(classFilename);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// 调用Classloader的defineClass方法将二进制数据转换成class对象</span></div><div class=\"line\"></div><div class=\"line\">                clazz = defineClass(name, raw, <span class=\"number\">0</span>, raw.length);</div><div class=\"line\"></div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException ie)</div><div class=\"line\"></div><div class=\"line\">            &#123;</div><div class=\"line\"></div><div class=\"line\">                ie.printStackTrace();</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 如果claszz为null,表明加载失败，则抛出异常</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (clazz == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException(name);</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> clazz;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 定义一个主方法</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception</span></div><div class=\"line\"></div><div class=\"line\">    &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 如果运行该程序时没有参数，即没有目标类</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (args.length &lt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">            System.out.println(<span class=\"string\">\"缺少运行的目标类，请按如下格式运行java源文件：\"</span>);</div><div class=\"line\"></div><div class=\"line\">            System.out.println(<span class=\"string\">\"java CompileClassLoader ClassName\"</span>);</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 第一个参数是需要运行的类</span></div><div class=\"line\"></div><div class=\"line\">        String progClass = args[<span class=\"number\">0</span>];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 剩下的参数将作为运行目标类时的参数，所以将这些参数复制到一个新数组中</span></div><div class=\"line\"></div><div class=\"line\">        String progargs[] = <span class=\"keyword\">new</span> String[args.length - <span class=\"number\">1</span>];</div><div class=\"line\"></div><div class=\"line\">        System.arraycopy(args, <span class=\"number\">1</span>, progargs, <span class=\"number\">0</span>, progargs.length);</div><div class=\"line\"></div><div class=\"line\">        CompileClassLoader cl = <span class=\"keyword\">new</span> CompileClassLoader();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 加载需要运行的类</span></div><div class=\"line\"></div><div class=\"line\">        Class&lt;?&gt; clazz = cl.loadClass(progClass);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 获取需要运行的类的主方法</span></div><div class=\"line\"></div><div class=\"line\">        Method main = clazz.getMethod(<span class=\"string\">\"main\"</span>, (<span class=\"keyword\">new</span> String[<span class=\"number\">0</span>]).getClass());</div><div class=\"line\"></div><div class=\"line\">        Object argsArray[] = &#123; progargs &#125;;</div><div class=\"line\"></div><div class=\"line\">        main.invoke(<span class=\"keyword\">null</span>, argsArray);</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"类的连接\"><a href=\"#类的连接\" class=\"headerlink\" title=\"类的连接\"></a>类的连接</h5><p>当类被加载后，系统会为之生成一个Class对象，接着将会进入连接阶段，链接阶段负责把类的二进制数据合并到JRE中。它分为三个阶段：</p>\n<ul>\n<li>验证：检验被加载的类是否有正确的内部结构，并和其他类协调一致</li>\n<li>准备：负责为类的类变量分配内存。并设置默认初始值</li>\n<li>解析：将类的二进制数据中的符号引用替换成直接引用</li>\n</ul>\n<p>如下图：</p>\n\n<h5 id=\"类的初始化\"><a href=\"#类的初始化\" class=\"headerlink\" title=\"类的初始化\"></a>类的初始化</h5><p>JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>\n<ul>\n<li>声明类变量是指定初始值</li>\n<li>使用静态代码块为类变量指定初始值</li>\n</ul>\n<p>JVM初始化步骤</p>\n<ul>\n<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>\n<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>\n<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>\n</ul>\n<p>类初始化时机</p>\n<ul>\n<li>创建类实例。也就是new的方式</li>\n<li>调用某个类的类方法</li>\n<li>访问某个类或接口的类变量，或为该类变量赋值</li>\n<li>使用反射方式强制创建某个类或接口对应的java.lang.Class对象</li>\n<li>初始化某个类的子类，则其父类也会被初始化</li>\n<li>直接使用java.exe命令来运行某个主类</li>\n</ul>\n<h3 id=\"三-反射\"><a href=\"#三-反射\" class=\"headerlink\" title=\"三 反射\"></a>三 反射</h3><p>要想获得运行时对象和类的真实信息通常有两种方式：</p>\n<ul>\n<li>第一种是在编译时和运行时都完全知道类型的具体信息，这种情况下，可以通过instanceof运算符进行判断，再使用强制类型转换将其转化成运行时类型的变量即可</li>\n<li>第二种是编译时根本无法获知对象和类的类型信息，这种情况下只能通过反射来获知运行时对象和类的真实信息</li>\n</ul>\n<h5 id=\"获取Class对象\"><a href=\"#获取Class对象\" class=\"headerlink\" title=\"获取Class对象\"></a>获取Class对象</h5><p>通常有以下3种方法：</p>\n<ul>\n<li>使用Class类的forName(String name)方法，如Class.forName(“Person”)获得person的Class对象</li>\n<li>使用某个类的class属性，如Person.class</li>\n<li>使用某个对象的getClass()方法，如Person.getClass()</li>\n</ul>\n<p>通常使用第二种方法。</p>\n<h5 id=\"从Class对象中获取信息\"><a href=\"#从Class对象中获取信息\" class=\"headerlink\" title=\"从Class对象中获取信息\"></a>从Class对象中获取信息</h5><p>Java的java.lang.Class类提供了大量的实例方法来获得某个类具体信息，如成员变量，方法，构造器等。具体方法请参考java.lang.Class的源码，这里不再赘述。</p>\n<h5 id=\"使用反射生成并操作对象\"><a href=\"#使用反射生成并操作对象\" class=\"headerlink\" title=\"使用反射生成并操作对象\"></a>使用反射生成并操作对象</h5><p>通过反射来生成对象有两种方式：</p>\n<ul>\n<li>通过Class对象的newInstance()方法来获取Class对象对应类的实例。但是该方法需要这个对应类有默认构造函数，执行newInstance()方法实际上就是通过默认构造方法获取类的实例。</li>\n<li>通过Class对象的获取指定的Constructor对象，在调用Constructor对象的newInstance()来获取Class对应类的实例。</li>\n</ul>\n<p>Java的java.lang.reflect包下有对应的Constructor，Field，Method，Array等类，来通过反射获取相应类的具体信息。（Array用来动态的创建数组）</p>\n<h3 id=\"四-动态代理\"><a href=\"#四-动态代理\" class=\"headerlink\" title=\"四 动态代理\"></a>四 动态代理</h3><h5 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h5><p>在Java的java.lang.refect包下有一个Proxy类和一个InvocationHandler接口，可以实现动态代理。</p>\n<p>Proxy是所有动态代理类的父类，它可以用于动态代理类和动态代理对象。如：</p>\n<ul>\n<li>static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;…interfaces):创建一个动态代理类对应的Class对象该代理类将实现interfaces所指定的多个接口，第一个参数指生成该动态代理类的类加载器。</li>\n<li>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;…interfaces,InvocationHandler h):创建动态代理对象，<strong>执行代理对象的每个方法时都会被替换成执行InvocationHandler的invoke方法</strong>。</li>\n</ul>\n<p>实际上即使采用第一种方法创建动态代理类后，如果需要创建动态代理实例，也需要传入一个InvocationHandler对象，每个动态代理实例都有一个与之对应的InvocationHandler对象。</p>\n<p>代码示例：</p>\n<p>被代理的接口即其实现类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rent</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(String str)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rent</span><span class=\"params\">()</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"I want to rent my house\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(String str)</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"hello: \"</span> + str);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代理类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//　这个就是我们要代理的真实对象</span></div><div class=\"line\">    <span class=\"keyword\">private</span> Object subject;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//    构造方法，给我们要代理的真实对象赋初值</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DynamicProxy</span><span class=\"params\">(Object subject)</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.subject = subject;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object object, Method method, Object[] args)</span></span></div><div class=\"line\">            <span class=\"keyword\">throws</span> Throwable</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">//　　在代理真实对象前我们可以添加一些自己的操作</span></div><div class=\"line\">        System.out.println(<span class=\"string\">\"before rent house\"</span>);</div><div class=\"line\">        </div><div class=\"line\">        System.out.println(<span class=\"string\">\"Method:\"</span> + method);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//    当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></div><div class=\"line\">        method.invoke(subject, args);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//　　在代理真实对象后我们也可以添加一些自己的操作</span></div><div class=\"line\">        System.out.println(<span class=\"string\">\"after rent house\"</span>);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主程序：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">//    我们要代理的真实对象</span></div><div class=\"line\">        Subject realSubject = <span class=\"keyword\">new</span> RealSubject();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//    我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的</span></div><div class=\"line\">        InvocationHandler handler = <span class=\"keyword\">new</span> DynamicProxy(realSubject);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">/*</span></div><div class=\"line\">         * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数</div><div class=\"line\">         * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象</div><div class=\"line\">         * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了</div><div class=\"line\">         * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上</div><div class=\"line\">         */</div><div class=\"line\">        Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject</div><div class=\"line\">                .getClass().getInterfaces(), handler);</div><div class=\"line\">        </div><div class=\"line\">        System.out.println(subject.getClass().getName());</div><div class=\"line\">        subject.rent();</div><div class=\"line\">        subject.hello(<span class=\"string\">\"world\"</span>);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h5 id=\"CGLIB代理\"><a href=\"#CGLIB代理\" class=\"headerlink\" title=\"CGLIB代理\"></a>CGLIB代理</h5><p>JDK的动态代理只能是面向接口的，要想面向类可以使用CGLIB代理。</p>\n","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>类加载即是编译好的class文件被加载进Java虚拟机的过程，而这就需要用到Java类加载器java.lang.ClassLoader。class文件被加载进虚拟机后会生成java.lang.Class对象，而这些是发生在Java虚拟机中的，除了类加载过程，其余的我们并不能看到。要想获得这个Class对象，我们就需要通过反射。</p>\n<h3 id=\"二-类加载\"><a href=\"#二-类加载\" class=\"headerlink\" title=\"二 类加载\"></a>二 类加载</h3><p>指将类的class文件读入内存，并为之创建一个java.lang.Class的对象。</p>\n<p>类文件来源</p>\n<ul>\n<li>从本地文件系统加载的class文件</li>\n<li>从JAR包加载class文件</li>\n<li>从网络加载class文件</li>\n<li>把一个Java源文件动态编译，并执行加载</li>\n</ul>\n<p>类加载器通常无须等到“首次使用”该类时才加载该类，JVM允许系统预先加载某些类</p>\n<h5 id=\"类加载器的层次结构\"><a href=\"#类加载器的层次结构\" class=\"headerlink\" title=\"类加载器的层次结构\"></a>类加载器的层次结构</h5><p>下面是Java中类加载器的层次结构（不是继承结构）：</p>\n<img src=\"/2017/03/19/Java基础之反射与类加载器/类加载器的层次结构.png\" alt=\"类加载器的层次结构\" title=\"类加载器的层次结构\">\n<ul>\n<li>根类加载器（Bootstrap ClassLoader）：其负责加载Java的核心类，比如String、System这些类</li>\n<li>拓展类加载器（Extension ClassLoader）：其负责加载JRE的拓展类库</li>\n<li>系统类加载器（System ClassLoader）：其负责加载CLASSPATH环境变量所指定的JAR包和类路径</li>\n<li>用户类加载器：用户自定义的加载器，以类加载器为父类</li>\n</ul>\n<p>代码示例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">    ClassLoader systemLoader = ClassLoader.getSystemClassLoader();</div><div class=\"line\">    System.out.println(<span class=\"string\">\"系统类加载\"</span>);</div><div class=\"line\">    Enumeration&lt;URL&gt; em1 = systemLoader.getResources(<span class=\"string\">\"\"</span>);</div><div class=\"line\">    <span class=\"keyword\">while</span> (em1.hasMoreElements()) &#123;</div><div class=\"line\">        System.out.println(em1.nextElement());</div><div class=\"line\">    &#125;</div><div class=\"line\">    ClassLoader extensionLader = systemLoader.getParent();</div><div class=\"line\">    System.out.println(<span class=\"string\">\"拓展类加载器\"</span> + extensionLader);</div><div class=\"line\">    System.out.println(<span class=\"string\">\"拓展类加载器的父\"</span> + extensionLader.getParent());</div></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">系统类加载</div><div class=\"line\">file:/E:/gaode/em/bin/</div><div class=\"line\">拓展类加载器sun.misc.Launcher$ExtClassLoader@<span class=\"number\">6</span>d06d69c</div><div class=\"line\">拓展类加载器的父<span class=\"keyword\">null</span></div></pre></td></tr></table></figure>\n<p><strong>注意</strong>根类加载器并不是Java实现的，而且由于程序通常须访问根加载器，因此访问扩展类加载器的父类加载器时返回NULL</p>\n<h5 id=\"JVM类加载机制\"><a href=\"#JVM类加载机制\" class=\"headerlink\" title=\"JVM类加载机制\"></a>JVM类加载机制</h5><ul>\n<li><p>全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p>\n</li>\n<li><p>父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p>\n</li>\n<li><p>缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p>\n</li>\n</ul>\n<h5 id=\"URLClassLoader类\"><a href=\"#URLClassLoader类\" class=\"headerlink\" title=\"URLClassLoader类\"></a>URLClassLoader类</h5><p>URLClassLoader为ClassLoader的一个实现类，该类也是系统类加载器和拓展类加载器的父类（继承关系）。它既可以从本地文件系统获取二进制文件来加载类，也可以远程主机获取二进制文件来加载类。</p>\n<p>它的两个构造器：</p>\n<ul>\n<li><p>URLClassLoader(URL[] urls):使用默认的父类加载器创建一个ClassLoader对象，该对象将从urls所指定的路径来查询并加载类</p>\n</li>\n<li><p>URLClassLoader(URL[] urls,ClassLoader parent):使用指定的父类加载器创建一个ClassLoader对象，其他功能与前一个构造器相同</p>\n</li>\n</ul>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.net.MalformedURLException;</div><div class=\"line\"><span class=\"keyword\">import</span> java.net.URL;</div><div class=\"line\"><span class=\"keyword\">import</span> java.net.URLClassLoader;</div><div class=\"line\"><span class=\"keyword\">import</span> java.sql.Connection;</div><div class=\"line\"><span class=\"keyword\">import</span> java.sql.SQLException;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.Properties;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.mysql.jdbc.Driver;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GetMysql</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Connection conn;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connection <span class=\"title\">getConn</span><span class=\"params\">(String url,String user,String pass)</span> <span class=\"keyword\">throws</span> MalformedURLException, InstantiationException, IllegalAccessException, ClassNotFoundException, SQLException</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(conn==<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            URL[]urls=&#123;<span class=\"keyword\">new</span> URL(<span class=\"string\">\"file:mysql-connector-java-5.1.18.jar\"</span>)&#125;;</div><div class=\"line\">            URLClassLoader myClassLoader=<span class=\"keyword\">new</span> URLClassLoader(urls);</div><div class=\"line\">            Driver driver=(Driver) myClassLoader.loadClass(<span class=\"string\">\"com.mysql.jdbc.Driver\"</span>).newInstance();</div><div class=\"line\">            Properties pros=<span class=\"keyword\">new</span> Properties();</div><div class=\"line\">            pros.setProperty(<span class=\"string\">\"user\"</span>, user);</div><div class=\"line\">            pros.setProperty(<span class=\"string\">\"password\"</span>, pass);</div><div class=\"line\">            conn=driver.connect(url, pros);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> conn;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> method1 <span class=\"title\">getConn</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> MalformedURLException, InstantiationException, IllegalAccessException, ClassNotFoundException, SQLException</span>&#123;</div><div class=\"line\">        </div><div class=\"line\">            URL[]urls=&#123;<span class=\"keyword\">new</span> URL(<span class=\"string\">\"file:com.em\"</span>)&#125;;</div><div class=\"line\">            URLClassLoader myClassLoader=<span class=\"keyword\">new</span> URLClassLoader(urls);</div><div class=\"line\">            method1 driver=(method1) myClassLoader.loadClass(<span class=\"string\">\"com.em.method1\"</span>).newInstance();</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> driver;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> MalformedURLException, InstantiationException, IllegalAccessException, ClassNotFoundException, SQLException </span>&#123;</div><div class=\"line\">        System.out.println(getConn(<span class=\"string\">\"jdbc:mysql://10.10.16.11:3306/auto?useUnicode=true&amp;characterEncoding=utf8&amp;allowMultiQueries=true\"</span>, <span class=\"string\">\"jiji\"</span>, <span class=\"string\">\"jiji\"</span>));</div><div class=\"line\">        System.out.println(getConn());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>获得URLClassLoader对象后，调用loanClass()方法来加载指定的类</p>\n<h5 id=\"自定义类加载器\"><a href=\"#自定义类加载器\" class=\"headerlink\" title=\"自定义类加载器\"></a>自定义类加载器</h5><p>JVM中除了根类加载器之外的所有类的加载器都是ClassLoader子类的实例，通过重写ClassLoader中的方法，实现自定义的类加载器，通常我们会使用以下两个方法中的一个（通常第二个）</p>\n<ul>\n<li><p>loadClass(String name,boolean resolve):为ClassLoader的入口点，根据指定名称来加载类，系统就是调用ClassLoader的该方法来获取制定累对应的Class对象</p>\n</li>\n<li><p>findClass(String name):根据指定名称来查找类</p>\n</li>\n</ul>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.io.File;</div><div class=\"line\"><span class=\"keyword\">import</span> java.io.FileInputStream;</div><div class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CompileClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span></div><div class=\"line\"></div><div class=\"line\"></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 读取一个文件的内容</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"resource\"</span>)</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] getBytes(String filename) <span class=\"keyword\">throws</span> IOException</div><div class=\"line\"></div><div class=\"line\">    &#123;</div><div class=\"line\"></div><div class=\"line\">        File file = <span class=\"keyword\">new</span> File(filename);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">long</span> len = file.length();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">byte</span>[] raw = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[(<span class=\"keyword\">int</span>) len];</div><div class=\"line\"></div><div class=\"line\">        FileInputStream fin = <span class=\"keyword\">new</span> FileInputStream(file);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 一次读取class文件的全部二进制数据</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> r = fin.read(raw);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (r != len)</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"无法读取全部文件\"</span> + r + <span class=\"string\">\"!=\"</span> + len);</div><div class=\"line\"></div><div class=\"line\">        fin.close();</div><div class=\"line\">        <span class=\"keyword\">return</span> raw;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 定义编译指定java文件的方法</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compile</span><span class=\"params\">(String javaFile)</span> <span class=\"keyword\">throws</span> IOException</div><div class=\"line\"></div><div class=\"line\">    </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        System.out.println(<span class=\"string\">\"CompileClassLoader:正在编译\"</span> + javaFile + <span class=\"string\">\"……..\"</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 调用系统的javac命令</span></div><div class=\"line\"></div><div class=\"line\">        Process p = Runtime.getRuntime().exec(<span class=\"string\">\"javac\"</span> + javaFile);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 其它线程都等待这个线程完成</span></div><div class=\"line\"></div><div class=\"line\">            p.waitFor();</div><div class=\"line\"></div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException ie)</div><div class=\"line\"></div><div class=\"line\">        &#123;</div><div class=\"line\"></div><div class=\"line\">            System.out.println(ie);</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 获取javac 的线程的退出值</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> ret = p.exitValue();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 返回编译是否成功</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> ret == <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 重写Classloader的findCLass方法</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException</div><div class=\"line\"></div><div class=\"line\">    &#123;</div><div class=\"line\"></div><div class=\"line\">        Class clazz = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 将包路径中的.替换成斜线/</span></div><div class=\"line\"></div><div class=\"line\">        String fileStub = name.replace(<span class=\"string\">\".\"</span>, <span class=\"string\">\"/\"</span>);</div><div class=\"line\"></div><div class=\"line\">        String javaFilename = fileStub + <span class=\"string\">\".java\"</span>;</div><div class=\"line\"></div><div class=\"line\">        String classFilename = fileStub + <span class=\"string\">\".class\"</span>;</div><div class=\"line\"></div><div class=\"line\">        File javaFile = <span class=\"keyword\">new</span> File(javaFilename);</div><div class=\"line\"></div><div class=\"line\">        File classFile = <span class=\"keyword\">new</span> File(classFilename);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 当指定Java源文件存在，且class文件不存在，或者Java源文件的修改时间比class文件//修改时间晚时，重新编译</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (javaFile.exists() &amp;&amp; (!classFile.exists())</div><div class=\"line\">                || javaFile.lastModified() &gt; classFile.lastModified())</div><div class=\"line\"></div><div class=\"line\">        &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// 如果编译失败，或该Class文件不存在</span></div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">if</span> (!compile(javaFilename) || !classFile.exists())</div><div class=\"line\"></div><div class=\"line\">                &#123;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException(<span class=\"string\">\"ClassNotFoundException:\"</span></div><div class=\"line\">                            + javaFilename);</div><div class=\"line\"></div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException ex)</div><div class=\"line\"></div><div class=\"line\">            &#123;</div><div class=\"line\"></div><div class=\"line\">                ex.printStackTrace();</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 如果class文件存在，系统负责将该文件转化成class对象</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (classFile.exists())</div><div class=\"line\"></div><div class=\"line\">        &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// 将class文件的二进制数据读入数组</span></div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">byte</span>[] raw = getBytes(classFilename);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// 调用Classloader的defineClass方法将二进制数据转换成class对象</span></div><div class=\"line\"></div><div class=\"line\">                clazz = defineClass(name, raw, <span class=\"number\">0</span>, raw.length);</div><div class=\"line\"></div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException ie)</div><div class=\"line\"></div><div class=\"line\">            &#123;</div><div class=\"line\"></div><div class=\"line\">                ie.printStackTrace();</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 如果claszz为null,表明加载失败，则抛出异常</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (clazz == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException(name);</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> clazz;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 定义一个主方法</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception</div><div class=\"line\"></div><div class=\"line\">    </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 如果运行该程序时没有参数，即没有目标类</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (args.length &lt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">            System.out.println(<span class=\"string\">\"缺少运行的目标类，请按如下格式运行java源文件：\"</span>);</div><div class=\"line\"></div><div class=\"line\">            System.out.println(<span class=\"string\">\"java CompileClassLoader ClassName\"</span>);</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 第一个参数是需要运行的类</span></div><div class=\"line\"></div><div class=\"line\">        String progClass = args[<span class=\"number\">0</span>];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 剩下的参数将作为运行目标类时的参数，所以将这些参数复制到一个新数组中</span></div><div class=\"line\"></div><div class=\"line\">        String progargs[] = <span class=\"keyword\">new</span> String[args.length - <span class=\"number\">1</span>];</div><div class=\"line\"></div><div class=\"line\">        System.arraycopy(args, <span class=\"number\">1</span>, progargs, <span class=\"number\">0</span>, progargs.length);</div><div class=\"line\"></div><div class=\"line\">        CompileClassLoader cl = <span class=\"keyword\">new</span> CompileClassLoader();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 加载需要运行的类</span></div><div class=\"line\"></div><div class=\"line\">        Class&lt;?&gt; clazz = cl.loadClass(progClass);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 获取需要运行的类的主方法</span></div><div class=\"line\"></div><div class=\"line\">        Method main = clazz.getMethod(<span class=\"string\">\"main\"</span>, (<span class=\"keyword\">new</span> String[<span class=\"number\">0</span>]).getClass());</div><div class=\"line\"></div><div class=\"line\">        Object argsArray[] = &#123; progargs &#125;;</div><div class=\"line\"></div><div class=\"line\">        main.invoke(<span class=\"keyword\">null</span>, argsArray);</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"类的连接\"><a href=\"#类的连接\" class=\"headerlink\" title=\"类的连接\"></a>类的连接</h5><p>当类被加载后，系统会为之生成一个Class对象，接着将会进入连接阶段，链接阶段负责把类的二进制数据合并到JRE中。它分为三个阶段：</p>\n<ul>\n<li>验证：检验被加载的类是否有正确的内部结构，并和其他类协调一致</li>\n<li>准备：负责为类的类变量分配内存。并设置默认初始值</li>\n<li>解析：将类的二进制数据中的符号引用替换成直接引用</li>\n</ul>\n<p>如下图：</p>\n\n<h5 id=\"类的初始化\"><a href=\"#类的初始化\" class=\"headerlink\" title=\"类的初始化\"></a>类的初始化</h5><p>JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>\n<ul>\n<li>声明类变量是指定初始值</li>\n<li>使用静态代码块为类变量指定初始值</li>\n</ul>\n<p>JVM初始化步骤</p>\n<ul>\n<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>\n<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>\n<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>\n</ul>\n<p>类初始化时机</p>\n<ul>\n<li>创建类实例。也就是new的方式</li>\n<li>调用某个类的类方法</li>\n<li>访问某个类或接口的类变量，或为该类变量赋值</li>\n<li>使用反射方式强制创建某个类或接口对应的java.lang.Class对象</li>\n<li>初始化某个类的子类，则其父类也会被初始化</li>\n<li>直接使用java.exe命令来运行某个主类</li>\n</ul>\n<h3 id=\"三-反射\"><a href=\"#三-反射\" class=\"headerlink\" title=\"三 反射\"></a>三 反射</h3><p>要想获得运行时对象和类的真实信息通常有两种方式：</p>\n<ul>\n<li>第一种是在编译时和运行时都完全知道类型的具体信息，这种情况下，可以通过instanceof运算符进行判断，再使用强制类型转换将其转化成运行时类型的变量即可</li>\n<li>第二种是编译时根本无法获知对象和类的类型信息，这种情况下只能通过反射来获知运行时对象和类的真实信息</li>\n</ul>\n<h5 id=\"获取Class对象\"><a href=\"#获取Class对象\" class=\"headerlink\" title=\"获取Class对象\"></a>获取Class对象</h5><p>通常有以下3种方法：</p>\n<ul>\n<li>使用Class类的forName(String name)方法，如Class.forName(“Person”)获得person的Class对象</li>\n<li>使用某个类的class属性，如Person.class</li>\n<li>使用某个对象的getClass()方法，如Person.getClass()</li>\n</ul>\n<p>通常使用第二种方法。</p>\n<h5 id=\"从Class对象中获取信息\"><a href=\"#从Class对象中获取信息\" class=\"headerlink\" title=\"从Class对象中获取信息\"></a>从Class对象中获取信息</h5><p>Java的java.lang.Class类提供了大量的实例方法来获得某个类具体信息，如成员变量，方法，构造器等。具体方法请参考java.lang.Class的源码，这里不再赘述。</p>\n<h5 id=\"使用反射生成并操作对象\"><a href=\"#使用反射生成并操作对象\" class=\"headerlink\" title=\"使用反射生成并操作对象\"></a>使用反射生成并操作对象</h5><p>通过反射来生成对象有两种方式：</p>\n<ul>\n<li>通过Class对象的newInstance()方法来获取Class对象对应类的实例。但是该方法需要这个对应类有默认构造函数，执行newInstance()方法实际上就是通过默认构造方法获取类的实例。</li>\n<li>通过Class对象的获取指定的Constructor对象，在调用Constructor对象的newInstance()来获取Class对应类的实例。</li>\n</ul>\n<p>Java的java.lang.reflect包下有对应的Constructor，Field，Method，Array等类，来通过反射获取相应类的具体信息。（Array用来动态的创建数组）</p>\n<h3 id=\"四-动态代理\"><a href=\"#四-动态代理\" class=\"headerlink\" title=\"四 动态代理\"></a>四 动态代理</h3><h5 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h5><p>在Java的java.lang.refect包下有一个Proxy类和一个InvocationHandler接口，可以实现动态代理。</p>\n<p>Proxy是所有动态代理类的父类，它可以用于动态代理类和动态代理对象。如：</p>\n<ul>\n<li>static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;…interfaces):创建一个动态代理类对应的Class对象该代理类将实现interfaces所指定的多个接口，第一个参数指生成该动态代理类的类加载器。</li>\n<li>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;…interfaces,InvocationHandler h):创建动态代理对象，<strong>执行代理对象的每个方法时都会被替换成执行InvocationHandler的invoke方法</strong>。</li>\n</ul>\n<p>实际上即使采用第一种方法创建动态代理类后，如果需要创建动态代理实例，也需要传入一个InvocationHandler对象，每个动态代理实例都有一个与之对应的InvocationHandler对象。</p>\n<p>代码示例：</p>\n<p>被代理的接口即其实现类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rent</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(String str)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rent</span><span class=\"params\">()</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"I want to rent my house\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(String str)</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"hello: \"</span> + str);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代理类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//　这个就是我们要代理的真实对象</span></div><div class=\"line\">    <span class=\"keyword\">private</span> Object subject;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//    构造方法，给我们要代理的真实对象赋初值</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DynamicProxy</span><span class=\"params\">(Object subject)</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.subject = subject;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object object, Method method, Object[] args)</span></div><div class=\"line\">            <span class=\"keyword\">throws</span> Throwable</div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//　　在代理真实对象前我们可以添加一些自己的操作</span></div><div class=\"line\">        System.out.println(<span class=\"string\">\"before rent house\"</span>);</div><div class=\"line\">        </div><div class=\"line\">        System.out.println(<span class=\"string\">\"Method:\"</span> + method);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//    当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></div><div class=\"line\">        method.invoke(subject, args);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//　　在代理真实对象后我们也可以添加一些自己的操作</span></div><div class=\"line\">        System.out.println(<span class=\"string\">\"after rent house\"</span>);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主程序：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//    我们要代理的真实对象</span></div><div class=\"line\">        Subject realSubject = <span class=\"keyword\">new</span> RealSubject();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//    我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的</span></div><div class=\"line\">        InvocationHandler handler = <span class=\"keyword\">new</span> DynamicProxy(realSubject);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">/*</div><div class=\"line\">         * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数</div><div class=\"line\">         * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象</div><div class=\"line\">         * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了</div><div class=\"line\">         * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上</div><div class=\"line\">         */</span></div><div class=\"line\">        Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject</div><div class=\"line\">                .getClass().getInterfaces(), handler);</div><div class=\"line\">        </div><div class=\"line\">        System.out.println(subject.getClass().getName());</div><div class=\"line\">        subject.rent();</div><div class=\"line\">        subject.hello(<span class=\"string\">\"world\"</span>);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h5 id=\"CGLIB代理\"><a href=\"#CGLIB代理\" class=\"headerlink\" title=\"CGLIB代理\"></a>CGLIB代理</h5><p>JDK的动态代理只能是面向接口的，要想面向类可以使用CGLIB代理。</p>\n"},{"title":"Java基础之内存管理","date":"2017-03-19T14:48:42.000Z","_content":"\n### 一 概述\n\n对于从事C和C++程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的皇帝，又是从事最基础工作的劳动人民—既拥有每一个对象的“所有权”，又担负着每一个对象生命开始到终结的维护责任。\n\n对于Java程序员来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，而且不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误将会成为一项异常艰难的工作。\n\nJava的内存管理分为分配和回收两部分。\n\n### 二 内存分配\n\nJava虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（第2版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示：\n\n{% asset_img 运行时数据区域.jpg 运行时数据区域 %}\n\n上图是较细的划分，可以再将它们划分为栈和堆两个部分。\n\n##### 1.栈与堆\n\n栈区：（线程私有）\n\n- 程序计数器：程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。\n\n- 虚拟机栈：java虚拟机运行的java方法(java字节码方法)构成的栈空间，这个空间在运行时存储这些方法的局部变量表、操作栈、动态链接和方法出口。程序员常说的栈其实主要就是指虚拟机栈，Java中的8种基本类型和对象的引用均存放在该区域中。\n\n- 本地方法栈：本地方法在运行时存储数据产生的栈区。本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。\n\n栈区可以自己管理自己，一般不会出现问题；造成内存泄露的主要是堆区。\n\n堆区：（线程共享）\n\n- 堆：这个就是我们重点要关心的区域，主要存放Java中new出来的对象，也是GC主要运行的重点。\n\n- 方法区：堆的一部分（但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来），用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。在有些虚拟机中它也被叫做“永久代”（如HotSpot），很少发生垃圾回收行为，这个区域的回收主要针对常量池的回收和对类型的卸载。\n\n- 运行时常量池：方法区的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。\n\n##### 2.Java中的对象访问是如何进行的\n\n介绍完Java虚拟机的运行时数据区之后，我们就可以来探讨一个问题：在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程\n\n序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码：\n\n```java\nObject obj = new Object();\n```\n\n假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而“new Object()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。\n\n由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。\n\n###### 使用句柄\n\n如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示：\n\n{% asset_img 通过句柄访问对象.jpg 通过句柄访问对象 %}\n\n###### 使用直接指针\n\n如果使用的是直接指针访问方式，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如下图所示：\n\n{% asset_img 通过直接指针访问对象.jpg 通过直接指针访问对象 %}\n\n这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。常见的Sun HotSpot虚拟机就是使用的第二种方式。\n\n### 三 垃圾回收\n\n说起垃圾收集（Garbage Collection，GC），大部分人都把这项技术当做Java语言的伴生产物。事实上，GC的历史远远比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。\n\n堆中几乎存放着Java世界中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。下面将详细介绍Java虚拟机是如何判断一个对象是否存活的。\n\n##### 1.程序计数法\n\n很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。\n\n客观地说，引用计数算法（Reference Counting）的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，也有一些比较著名的应用案例，例如微软的COM（Component Object Model）技术、使用ActionScript 3的FlashPlayer、Python语言以及在游戏脚本领域中被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。**但是，Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题（也就是所谓的隔离岛问题）。**如下面示例：\n\n```java\n public class ReferenceCountingGC {\n     public static void main(String[] args) {\n         testGC();\n     }\n     public Object instance = null;\n     private static final int _1MB=1024*1024;\n     /**\n      * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过 \n      */\n     private byte[] bigSize = new byte[2 * _1MB];\n     public static void testGC(){\n         ReferenceCountingGC objA=new ReferenceCountingGC();\n         ReferenceCountingGC objB=new ReferenceCountingGC();\n         objA.instance=objB;\n         objB.instance=objA;\n         objA=null;\n         objB=null;\n         // 假设在这行发生GC，那么objA和objB是否能被回收？\n         System.gc();\n     }\n }\n```\n\n程序计数法无法回收这一类的对象，但事实上Java可以回收他们，因此Java对象判活使用的不是程序计数法而是根搜索法。\n\n##### 2. 根搜索法\n\n在主流的商用程序语言中（Java和C#，甚至包括前面提到的古老的Lisp），都是使用根搜索算法（GC Roots Tracing）判定对象是否存活的。这个算法的基本思路就是通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。如图3-1所示，对象object 5、object 6、object7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。\n\n在Java语言里，可作为GC Roots的对象包括下面几种：\n\n- 虚拟机栈（栈帧中的本地变量表）中的引用的对象。\n- 方法区中的类静态属性引用的对象。\n- 方法区中的常量引用的对象。\n- 本地方法栈中JNI（即一般说的Native方法）的引用的对象。\n\n\n{% asset_img 根搜索算法判断对象是否可回收.jpg 根搜索算法判断对象是否可回收 %}\n\n在根搜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。\n\n如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己—只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。\n\n另外一个值得注意的地方任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。 需要特别说明的是，上面关于对象死亡时finalize()方法的描述可能带有悲情的艺术色彩，笔者并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用它，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中提到它适合做“关闭外部资源”之类的工作，这完全是对这种方法的用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或其他方式都可以做得更好、更及时，大家完全可以忘掉Java语言中还有这个方法的存在。\n\n##### 3. Java中的引用\n\nJDK1.2开始Java将引用分成了四种：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（WeakReference）、虚引用（Phantom Reference），这四种引用强度依次逐渐减弱。\n\n- 强引用：强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。\n- 软引用：软引用用来描述一些还有用，但并非必需的对象。只有在内存不足时，才会回收该对象。在JDK 1.2之后，提供了SoftReference类来实现软引用。\n- 弱引用：弱引用比软引用更弱一些，只要GC线程扫到它，不管内存是否不足，都会回收它。在JDK 1.2之后，提供了WeakReference类来实现弱引用。\n- 虚引用：虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。\n\n\n##### 4. 回收方法区\n\n很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。\n\n永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。 判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：\n\n- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。\n- 加载该类的ClassLoader已经被回收。\n- 该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class及-XX:+TraceClassLoading、 -XX:+TraceClassUnLoading查看类的加载和卸载信息。\n\n在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。\n\n##### 5.垃圾收集算法\n\n##### 1. 标记-清除算法\n\n最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经基本介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n\n##### 2.复制算法\n\n为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。\n\n现在的商业虚拟机都采用这种收集算法来回收新生代，IBM的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1∶1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。\n\n##### 3.标记-整理算法\n\n复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。\n\n根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，这样就不会造成内存碎片。\n\n##### 4.分代收集算法\n\n当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。因**此现在的垃圾回收器都是同时采用多种算法，以达到更高性能。**\n\n","source":"_posts/Java基础之内存管理.md","raw":"---\ntitle: Java基础之内存管理\ndate: 2017-03-19 22:48:42\ncategories: Java\ntags:\n- Java\n- 内存管理\n- 垃圾回收\n---\n\n### 一 概述\n\n对于从事C和C++程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的皇帝，又是从事最基础工作的劳动人民—既拥有每一个对象的“所有权”，又担负着每一个对象生命开始到终结的维护责任。\n\n对于Java程序员来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，而且不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误将会成为一项异常艰难的工作。\n\nJava的内存管理分为分配和回收两部分。\n\n### 二 内存分配\n\nJava虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（第2版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示：\n\n{% asset_img 运行时数据区域.jpg 运行时数据区域 %}\n\n上图是较细的划分，可以再将它们划分为栈和堆两个部分。\n\n##### 1.栈与堆\n\n栈区：（线程私有）\n\n- 程序计数器：程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。\n\n- 虚拟机栈：java虚拟机运行的java方法(java字节码方法)构成的栈空间，这个空间在运行时存储这些方法的局部变量表、操作栈、动态链接和方法出口。程序员常说的栈其实主要就是指虚拟机栈，Java中的8种基本类型和对象的引用均存放在该区域中。\n\n- 本地方法栈：本地方法在运行时存储数据产生的栈区。本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。\n\n栈区可以自己管理自己，一般不会出现问题；造成内存泄露的主要是堆区。\n\n堆区：（线程共享）\n\n- 堆：这个就是我们重点要关心的区域，主要存放Java中new出来的对象，也是GC主要运行的重点。\n\n- 方法区：堆的一部分（但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来），用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。在有些虚拟机中它也被叫做“永久代”（如HotSpot），很少发生垃圾回收行为，这个区域的回收主要针对常量池的回收和对类型的卸载。\n\n- 运行时常量池：方法区的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。\n\n##### 2.Java中的对象访问是如何进行的\n\n介绍完Java虚拟机的运行时数据区之后，我们就可以来探讨一个问题：在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程\n\n序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码：\n\n```java\nObject obj = new Object();\n```\n\n假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而“new Object()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。\n\n由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。\n\n###### 使用句柄\n\n如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示：\n\n{% asset_img 通过句柄访问对象.jpg 通过句柄访问对象 %}\n\n###### 使用直接指针\n\n如果使用的是直接指针访问方式，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如下图所示：\n\n{% asset_img 通过直接指针访问对象.jpg 通过直接指针访问对象 %}\n\n这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。常见的Sun HotSpot虚拟机就是使用的第二种方式。\n\n### 三 垃圾回收\n\n说起垃圾收集（Garbage Collection，GC），大部分人都把这项技术当做Java语言的伴生产物。事实上，GC的历史远远比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。\n\n堆中几乎存放着Java世界中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。下面将详细介绍Java虚拟机是如何判断一个对象是否存活的。\n\n##### 1.程序计数法\n\n很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。\n\n客观地说，引用计数算法（Reference Counting）的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，也有一些比较著名的应用案例，例如微软的COM（Component Object Model）技术、使用ActionScript 3的FlashPlayer、Python语言以及在游戏脚本领域中被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。**但是，Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题（也就是所谓的隔离岛问题）。**如下面示例：\n\n```java\n public class ReferenceCountingGC {\n     public static void main(String[] args) {\n         testGC();\n     }\n     public Object instance = null;\n     private static final int _1MB=1024*1024;\n     /**\n      * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过 \n      */\n     private byte[] bigSize = new byte[2 * _1MB];\n     public static void testGC(){\n         ReferenceCountingGC objA=new ReferenceCountingGC();\n         ReferenceCountingGC objB=new ReferenceCountingGC();\n         objA.instance=objB;\n         objB.instance=objA;\n         objA=null;\n         objB=null;\n         // 假设在这行发生GC，那么objA和objB是否能被回收？\n         System.gc();\n     }\n }\n```\n\n程序计数法无法回收这一类的对象，但事实上Java可以回收他们，因此Java对象判活使用的不是程序计数法而是根搜索法。\n\n##### 2. 根搜索法\n\n在主流的商用程序语言中（Java和C#，甚至包括前面提到的古老的Lisp），都是使用根搜索算法（GC Roots Tracing）判定对象是否存活的。这个算法的基本思路就是通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。如图3-1所示，对象object 5、object 6、object7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。\n\n在Java语言里，可作为GC Roots的对象包括下面几种：\n\n- 虚拟机栈（栈帧中的本地变量表）中的引用的对象。\n- 方法区中的类静态属性引用的对象。\n- 方法区中的常量引用的对象。\n- 本地方法栈中JNI（即一般说的Native方法）的引用的对象。\n\n\n{% asset_img 根搜索算法判断对象是否可回收.jpg 根搜索算法判断对象是否可回收 %}\n\n在根搜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。\n\n如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己—只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。\n\n另外一个值得注意的地方任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。 需要特别说明的是，上面关于对象死亡时finalize()方法的描述可能带有悲情的艺术色彩，笔者并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用它，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中提到它适合做“关闭外部资源”之类的工作，这完全是对这种方法的用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或其他方式都可以做得更好、更及时，大家完全可以忘掉Java语言中还有这个方法的存在。\n\n##### 3. Java中的引用\n\nJDK1.2开始Java将引用分成了四种：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（WeakReference）、虚引用（Phantom Reference），这四种引用强度依次逐渐减弱。\n\n- 强引用：强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。\n- 软引用：软引用用来描述一些还有用，但并非必需的对象。只有在内存不足时，才会回收该对象。在JDK 1.2之后，提供了SoftReference类来实现软引用。\n- 弱引用：弱引用比软引用更弱一些，只要GC线程扫到它，不管内存是否不足，都会回收它。在JDK 1.2之后，提供了WeakReference类来实现弱引用。\n- 虚引用：虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。\n\n\n##### 4. 回收方法区\n\n很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。\n\n永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。 判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：\n\n- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。\n- 加载该类的ClassLoader已经被回收。\n- 该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class及-XX:+TraceClassLoading、 -XX:+TraceClassUnLoading查看类的加载和卸载信息。\n\n在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。\n\n##### 5.垃圾收集算法\n\n##### 1. 标记-清除算法\n\n最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经基本介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n\n##### 2.复制算法\n\n为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。\n\n现在的商业虚拟机都采用这种收集算法来回收新生代，IBM的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1∶1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。\n\n##### 3.标记-整理算法\n\n复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。\n\n根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，这样就不会造成内存碎片。\n\n##### 4.分代收集算法\n\n当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。因**此现在的垃圾回收器都是同时采用多种算法，以达到更高性能。**\n\n","slug":"Java基础之内存管理","published":1,"updated":"2017-03-21T03:11:52.824Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk0m0002aknzlnrmuxjh","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>对于从事C和C++程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的皇帝，又是从事最基础工作的劳动人民—既拥有每一个对象的“所有权”，又担负着每一个对象生命开始到终结的维护责任。</p>\n<p>对于Java程序员来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，而且不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误将会成为一项异常艰难的工作。</p>\n<p>Java的内存管理分为分配和回收两部分。</p>\n<h3 id=\"二-内存分配\"><a href=\"#二-内存分配\" class=\"headerlink\" title=\"二 内存分配\"></a>二 内存分配</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（第2版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示：</p>\n<img src=\"/2017/03/19/Java基础之内存管理/运行时数据区域.jpg\" alt=\"运行时数据区域\" title=\"运行时数据区域\">\n<p>上图是较细的划分，可以再将它们划分为栈和堆两个部分。</p>\n<h5 id=\"1-栈与堆\"><a href=\"#1-栈与堆\" class=\"headerlink\" title=\"1.栈与堆\"></a>1.栈与堆</h5><p>栈区：（线程私有）</p>\n<ul>\n<li><p>程序计数器：程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>\n</li>\n<li><p>虚拟机栈：java虚拟机运行的java方法(java字节码方法)构成的栈空间，这个空间在运行时存储这些方法的局部变量表、操作栈、动态链接和方法出口。程序员常说的栈其实主要就是指虚拟机栈，Java中的8种基本类型和对象的引用均存放在该区域中。</p>\n</li>\n<li><p>本地方法栈：本地方法在运行时存储数据产生的栈区。本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p>\n</li>\n</ul>\n<p>栈区可以自己管理自己，一般不会出现问题；造成内存泄露的主要是堆区。</p>\n<p>堆区：（线程共享）</p>\n<ul>\n<li><p>堆：这个就是我们重点要关心的区域，主要存放Java中new出来的对象，也是GC主要运行的重点。</p>\n</li>\n<li><p>方法区：堆的一部分（但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来），用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。在有些虚拟机中它也被叫做“永久代”（如HotSpot），很少发生垃圾回收行为，这个区域的回收主要针对常量池的回收和对类型的卸载。</p>\n</li>\n<li><p>运行时常量池：方法区的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p>\n</li>\n</ul>\n<h5 id=\"2-Java中的对象访问是如何进行的\"><a href=\"#2-Java中的对象访问是如何进行的\" class=\"headerlink\" title=\"2.Java中的对象访问是如何进行的\"></a>2.Java中的对象访问是如何进行的</h5><p>介绍完Java虚拟机的运行时数据区之后，我们就可以来探讨一个问题：在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程</p>\n<p>序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object obj = <span class=\"keyword\">new</span> Object();</div></pre></td></tr></table></figure>\n<p>假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而“new Object()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。</p>\n<p>由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。</p>\n<h6 id=\"使用句柄\"><a href=\"#使用句柄\" class=\"headerlink\" title=\"使用句柄\"></a>使用句柄</h6><p>如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示：</p>\n<img src=\"/2017/03/19/Java基础之内存管理/通过句柄访问对象.jpg\" alt=\"通过句柄访问对象\" title=\"通过句柄访问对象\">\n<h6 id=\"使用直接指针\"><a href=\"#使用直接指针\" class=\"headerlink\" title=\"使用直接指针\"></a>使用直接指针</h6><p>如果使用的是直接指针访问方式，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如下图所示：</p>\n<img src=\"/2017/03/19/Java基础之内存管理/通过直接指针访问对象.jpg\" alt=\"通过直接指针访问对象\" title=\"通过直接指针访问对象\">\n<p>这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。常见的Sun HotSpot虚拟机就是使用的第二种方式。</p>\n<h3 id=\"三-垃圾回收\"><a href=\"#三-垃圾回收\" class=\"headerlink\" title=\"三 垃圾回收\"></a>三 垃圾回收</h3><p>说起垃圾收集（Garbage Collection，GC），大部分人都把这项技术当做Java语言的伴生产物。事实上，GC的历史远远比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。</p>\n<p>堆中几乎存放着Java世界中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。下面将详细介绍Java虚拟机是如何判断一个对象是否存活的。</p>\n<h5 id=\"1-程序计数法\"><a href=\"#1-程序计数法\" class=\"headerlink\" title=\"1.程序计数法\"></a>1.程序计数法</h5><p>很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。</p>\n<p>客观地说，引用计数算法（Reference Counting）的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，也有一些比较著名的应用案例，例如微软的COM（Component Object Model）技术、使用ActionScript 3的FlashPlayer、Python语言以及在游戏脚本领域中被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。<strong>但是，Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题（也就是所谓的隔离岛问题）。</strong>如下面示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReferenceCountingGC</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        testGC();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">public</span> Object instance = <span class=\"keyword\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> _1MB=<span class=\"number\">1024</span>*<span class=\"number\">1024</span>;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过 </div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] bigSize = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">2</span> * _1MB];</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testGC</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        ReferenceCountingGC objA=<span class=\"keyword\">new</span> ReferenceCountingGC();</div><div class=\"line\">        ReferenceCountingGC objB=<span class=\"keyword\">new</span> ReferenceCountingGC();</div><div class=\"line\">        objA.instance=objB;</div><div class=\"line\">        objB.instance=objA;</div><div class=\"line\">        objA=<span class=\"keyword\">null</span>;</div><div class=\"line\">        objB=<span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"comment\">// 假设在这行发生GC，那么objA和objB是否能被回收？</span></div><div class=\"line\">        System.gc();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>程序计数法无法回收这一类的对象，但事实上Java可以回收他们，因此Java对象判活使用的不是程序计数法而是根搜索法。</p>\n<h5 id=\"2-根搜索法\"><a href=\"#2-根搜索法\" class=\"headerlink\" title=\"2. 根搜索法\"></a>2. 根搜索法</h5><p>在主流的商用程序语言中（Java和C#，甚至包括前面提到的古老的Lisp），都是使用根搜索算法（GC Roots Tracing）判定对象是否存活的。这个算法的基本思路就是通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。如图3-1所示，对象object 5、object 6、object7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。</p>\n<p>在Java语言里，可作为GC Roots的对象包括下面几种：</p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li>\n<li>方法区中的类静态属性引用的对象。</li>\n<li>方法区中的常量引用的对象。</li>\n<li>本地方法栈中JNI（即一般说的Native方法）的引用的对象。</li>\n</ul>\n<img src=\"/2017/03/19/Java基础之内存管理/根搜索算法判断对象是否可回收.jpg\" alt=\"根搜索算法判断对象是否可回收\" title=\"根搜索算法判断对象是否可回收\">\n<p>在根搜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>\n<p>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己—只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。</p>\n<p>另外一个值得注意的地方任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。 需要特别说明的是，上面关于对象死亡时finalize()方法的描述可能带有悲情的艺术色彩，笔者并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用它，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中提到它适合做“关闭外部资源”之类的工作，这完全是对这种方法的用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或其他方式都可以做得更好、更及时，大家完全可以忘掉Java语言中还有这个方法的存在。</p>\n<h5 id=\"3-Java中的引用\"><a href=\"#3-Java中的引用\" class=\"headerlink\" title=\"3. Java中的引用\"></a>3. Java中的引用</h5><p>JDK1.2开始Java将引用分成了四种：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（WeakReference）、虚引用（Phantom Reference），这四种引用强度依次逐渐减弱。</p>\n<ul>\n<li>强引用：强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>\n<li>软引用：软引用用来描述一些还有用，但并非必需的对象。只有在内存不足时，才会回收该对象。在JDK 1.2之后，提供了SoftReference类来实现软引用。</li>\n<li>弱引用：弱引用比软引用更弱一些，只要GC线程扫到它，不管内存是否不足，都会回收它。在JDK 1.2之后，提供了WeakReference类来实现弱引用。</li>\n<li>虚引用：虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。</li>\n</ul>\n<h5 id=\"4-回收方法区\"><a href=\"#4-回收方法区\" class=\"headerlink\" title=\"4. 回收方法区\"></a>4. 回收方法区</h5><p>很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。</p>\n<p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。 判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li>\n<li>加载该类的ClassLoader已经被回收。</li>\n<li>该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>\n</ul>\n<p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class及-XX:+TraceClassLoading、 -XX:+TraceClassUnLoading查看类的加载和卸载信息。</p>\n<p>在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>\n<h5 id=\"5-垃圾收集算法\"><a href=\"#5-垃圾收集算法\" class=\"headerlink\" title=\"5.垃圾收集算法\"></a>5.垃圾收集算法</h5><h5 id=\"1-标记-清除算法\"><a href=\"#1-标记-清除算法\" class=\"headerlink\" title=\"1. 标记-清除算法\"></a>1. 标记-清除算法</h5><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经基本介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>\n<h5 id=\"2-复制算法\"><a href=\"#2-复制算法\" class=\"headerlink\" title=\"2.复制算法\"></a>2.复制算法</h5><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。</p>\n<p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1∶1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p>\n<h5 id=\"3-标记-整理算法\"><a href=\"#3-标记-整理算法\" class=\"headerlink\" title=\"3.标记-整理算法\"></a>3.标记-整理算法</h5><p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>\n<p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，这样就不会造成内存碎片。</p>\n<h5 id=\"4-分代收集算法\"><a href=\"#4-分代收集算法\" class=\"headerlink\" title=\"4.分代收集算法\"></a>4.分代收集算法</h5><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。因<strong>此现在的垃圾回收器都是同时采用多种算法，以达到更高性能。</strong></p>\n","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>对于从事C和C++程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的皇帝，又是从事最基础工作的劳动人民—既拥有每一个对象的“所有权”，又担负着每一个对象生命开始到终结的维护责任。</p>\n<p>对于Java程序员来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，而且不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误将会成为一项异常艰难的工作。</p>\n<p>Java的内存管理分为分配和回收两部分。</p>\n<h3 id=\"二-内存分配\"><a href=\"#二-内存分配\" class=\"headerlink\" title=\"二 内存分配\"></a>二 内存分配</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（第2版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示：</p>\n<img src=\"/2017/03/19/Java基础之内存管理/运行时数据区域.jpg\" alt=\"运行时数据区域\" title=\"运行时数据区域\">\n<p>上图是较细的划分，可以再将它们划分为栈和堆两个部分。</p>\n<h5 id=\"1-栈与堆\"><a href=\"#1-栈与堆\" class=\"headerlink\" title=\"1.栈与堆\"></a>1.栈与堆</h5><p>栈区：（线程私有）</p>\n<ul>\n<li><p>程序计数器：程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>\n</li>\n<li><p>虚拟机栈：java虚拟机运行的java方法(java字节码方法)构成的栈空间，这个空间在运行时存储这些方法的局部变量表、操作栈、动态链接和方法出口。程序员常说的栈其实主要就是指虚拟机栈，Java中的8种基本类型和对象的引用均存放在该区域中。</p>\n</li>\n<li><p>本地方法栈：本地方法在运行时存储数据产生的栈区。本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p>\n</li>\n</ul>\n<p>栈区可以自己管理自己，一般不会出现问题；造成内存泄露的主要是堆区。</p>\n<p>堆区：（线程共享）</p>\n<ul>\n<li><p>堆：这个就是我们重点要关心的区域，主要存放Java中new出来的对象，也是GC主要运行的重点。</p>\n</li>\n<li><p>方法区：堆的一部分（但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来），用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。在有些虚拟机中它也被叫做“永久代”（如HotSpot），很少发生垃圾回收行为，这个区域的回收主要针对常量池的回收和对类型的卸载。</p>\n</li>\n<li><p>运行时常量池：方法区的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p>\n</li>\n</ul>\n<h5 id=\"2-Java中的对象访问是如何进行的\"><a href=\"#2-Java中的对象访问是如何进行的\" class=\"headerlink\" title=\"2.Java中的对象访问是如何进行的\"></a>2.Java中的对象访问是如何进行的</h5><p>介绍完Java虚拟机的运行时数据区之后，我们就可以来探讨一个问题：在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程</p>\n<p>序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object obj = <span class=\"keyword\">new</span> Object();</div></pre></td></tr></table></figure>\n<p>假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而“new Object()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。</p>\n<p>由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。</p>\n<h6 id=\"使用句柄\"><a href=\"#使用句柄\" class=\"headerlink\" title=\"使用句柄\"></a>使用句柄</h6><p>如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示：</p>\n<img src=\"/2017/03/19/Java基础之内存管理/通过句柄访问对象.jpg\" alt=\"通过句柄访问对象\" title=\"通过句柄访问对象\">\n<h6 id=\"使用直接指针\"><a href=\"#使用直接指针\" class=\"headerlink\" title=\"使用直接指针\"></a>使用直接指针</h6><p>如果使用的是直接指针访问方式，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如下图所示：</p>\n<img src=\"/2017/03/19/Java基础之内存管理/通过直接指针访问对象.jpg\" alt=\"通过直接指针访问对象\" title=\"通过直接指针访问对象\">\n<p>这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。常见的Sun HotSpot虚拟机就是使用的第二种方式。</p>\n<h3 id=\"三-垃圾回收\"><a href=\"#三-垃圾回收\" class=\"headerlink\" title=\"三 垃圾回收\"></a>三 垃圾回收</h3><p>说起垃圾收集（Garbage Collection，GC），大部分人都把这项技术当做Java语言的伴生产物。事实上，GC的历史远远比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。</p>\n<p>堆中几乎存放着Java世界中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。下面将详细介绍Java虚拟机是如何判断一个对象是否存活的。</p>\n<h5 id=\"1-程序计数法\"><a href=\"#1-程序计数法\" class=\"headerlink\" title=\"1.程序计数法\"></a>1.程序计数法</h5><p>很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。</p>\n<p>客观地说，引用计数算法（Reference Counting）的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，也有一些比较著名的应用案例，例如微软的COM（Component Object Model）技术、使用ActionScript 3的FlashPlayer、Python语言以及在游戏脚本领域中被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。<strong>但是，Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题（也就是所谓的隔离岛问题）。</strong>如下面示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReferenceCountingGC</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        testGC();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">public</span> Object instance = <span class=\"keyword\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> _1MB=<span class=\"number\">1024</span>*<span class=\"number\">1024</span>;</div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过 </div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] bigSize = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">2</span> * _1MB];</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testGC</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        ReferenceCountingGC objA=<span class=\"keyword\">new</span> ReferenceCountingGC();</div><div class=\"line\">        ReferenceCountingGC objB=<span class=\"keyword\">new</span> ReferenceCountingGC();</div><div class=\"line\">        objA.instance=objB;</div><div class=\"line\">        objB.instance=objA;</div><div class=\"line\">        objA=<span class=\"keyword\">null</span>;</div><div class=\"line\">        objB=<span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"comment\">// 假设在这行发生GC，那么objA和objB是否能被回收？</span></div><div class=\"line\">        System.gc();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>程序计数法无法回收这一类的对象，但事实上Java可以回收他们，因此Java对象判活使用的不是程序计数法而是根搜索法。</p>\n<h5 id=\"2-根搜索法\"><a href=\"#2-根搜索法\" class=\"headerlink\" title=\"2. 根搜索法\"></a>2. 根搜索法</h5><p>在主流的商用程序语言中（Java和C#，甚至包括前面提到的古老的Lisp），都是使用根搜索算法（GC Roots Tracing）判定对象是否存活的。这个算法的基本思路就是通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。如图3-1所示，对象object 5、object 6、object7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。</p>\n<p>在Java语言里，可作为GC Roots的对象包括下面几种：</p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li>\n<li>方法区中的类静态属性引用的对象。</li>\n<li>方法区中的常量引用的对象。</li>\n<li>本地方法栈中JNI（即一般说的Native方法）的引用的对象。</li>\n</ul>\n<img src=\"/2017/03/19/Java基础之内存管理/根搜索算法判断对象是否可回收.jpg\" alt=\"根搜索算法判断对象是否可回收\" title=\"根搜索算法判断对象是否可回收\">\n<p>在根搜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>\n<p>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己—只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。</p>\n<p>另外一个值得注意的地方任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。 需要特别说明的是，上面关于对象死亡时finalize()方法的描述可能带有悲情的艺术色彩，笔者并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用它，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中提到它适合做“关闭外部资源”之类的工作，这完全是对这种方法的用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或其他方式都可以做得更好、更及时，大家完全可以忘掉Java语言中还有这个方法的存在。</p>\n<h5 id=\"3-Java中的引用\"><a href=\"#3-Java中的引用\" class=\"headerlink\" title=\"3. Java中的引用\"></a>3. Java中的引用</h5><p>JDK1.2开始Java将引用分成了四种：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（WeakReference）、虚引用（Phantom Reference），这四种引用强度依次逐渐减弱。</p>\n<ul>\n<li>强引用：强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>\n<li>软引用：软引用用来描述一些还有用，但并非必需的对象。只有在内存不足时，才会回收该对象。在JDK 1.2之后，提供了SoftReference类来实现软引用。</li>\n<li>弱引用：弱引用比软引用更弱一些，只要GC线程扫到它，不管内存是否不足，都会回收它。在JDK 1.2之后，提供了WeakReference类来实现弱引用。</li>\n<li>虚引用：虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。</li>\n</ul>\n<h5 id=\"4-回收方法区\"><a href=\"#4-回收方法区\" class=\"headerlink\" title=\"4. 回收方法区\"></a>4. 回收方法区</h5><p>很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。</p>\n<p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。 判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li>\n<li>加载该类的ClassLoader已经被回收。</li>\n<li>该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>\n</ul>\n<p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class及-XX:+TraceClassLoading、 -XX:+TraceClassUnLoading查看类的加载和卸载信息。</p>\n<p>在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>\n<h5 id=\"5-垃圾收集算法\"><a href=\"#5-垃圾收集算法\" class=\"headerlink\" title=\"5.垃圾收集算法\"></a>5.垃圾收集算法</h5><h5 id=\"1-标记-清除算法\"><a href=\"#1-标记-清除算法\" class=\"headerlink\" title=\"1. 标记-清除算法\"></a>1. 标记-清除算法</h5><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经基本介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>\n<h5 id=\"2-复制算法\"><a href=\"#2-复制算法\" class=\"headerlink\" title=\"2.复制算法\"></a>2.复制算法</h5><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。</p>\n<p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1∶1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p>\n<h5 id=\"3-标记-整理算法\"><a href=\"#3-标记-整理算法\" class=\"headerlink\" title=\"3.标记-整理算法\"></a>3.标记-整理算法</h5><p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>\n<p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，这样就不会造成内存碎片。</p>\n<h5 id=\"4-分代收集算法\"><a href=\"#4-分代收集算法\" class=\"headerlink\" title=\"4.分代收集算法\"></a>4.分代收集算法</h5><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。因<strong>此现在的垃圾回收器都是同时采用多种算法，以达到更高性能。</strong></p>\n"},{"title":"Java基础之异常","date":"2017-03-17T08:06:28.000Z","_content":"\n### 一 概述\n\n异常处理已经成为衡量一门语言是否成熟的标准之一，目前主流的C++，C#，Ruby，Python等大都提供了异常处理机制。异常处理可以使正常业务代码与异常代码分离开，使程序具有更好的容错性和健壮性。一个好的程序员不只能做好”对“的事情，“错”的事情也要做好。\n\n### 二 Java异常继承体系\n\nJava中的异常皆继承于Exception，Exception与Error共同继承于Throwable。下面是Java的异常继承体系图：\n\n{% asset_img Java异常继承体系图.jpg Java异常继承体系图 %}\n\n### 三 Java中的异常处理\n\nJava中的异常分为Checked（编译时异常）和RuntimeException（运行时异常）两种，同时规定Checked异常必须被处理否则无法通过编译，这虽进一步增强了Java程序的健壮性，但是也使开发者烦不胜烦，是否应该存在该类异常一直是备受争议的问题。\n\nJava定义了5个关键字来处理异常：try，catch，finally，throw，throws。\n\n##### 1.使用try...catch...finally捕获异常\n\nJava提供了try...catch...finally的方式来捕获异常，在try块中处理业务代码，在catch块中捕获异常并处理异常，在finally块中关闭在try中打开的物理资源，如文件，数据库等。如下面代码示例：\n\n```java\n    try{\n       System.out.println(\"try\") ;\n    }catch(ArrayIndexOutOfBoundsException e){\n       System.out.println(\"Exception thrown  :\" + e);\n    }\n    finally{\n       System.out.println(\"The finally statement is executed\");\n    }\n```\n\n如果没有在捕获异常后还需要处理的问题，则可以省略finally块；若有多个异常，可以写多个catch块（但是只能执行一个），在Java7之前一个catch块只能捕获一个异常，同时要注意子异常应该写在父异常前面，否者编译不通过。\n\n**注意finally是无论如何都会执行的模块（除非虚拟机崩了），尽量不要再finally中添加return，它会覆盖try的return。**\n\n##### 2.访问异常信息\n\n前面说到Java中的异常最终皆继承于Throwable，而Throwable有以下几个方法在捕获异常后经常用到：\n\n- getMessage()： 返回该异常的详细描述字符串。\n- printStackTrace()：将该异常的跟踪栈信息打印出来\n- printStackTrace(PrintStream s)：将该异常的跟踪栈信息输出到指定输出流\n- getStackTrace()：返回该异常的跟踪栈信息\n\n##### 3.Java中Checked异常和Runtime异常\n\nJava中增加了一个Checked异常，而其他语言都没有该异常。这些异常必须被显示处理，否则编译不通过。这体现了java\n设计的哲学--没有完善错误处理的代码根本不会被执行。对checked异常的处理有以下两种：\n\n- 使用try...catch捕获异常\n- 使用throws抛出异常\n\n而Runtime异常很灵活，不需要显示声明抛出，当然也可以使用try-catch捕获该异常并处理，而Checked异常就是个老流氓，你要么捕获并处理它，要么抛出它让你的上一层调用者处理它。\n\n##### 4.使用throws声明抛出异常\n\nthrows只能在方法签名后声明抛出异常，可以抛出多个异常类。\n\n使用throws抛出异常的思路是：当前方法不知道如果处理该异常（如果能处理就用try-catch捕获它），将它抛给上层调用者处理，如果上层调用者也无法处理，继续向上抛出，知道main方法，如果main方法也不能处理，抛给JVM虚拟机。JVM对异常的处理方式是：打印异常的跟踪栈信息，并中止程序。\n\n使用throws抛出异常也有限制:子类方法声音抛出的异常应当是父类抛出异常的子类（或者二者想同），子类声明抛出的异常不允许比父类抛出的多。\n\nthrows一般用来抛出Checked异常。\n\n##### 5.使用throw抛出异常\n\n异常这个东西很有哲学性，你可以把它理解为与预想不符的东西，在这个地方它不是异常，而在另一个地方它可能就是异常。所以很多时候，系统是否要抛出异常，可能要根据具体的业务来决定，而这些有具体业务需求而产生的异常，系统无法自动抛出，不需有程序员手动抛出。这时就使用throw。\nthrow抛出的是一个异常实例，可单独成句，自行抛出异常，但每次只能抛出一个异常。示例：\n\n```java\n\tthrow new Exception(\"你要打开的文件已经存在了\");\n```\n\n使用throw抛出的异常，在catch中亦可以捕获到。但throw一般不这样是使用，它一般与throws结合使用。因为有时候底层的异常比较敏感，我们不希望程序的调用者或者使用者看到这些异常，这时候我们就可以在catch中捕获这些敏感异常（一般将其输入到日志中），然后再用throw抛出一个新的异常（一般是对发生的异常的描述）给它的调用者，最后通过throws抛给它的调用者。这样我们就对底层进行了很好的封装。\n\n在Java7之前我们通过throw抛出的是什么异常，那方法签名后的throws也要抛出相应异常。Java7之后，系统可以判断出具体发生的异常。比如，如果发生的是FileOutputException，而捕获并throw的是Exception异常，在Java7之前throws必须抛出Exception异常，而Java7之后throws FileOutputException即可。\n\n### 四 Java7增强的异常\n\n##### 1.Java7增强功能点一\n\n在Java7之前一个catch只能捕获一个异常，但Java7新增了一个功能是的一个catch可以捕获多个异常。使用一个catch捕获多个异常应该注意一下两个方面：\n\n- 在捕获多异常时多个异常之间用“|”分隔\n- 捕获多异常时，异常对象有隐式的final属性，无法对它重新赋值（单异常时可以）\n\n##### 2.Java7增强功能点二\n\n在Java7之前如果在try中打开了物理资源，就必须在finally中关闭，Java7新增了一个功能，可以使try中打开的资源自动关闭。如：\n\n```java\n\ttry(\n\t\tBufferedReader br = new BufferedReader(\n\t\t\tnew FileReader(\"test.java\"));\n\t\tPrintStream ps = new PrintStream(\n\t\t\tnew FileOutputStream(\"a.txt\"))\n\t){\n\t\tSystem.out.println(br.readLine());\n\t\tps.println(\"我若成佛，天下无魔；我若成魔，佛奈我何\");\t\n\t}\n```\n\n需要指出的是要想自动关闭资源，这些资源实现类必须实现AutoCloseable或Closeable接口，实现它们的close方法。放心这些工作不需要你来做，Java7基本把所有的资源类进行了改写，使它们实现了AutoCloseable或Closeable接口。\n\n### 五 自定义异常\n\n有时候为了抛出明确的异常，我们需要自定义异常类。\n\n自定义异常类继承于Exception类，如果希望自定义Runtime异常，就继承于RuntimeException类。定义自定义异常类需要提供了两个构造器：\n\n- 一个是无参构造器\n- 一个是带一个字符串参数的构造器，该字符串传入该异常对象的描述信息\n\n下面是代码示例：\n\n```java\n\tpublic class CustomException extends Exception{\n\t\t\n\t\tpublic CustomException(){}\n\t\tpuvlic CustomException(String msg){\n\t\t\tsuper(msg);\n\t\t}\n\t}\n```\n\n自定义异常类应该取一个足以描述异常的类名。\n\n### 六 异常处理规则\n\n在Java中使用异常应该遵守一定的规则：\n\n- 不要过度使用异常，只对可能发生异常的语句捕获异常\n- 不要使用过大的try块，不要将可能发生异常的代码与正常代码都放在一个try块中\n- 捕获的异常尽量具体，不要捕获的均是Exception\n- 不要忽略捕获的异常","source":"_posts/Java基础之异常.md","raw":"---\ntitle: Java基础之异常\ndate: 2017-03-17 16:06:28\ncategories: Java\ntags:\n- Java\n- 异常\n---\n\n### 一 概述\n\n异常处理已经成为衡量一门语言是否成熟的标准之一，目前主流的C++，C#，Ruby，Python等大都提供了异常处理机制。异常处理可以使正常业务代码与异常代码分离开，使程序具有更好的容错性和健壮性。一个好的程序员不只能做好”对“的事情，“错”的事情也要做好。\n\n### 二 Java异常继承体系\n\nJava中的异常皆继承于Exception，Exception与Error共同继承于Throwable。下面是Java的异常继承体系图：\n\n{% asset_img Java异常继承体系图.jpg Java异常继承体系图 %}\n\n### 三 Java中的异常处理\n\nJava中的异常分为Checked（编译时异常）和RuntimeException（运行时异常）两种，同时规定Checked异常必须被处理否则无法通过编译，这虽进一步增强了Java程序的健壮性，但是也使开发者烦不胜烦，是否应该存在该类异常一直是备受争议的问题。\n\nJava定义了5个关键字来处理异常：try，catch，finally，throw，throws。\n\n##### 1.使用try...catch...finally捕获异常\n\nJava提供了try...catch...finally的方式来捕获异常，在try块中处理业务代码，在catch块中捕获异常并处理异常，在finally块中关闭在try中打开的物理资源，如文件，数据库等。如下面代码示例：\n\n```java\n    try{\n       System.out.println(\"try\") ;\n    }catch(ArrayIndexOutOfBoundsException e){\n       System.out.println(\"Exception thrown  :\" + e);\n    }\n    finally{\n       System.out.println(\"The finally statement is executed\");\n    }\n```\n\n如果没有在捕获异常后还需要处理的问题，则可以省略finally块；若有多个异常，可以写多个catch块（但是只能执行一个），在Java7之前一个catch块只能捕获一个异常，同时要注意子异常应该写在父异常前面，否者编译不通过。\n\n**注意finally是无论如何都会执行的模块（除非虚拟机崩了），尽量不要再finally中添加return，它会覆盖try的return。**\n\n##### 2.访问异常信息\n\n前面说到Java中的异常最终皆继承于Throwable，而Throwable有以下几个方法在捕获异常后经常用到：\n\n- getMessage()： 返回该异常的详细描述字符串。\n- printStackTrace()：将该异常的跟踪栈信息打印出来\n- printStackTrace(PrintStream s)：将该异常的跟踪栈信息输出到指定输出流\n- getStackTrace()：返回该异常的跟踪栈信息\n\n##### 3.Java中Checked异常和Runtime异常\n\nJava中增加了一个Checked异常，而其他语言都没有该异常。这些异常必须被显示处理，否则编译不通过。这体现了java\n设计的哲学--没有完善错误处理的代码根本不会被执行。对checked异常的处理有以下两种：\n\n- 使用try...catch捕获异常\n- 使用throws抛出异常\n\n而Runtime异常很灵活，不需要显示声明抛出，当然也可以使用try-catch捕获该异常并处理，而Checked异常就是个老流氓，你要么捕获并处理它，要么抛出它让你的上一层调用者处理它。\n\n##### 4.使用throws声明抛出异常\n\nthrows只能在方法签名后声明抛出异常，可以抛出多个异常类。\n\n使用throws抛出异常的思路是：当前方法不知道如果处理该异常（如果能处理就用try-catch捕获它），将它抛给上层调用者处理，如果上层调用者也无法处理，继续向上抛出，知道main方法，如果main方法也不能处理，抛给JVM虚拟机。JVM对异常的处理方式是：打印异常的跟踪栈信息，并中止程序。\n\n使用throws抛出异常也有限制:子类方法声音抛出的异常应当是父类抛出异常的子类（或者二者想同），子类声明抛出的异常不允许比父类抛出的多。\n\nthrows一般用来抛出Checked异常。\n\n##### 5.使用throw抛出异常\n\n异常这个东西很有哲学性，你可以把它理解为与预想不符的东西，在这个地方它不是异常，而在另一个地方它可能就是异常。所以很多时候，系统是否要抛出异常，可能要根据具体的业务来决定，而这些有具体业务需求而产生的异常，系统无法自动抛出，不需有程序员手动抛出。这时就使用throw。\nthrow抛出的是一个异常实例，可单独成句，自行抛出异常，但每次只能抛出一个异常。示例：\n\n```java\n\tthrow new Exception(\"你要打开的文件已经存在了\");\n```\n\n使用throw抛出的异常，在catch中亦可以捕获到。但throw一般不这样是使用，它一般与throws结合使用。因为有时候底层的异常比较敏感，我们不希望程序的调用者或者使用者看到这些异常，这时候我们就可以在catch中捕获这些敏感异常（一般将其输入到日志中），然后再用throw抛出一个新的异常（一般是对发生的异常的描述）给它的调用者，最后通过throws抛给它的调用者。这样我们就对底层进行了很好的封装。\n\n在Java7之前我们通过throw抛出的是什么异常，那方法签名后的throws也要抛出相应异常。Java7之后，系统可以判断出具体发生的异常。比如，如果发生的是FileOutputException，而捕获并throw的是Exception异常，在Java7之前throws必须抛出Exception异常，而Java7之后throws FileOutputException即可。\n\n### 四 Java7增强的异常\n\n##### 1.Java7增强功能点一\n\n在Java7之前一个catch只能捕获一个异常，但Java7新增了一个功能是的一个catch可以捕获多个异常。使用一个catch捕获多个异常应该注意一下两个方面：\n\n- 在捕获多异常时多个异常之间用“|”分隔\n- 捕获多异常时，异常对象有隐式的final属性，无法对它重新赋值（单异常时可以）\n\n##### 2.Java7增强功能点二\n\n在Java7之前如果在try中打开了物理资源，就必须在finally中关闭，Java7新增了一个功能，可以使try中打开的资源自动关闭。如：\n\n```java\n\ttry(\n\t\tBufferedReader br = new BufferedReader(\n\t\t\tnew FileReader(\"test.java\"));\n\t\tPrintStream ps = new PrintStream(\n\t\t\tnew FileOutputStream(\"a.txt\"))\n\t){\n\t\tSystem.out.println(br.readLine());\n\t\tps.println(\"我若成佛，天下无魔；我若成魔，佛奈我何\");\t\n\t}\n```\n\n需要指出的是要想自动关闭资源，这些资源实现类必须实现AutoCloseable或Closeable接口，实现它们的close方法。放心这些工作不需要你来做，Java7基本把所有的资源类进行了改写，使它们实现了AutoCloseable或Closeable接口。\n\n### 五 自定义异常\n\n有时候为了抛出明确的异常，我们需要自定义异常类。\n\n自定义异常类继承于Exception类，如果希望自定义Runtime异常，就继承于RuntimeException类。定义自定义异常类需要提供了两个构造器：\n\n- 一个是无参构造器\n- 一个是带一个字符串参数的构造器，该字符串传入该异常对象的描述信息\n\n下面是代码示例：\n\n```java\n\tpublic class CustomException extends Exception{\n\t\t\n\t\tpublic CustomException(){}\n\t\tpuvlic CustomException(String msg){\n\t\t\tsuper(msg);\n\t\t}\n\t}\n```\n\n自定义异常类应该取一个足以描述异常的类名。\n\n### 六 异常处理规则\n\n在Java中使用异常应该遵守一定的规则：\n\n- 不要过度使用异常，只对可能发生异常的语句捕获异常\n- 不要使用过大的try块，不要将可能发生异常的代码与正常代码都放在一个try块中\n- 捕获的异常尽量具体，不要捕获的均是Exception\n- 不要忽略捕获的异常","slug":"Java基础之异常","published":1,"updated":"2017-03-23T03:41:37.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk0r0005aknzmiu523y3","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>异常处理已经成为衡量一门语言是否成熟的标准之一，目前主流的C++，C#，Ruby，Python等大都提供了异常处理机制。异常处理可以使正常业务代码与异常代码分离开，使程序具有更好的容错性和健壮性。一个好的程序员不只能做好”对“的事情，“错”的事情也要做好。</p>\n<h3 id=\"二-Java异常继承体系\"><a href=\"#二-Java异常继承体系\" class=\"headerlink\" title=\"二 Java异常继承体系\"></a>二 Java异常继承体系</h3><p>Java中的异常皆继承于Exception，Exception与Error共同继承于Throwable。下面是Java的异常继承体系图：</p>\n<img src=\"/2017/03/17/Java基础之异常/Java异常继承体系图.jpg\" alt=\"Java异常继承体系图\" title=\"Java异常继承体系图\">\n<h3 id=\"三-Java中的异常处理\"><a href=\"#三-Java中的异常处理\" class=\"headerlink\" title=\"三 Java中的异常处理\"></a>三 Java中的异常处理</h3><p>Java中的异常分为Checked（编译时异常）和RuntimeException（运行时异常）两种，同时规定Checked异常必须被处理否则无法通过编译，这虽进一步增强了Java程序的健壮性，但是也使开发者烦不胜烦，是否应该存在该类异常一直是备受争议的问题。</p>\n<p>Java定义了5个关键字来处理异常：try，catch，finally，throw，throws。</p>\n<h5 id=\"1-使用try…catch…finally捕获异常\"><a href=\"#1-使用try…catch…finally捕获异常\" class=\"headerlink\" title=\"1.使用try…catch…finally捕获异常\"></a>1.使用try…catch…finally捕获异常</h5><p>Java提供了try…catch…finally的方式来捕获异常，在try块中处理业务代码，在catch块中捕获异常并处理异常，在finally块中关闭在try中打开的物理资源，如文件，数据库等。如下面代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>&#123;</div><div class=\"line\">   System.out.println(<span class=\"string\">\"try\"</span>) ;</div><div class=\"line\">&#125;<span class=\"keyword\">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</div><div class=\"line\">   System.out.println(<span class=\"string\">\"Exception thrown  :\"</span> + e);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">finally</span>&#123;</div><div class=\"line\">   System.out.println(<span class=\"string\">\"The finally statement is executed\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果没有在捕获异常后还需要处理的问题，则可以省略finally块；若有多个异常，可以写多个catch块（但是只能执行一个），在Java7之前一个catch块只能捕获一个异常，同时要注意子异常应该写在父异常前面，否者编译不通过。</p>\n<p><strong>注意finally是无论如何都会执行的模块（除非虚拟机崩了），尽量不要再finally中添加return，它会覆盖try的return。</strong></p>\n<h5 id=\"2-访问异常信息\"><a href=\"#2-访问异常信息\" class=\"headerlink\" title=\"2.访问异常信息\"></a>2.访问异常信息</h5><p>前面说到Java中的异常最终皆继承于Throwable，而Throwable有以下几个方法在捕获异常后经常用到：</p>\n<ul>\n<li>getMessage()： 返回该异常的详细描述字符串。</li>\n<li>printStackTrace()：将该异常的跟踪栈信息打印出来</li>\n<li>printStackTrace(PrintStream s)：将该异常的跟踪栈信息输出到指定输出流</li>\n<li>getStackTrace()：返回该异常的跟踪栈信息</li>\n</ul>\n<h5 id=\"3-Java中Checked异常和Runtime异常\"><a href=\"#3-Java中Checked异常和Runtime异常\" class=\"headerlink\" title=\"3.Java中Checked异常和Runtime异常\"></a>3.Java中Checked异常和Runtime异常</h5><p>Java中增加了一个Checked异常，而其他语言都没有该异常。这些异常必须被显示处理，否则编译不通过。这体现了java<br>设计的哲学–没有完善错误处理的代码根本不会被执行。对checked异常的处理有以下两种：</p>\n<ul>\n<li>使用try…catch捕获异常</li>\n<li>使用throws抛出异常</li>\n</ul>\n<p>而Runtime异常很灵活，不需要显示声明抛出，当然也可以使用try-catch捕获该异常并处理，而Checked异常就是个老流氓，你要么捕获并处理它，要么抛出它让你的上一层调用者处理它。</p>\n<h5 id=\"4-使用throws声明抛出异常\"><a href=\"#4-使用throws声明抛出异常\" class=\"headerlink\" title=\"4.使用throws声明抛出异常\"></a>4.使用throws声明抛出异常</h5><p>throws只能在方法签名后声明抛出异常，可以抛出多个异常类。</p>\n<p>使用throws抛出异常的思路是：当前方法不知道如果处理该异常（如果能处理就用try-catch捕获它），将它抛给上层调用者处理，如果上层调用者也无法处理，继续向上抛出，知道main方法，如果main方法也不能处理，抛给JVM虚拟机。JVM对异常的处理方式是：打印异常的跟踪栈信息，并中止程序。</p>\n<p>使用throws抛出异常也有限制:子类方法声音抛出的异常应当是父类抛出异常的子类（或者二者想同），子类声明抛出的异常不允许比父类抛出的多。</p>\n<p>throws一般用来抛出Checked异常。</p>\n<h5 id=\"5-使用throw抛出异常\"><a href=\"#5-使用throw抛出异常\" class=\"headerlink\" title=\"5.使用throw抛出异常\"></a>5.使用throw抛出异常</h5><p>异常这个东西很有哲学性，你可以把它理解为与预想不符的东西，在这个地方它不是异常，而在另一个地方它可能就是异常。所以很多时候，系统是否要抛出异常，可能要根据具体的业务来决定，而这些有具体业务需求而产生的异常，系统无法自动抛出，不需有程序员手动抛出。这时就使用throw。<br>throw抛出的是一个异常实例，可单独成句，自行抛出异常，但每次只能抛出一个异常。示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"你要打开的文件已经存在了\"</span>);</div></pre></td></tr></table></figure>\n<p>使用throw抛出的异常，在catch中亦可以捕获到。但throw一般不这样是使用，它一般与throws结合使用。因为有时候底层的异常比较敏感，我们不希望程序的调用者或者使用者看到这些异常，这时候我们就可以在catch中捕获这些敏感异常（一般将其输入到日志中），然后再用throw抛出一个新的异常（一般是对发生的异常的描述）给它的调用者，最后通过throws抛给它的调用者。这样我们就对底层进行了很好的封装。</p>\n<p>在Java7之前我们通过throw抛出的是什么异常，那方法签名后的throws也要抛出相应异常。Java7之后，系统可以判断出具体发生的异常。比如，如果发生的是FileOutputException，而捕获并throw的是Exception异常，在Java7之前throws必须抛出Exception异常，而Java7之后throws FileOutputException即可。</p>\n<h3 id=\"四-Java7增强的异常\"><a href=\"#四-Java7增强的异常\" class=\"headerlink\" title=\"四 Java7增强的异常\"></a>四 Java7增强的异常</h3><h5 id=\"1-Java7增强功能点一\"><a href=\"#1-Java7增强功能点一\" class=\"headerlink\" title=\"1.Java7增强功能点一\"></a>1.Java7增强功能点一</h5><p>在Java7之前一个catch只能捕获一个异常，但Java7新增了一个功能是的一个catch可以捕获多个异常。使用一个catch捕获多个异常应该注意一下两个方面：</p>\n<ul>\n<li>在捕获多异常时多个异常之间用“|”分隔</li>\n<li>捕获多异常时，异常对象有隐式的final属性，无法对它重新赋值（单异常时可以）</li>\n</ul>\n<h5 id=\"2-Java7增强功能点二\"><a href=\"#2-Java7增强功能点二\" class=\"headerlink\" title=\"2.Java7增强功能点二\"></a>2.Java7增强功能点二</h5><p>在Java7之前如果在try中打开了物理资源，就必须在finally中关闭，Java7新增了一个功能，可以使try中打开的资源自动关闭。如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>(</div><div class=\"line\">\tBufferedReader br = <span class=\"keyword\">new</span> BufferedReader(</div><div class=\"line\">\t\t<span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"test.java\"</span>));</div><div class=\"line\">\tPrintStream ps = <span class=\"keyword\">new</span> PrintStream(</div><div class=\"line\">\t\t<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"a.txt\"</span>))</div><div class=\"line\">)&#123;</div><div class=\"line\">\tSystem.out.println(br.readLine());</div><div class=\"line\">\tps.println(<span class=\"string\">\"我若成佛，天下无魔；我若成魔，佛奈我何\"</span>);\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要指出的是要想自动关闭资源，这些资源实现类必须实现AutoCloseable或Closeable接口，实现它们的close方法。放心这些工作不需要你来做，Java7基本把所有的资源类进行了改写，使它们实现了AutoCloseable或Closeable接口。</p>\n<h3 id=\"五-自定义异常\"><a href=\"#五-自定义异常\" class=\"headerlink\" title=\"五 自定义异常\"></a>五 自定义异常</h3><p>有时候为了抛出明确的异常，我们需要自定义异常类。</p>\n<p>自定义异常类继承于Exception类，如果希望自定义Runtime异常，就继承于RuntimeException类。定义自定义异常类需要提供了两个构造器：</p>\n<ul>\n<li>一个是无参构造器</li>\n<li>一个是带一个字符串参数的构造器，该字符串传入该异常对象的描述信息</li>\n</ul>\n<p>下面是代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomException</span> <span class=\"keyword\">extends</span> <span class=\"title\">Exception</span></span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CustomException</span><span class=\"params\">()</span></span>&#123;&#125;</div><div class=\"line\">\t<span class=\"function\">puvlic <span class=\"title\">CustomException</span><span class=\"params\">(String msg)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">super</span>(msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>自定义异常类应该取一个足以描述异常的类名。</p>\n<h3 id=\"六-异常处理规则\"><a href=\"#六-异常处理规则\" class=\"headerlink\" title=\"六 异常处理规则\"></a>六 异常处理规则</h3><p>在Java中使用异常应该遵守一定的规则：</p>\n<ul>\n<li>不要过度使用异常，只对可能发生异常的语句捕获异常</li>\n<li>不要使用过大的try块，不要将可能发生异常的代码与正常代码都放在一个try块中</li>\n<li>捕获的异常尽量具体，不要捕获的均是Exception</li>\n<li>不要忽略捕获的异常</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>异常处理已经成为衡量一门语言是否成熟的标准之一，目前主流的C++，C#，Ruby，Python等大都提供了异常处理机制。异常处理可以使正常业务代码与异常代码分离开，使程序具有更好的容错性和健壮性。一个好的程序员不只能做好”对“的事情，“错”的事情也要做好。</p>\n<h3 id=\"二-Java异常继承体系\"><a href=\"#二-Java异常继承体系\" class=\"headerlink\" title=\"二 Java异常继承体系\"></a>二 Java异常继承体系</h3><p>Java中的异常皆继承于Exception，Exception与Error共同继承于Throwable。下面是Java的异常继承体系图：</p>\n<img src=\"/2017/03/17/Java基础之异常/Java异常继承体系图.jpg\" alt=\"Java异常继承体系图\" title=\"Java异常继承体系图\">\n<h3 id=\"三-Java中的异常处理\"><a href=\"#三-Java中的异常处理\" class=\"headerlink\" title=\"三 Java中的异常处理\"></a>三 Java中的异常处理</h3><p>Java中的异常分为Checked（编译时异常）和RuntimeException（运行时异常）两种，同时规定Checked异常必须被处理否则无法通过编译，这虽进一步增强了Java程序的健壮性，但是也使开发者烦不胜烦，是否应该存在该类异常一直是备受争议的问题。</p>\n<p>Java定义了5个关键字来处理异常：try，catch，finally，throw，throws。</p>\n<h5 id=\"1-使用try…catch…finally捕获异常\"><a href=\"#1-使用try…catch…finally捕获异常\" class=\"headerlink\" title=\"1.使用try…catch…finally捕获异常\"></a>1.使用try…catch…finally捕获异常</h5><p>Java提供了try…catch…finally的方式来捕获异常，在try块中处理业务代码，在catch块中捕获异常并处理异常，在finally块中关闭在try中打开的物理资源，如文件，数据库等。如下面代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>&#123;</div><div class=\"line\">   System.out.println(<span class=\"string\">\"try\"</span>) ;</div><div class=\"line\">&#125;<span class=\"keyword\">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</div><div class=\"line\">   System.out.println(<span class=\"string\">\"Exception thrown  :\"</span> + e);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">finally</span>&#123;</div><div class=\"line\">   System.out.println(<span class=\"string\">\"The finally statement is executed\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果没有在捕获异常后还需要处理的问题，则可以省略finally块；若有多个异常，可以写多个catch块（但是只能执行一个），在Java7之前一个catch块只能捕获一个异常，同时要注意子异常应该写在父异常前面，否者编译不通过。</p>\n<p><strong>注意finally是无论如何都会执行的模块（除非虚拟机崩了），尽量不要再finally中添加return，它会覆盖try的return。</strong></p>\n<h5 id=\"2-访问异常信息\"><a href=\"#2-访问异常信息\" class=\"headerlink\" title=\"2.访问异常信息\"></a>2.访问异常信息</h5><p>前面说到Java中的异常最终皆继承于Throwable，而Throwable有以下几个方法在捕获异常后经常用到：</p>\n<ul>\n<li>getMessage()： 返回该异常的详细描述字符串。</li>\n<li>printStackTrace()：将该异常的跟踪栈信息打印出来</li>\n<li>printStackTrace(PrintStream s)：将该异常的跟踪栈信息输出到指定输出流</li>\n<li>getStackTrace()：返回该异常的跟踪栈信息</li>\n</ul>\n<h5 id=\"3-Java中Checked异常和Runtime异常\"><a href=\"#3-Java中Checked异常和Runtime异常\" class=\"headerlink\" title=\"3.Java中Checked异常和Runtime异常\"></a>3.Java中Checked异常和Runtime异常</h5><p>Java中增加了一个Checked异常，而其他语言都没有该异常。这些异常必须被显示处理，否则编译不通过。这体现了java<br>设计的哲学–没有完善错误处理的代码根本不会被执行。对checked异常的处理有以下两种：</p>\n<ul>\n<li>使用try…catch捕获异常</li>\n<li>使用throws抛出异常</li>\n</ul>\n<p>而Runtime异常很灵活，不需要显示声明抛出，当然也可以使用try-catch捕获该异常并处理，而Checked异常就是个老流氓，你要么捕获并处理它，要么抛出它让你的上一层调用者处理它。</p>\n<h5 id=\"4-使用throws声明抛出异常\"><a href=\"#4-使用throws声明抛出异常\" class=\"headerlink\" title=\"4.使用throws声明抛出异常\"></a>4.使用throws声明抛出异常</h5><p>throws只能在方法签名后声明抛出异常，可以抛出多个异常类。</p>\n<p>使用throws抛出异常的思路是：当前方法不知道如果处理该异常（如果能处理就用try-catch捕获它），将它抛给上层调用者处理，如果上层调用者也无法处理，继续向上抛出，知道main方法，如果main方法也不能处理，抛给JVM虚拟机。JVM对异常的处理方式是：打印异常的跟踪栈信息，并中止程序。</p>\n<p>使用throws抛出异常也有限制:子类方法声音抛出的异常应当是父类抛出异常的子类（或者二者想同），子类声明抛出的异常不允许比父类抛出的多。</p>\n<p>throws一般用来抛出Checked异常。</p>\n<h5 id=\"5-使用throw抛出异常\"><a href=\"#5-使用throw抛出异常\" class=\"headerlink\" title=\"5.使用throw抛出异常\"></a>5.使用throw抛出异常</h5><p>异常这个东西很有哲学性，你可以把它理解为与预想不符的东西，在这个地方它不是异常，而在另一个地方它可能就是异常。所以很多时候，系统是否要抛出异常，可能要根据具体的业务来决定，而这些有具体业务需求而产生的异常，系统无法自动抛出，不需有程序员手动抛出。这时就使用throw。<br>throw抛出的是一个异常实例，可单独成句，自行抛出异常，但每次只能抛出一个异常。示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"你要打开的文件已经存在了\"</span>);</div></pre></td></tr></table></figure>\n<p>使用throw抛出的异常，在catch中亦可以捕获到。但throw一般不这样是使用，它一般与throws结合使用。因为有时候底层的异常比较敏感，我们不希望程序的调用者或者使用者看到这些异常，这时候我们就可以在catch中捕获这些敏感异常（一般将其输入到日志中），然后再用throw抛出一个新的异常（一般是对发生的异常的描述）给它的调用者，最后通过throws抛给它的调用者。这样我们就对底层进行了很好的封装。</p>\n<p>在Java7之前我们通过throw抛出的是什么异常，那方法签名后的throws也要抛出相应异常。Java7之后，系统可以判断出具体发生的异常。比如，如果发生的是FileOutputException，而捕获并throw的是Exception异常，在Java7之前throws必须抛出Exception异常，而Java7之后throws FileOutputException即可。</p>\n<h3 id=\"四-Java7增强的异常\"><a href=\"#四-Java7增强的异常\" class=\"headerlink\" title=\"四 Java7增强的异常\"></a>四 Java7增强的异常</h3><h5 id=\"1-Java7增强功能点一\"><a href=\"#1-Java7增强功能点一\" class=\"headerlink\" title=\"1.Java7增强功能点一\"></a>1.Java7增强功能点一</h5><p>在Java7之前一个catch只能捕获一个异常，但Java7新增了一个功能是的一个catch可以捕获多个异常。使用一个catch捕获多个异常应该注意一下两个方面：</p>\n<ul>\n<li>在捕获多异常时多个异常之间用“|”分隔</li>\n<li>捕获多异常时，异常对象有隐式的final属性，无法对它重新赋值（单异常时可以）</li>\n</ul>\n<h5 id=\"2-Java7增强功能点二\"><a href=\"#2-Java7增强功能点二\" class=\"headerlink\" title=\"2.Java7增强功能点二\"></a>2.Java7增强功能点二</h5><p>在Java7之前如果在try中打开了物理资源，就必须在finally中关闭，Java7新增了一个功能，可以使try中打开的资源自动关闭。如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>(</div><div class=\"line\">\tBufferedReader br = <span class=\"keyword\">new</span> BufferedReader(</div><div class=\"line\">\t\t<span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"test.java\"</span>));</div><div class=\"line\">\tPrintStream ps = <span class=\"keyword\">new</span> PrintStream(</div><div class=\"line\">\t\t<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"a.txt\"</span>))</div><div class=\"line\">)&#123;</div><div class=\"line\">\tSystem.out.println(br.readLine());</div><div class=\"line\">\tps.println(<span class=\"string\">\"我若成佛，天下无魔；我若成魔，佛奈我何\"</span>);\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要指出的是要想自动关闭资源，这些资源实现类必须实现AutoCloseable或Closeable接口，实现它们的close方法。放心这些工作不需要你来做，Java7基本把所有的资源类进行了改写，使它们实现了AutoCloseable或Closeable接口。</p>\n<h3 id=\"五-自定义异常\"><a href=\"#五-自定义异常\" class=\"headerlink\" title=\"五 自定义异常\"></a>五 自定义异常</h3><p>有时候为了抛出明确的异常，我们需要自定义异常类。</p>\n<p>自定义异常类继承于Exception类，如果希望自定义Runtime异常，就继承于RuntimeException类。定义自定义异常类需要提供了两个构造器：</p>\n<ul>\n<li>一个是无参构造器</li>\n<li>一个是带一个字符串参数的构造器，该字符串传入该异常对象的描述信息</li>\n</ul>\n<p>下面是代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomException</span> <span class=\"keyword\">extends</span> <span class=\"title\">Exception</span></span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CustomException</span><span class=\"params\">()</span></span>&#123;&#125;</div><div class=\"line\">\t<span class=\"function\">puvlic <span class=\"title\">CustomException</span><span class=\"params\">(String msg)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">super</span>(msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>自定义异常类应该取一个足以描述异常的类名。</p>\n<h3 id=\"六-异常处理规则\"><a href=\"#六-异常处理规则\" class=\"headerlink\" title=\"六 异常处理规则\"></a>六 异常处理规则</h3><p>在Java中使用异常应该遵守一定的规则：</p>\n<ul>\n<li>不要过度使用异常，只对可能发生异常的语句捕获异常</li>\n<li>不要使用过大的try块，不要将可能发生异常的代码与正常代码都放在一个try块中</li>\n<li>捕获的异常尽量具体，不要捕获的均是Exception</li>\n<li>不要忽略捕获的异常</li>\n</ul>\n"},{"title":"Java基础之泛型","date":"2017-03-17T02:26:13.000Z","_content":"\n### 一 概述\n\nJava泛型（generics）是JDK 5中引入的一个新特性，允许在定义类和接口的时候使用类型参数（type parameter）。声明的类型参数在使用时用具体的类型来替换。泛型最主要的应用是在JDK 5中的新集合类框架中。对于泛型概念的引入，开发社区的观点是褒贬不一。从好的方面来说，泛型的引入可以解决之前的集合类框架在使用过程中通常会出现的运行时刻类型错误，因为编译器可以在编译时刻就发现很多明显的错误。而从不好的地方来说，为了保证与旧有版本的兼容性，Java泛型的实现上存在着一些不够优雅的地方。当然这也是任何有历史的编程语言所需要承担的历史包袱。后续的版本更新会为早期的设计缺陷所累。\n\n引入泛型要分清两种继承结构：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于 List<String>和List<Object>这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。\n\n开发人员在使用泛型的时候，很容易根据自己的直觉而犯一些错误。比如一个方法如果接收List<Object>作为形式参数，那么如果尝试将一个List<String>的对象作为实际参数传进去，却发现无法通过编译。虽然从直觉上来说，Object是String的父类，这种类型转换应该是合理的。但是实际上这会产生隐含的类型转换问题，因此编译器直接就禁止这样的行为。\n\n### 二 类型擦除\n\n正确理解泛型概念的首要前提是理解类型擦除（type erasure）。 Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的List<Object>和List<String>等类型，在编译之后都会变成List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。类型擦除也是Java的泛型实现方式与C++模板机制实现方式之间的重要区别。\n\n很多泛型的奇怪特性都与这个类型擦除的存在有关，包括：\n\n- 泛型类并没有自己独有的Class类对象。比如并不存在List<String>.class或是List<Integer>.class，而只有List.class。\n    \n- 静态变量是被泛型类的所有实例所共享的。对于声明为MyClass<T>的类，访问其中的静态变量的方法仍然是 MyClass.myStaticVar。不管是通过new MyClass<String>还是new MyClass<Integer>创建的对象，都是共享一个静态变量。\n    \n- 泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型MyException<String>和MyException<Integer>的。对于JVM来说，它们都是 MyException类型的。也就无法执行与异常对应的catch语句。\n\n类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。同时去掉出现的类型声明，即去掉<>的内容。比如T get()方法声明就变成了Object get()；List<String>就变成了List。接下来就可能需要生成一些桥接方法（bridge method）。这是由于擦除了类型之后的类可能缺少某些必须的方法。比如考虑下面的代码：\n\n```java\nclass MyString implements Comparable<String> {\n    public int compareTo(String str) {        \n        return 0;    \n    }\n} \n```\n\n当类型信息被擦除之后，上述类的声明变成了class MyString implements Comparable。但是这样的话，类MyString就会有编译错误，因为没有实现接口Comparable声明的int compareTo(Object)方法。这个时候就由编译器来动态生成这个方法。\n\n### 三 泛型接口，泛型类与泛型方法\n\n##### 1. 泛型接口\n\n示例：\n\n```java\npublic interface Generator<T> {\n    public T next();\n}\n```\n\n然后定义一个生成器类来实现这个接口：\n\n```java\npublic class FruitGenerator implements Generator<String> {\n\n    private String[] fruits = new String[]{\"Apple\", \"Banana\", \"Pear\"};\n\n    @Override\n    public String next() {\n        Random rand = new Random();\n        return fruits[rand.nextInt(3)];\n    }\n}\n```\n\n##### 2. 泛型类\n\n示例：\n\n```java\npublic class Container<K, V> {\n    private K key;\n    private V value;\n\n    public Container(K k, V v) {\n        key = k;\n        value = v;\n    }\n\n    public K getKey() {\n        return key;\n    }\n\n    public void setKey(K key) {\n        this.key = key;\n    }\n\n    public V getValue() {\n        return value;\n    }\n\n    public void setValue(V value) {\n        this.value = value;\n    }\n}\n```\n\n调用：\n\n```java\n\tContainer<String, String> c1 = new Container<String, String>(\"name\", \"findingsea\");\n    Container<String, Integer> c2 = new Container<String, Integer>(\"age\", 24);\n```\n\n##### 3.泛型方法\n\n示例：\n\n```java\npublic static <T> void out(T t) {\n        System.out.println(t);\n    }\n```\n\n### 四 通配符与上下界\n\nJava中泛型可使用通配符“？”来代替任意类型，如：\n\n```java\n\npublic class GenericTest {\n     \n    public static void main(String[] args) {\n        List<String> name = new ArrayList<String>();\n        List<Integer> age = new ArrayList<Integer>();\n        List<Number> number = new ArrayList<Number>();\n        \n        name.add(\"icon\");\n        age.add(18);\n        number.add(314);\n \n        getData(name);\n        getData(age);\n        getData(number);\n       \n   }\n \n   public static void getData(List<?> data) {\n      System.out.println(\"data :\" + data.get(0));\n   }\n}\n\n```\n\njava中亦可以使用<? extends T>和<? super T>来设置传入类型的上下界（Java中泛型传入的类型都是对象，因此这些其实就是子类和父类的限制） \n\n代码示例：\n\n","source":"_posts/Java基础之泛型.md","raw":"---\ntitle: Java基础之泛型\ndate: 2017-03-17 10:26:13\ncategories: Java\ntags:\n- Java\n- 泛型\n---\n\n### 一 概述\n\nJava泛型（generics）是JDK 5中引入的一个新特性，允许在定义类和接口的时候使用类型参数（type parameter）。声明的类型参数在使用时用具体的类型来替换。泛型最主要的应用是在JDK 5中的新集合类框架中。对于泛型概念的引入，开发社区的观点是褒贬不一。从好的方面来说，泛型的引入可以解决之前的集合类框架在使用过程中通常会出现的运行时刻类型错误，因为编译器可以在编译时刻就发现很多明显的错误。而从不好的地方来说，为了保证与旧有版本的兼容性，Java泛型的实现上存在着一些不够优雅的地方。当然这也是任何有历史的编程语言所需要承担的历史包袱。后续的版本更新会为早期的设计缺陷所累。\n\n引入泛型要分清两种继承结构：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于 List<String>和List<Object>这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。\n\n开发人员在使用泛型的时候，很容易根据自己的直觉而犯一些错误。比如一个方法如果接收List<Object>作为形式参数，那么如果尝试将一个List<String>的对象作为实际参数传进去，却发现无法通过编译。虽然从直觉上来说，Object是String的父类，这种类型转换应该是合理的。但是实际上这会产生隐含的类型转换问题，因此编译器直接就禁止这样的行为。\n\n### 二 类型擦除\n\n正确理解泛型概念的首要前提是理解类型擦除（type erasure）。 Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的List<Object>和List<String>等类型，在编译之后都会变成List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。类型擦除也是Java的泛型实现方式与C++模板机制实现方式之间的重要区别。\n\n很多泛型的奇怪特性都与这个类型擦除的存在有关，包括：\n\n- 泛型类并没有自己独有的Class类对象。比如并不存在List<String>.class或是List<Integer>.class，而只有List.class。\n    \n- 静态变量是被泛型类的所有实例所共享的。对于声明为MyClass<T>的类，访问其中的静态变量的方法仍然是 MyClass.myStaticVar。不管是通过new MyClass<String>还是new MyClass<Integer>创建的对象，都是共享一个静态变量。\n    \n- 泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型MyException<String>和MyException<Integer>的。对于JVM来说，它们都是 MyException类型的。也就无法执行与异常对应的catch语句。\n\n类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。同时去掉出现的类型声明，即去掉<>的内容。比如T get()方法声明就变成了Object get()；List<String>就变成了List。接下来就可能需要生成一些桥接方法（bridge method）。这是由于擦除了类型之后的类可能缺少某些必须的方法。比如考虑下面的代码：\n\n```java\nclass MyString implements Comparable<String> {\n    public int compareTo(String str) {        \n        return 0;    \n    }\n} \n```\n\n当类型信息被擦除之后，上述类的声明变成了class MyString implements Comparable。但是这样的话，类MyString就会有编译错误，因为没有实现接口Comparable声明的int compareTo(Object)方法。这个时候就由编译器来动态生成这个方法。\n\n### 三 泛型接口，泛型类与泛型方法\n\n##### 1. 泛型接口\n\n示例：\n\n```java\npublic interface Generator<T> {\n    public T next();\n}\n```\n\n然后定义一个生成器类来实现这个接口：\n\n```java\npublic class FruitGenerator implements Generator<String> {\n\n    private String[] fruits = new String[]{\"Apple\", \"Banana\", \"Pear\"};\n\n    @Override\n    public String next() {\n        Random rand = new Random();\n        return fruits[rand.nextInt(3)];\n    }\n}\n```\n\n##### 2. 泛型类\n\n示例：\n\n```java\npublic class Container<K, V> {\n    private K key;\n    private V value;\n\n    public Container(K k, V v) {\n        key = k;\n        value = v;\n    }\n\n    public K getKey() {\n        return key;\n    }\n\n    public void setKey(K key) {\n        this.key = key;\n    }\n\n    public V getValue() {\n        return value;\n    }\n\n    public void setValue(V value) {\n        this.value = value;\n    }\n}\n```\n\n调用：\n\n```java\n\tContainer<String, String> c1 = new Container<String, String>(\"name\", \"findingsea\");\n    Container<String, Integer> c2 = new Container<String, Integer>(\"age\", 24);\n```\n\n##### 3.泛型方法\n\n示例：\n\n```java\npublic static <T> void out(T t) {\n        System.out.println(t);\n    }\n```\n\n### 四 通配符与上下界\n\nJava中泛型可使用通配符“？”来代替任意类型，如：\n\n```java\n\npublic class GenericTest {\n     \n    public static void main(String[] args) {\n        List<String> name = new ArrayList<String>();\n        List<Integer> age = new ArrayList<Integer>();\n        List<Number> number = new ArrayList<Number>();\n        \n        name.add(\"icon\");\n        age.add(18);\n        number.add(314);\n \n        getData(name);\n        getData(age);\n        getData(number);\n       \n   }\n \n   public static void getData(List<?> data) {\n      System.out.println(\"data :\" + data.get(0));\n   }\n}\n\n```\n\njava中亦可以使用<? extends T>和<? super T>来设置传入类型的上下界（Java中泛型传入的类型都是对象，因此这些其实就是子类和父类的限制） \n\n代码示例：\n\n","slug":"Java基础之泛型","published":1,"updated":"2017-03-17T10:52:38.426Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk0w0006aknzj2ioceyd","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Java泛型（generics）是JDK 5中引入的一个新特性，允许在定义类和接口的时候使用类型参数（type parameter）。声明的类型参数在使用时用具体的类型来替换。泛型最主要的应用是在JDK 5中的新集合类框架中。对于泛型概念的引入，开发社区的观点是褒贬不一。从好的方面来说，泛型的引入可以解决之前的集合类框架在使用过程中通常会出现的运行时刻类型错误，因为编译器可以在编译时刻就发现很多明显的错误。而从不好的地方来说，为了保证与旧有版本的兼容性，Java泛型的实现上存在着一些不够优雅的地方。当然这也是任何有历史的编程语言所需要承担的历史包袱。后续的版本更新会为早期的设计缺陷所累。</p>\n<p>引入泛型要分清两种继承结构：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于 List<string>和List<object>这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。</object></string></p>\n<p>开发人员在使用泛型的时候，很容易根据自己的直觉而犯一些错误。比如一个方法如果接收List<object>作为形式参数，那么如果尝试将一个List<string>的对象作为实际参数传进去，却发现无法通过编译。虽然从直觉上来说，Object是String的父类，这种类型转换应该是合理的。但是实际上这会产生隐含的类型转换问题，因此编译器直接就禁止这样的行为。</string></object></p>\n<h3 id=\"二-类型擦除\"><a href=\"#二-类型擦除\" class=\"headerlink\" title=\"二 类型擦除\"></a>二 类型擦除</h3><p>正确理解泛型概念的首要前提是理解类型擦除（type erasure）。 Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的List<object>和List<string>等类型，在编译之后都会变成List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。类型擦除也是Java的泛型实现方式与C++模板机制实现方式之间的重要区别。</string></object></p>\n<p>很多泛型的奇怪特性都与这个类型擦除的存在有关，包括：</p>\n<ul>\n<li><p>泛型类并没有自己独有的Class类对象。比如并不存在List<string>.class或是List<integer>.class，而只有List.class。</integer></string></p>\n</li>\n<li><p>静态变量是被泛型类的所有实例所共享的。对于声明为MyClass<t>的类，访问其中的静态变量的方法仍然是 MyClass.myStaticVar。不管是通过new MyClass<string>还是new MyClass<integer>创建的对象，都是共享一个静态变量。</integer></string></t></p>\n</li>\n<li><p>泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型MyException<string>和MyException<integer>的。对于JVM来说，它们都是 MyException类型的。也就无法执行与异常对应的catch语句。</integer></string></p>\n</li>\n</ul>\n<p>类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。同时去掉出现的类型声明，即去掉&lt;&gt;的内容。比如T get()方法声明就变成了Object get()；List<string>就变成了List。接下来就可能需要生成一些桥接方法（bridge method）。这是由于擦除了类型之后的类可能缺少某些必须的方法。比如考虑下面的代码：</string></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyString</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(String str)</span> </span>&#123;        </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;    </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当类型信息被擦除之后，上述类的声明变成了class MyString implements Comparable。但是这样的话，类MyString就会有编译错误，因为没有实现接口Comparable声明的int compareTo(Object)方法。这个时候就由编译器来动态生成这个方法。</p>\n<h3 id=\"三-泛型接口，泛型类与泛型方法\"><a href=\"#三-泛型接口，泛型类与泛型方法\" class=\"headerlink\" title=\"三 泛型接口，泛型类与泛型方法\"></a>三 泛型接口，泛型类与泛型方法</h3><h5 id=\"1-泛型接口\"><a href=\"#1-泛型接口\" class=\"headerlink\" title=\"1. 泛型接口\"></a>1. 泛型接口</h5><p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Generator</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">next</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后定义一个生成器类来实现这个接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FruitGenerator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Generator</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> String[] fruits = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"Apple\"</span>, <span class=\"string\">\"Banana\"</span>, <span class=\"string\">\"Pear\"</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Random rand = <span class=\"keyword\">new</span> Random();</div><div class=\"line\">        <span class=\"keyword\">return</span> fruits[rand.nextInt(<span class=\"number\">3</span>)];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"2-泛型类\"><a href=\"#2-泛型类\" class=\"headerlink\" title=\"2. 泛型类\"></a>2. 泛型类</h5><p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Container</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> K key;</div><div class=\"line\">    <span class=\"keyword\">private</span> V value;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Container</span><span class=\"params\">(K k, V v)</span> </span>&#123;</div><div class=\"line\">        key = k;</div><div class=\"line\">        value = v;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> key;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setKey</span><span class=\"params\">(K key)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.key = key;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> value;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(V value)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.value = value;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Container&lt;String, String&gt; c1 = <span class=\"keyword\">new</span> Container&lt;String, String&gt;(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"findingsea\"</span>);</div><div class=\"line\">   Container&lt;String, Integer&gt; c2 = <span class=\"keyword\">new</span> Container&lt;String, Integer&gt;(<span class=\"string\">\"age\"</span>, <span class=\"number\">24</span>);</div></pre></td></tr></table></figure>\n<h5 id=\"3-泛型方法\"><a href=\"#3-泛型方法\" class=\"headerlink\" title=\"3.泛型方法\"></a>3.泛型方法</h5><p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">out</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">        System.out.println(t);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"四-通配符与上下界\"><a href=\"#四-通配符与上下界\" class=\"headerlink\" title=\"四 通配符与上下界\"></a>四 通配符与上下界</h3><p>Java中泛型可使用通配符“？”来代替任意类型，如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GenericTest</span> </span>&#123;</div><div class=\"line\">     </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        List&lt;String&gt; name = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</div><div class=\"line\">        List&lt;Integer&gt; age = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</div><div class=\"line\">        List&lt;Number&gt; number = <span class=\"keyword\">new</span> ArrayList&lt;Number&gt;();</div><div class=\"line\">        </div><div class=\"line\">        name.add(<span class=\"string\">\"icon\"</span>);</div><div class=\"line\">        age.add(<span class=\"number\">18</span>);</div><div class=\"line\">        number.add(<span class=\"number\">314</span>);</div><div class=\"line\"> </div><div class=\"line\">        getData(name);</div><div class=\"line\">        getData(age);</div><div class=\"line\">        getData(number);</div><div class=\"line\">       </div><div class=\"line\">   &#125;</div><div class=\"line\"> </div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getData</span><span class=\"params\">(List&lt;?&gt; data)</span> </span>&#123;</div><div class=\"line\">      System.out.println(<span class=\"string\">\"data :\"</span> + data.get(<span class=\"number\">0</span>));</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>java中亦可以使用&lt;? extends T&gt;和&lt;? super T&gt;来设置传入类型的上下界（Java中泛型传入的类型都是对象，因此这些其实就是子类和父类的限制） </p>\n<p>代码示例：</p>\n","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Java泛型（generics）是JDK 5中引入的一个新特性，允许在定义类和接口的时候使用类型参数（type parameter）。声明的类型参数在使用时用具体的类型来替换。泛型最主要的应用是在JDK 5中的新集合类框架中。对于泛型概念的引入，开发社区的观点是褒贬不一。从好的方面来说，泛型的引入可以解决之前的集合类框架在使用过程中通常会出现的运行时刻类型错误，因为编译器可以在编译时刻就发现很多明显的错误。而从不好的地方来说，为了保证与旧有版本的兼容性，Java泛型的实现上存在着一些不够优雅的地方。当然这也是任何有历史的编程语言所需要承担的历史包袱。后续的版本更新会为早期的设计缺陷所累。</p>\n<p>引入泛型要分清两种继承结构：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于 List<String>和List<Object>这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。</p>\n<p>开发人员在使用泛型的时候，很容易根据自己的直觉而犯一些错误。比如一个方法如果接收List<Object>作为形式参数，那么如果尝试将一个List<String>的对象作为实际参数传进去，却发现无法通过编译。虽然从直觉上来说，Object是String的父类，这种类型转换应该是合理的。但是实际上这会产生隐含的类型转换问题，因此编译器直接就禁止这样的行为。</p>\n<h3 id=\"二-类型擦除\"><a href=\"#二-类型擦除\" class=\"headerlink\" title=\"二 类型擦除\"></a>二 类型擦除</h3><p>正确理解泛型概念的首要前提是理解类型擦除（type erasure）。 Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的List<Object>和List<String>等类型，在编译之后都会变成List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。类型擦除也是Java的泛型实现方式与C++模板机制实现方式之间的重要区别。</p>\n<p>很多泛型的奇怪特性都与这个类型擦除的存在有关，包括：</p>\n<ul>\n<li><p>泛型类并没有自己独有的Class类对象。比如并不存在List<String>.class或是List<Integer>.class，而只有List.class。</p>\n</li>\n<li><p>静态变量是被泛型类的所有实例所共享的。对于声明为MyClass<T>的类，访问其中的静态变量的方法仍然是 MyClass.myStaticVar。不管是通过new MyClass<String>还是new MyClass<Integer>创建的对象，都是共享一个静态变量。</p>\n</li>\n<li><p>泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型MyException<String>和MyException<Integer>的。对于JVM来说，它们都是 MyException类型的。也就无法执行与异常对应的catch语句。</p>\n</li>\n</ul>\n<p>类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。同时去掉出现的类型声明，即去掉&lt;&gt;的内容。比如T get()方法声明就变成了Object get()；List<String>就变成了List。接下来就可能需要生成一些桥接方法（bridge method）。这是由于擦除了类型之后的类可能缺少某些必须的方法。比如考虑下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyString</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(String str)</span> </span>&#123;        </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;    </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当类型信息被擦除之后，上述类的声明变成了class MyString implements Comparable。但是这样的话，类MyString就会有编译错误，因为没有实现接口Comparable声明的int compareTo(Object)方法。这个时候就由编译器来动态生成这个方法。</p>\n<h3 id=\"三-泛型接口，泛型类与泛型方法\"><a href=\"#三-泛型接口，泛型类与泛型方法\" class=\"headerlink\" title=\"三 泛型接口，泛型类与泛型方法\"></a>三 泛型接口，泛型类与泛型方法</h3><h5 id=\"1-泛型接口\"><a href=\"#1-泛型接口\" class=\"headerlink\" title=\"1. 泛型接口\"></a>1. 泛型接口</h5><p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Generator</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">next</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后定义一个生成器类来实现这个接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FruitGenerator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Generator</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> String[] fruits = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"Apple\"</span>, <span class=\"string\">\"Banana\"</span>, <span class=\"string\">\"Pear\"</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Random rand = <span class=\"keyword\">new</span> Random();</div><div class=\"line\">        <span class=\"keyword\">return</span> fruits[rand.nextInt(<span class=\"number\">3</span>)];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"2-泛型类\"><a href=\"#2-泛型类\" class=\"headerlink\" title=\"2. 泛型类\"></a>2. 泛型类</h5><p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Container</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> K key;</div><div class=\"line\">    <span class=\"keyword\">private</span> V value;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Container</span><span class=\"params\">(K k, V v)</span> </span>&#123;</div><div class=\"line\">        key = k;</div><div class=\"line\">        value = v;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> key;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setKey</span><span class=\"params\">(K key)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.key = key;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> value;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(V value)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.value = value;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Container&lt;String, String&gt; c1 = <span class=\"keyword\">new</span> Container&lt;String, String&gt;(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"findingsea\"</span>);</div><div class=\"line\">   Container&lt;String, Integer&gt; c2 = <span class=\"keyword\">new</span> Container&lt;String, Integer&gt;(<span class=\"string\">\"age\"</span>, <span class=\"number\">24</span>);</div></pre></td></tr></table></figure>\n<h5 id=\"3-泛型方法\"><a href=\"#3-泛型方法\" class=\"headerlink\" title=\"3.泛型方法\"></a>3.泛型方法</h5><p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">out</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">        System.out.println(t);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"四-通配符与上下界\"><a href=\"#四-通配符与上下界\" class=\"headerlink\" title=\"四 通配符与上下界\"></a>四 通配符与上下界</h3><p>Java中泛型可使用通配符“？”来代替任意类型，如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GenericTest</span> </span>&#123;</div><div class=\"line\">     </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        List&lt;String&gt; name = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</div><div class=\"line\">        List&lt;Integer&gt; age = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</div><div class=\"line\">        List&lt;Number&gt; number = <span class=\"keyword\">new</span> ArrayList&lt;Number&gt;();</div><div class=\"line\">        </div><div class=\"line\">        name.add(<span class=\"string\">\"icon\"</span>);</div><div class=\"line\">        age.add(<span class=\"number\">18</span>);</div><div class=\"line\">        number.add(<span class=\"number\">314</span>);</div><div class=\"line\"> </div><div class=\"line\">        getData(name);</div><div class=\"line\">        getData(age);</div><div class=\"line\">        getData(number);</div><div class=\"line\">       </div><div class=\"line\">   &#125;</div><div class=\"line\"> </div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getData</span><span class=\"params\">(List&lt;?&gt; data)</span> </span>&#123;</div><div class=\"line\">      System.out.println(<span class=\"string\">\"data :\"</span> + data.get(<span class=\"number\">0</span>));</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>java中亦可以使用&lt;? extends T&gt;和&lt;? super T&gt;来设置传入类型的上下界（Java中泛型传入的类型都是对象，因此这些其实就是子类和父类的限制） </p>\n<p>代码示例：</p>\n"},{"title":"Java基础之流","date":"2017-03-17T08:06:59.000Z","_content":"\n### 一 概述\n\nJava在java.io包下提供了相应的类和接口来对IO进行支持。Java中主要包含输入输出两种流，没中输入输出流又分为字节流和字符流两种流。其中字节流以字节为单位处理输入输出操作，字符流以字符来处理输入输出操作。从Java7开始Java在java.nio包下提供了一种全新的API，被称作NIO，它可以更高效的进行输入、输出操作。\n\n### 二 Java IO流相关的类\n\n- File类：系统中文件或者目录的实例，里面有很多方法用于获取文件和目录信息，可以通过查看File的源码获知。\n- 字节流：InputStream/OutputStream输入输出字节流的基类\n- 字符流：Reader/Writer 输入输出字符流的基类\n- 处理流：如PrintStream，可以通过传入节点流来简化读写操作。上面的字节流和字符流就叫做节点流。\n- 转换流：如InputStreamReader，字节流转换成字符流，由于字符流比字节流处理方便，所以Java中只有字节流转字符流的类，没有字符流转字节流的类。\n- 缓冲流：如BufferedReader，用于包装字符流。\n\n\n### 三 RandomAccessFile类\n\n一个强大的文件内容访问类，可以直接跳转到文件的任意位置读写数据。\n\n### 四 序列化\n\nJava中的序列化是将Java对象转化为二进制流，以便写入磁盘或者在网络上传输。要序列化某个对像需要实现Serializable或者Externalizable（一般是实现Serializable），这在JavaEE中非常普遍，因为JavaEE张系统之间要相互远程调用，一般建议将每一个JavaBean都要序列化。\n\n如果一个类中注入了另一个对象，若想这个类可以序列化，则这个对象所在的类也必须序列化。\n\n##### 自定义序列化\n\n- 使用transient关键字    \n有时候我们序列化一个对象，却不想它的某个成员变量被序列化，可以使用transient关键字修饰该变量。\n\n- 实现特殊的签名方法    \n自定义序列化的类要实现这些方法：writeObject，readObject，readObjectNoData\n\n- 实现Externalizable接口，自定义序列化\n\n##### 版本\n\n反序列化必须提供对象的class文件，但是随着项目的升级，class文件也会改变，为了保证两个class文件的兼容性，Java要求需要序列化的类要是设置一个private static final变量serialVersionUID。只要改值不变，则被认为是同一个序列化版本。\n\n### 五 Java NIO（Java4新增，Java7增强）\n\n采用内存映射文件的方式来处理输入/输出，效率很高。\n","source":"_posts/Java基础之流.md","raw":"---\ntitle: Java基础之流\ndate: 2017-03-17 16:06:59\ncategories: Java\ntags:\n- Java\n- IO\n---\n\n### 一 概述\n\nJava在java.io包下提供了相应的类和接口来对IO进行支持。Java中主要包含输入输出两种流，没中输入输出流又分为字节流和字符流两种流。其中字节流以字节为单位处理输入输出操作，字符流以字符来处理输入输出操作。从Java7开始Java在java.nio包下提供了一种全新的API，被称作NIO，它可以更高效的进行输入、输出操作。\n\n### 二 Java IO流相关的类\n\n- File类：系统中文件或者目录的实例，里面有很多方法用于获取文件和目录信息，可以通过查看File的源码获知。\n- 字节流：InputStream/OutputStream输入输出字节流的基类\n- 字符流：Reader/Writer 输入输出字符流的基类\n- 处理流：如PrintStream，可以通过传入节点流来简化读写操作。上面的字节流和字符流就叫做节点流。\n- 转换流：如InputStreamReader，字节流转换成字符流，由于字符流比字节流处理方便，所以Java中只有字节流转字符流的类，没有字符流转字节流的类。\n- 缓冲流：如BufferedReader，用于包装字符流。\n\n\n### 三 RandomAccessFile类\n\n一个强大的文件内容访问类，可以直接跳转到文件的任意位置读写数据。\n\n### 四 序列化\n\nJava中的序列化是将Java对象转化为二进制流，以便写入磁盘或者在网络上传输。要序列化某个对像需要实现Serializable或者Externalizable（一般是实现Serializable），这在JavaEE中非常普遍，因为JavaEE张系统之间要相互远程调用，一般建议将每一个JavaBean都要序列化。\n\n如果一个类中注入了另一个对象，若想这个类可以序列化，则这个对象所在的类也必须序列化。\n\n##### 自定义序列化\n\n- 使用transient关键字    \n有时候我们序列化一个对象，却不想它的某个成员变量被序列化，可以使用transient关键字修饰该变量。\n\n- 实现特殊的签名方法    \n自定义序列化的类要实现这些方法：writeObject，readObject，readObjectNoData\n\n- 实现Externalizable接口，自定义序列化\n\n##### 版本\n\n反序列化必须提供对象的class文件，但是随着项目的升级，class文件也会改变，为了保证两个class文件的兼容性，Java要求需要序列化的类要是设置一个private static final变量serialVersionUID。只要改值不变，则被认为是同一个序列化版本。\n\n### 五 Java NIO（Java4新增，Java7增强）\n\n采用内存映射文件的方式来处理输入/输出，效率很高。\n","slug":"Java基础之流","published":1,"updated":"2017-03-23T08:55:50.516Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk110007aknznbenjmza","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Java在java.io包下提供了相应的类和接口来对IO进行支持。Java中主要包含输入输出两种流，没中输入输出流又分为字节流和字符流两种流。其中字节流以字节为单位处理输入输出操作，字符流以字符来处理输入输出操作。从Java7开始Java在java.nio包下提供了一种全新的API，被称作NIO，它可以更高效的进行输入、输出操作。</p>\n<h3 id=\"二-Java-IO流相关的类\"><a href=\"#二-Java-IO流相关的类\" class=\"headerlink\" title=\"二 Java IO流相关的类\"></a>二 Java IO流相关的类</h3><ul>\n<li>File类：系统中文件或者目录的实例，里面有很多方法用于获取文件和目录信息，可以通过查看File的源码获知。</li>\n<li>字节流：InputStream/OutputStream输入输出字节流的基类</li>\n<li>字符流：Reader/Writer 输入输出字符流的基类</li>\n<li>处理流：如PrintStream，可以通过传入节点流来简化读写操作。上面的字节流和字符流就叫做节点流。</li>\n<li>转换流：如InputStreamReader，字节流转换成字符流，由于字符流比字节流处理方便，所以Java中只有字节流转字符流的类，没有字符流转字节流的类。</li>\n<li>缓冲流：如BufferedReader，用于包装字符流。</li>\n</ul>\n<h3 id=\"三-RandomAccessFile类\"><a href=\"#三-RandomAccessFile类\" class=\"headerlink\" title=\"三 RandomAccessFile类\"></a>三 RandomAccessFile类</h3><p>一个强大的文件内容访问类，可以直接跳转到文件的任意位置读写数据。</p>\n<h3 id=\"四-序列化\"><a href=\"#四-序列化\" class=\"headerlink\" title=\"四 序列化\"></a>四 序列化</h3><p>Java中的序列化是将Java对象转化为二进制流，以便写入磁盘或者在网络上传输。要序列化某个对像需要实现Serializable或者Externalizable（一般是实现Serializable），这在JavaEE中非常普遍，因为JavaEE张系统之间要相互远程调用，一般建议将每一个JavaBean都要序列化。</p>\n<p>如果一个类中注入了另一个对象，若想这个类可以序列化，则这个对象所在的类也必须序列化。</p>\n<h5 id=\"自定义序列化\"><a href=\"#自定义序列化\" class=\"headerlink\" title=\"自定义序列化\"></a>自定义序列化</h5><ul>\n<li><p>使用transient关键字<br>有时候我们序列化一个对象，却不想它的某个成员变量被序列化，可以使用transient关键字修饰该变量。</p>\n</li>\n<li><p>实现特殊的签名方法<br>自定义序列化的类要实现这些方法：writeObject，readObject，readObjectNoData</p>\n</li>\n<li><p>实现Externalizable接口，自定义序列化</p>\n</li>\n</ul>\n<h5 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h5><p>反序列化必须提供对象的class文件，但是随着项目的升级，class文件也会改变，为了保证两个class文件的兼容性，Java要求需要序列化的类要是设置一个private static final变量serialVersionUID。只要改值不变，则被认为是同一个序列化版本。</p>\n<h3 id=\"五-Java-NIO（Java4新增，Java7增强）\"><a href=\"#五-Java-NIO（Java4新增，Java7增强）\" class=\"headerlink\" title=\"五 Java NIO（Java4新增，Java7增强）\"></a>五 Java NIO（Java4新增，Java7增强）</h3><p>采用内存映射文件的方式来处理输入/输出，效率很高。</p>\n","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Java在java.io包下提供了相应的类和接口来对IO进行支持。Java中主要包含输入输出两种流，没中输入输出流又分为字节流和字符流两种流。其中字节流以字节为单位处理输入输出操作，字符流以字符来处理输入输出操作。从Java7开始Java在java.nio包下提供了一种全新的API，被称作NIO，它可以更高效的进行输入、输出操作。</p>\n<h3 id=\"二-Java-IO流相关的类\"><a href=\"#二-Java-IO流相关的类\" class=\"headerlink\" title=\"二 Java IO流相关的类\"></a>二 Java IO流相关的类</h3><ul>\n<li>File类：系统中文件或者目录的实例，里面有很多方法用于获取文件和目录信息，可以通过查看File的源码获知。</li>\n<li>字节流：InputStream/OutputStream输入输出字节流的基类</li>\n<li>字符流：Reader/Writer 输入输出字符流的基类</li>\n<li>处理流：如PrintStream，可以通过传入节点流来简化读写操作。上面的字节流和字符流就叫做节点流。</li>\n<li>转换流：如InputStreamReader，字节流转换成字符流，由于字符流比字节流处理方便，所以Java中只有字节流转字符流的类，没有字符流转字节流的类。</li>\n<li>缓冲流：如BufferedReader，用于包装字符流。</li>\n</ul>\n<h3 id=\"三-RandomAccessFile类\"><a href=\"#三-RandomAccessFile类\" class=\"headerlink\" title=\"三 RandomAccessFile类\"></a>三 RandomAccessFile类</h3><p>一个强大的文件内容访问类，可以直接跳转到文件的任意位置读写数据。</p>\n<h3 id=\"四-序列化\"><a href=\"#四-序列化\" class=\"headerlink\" title=\"四 序列化\"></a>四 序列化</h3><p>Java中的序列化是将Java对象转化为二进制流，以便写入磁盘或者在网络上传输。要序列化某个对像需要实现Serializable或者Externalizable（一般是实现Serializable），这在JavaEE中非常普遍，因为JavaEE张系统之间要相互远程调用，一般建议将每一个JavaBean都要序列化。</p>\n<p>如果一个类中注入了另一个对象，若想这个类可以序列化，则这个对象所在的类也必须序列化。</p>\n<h5 id=\"自定义序列化\"><a href=\"#自定义序列化\" class=\"headerlink\" title=\"自定义序列化\"></a>自定义序列化</h5><ul>\n<li><p>使用transient关键字<br>有时候我们序列化一个对象，却不想它的某个成员变量被序列化，可以使用transient关键字修饰该变量。</p>\n</li>\n<li><p>实现特殊的签名方法<br>自定义序列化的类要实现这些方法：writeObject，readObject，readObjectNoData</p>\n</li>\n<li><p>实现Externalizable接口，自定义序列化</p>\n</li>\n</ul>\n<h5 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h5><p>反序列化必须提供对象的class文件，但是随着项目的升级，class文件也会改变，为了保证两个class文件的兼容性，Java要求需要序列化的类要是设置一个private static final变量serialVersionUID。只要改值不变，则被认为是同一个序列化版本。</p>\n<h3 id=\"五-Java-NIO（Java4新增，Java7增强）\"><a href=\"#五-Java-NIO（Java4新增，Java7增强）\" class=\"headerlink\" title=\"五 Java NIO（Java4新增，Java7增强）\"></a>五 Java NIO（Java4新增，Java7增强）</h3><p>采用内存映射文件的方式来处理输入/输出，效率很高。</p>\n"},{"title":"Java基础之注解","date":"2017-03-17T02:26:21.000Z","_content":"\n### 一 概述\n\n从Java5开始，Java增加了对元数据的支持，也就是Annotation（注解）。Annotation其实就是代码中的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用注解，程序开发人员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。代码分析工具，开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。\n\n注解在定义时类似一个接口，程序可以通过反射来获取指定程序元素的注解对象，在使用时注解就像修饰符一样，可用于修饰类，方法，变量参数等。这些信息被存储在注解的“name=value”对中。\n\n### 二 Java中内置注解\n\n下面是5个Java中内置的注解：\n\n- @Override    \n用于标记重写方法，被标记的方法说明是重写父类或父接口的方法\n\n- @Deprecated    \n标记方法已过时，是不推荐使用的方法\n\n- SuppressWarning   \n抑制某个编译器警告，被它标记的方法或者类，在执行时编译器将不再显示其表明抑制的警告。如@SuppressWarning（value=“unchecked”），注解后面的是一些可以设置的值，若只有一个value值，可以省略为@SuppressWarning（“unchecked”）\n\n- @SafeVarargs      \nJava7新增的注解，它的效果类似于@SuppressWarning（“unchecked”）\n\n- @FunctionalInterface    \n该注解标记该接口为函数式接口。Java8规定：如果如果接口中只有一个抽象方法，则该方法为函数式接口（可以包含多个静态方法或者多个默认方法）。函数式接口就是Java8中为Lambda表达式定义的，Lambda表达式可以直接创建函数式接口的实例。默认方法是Java8中新增的特性，使用default关键字修饰，默认方法同static方法一样可以直接在接口中实现，实际上默认方法就是为了解耦接口和它的实现类而设计的（实现了接口就必须实现它的抽象方法，若接口改变，则所有的实现类都要改变）\n\n### 三 元注解\n\n元注解即是修饰注解的注解，用在注解定义的地方。Java中内置了以下几个常用的元注解。\n\n- @Retention     \n该注解只能用于修饰注解的定义，说明该注解可以保留多长时间。它定义了一个value变量，可以有3中取值，对应类加载时的3中状态。  \n1.RetentionPolicy.CLASS：该属性是默认值，说明该注解信息被编译在class文件中，但无法在运行时获取注解信息。   \n2.RetentionPolicy.RUNTIME：表明该注解不止被编译在了class文件中，而且可以在程序运行时通过反射获取注解的信息。    \n3.RetentionPolicy.SOURCE：说明该注解信息只放在源文件中，编译时直接丢弃。   \n\n- @Target\n用于指定被修饰的注解能用于修饰哪些程序单元。它也包含一个名为value的成员变量，该变量包含以下几种取值：   \n1.ElementType.ANNOTATION_TYPE：指定该策略的注解只能修饰注解。    \n2.ElementType.CONSTRUCTOR：标记该注解只能修饰构造器    \n3.ElementType.FIELD：标记该注解只能修饰成员变量     \n4.ElementType.LOCAL_VARIABLE：标记该注解只能修饰局部变量    \n5.ElementType.METHOD：标记该注解只能修饰方法    \n6.ElementType.PACKAGE：标记该注解只能修饰包     \n7.ElementType.PARAMETER：标记该注解只能修饰参数    \n8.ElementType.TYPE：标记该注解能修饰类，接口（包括注解），枚举类型    \n\n- @Documented    \n表明被该元注解修饰的注解将被javadoc提取为文档，如果一个注解在定义时使用该元注解修饰，那么所有被该注解修饰的程序元素的API文档中将会包含该注解信息。\n\n- @Inherited   \n表明被该元注解修饰的注解具有继承性，即若该被修饰的注解修饰了某个类，则它的子类会自动被该注解修饰。\n\n### 四 自定义注解\n\n定义注解：\n\n```java\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t\n\tpublic @interface MyAnnotation {\n\t  public String name();\n\t  public String value();\n\t}\n```\n\n上面是注解的定义过程，可以看到它类似一个接口。起方法名和返回值定义了该成员变量的名字和类型，在定义了这些成员变量后，使用注解时，必须给他们赋值；同时它也可以使用default关键字来定义默认值，这样在使用时就不必须给它赋值。如：\n\n```java\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t\n\tpublic @interface MyAnnotation {\n\t  public String name() default \"Tom\";\n\t  public String value() default \"jeri\";\n\t}\n```\n\n使用注解：\n\n```java\n\t@MyAnnotation(name=\"someName\",  value = \"Hello World\")\n\tpublic class TheClass {\n\t}\n```\n\n### 五 提取注解信息\n\n在使用注解修饰了类，方法，成员变量后这些注解不会自己生效，必须有开发者提供相应的工具类来提取并处理这些注解信息。\n\nJava为此提供了一个Annotation接口，它是所有注解的父接口，Java同时还在java.lang.reflect包下新增了AnnotatedElement接口，该接口代表了程序中可以接受注解的程序元素，里面定义一些获取相应元素的注解的方法。它有以下几个实现类：\n\n- Class\n- Constructor\n- Field\n- Method\n- Package\n\n### 六 Java8新增的重复注解\n\n从Java8开始为简化两个相同注解修饰同一个程序元素的情况，定义了重复注解，这个注解也是个元注解--@Repeatable。\n代码示例：\n\n可重复的注解：\n\n```java\n\t@Retention(Retention.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Repeatable（examples.class）\n\tpublic @interface example{\n\t\tString name() default \"Tom\";\n\t\tint age();\n\t}\n```\n\n作为父容器的注解：\n\n```java\n\t@Retention(Retention.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface examples{\n\t\texample[] value();\n\t}\n```\n\n使用：\n\n```java\n\t@example(age=5)\n\t@example(name=\"jeri\",age=9)\n\tpublic class RepeatTest{\n\n\t}\n```\n\n而不必写成：\n\n```java\n\t@examples({@example(age=5),@example(name=\"jeri\",age=9)})\n\tpublic class RepeatTest{\n\n\t}\n```\n\n实际上两种情况都对，Java8就是为了简化第二种形式，才设计了重复注解。\n\n### 七 Java8新增的类型注解\n\nJava8为ElementType枚举增加了TYPE_PARAMETER和TYPE_USE两个枚举值，这样定义注解时就允许使用@Target(ElementType.TYPE_USE)修饰，这种注解被称为类型注解，类型注解可用在任何使用类型的地方，如：\n\n- 创建对象（用new关键字创建）\n\n```java\nObject str = new @NotNull Object();\n```\n\n- 类型转换\n\n```java\nString str = (@NotNull String)Object;\n```\n\n- 使用implement实现接口\n\n```java\npuclic class example implements @NotNull Serializable{}\n```\n\n- 使用throws声明抛出异常\n\n```java\npublic void example(int i)  throws @NotNull FlieNotFoundException{}\n```\n\n### 八 注解处理工具APT\n\n\n\n\n \n\n\n\n\n\n\n","source":"_posts/Java基础之注解.md","raw":"---\ntitle: Java基础之注解\ndate: 2017-03-17 10:26:21\ncategories: Java\ntags:\n- Java\n- 注解\n- 注释\n---\n\n### 一 概述\n\n从Java5开始，Java增加了对元数据的支持，也就是Annotation（注解）。Annotation其实就是代码中的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用注解，程序开发人员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。代码分析工具，开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。\n\n注解在定义时类似一个接口，程序可以通过反射来获取指定程序元素的注解对象，在使用时注解就像修饰符一样，可用于修饰类，方法，变量参数等。这些信息被存储在注解的“name=value”对中。\n\n### 二 Java中内置注解\n\n下面是5个Java中内置的注解：\n\n- @Override    \n用于标记重写方法，被标记的方法说明是重写父类或父接口的方法\n\n- @Deprecated    \n标记方法已过时，是不推荐使用的方法\n\n- SuppressWarning   \n抑制某个编译器警告，被它标记的方法或者类，在执行时编译器将不再显示其表明抑制的警告。如@SuppressWarning（value=“unchecked”），注解后面的是一些可以设置的值，若只有一个value值，可以省略为@SuppressWarning（“unchecked”）\n\n- @SafeVarargs      \nJava7新增的注解，它的效果类似于@SuppressWarning（“unchecked”）\n\n- @FunctionalInterface    \n该注解标记该接口为函数式接口。Java8规定：如果如果接口中只有一个抽象方法，则该方法为函数式接口（可以包含多个静态方法或者多个默认方法）。函数式接口就是Java8中为Lambda表达式定义的，Lambda表达式可以直接创建函数式接口的实例。默认方法是Java8中新增的特性，使用default关键字修饰，默认方法同static方法一样可以直接在接口中实现，实际上默认方法就是为了解耦接口和它的实现类而设计的（实现了接口就必须实现它的抽象方法，若接口改变，则所有的实现类都要改变）\n\n### 三 元注解\n\n元注解即是修饰注解的注解，用在注解定义的地方。Java中内置了以下几个常用的元注解。\n\n- @Retention     \n该注解只能用于修饰注解的定义，说明该注解可以保留多长时间。它定义了一个value变量，可以有3中取值，对应类加载时的3中状态。  \n1.RetentionPolicy.CLASS：该属性是默认值，说明该注解信息被编译在class文件中，但无法在运行时获取注解信息。   \n2.RetentionPolicy.RUNTIME：表明该注解不止被编译在了class文件中，而且可以在程序运行时通过反射获取注解的信息。    \n3.RetentionPolicy.SOURCE：说明该注解信息只放在源文件中，编译时直接丢弃。   \n\n- @Target\n用于指定被修饰的注解能用于修饰哪些程序单元。它也包含一个名为value的成员变量，该变量包含以下几种取值：   \n1.ElementType.ANNOTATION_TYPE：指定该策略的注解只能修饰注解。    \n2.ElementType.CONSTRUCTOR：标记该注解只能修饰构造器    \n3.ElementType.FIELD：标记该注解只能修饰成员变量     \n4.ElementType.LOCAL_VARIABLE：标记该注解只能修饰局部变量    \n5.ElementType.METHOD：标记该注解只能修饰方法    \n6.ElementType.PACKAGE：标记该注解只能修饰包     \n7.ElementType.PARAMETER：标记该注解只能修饰参数    \n8.ElementType.TYPE：标记该注解能修饰类，接口（包括注解），枚举类型    \n\n- @Documented    \n表明被该元注解修饰的注解将被javadoc提取为文档，如果一个注解在定义时使用该元注解修饰，那么所有被该注解修饰的程序元素的API文档中将会包含该注解信息。\n\n- @Inherited   \n表明被该元注解修饰的注解具有继承性，即若该被修饰的注解修饰了某个类，则它的子类会自动被该注解修饰。\n\n### 四 自定义注解\n\n定义注解：\n\n```java\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t\n\tpublic @interface MyAnnotation {\n\t  public String name();\n\t  public String value();\n\t}\n```\n\n上面是注解的定义过程，可以看到它类似一个接口。起方法名和返回值定义了该成员变量的名字和类型，在定义了这些成员变量后，使用注解时，必须给他们赋值；同时它也可以使用default关键字来定义默认值，这样在使用时就不必须给它赋值。如：\n\n```java\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t\n\tpublic @interface MyAnnotation {\n\t  public String name() default \"Tom\";\n\t  public String value() default \"jeri\";\n\t}\n```\n\n使用注解：\n\n```java\n\t@MyAnnotation(name=\"someName\",  value = \"Hello World\")\n\tpublic class TheClass {\n\t}\n```\n\n### 五 提取注解信息\n\n在使用注解修饰了类，方法，成员变量后这些注解不会自己生效，必须有开发者提供相应的工具类来提取并处理这些注解信息。\n\nJava为此提供了一个Annotation接口，它是所有注解的父接口，Java同时还在java.lang.reflect包下新增了AnnotatedElement接口，该接口代表了程序中可以接受注解的程序元素，里面定义一些获取相应元素的注解的方法。它有以下几个实现类：\n\n- Class\n- Constructor\n- Field\n- Method\n- Package\n\n### 六 Java8新增的重复注解\n\n从Java8开始为简化两个相同注解修饰同一个程序元素的情况，定义了重复注解，这个注解也是个元注解--@Repeatable。\n代码示例：\n\n可重复的注解：\n\n```java\n\t@Retention(Retention.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Repeatable（examples.class）\n\tpublic @interface example{\n\t\tString name() default \"Tom\";\n\t\tint age();\n\t}\n```\n\n作为父容器的注解：\n\n```java\n\t@Retention(Retention.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface examples{\n\t\texample[] value();\n\t}\n```\n\n使用：\n\n```java\n\t@example(age=5)\n\t@example(name=\"jeri\",age=9)\n\tpublic class RepeatTest{\n\n\t}\n```\n\n而不必写成：\n\n```java\n\t@examples({@example(age=5),@example(name=\"jeri\",age=9)})\n\tpublic class RepeatTest{\n\n\t}\n```\n\n实际上两种情况都对，Java8就是为了简化第二种形式，才设计了重复注解。\n\n### 七 Java8新增的类型注解\n\nJava8为ElementType枚举增加了TYPE_PARAMETER和TYPE_USE两个枚举值，这样定义注解时就允许使用@Target(ElementType.TYPE_USE)修饰，这种注解被称为类型注解，类型注解可用在任何使用类型的地方，如：\n\n- 创建对象（用new关键字创建）\n\n```java\nObject str = new @NotNull Object();\n```\n\n- 类型转换\n\n```java\nString str = (@NotNull String)Object;\n```\n\n- 使用implement实现接口\n\n```java\npuclic class example implements @NotNull Serializable{}\n```\n\n- 使用throws声明抛出异常\n\n```java\npublic void example(int i)  throws @NotNull FlieNotFoundException{}\n```\n\n### 八 注解处理工具APT\n\n\n\n\n \n\n\n\n\n\n\n","slug":"Java基础之注解","published":1,"updated":"2017-03-23T09:24:43.331Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk14000aaknzbx8pt6tr","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>从Java5开始，Java增加了对元数据的支持，也就是Annotation（注解）。Annotation其实就是代码中的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用注解，程序开发人员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。代码分析工具，开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</p>\n<p>注解在定义时类似一个接口，程序可以通过反射来获取指定程序元素的注解对象，在使用时注解就像修饰符一样，可用于修饰类，方法，变量参数等。这些信息被存储在注解的“name=value”对中。</p>\n<h3 id=\"二-Java中内置注解\"><a href=\"#二-Java中内置注解\" class=\"headerlink\" title=\"二 Java中内置注解\"></a>二 Java中内置注解</h3><p>下面是5个Java中内置的注解：</p>\n<ul>\n<li><p>@Override<br>用于标记重写方法，被标记的方法说明是重写父类或父接口的方法</p>\n</li>\n<li><p>@Deprecated<br>标记方法已过时，是不推荐使用的方法</p>\n</li>\n<li><p>SuppressWarning<br>抑制某个编译器警告，被它标记的方法或者类，在执行时编译器将不再显示其表明抑制的警告。如@SuppressWarning（value=“unchecked”），注解后面的是一些可以设置的值，若只有一个value值，可以省略为@SuppressWarning（“unchecked”）</p>\n</li>\n<li><p>@SafeVarargs<br>Java7新增的注解，它的效果类似于@SuppressWarning（“unchecked”）</p>\n</li>\n<li><p>@FunctionalInterface<br>该注解标记该接口为函数式接口。Java8规定：如果如果接口中只有一个抽象方法，则该方法为函数式接口（可以包含多个静态方法或者多个默认方法）。函数式接口就是Java8中为Lambda表达式定义的，Lambda表达式可以直接创建函数式接口的实例。默认方法是Java8中新增的特性，使用default关键字修饰，默认方法同static方法一样可以直接在接口中实现，实际上默认方法就是为了解耦接口和它的实现类而设计的（实现了接口就必须实现它的抽象方法，若接口改变，则所有的实现类都要改变）</p>\n</li>\n</ul>\n<h3 id=\"三-元注解\"><a href=\"#三-元注解\" class=\"headerlink\" title=\"三 元注解\"></a>三 元注解</h3><p>元注解即是修饰注解的注解，用在注解定义的地方。Java中内置了以下几个常用的元注解。</p>\n<ul>\n<li><p>@Retention<br>该注解只能用于修饰注解的定义，说明该注解可以保留多长时间。它定义了一个value变量，可以有3中取值，对应类加载时的3中状态。<br>1.RetentionPolicy.CLASS：该属性是默认值，说明该注解信息被编译在class文件中，但无法在运行时获取注解信息。<br>2.RetentionPolicy.RUNTIME：表明该注解不止被编译在了class文件中，而且可以在程序运行时通过反射获取注解的信息。<br>3.RetentionPolicy.SOURCE：说明该注解信息只放在源文件中，编译时直接丢弃。   </p>\n</li>\n<li><p>@Target<br>用于指定被修饰的注解能用于修饰哪些程序单元。它也包含一个名为value的成员变量，该变量包含以下几种取值：<br>1.ElementType.ANNOTATION_TYPE：指定该策略的注解只能修饰注解。<br>2.ElementType.CONSTRUCTOR：标记该注解只能修饰构造器<br>3.ElementType.FIELD：标记该注解只能修饰成员变量<br>4.ElementType.LOCAL_VARIABLE：标记该注解只能修饰局部变量<br>5.ElementType.METHOD：标记该注解只能修饰方法<br>6.ElementType.PACKAGE：标记该注解只能修饰包<br>7.ElementType.PARAMETER：标记该注解只能修饰参数<br>8.ElementType.TYPE：标记该注解能修饰类，接口（包括注解），枚举类型    </p>\n</li>\n<li><p>@Documented<br>表明被该元注解修饰的注解将被javadoc提取为文档，如果一个注解在定义时使用该元注解修饰，那么所有被该注解修饰的程序元素的API文档中将会包含该注解信息。</p>\n</li>\n<li><p>@Inherited<br>表明被该元注解修饰的注解具有继承性，即若该被修饰的注解修饰了某个类，则它的子类会自动被该注解修饰。</p>\n</li>\n</ul>\n<h3 id=\"四-自定义注解\"><a href=\"#四-自定义注解\" class=\"headerlink\" title=\"四 自定义注解\"></a>四 自定义注解</h3><p>定义注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> MyAnnotation &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">name</span><span class=\"params\">()</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">value</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面是注解的定义过程，可以看到它类似一个接口。起方法名和返回值定义了该成员变量的名字和类型，在定义了这些成员变量后，使用注解时，必须给他们赋值；同时它也可以使用default关键字来定义默认值，这样在使用时就不必须给它赋值。如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> MyAnnotation &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"Tom\"</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"jeri\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MyAnnotation</span>(name=<span class=\"string\">\"someName\"</span>,  value = <span class=\"string\">\"Hello World\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TheClass</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"五-提取注解信息\"><a href=\"#五-提取注解信息\" class=\"headerlink\" title=\"五 提取注解信息\"></a>五 提取注解信息</h3><p>在使用注解修饰了类，方法，成员变量后这些注解不会自己生效，必须有开发者提供相应的工具类来提取并处理这些注解信息。</p>\n<p>Java为此提供了一个Annotation接口，它是所有注解的父接口，Java同时还在java.lang.reflect包下新增了AnnotatedElement接口，该接口代表了程序中可以接受注解的程序元素，里面定义一些获取相应元素的注解的方法。它有以下几个实现类：</p>\n<ul>\n<li>Class</li>\n<li>Constructor</li>\n<li>Field</li>\n<li>Method</li>\n<li>Package</li>\n</ul>\n<h3 id=\"六-Java8新增的重复注解\"><a href=\"#六-Java8新增的重复注解\" class=\"headerlink\" title=\"六 Java8新增的重复注解\"></a>六 Java8新增的重复注解</h3><p>从Java8开始为简化两个相同注解修饰同一个程序元素的情况，定义了重复注解，这个注解也是个元注解–@Repeatable。<br>代码示例：</p>\n<p>可重复的注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Retention</span>(Retention.RUNTIME)</div><div class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</div><div class=\"line\"><span class=\"meta\">@Repeatable</span>（examples.class）</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> example&#123;</div><div class=\"line\">\t<span class=\"function\">String <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"Tom\"</span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">age</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>作为父容器的注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Retention</span>(Retention.RUNTIME)</div><div class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> examples&#123;</div><div class=\"line\">\texample[] value();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@example</span>(age=<span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"meta\">@example</span>(name=<span class=\"string\">\"jeri\"</span>,age=<span class=\"number\">9</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RepeatTest</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而不必写成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@examples</span>(&#123;<span class=\"meta\">@example</span>(age=<span class=\"number\">5</span>),<span class=\"meta\">@example</span>(name=<span class=\"string\">\"jeri\"</span>,age=<span class=\"number\">9</span>)&#125;)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RepeatTest</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际上两种情况都对，Java8就是为了简化第二种形式，才设计了重复注解。</p>\n<h3 id=\"七-Java8新增的类型注解\"><a href=\"#七-Java8新增的类型注解\" class=\"headerlink\" title=\"七 Java8新增的类型注解\"></a>七 Java8新增的类型注解</h3><p>Java8为ElementType枚举增加了TYPE_PARAMETER和TYPE_USE两个枚举值，这样定义注解时就允许使用@Target(ElementType.TYPE_USE)修饰，这种注解被称为类型注解，类型注解可用在任何使用类型的地方，如：</p>\n<ul>\n<li>创建对象（用new关键字创建）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object str = <span class=\"keyword\">new</span> <span class=\"meta\">@NotNull</span> Object();</div></pre></td></tr></table></figure>\n<ul>\n<li>类型转换</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str = (<span class=\"meta\">@NotNull</span> String)Object;</div></pre></td></tr></table></figure>\n<ul>\n<li>使用implement实现接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">puclic <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">example</span> <span class=\"keyword\">implements</span> @<span class=\"title\">NotNull</span> <span class=\"title\">Serializable</span></span>&#123;&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>使用throws声明抛出异常</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">example</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span>  <span class=\"keyword\">throws</span> @NotNull FlieNotFoundException</span>&#123;&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"八-注解处理工具APT\"><a href=\"#八-注解处理工具APT\" class=\"headerlink\" title=\"八 注解处理工具APT\"></a>八 注解处理工具APT</h3>","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>从Java5开始，Java增加了对元数据的支持，也就是Annotation（注解）。Annotation其实就是代码中的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用注解，程序开发人员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。代码分析工具，开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</p>\n<p>注解在定义时类似一个接口，程序可以通过反射来获取指定程序元素的注解对象，在使用时注解就像修饰符一样，可用于修饰类，方法，变量参数等。这些信息被存储在注解的“name=value”对中。</p>\n<h3 id=\"二-Java中内置注解\"><a href=\"#二-Java中内置注解\" class=\"headerlink\" title=\"二 Java中内置注解\"></a>二 Java中内置注解</h3><p>下面是5个Java中内置的注解：</p>\n<ul>\n<li><p>@Override<br>用于标记重写方法，被标记的方法说明是重写父类或父接口的方法</p>\n</li>\n<li><p>@Deprecated<br>标记方法已过时，是不推荐使用的方法</p>\n</li>\n<li><p>SuppressWarning<br>抑制某个编译器警告，被它标记的方法或者类，在执行时编译器将不再显示其表明抑制的警告。如@SuppressWarning（value=“unchecked”），注解后面的是一些可以设置的值，若只有一个value值，可以省略为@SuppressWarning（“unchecked”）</p>\n</li>\n<li><p>@SafeVarargs<br>Java7新增的注解，它的效果类似于@SuppressWarning（“unchecked”）</p>\n</li>\n<li><p>@FunctionalInterface<br>该注解标记该接口为函数式接口。Java8规定：如果如果接口中只有一个抽象方法，则该方法为函数式接口（可以包含多个静态方法或者多个默认方法）。函数式接口就是Java8中为Lambda表达式定义的，Lambda表达式可以直接创建函数式接口的实例。默认方法是Java8中新增的特性，使用default关键字修饰，默认方法同static方法一样可以直接在接口中实现，实际上默认方法就是为了解耦接口和它的实现类而设计的（实现了接口就必须实现它的抽象方法，若接口改变，则所有的实现类都要改变）</p>\n</li>\n</ul>\n<h3 id=\"三-元注解\"><a href=\"#三-元注解\" class=\"headerlink\" title=\"三 元注解\"></a>三 元注解</h3><p>元注解即是修饰注解的注解，用在注解定义的地方。Java中内置了以下几个常用的元注解。</p>\n<ul>\n<li><p>@Retention<br>该注解只能用于修饰注解的定义，说明该注解可以保留多长时间。它定义了一个value变量，可以有3中取值，对应类加载时的3中状态。<br>1.RetentionPolicy.CLASS：该属性是默认值，说明该注解信息被编译在class文件中，但无法在运行时获取注解信息。<br>2.RetentionPolicy.RUNTIME：表明该注解不止被编译在了class文件中，而且可以在程序运行时通过反射获取注解的信息。<br>3.RetentionPolicy.SOURCE：说明该注解信息只放在源文件中，编译时直接丢弃。   </p>\n</li>\n<li><p>@Target<br>用于指定被修饰的注解能用于修饰哪些程序单元。它也包含一个名为value的成员变量，该变量包含以下几种取值：<br>1.ElementType.ANNOTATION_TYPE：指定该策略的注解只能修饰注解。<br>2.ElementType.CONSTRUCTOR：标记该注解只能修饰构造器<br>3.ElementType.FIELD：标记该注解只能修饰成员变量<br>4.ElementType.LOCAL_VARIABLE：标记该注解只能修饰局部变量<br>5.ElementType.METHOD：标记该注解只能修饰方法<br>6.ElementType.PACKAGE：标记该注解只能修饰包<br>7.ElementType.PARAMETER：标记该注解只能修饰参数<br>8.ElementType.TYPE：标记该注解能修饰类，接口（包括注解），枚举类型    </p>\n</li>\n<li><p>@Documented<br>表明被该元注解修饰的注解将被javadoc提取为文档，如果一个注解在定义时使用该元注解修饰，那么所有被该注解修饰的程序元素的API文档中将会包含该注解信息。</p>\n</li>\n<li><p>@Inherited<br>表明被该元注解修饰的注解具有继承性，即若该被修饰的注解修饰了某个类，则它的子类会自动被该注解修饰。</p>\n</li>\n</ul>\n<h3 id=\"四-自定义注解\"><a href=\"#四-自定义注解\" class=\"headerlink\" title=\"四 自定义注解\"></a>四 自定义注解</h3><p>定义注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> MyAnnotation &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">name</span><span class=\"params\">()</span></span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">value</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面是注解的定义过程，可以看到它类似一个接口。起方法名和返回值定义了该成员变量的名字和类型，在定义了这些成员变量后，使用注解时，必须给他们赋值；同时它也可以使用default关键字来定义默认值，这样在使用时就不必须给它赋值。如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> MyAnnotation &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"Tom\"</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"jeri\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MyAnnotation</span>(name=<span class=\"string\">\"someName\"</span>,  value = <span class=\"string\">\"Hello World\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TheClass</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"五-提取注解信息\"><a href=\"#五-提取注解信息\" class=\"headerlink\" title=\"五 提取注解信息\"></a>五 提取注解信息</h3><p>在使用注解修饰了类，方法，成员变量后这些注解不会自己生效，必须有开发者提供相应的工具类来提取并处理这些注解信息。</p>\n<p>Java为此提供了一个Annotation接口，它是所有注解的父接口，Java同时还在java.lang.reflect包下新增了AnnotatedElement接口，该接口代表了程序中可以接受注解的程序元素，里面定义一些获取相应元素的注解的方法。它有以下几个实现类：</p>\n<ul>\n<li>Class</li>\n<li>Constructor</li>\n<li>Field</li>\n<li>Method</li>\n<li>Package</li>\n</ul>\n<h3 id=\"六-Java8新增的重复注解\"><a href=\"#六-Java8新增的重复注解\" class=\"headerlink\" title=\"六 Java8新增的重复注解\"></a>六 Java8新增的重复注解</h3><p>从Java8开始为简化两个相同注解修饰同一个程序元素的情况，定义了重复注解，这个注解也是个元注解–@Repeatable。<br>代码示例：</p>\n<p>可重复的注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Retention</span>(Retention.RUNTIME)</div><div class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</div><div class=\"line\"><span class=\"meta\">@Repeatable</span>（examples.class）</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> example&#123;</div><div class=\"line\">\t<span class=\"function\">String <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"Tom\"</span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">age</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>作为父容器的注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Retention</span>(Retention.RUNTIME)</div><div class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> examples&#123;</div><div class=\"line\">\texample[] value();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@example</span>(age=<span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"meta\">@example</span>(name=<span class=\"string\">\"jeri\"</span>,age=<span class=\"number\">9</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RepeatTest</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而不必写成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@examples</span>(&#123;<span class=\"meta\">@example</span>(age=<span class=\"number\">5</span>),<span class=\"meta\">@example</span>(name=<span class=\"string\">\"jeri\"</span>,age=<span class=\"number\">9</span>)&#125;)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RepeatTest</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际上两种情况都对，Java8就是为了简化第二种形式，才设计了重复注解。</p>\n<h3 id=\"七-Java8新增的类型注解\"><a href=\"#七-Java8新增的类型注解\" class=\"headerlink\" title=\"七 Java8新增的类型注解\"></a>七 Java8新增的类型注解</h3><p>Java8为ElementType枚举增加了TYPE_PARAMETER和TYPE_USE两个枚举值，这样定义注解时就允许使用@Target(ElementType.TYPE_USE)修饰，这种注解被称为类型注解，类型注解可用在任何使用类型的地方，如：</p>\n<ul>\n<li>创建对象（用new关键字创建）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object str = <span class=\"keyword\">new</span> <span class=\"meta\">@NotNull</span> Object();</div></pre></td></tr></table></figure>\n<ul>\n<li>类型转换</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str = (<span class=\"meta\">@NotNull</span> String)Object;</div></pre></td></tr></table></figure>\n<ul>\n<li>使用implement实现接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">puclic <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">example</span> <span class=\"keyword\">implements</span> @<span class=\"title\">NotNull</span> <span class=\"title\">Serializable</span></span>&#123;&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>使用throws声明抛出异常</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">example</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span>  <span class=\"keyword\">throws</span> @NotNull FlieNotFoundException</span>&#123;&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"八-注解处理工具APT\"><a href=\"#八-注解处理工具APT\" class=\"headerlink\" title=\"八 注解处理工具APT\"></a>八 注解处理工具APT</h3>"},{"title":"Java基础之线程","date":"2017-03-16T01:58:21.000Z","_content":"\n### 一 概述\n\n所谓的多线程就是一个程序中存在多个顺序执行流，每个执行流便是一个线程。Java提供了优秀的多线程支持，下面将会详细介绍Java多线程编程的相关知识。\n\n### 二 线程与进程的比较\n\n现在的操作系统基本都支持多进程，即可以同时运行多个任务，每个任务通常是一个程序，每个运行的程序便是一个进程。而一个程序运行时往往有多个顺序执行流，这每个顺序执行流便是一个线程。\n\n线程与进程的区别：\n\n- 线程比进程更轻，并发性更高\n- 线程可以共享进程的资源，便于实现相互之间的通信\n- 创建线程的代价比创建进程的代价小得多\n- java内置了多线程编程支持，可以非常方便的操作线程\n\n并发与并行的区别：\n\n并行是某一时刻同时运行，并发是某一时刻只有一个指令运行，但是多个指令之间切换过快，所以看起来像是同时运行。\n\n### 三 创建线程的三种方式\n\n##### 1.继承Thread类创建线程\n\n使用Thread类创建线程的步骤如下：\n\n1. 定义Thread的子类并重写它的run方法，run方法的方法体里面就是线程需要完成的任务\n2. 创建Thread子类的实例，即创建了线程对象\n3. 调用线程对象的start()方法来启动线程\n\n代码示例：\n\n抽空写\n\n##### 2.实现Runnable接口创建线程\n\n步骤如下：\n\n1. 实现接口Runnable接口，并实现它的run方法。\n2. 创建Runnable接口实现类的实例，并把它作为参数传给Thread的构造函数，创建Thread对象（即将该实例作为Thread类的Target），并调用它的start方法启动线程。（Runnable接口时函数式接口，可使用Lambda表达式）\n\n代码示例：\n\n- 使用Runnable创建线程的一个优势是多个线程之间可以共享线程类中的实例变量。这也是最常用的一种创建线程的方式，但一般都采用匿名内部类的方式简写。\n\n##### 3. 使用Callable和Future创建线程\n\n从java5开始，java提供了一个Callable接口，接口中提供了一个call()方法来替代run()方法，它比run方法的功能更强大。主要有以下两点：\n\n- call方法可以有返回值\n- call方法可以声明抛出异常\n\n由于Callable接口没有继承Runnable接口，且call方法有返回值，因此实现Callable接口的类无法作为Target传入Thread类中。为此java5提供了Future接口来包装Callable接口创建线程，该接口有一个FutureTask实现类，该类同时也实现了Runnable接口，因此该类的对象可以作为Target传入Thread类中来创建线程。\n\n创建并启动有返回值的线程的步骤如下：\n\n1. 创建Callable接口的实现类，并实现它的call方法。、\n2. 创建FutureTask类来包装Callable接口的实现类的对象（Callable是函数式接口，这一步可以是Lambda表达式）\n3. 将FutureTask对象作为Target传入Thread类中，创建线程。\n4. 使用FutureTask对象的get方法得到call的返回值\n\nCallab接口实现线程与Runnable接口类似，因此它也有Runnable接口的优势。\n\n##### 4. 创建线程的三种方式对比\n\n使用Runnable和Callable接口创建线程的优势：\n\n- 因为是实现接口，还可以继承其他类，避免由于Java的单继承特性而带来的局限。\n- 这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而将CPU，代码和数据分开，更清晰。\n\n劣势：\n\n- 编程稍稍复杂，且要访问当前线程，需要使用Thread.currentThread()方法获取当前线程的实例\n\n使用继承Thread类的方式优势：\n\n- 编程简单\n\n劣势：\n\n因为已经继承了Thread类，无法再继承其他的类。\n\n### 三 线程的生命周期\n\nJava中的线程总结起来可以划分为5个生命周期：\n\n- 新建：创建Thread类或其子类对象\n- 就绪（可运行）：调用Thread类的start方法启动线程，此时线程处于可运行状态，但何时运行取决于JVM线程调度器的调度。一个就绪的线程只有获得CPU时间片才可以进入运行状态。\n- 运行：获得CPU时间片开始运行。现在的操作系统基本上都是抢占式调度策略（当然也有些小型设备是协作式调度策略），即当前时间片用完，即会被其他线程抢占（取决于优先级）。\n- 阻塞：有sleep、join或者IO造成的线程阻塞（调用suspend()也可以使线程挂起，但是该方法容易导致死锁，已不推荐使用）\n- 死亡：run结束或者异常。（调用stop方法也可以结束线程，但该方法容易造成死锁，已不推荐使用）\n\n下面是线程状态转换图：\n\n{% asset_img Java线程状态转换图.png Java线程状态转换图 %}\n\n### 四 Java中内置的用于线程控制的方法\n\n常见的有以下几个方法：（详细请查看Thread源码）\n\n- join：加入一个线程，是当前线程（调用join的线程所处的线程）阻塞，直到调用join的线程执行完。\n- setDaemon：将一个线程设置为后台线程（守护线程），该方法必须在start方法前调用；isDaemon判断一个线程是否是后台线程。\n- sleep：是当前正在执行的线程阻塞\n- yield：使当前正在执行的线程进入就绪状态。将机会让给与它优先级相同或者比它高的线程，如其优先级很高，完全有可能被JVM的线程调度器再次调用\n- setPriority：设置当前线程的优先级\n\n### 五 线程同步\n\n##### 1. 使用synchronized关键实现同步\n\n- 同步代码块  \n使用synchronized对对象进行加锁，如：\n\n```java\nsynchronized（obj）{\n   \n   //TODO\n   ...\n}\n```\n\n- 同步方法   \n使用synchronized对方法进行加锁\n\n```java\npublic synchronized void lock（Object obj）{\n\n    //TODO\n}\n```\n\nsynchronized关键字可以对代码块，方法加锁，但不能修饰构造器，成员变量等。\n\n使用synchronized加锁后，线程什么情况下会释放锁：\n\n- 同步方法，代码块执行完毕\n- 在同步方法，代码块执行中遇到了break，return\n- 出现了未处理的异常和Error\n- 调用wait方法\n\n下列情况下不会释放锁：\n\n- 调用sleep，yield方法\n- 调用suspend方法\n\n##### 2. 同步锁\n\n从java5开始java提供了接口Lock和ReadWriteLock来实现锁同步。Lock接口有个实现类ReentrantLock，ReadWriteLock有个实现类ReentrantReadWriteLock。使用这两个类可以实现锁同步。如：\n\n```java\npublic void test(){\n   lock.lock();\n   try{\n      //需要保证线程安全的代码\n   }\n   finally{\n      lock.unlock();\n   }\n}\n```\n\nJava8又新增了一个StampedLock类，在大多数情况下它可以替代ReentrantReadWriteLock。\n\n### 六 线程通信\n\n##### 1.传统的线程通信\n\n使用wait、notify、notifyAll实现线程通信，适用于使用synchronized关键字来保证线程同步的情况下。代码示例：\n\n##### 2.使用Contition实现线程通信\n\n若是使用Lock对象实现线程同步，则无法使用上述的线程通信的方法，java5提供了一个Condition类来实现线程通信。可通过Lock对象的newCondition()方法获得Condition对象，Condition对象中有await，signal，signalAll方法分别对应传统的wait，notify，notifyAll方法，用于实现线程通信。\n\n##### 3.使用阻塞队列实现线程通信\n\njava5提供了一个BlockingQueue接口，它有一个特征：当生产者线程试图向BlockingQueue里放入元素时，若队列已满，则该线程被阻塞；当消费者试图从BlockingQueue里取出元素时，若队列为空，这该线程被阻塞。利用此原理可以实现线程通信。\n\n该接口有几个实现类，可用于构造线程池。\n\n### 七 线程池\n\n线程池即是一个对象池，传入的都是Runnable对象，底层使用数组或者集合来实现。java中内置了一个Executeors工厂类来实现线程池（它还有一个子类ForkjoinPool）,此外还可以使用其他的第三方框架，如ThreadPoolExecutor。\n\n### 八 ThreadLocal类\n\n在处理多线程并发问题上还有一个解决方案，是使用ThreadLocal类将需要并发的资源封装起来，这样当多个线程并发访问这些资源时，ThreadLocal类会为没一个线程均复制一份该资源的副本，从根本上解决了资源的共享冲突问题。但是此方式虽解决了冲突，但多个线程之间也无法共享资源。","source":"_posts/Java基础之线程.md","raw":"---\ntitle: Java基础之线程\ndate: 2017-03-16 09:58:21\ncategories: Java\ntags:\n- Java\n- 线程\n---\n\n### 一 概述\n\n所谓的多线程就是一个程序中存在多个顺序执行流，每个执行流便是一个线程。Java提供了优秀的多线程支持，下面将会详细介绍Java多线程编程的相关知识。\n\n### 二 线程与进程的比较\n\n现在的操作系统基本都支持多进程，即可以同时运行多个任务，每个任务通常是一个程序，每个运行的程序便是一个进程。而一个程序运行时往往有多个顺序执行流，这每个顺序执行流便是一个线程。\n\n线程与进程的区别：\n\n- 线程比进程更轻，并发性更高\n- 线程可以共享进程的资源，便于实现相互之间的通信\n- 创建线程的代价比创建进程的代价小得多\n- java内置了多线程编程支持，可以非常方便的操作线程\n\n并发与并行的区别：\n\n并行是某一时刻同时运行，并发是某一时刻只有一个指令运行，但是多个指令之间切换过快，所以看起来像是同时运行。\n\n### 三 创建线程的三种方式\n\n##### 1.继承Thread类创建线程\n\n使用Thread类创建线程的步骤如下：\n\n1. 定义Thread的子类并重写它的run方法，run方法的方法体里面就是线程需要完成的任务\n2. 创建Thread子类的实例，即创建了线程对象\n3. 调用线程对象的start()方法来启动线程\n\n代码示例：\n\n抽空写\n\n##### 2.实现Runnable接口创建线程\n\n步骤如下：\n\n1. 实现接口Runnable接口，并实现它的run方法。\n2. 创建Runnable接口实现类的实例，并把它作为参数传给Thread的构造函数，创建Thread对象（即将该实例作为Thread类的Target），并调用它的start方法启动线程。（Runnable接口时函数式接口，可使用Lambda表达式）\n\n代码示例：\n\n- 使用Runnable创建线程的一个优势是多个线程之间可以共享线程类中的实例变量。这也是最常用的一种创建线程的方式，但一般都采用匿名内部类的方式简写。\n\n##### 3. 使用Callable和Future创建线程\n\n从java5开始，java提供了一个Callable接口，接口中提供了一个call()方法来替代run()方法，它比run方法的功能更强大。主要有以下两点：\n\n- call方法可以有返回值\n- call方法可以声明抛出异常\n\n由于Callable接口没有继承Runnable接口，且call方法有返回值，因此实现Callable接口的类无法作为Target传入Thread类中。为此java5提供了Future接口来包装Callable接口创建线程，该接口有一个FutureTask实现类，该类同时也实现了Runnable接口，因此该类的对象可以作为Target传入Thread类中来创建线程。\n\n创建并启动有返回值的线程的步骤如下：\n\n1. 创建Callable接口的实现类，并实现它的call方法。、\n2. 创建FutureTask类来包装Callable接口的实现类的对象（Callable是函数式接口，这一步可以是Lambda表达式）\n3. 将FutureTask对象作为Target传入Thread类中，创建线程。\n4. 使用FutureTask对象的get方法得到call的返回值\n\nCallab接口实现线程与Runnable接口类似，因此它也有Runnable接口的优势。\n\n##### 4. 创建线程的三种方式对比\n\n使用Runnable和Callable接口创建线程的优势：\n\n- 因为是实现接口，还可以继承其他类，避免由于Java的单继承特性而带来的局限。\n- 这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而将CPU，代码和数据分开，更清晰。\n\n劣势：\n\n- 编程稍稍复杂，且要访问当前线程，需要使用Thread.currentThread()方法获取当前线程的实例\n\n使用继承Thread类的方式优势：\n\n- 编程简单\n\n劣势：\n\n因为已经继承了Thread类，无法再继承其他的类。\n\n### 三 线程的生命周期\n\nJava中的线程总结起来可以划分为5个生命周期：\n\n- 新建：创建Thread类或其子类对象\n- 就绪（可运行）：调用Thread类的start方法启动线程，此时线程处于可运行状态，但何时运行取决于JVM线程调度器的调度。一个就绪的线程只有获得CPU时间片才可以进入运行状态。\n- 运行：获得CPU时间片开始运行。现在的操作系统基本上都是抢占式调度策略（当然也有些小型设备是协作式调度策略），即当前时间片用完，即会被其他线程抢占（取决于优先级）。\n- 阻塞：有sleep、join或者IO造成的线程阻塞（调用suspend()也可以使线程挂起，但是该方法容易导致死锁，已不推荐使用）\n- 死亡：run结束或者异常。（调用stop方法也可以结束线程，但该方法容易造成死锁，已不推荐使用）\n\n下面是线程状态转换图：\n\n{% asset_img Java线程状态转换图.png Java线程状态转换图 %}\n\n### 四 Java中内置的用于线程控制的方法\n\n常见的有以下几个方法：（详细请查看Thread源码）\n\n- join：加入一个线程，是当前线程（调用join的线程所处的线程）阻塞，直到调用join的线程执行完。\n- setDaemon：将一个线程设置为后台线程（守护线程），该方法必须在start方法前调用；isDaemon判断一个线程是否是后台线程。\n- sleep：是当前正在执行的线程阻塞\n- yield：使当前正在执行的线程进入就绪状态。将机会让给与它优先级相同或者比它高的线程，如其优先级很高，完全有可能被JVM的线程调度器再次调用\n- setPriority：设置当前线程的优先级\n\n### 五 线程同步\n\n##### 1. 使用synchronized关键实现同步\n\n- 同步代码块  \n使用synchronized对对象进行加锁，如：\n\n```java\nsynchronized（obj）{\n   \n   //TODO\n   ...\n}\n```\n\n- 同步方法   \n使用synchronized对方法进行加锁\n\n```java\npublic synchronized void lock（Object obj）{\n\n    //TODO\n}\n```\n\nsynchronized关键字可以对代码块，方法加锁，但不能修饰构造器，成员变量等。\n\n使用synchronized加锁后，线程什么情况下会释放锁：\n\n- 同步方法，代码块执行完毕\n- 在同步方法，代码块执行中遇到了break，return\n- 出现了未处理的异常和Error\n- 调用wait方法\n\n下列情况下不会释放锁：\n\n- 调用sleep，yield方法\n- 调用suspend方法\n\n##### 2. 同步锁\n\n从java5开始java提供了接口Lock和ReadWriteLock来实现锁同步。Lock接口有个实现类ReentrantLock，ReadWriteLock有个实现类ReentrantReadWriteLock。使用这两个类可以实现锁同步。如：\n\n```java\npublic void test(){\n   lock.lock();\n   try{\n      //需要保证线程安全的代码\n   }\n   finally{\n      lock.unlock();\n   }\n}\n```\n\nJava8又新增了一个StampedLock类，在大多数情况下它可以替代ReentrantReadWriteLock。\n\n### 六 线程通信\n\n##### 1.传统的线程通信\n\n使用wait、notify、notifyAll实现线程通信，适用于使用synchronized关键字来保证线程同步的情况下。代码示例：\n\n##### 2.使用Contition实现线程通信\n\n若是使用Lock对象实现线程同步，则无法使用上述的线程通信的方法，java5提供了一个Condition类来实现线程通信。可通过Lock对象的newCondition()方法获得Condition对象，Condition对象中有await，signal，signalAll方法分别对应传统的wait，notify，notifyAll方法，用于实现线程通信。\n\n##### 3.使用阻塞队列实现线程通信\n\njava5提供了一个BlockingQueue接口，它有一个特征：当生产者线程试图向BlockingQueue里放入元素时，若队列已满，则该线程被阻塞；当消费者试图从BlockingQueue里取出元素时，若队列为空，这该线程被阻塞。利用此原理可以实现线程通信。\n\n该接口有几个实现类，可用于构造线程池。\n\n### 七 线程池\n\n线程池即是一个对象池，传入的都是Runnable对象，底层使用数组或者集合来实现。java中内置了一个Executeors工厂类来实现线程池（它还有一个子类ForkjoinPool）,此外还可以使用其他的第三方框架，如ThreadPoolExecutor。\n\n### 八 ThreadLocal类\n\n在处理多线程并发问题上还有一个解决方案，是使用ThreadLocal类将需要并发的资源封装起来，这样当多个线程并发访问这些资源时，ThreadLocal类会为没一个线程均复制一份该资源的副本，从根本上解决了资源的共享冲突问题。但是此方式虽解决了冲突，但多个线程之间也无法共享资源。","slug":"Java基础之线程","published":1,"updated":"2017-03-17T08:40:06.930Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk1b000caknz7br2kmml","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>所谓的多线程就是一个程序中存在多个顺序执行流，每个执行流便是一个线程。Java提供了优秀的多线程支持，下面将会详细介绍Java多线程编程的相关知识。</p>\n<h3 id=\"二-线程与进程的比较\"><a href=\"#二-线程与进程的比较\" class=\"headerlink\" title=\"二 线程与进程的比较\"></a>二 线程与进程的比较</h3><p>现在的操作系统基本都支持多进程，即可以同时运行多个任务，每个任务通常是一个程序，每个运行的程序便是一个进程。而一个程序运行时往往有多个顺序执行流，这每个顺序执行流便是一个线程。</p>\n<p>线程与进程的区别：</p>\n<ul>\n<li>线程比进程更轻，并发性更高</li>\n<li>线程可以共享进程的资源，便于实现相互之间的通信</li>\n<li>创建线程的代价比创建进程的代价小得多</li>\n<li>java内置了多线程编程支持，可以非常方便的操作线程</li>\n</ul>\n<p>并发与并行的区别：</p>\n<p>并行是某一时刻同时运行，并发是某一时刻只有一个指令运行，但是多个指令之间切换过快，所以看起来像是同时运行。</p>\n<h3 id=\"三-创建线程的三种方式\"><a href=\"#三-创建线程的三种方式\" class=\"headerlink\" title=\"三 创建线程的三种方式\"></a>三 创建线程的三种方式</h3><h5 id=\"1-继承Thread类创建线程\"><a href=\"#1-继承Thread类创建线程\" class=\"headerlink\" title=\"1.继承Thread类创建线程\"></a>1.继承Thread类创建线程</h5><p>使用Thread类创建线程的步骤如下：</p>\n<ol>\n<li>定义Thread的子类并重写它的run方法，run方法的方法体里面就是线程需要完成的任务</li>\n<li>创建Thread子类的实例，即创建了线程对象</li>\n<li>调用线程对象的start()方法来启动线程</li>\n</ol>\n<p>代码示例：</p>\n<p>抽空写</p>\n<h5 id=\"2-实现Runnable接口创建线程\"><a href=\"#2-实现Runnable接口创建线程\" class=\"headerlink\" title=\"2.实现Runnable接口创建线程\"></a>2.实现Runnable接口创建线程</h5><p>步骤如下：</p>\n<ol>\n<li>实现接口Runnable接口，并实现它的run方法。</li>\n<li>创建Runnable接口实现类的实例，并把它作为参数传给Thread的构造函数，创建Thread对象（即将该实例作为Thread类的Target），并调用它的start方法启动线程。（Runnable接口时函数式接口，可使用Lambda表达式）</li>\n</ol>\n<p>代码示例：</p>\n<ul>\n<li>使用Runnable创建线程的一个优势是多个线程之间可以共享线程类中的实例变量。这也是最常用的一种创建线程的方式，但一般都采用匿名内部类的方式简写。</li>\n</ul>\n<h5 id=\"3-使用Callable和Future创建线程\"><a href=\"#3-使用Callable和Future创建线程\" class=\"headerlink\" title=\"3. 使用Callable和Future创建线程\"></a>3. 使用Callable和Future创建线程</h5><p>从java5开始，java提供了一个Callable接口，接口中提供了一个call()方法来替代run()方法，它比run方法的功能更强大。主要有以下两点：</p>\n<ul>\n<li>call方法可以有返回值</li>\n<li>call方法可以声明抛出异常</li>\n</ul>\n<p>由于Callable接口没有继承Runnable接口，且call方法有返回值，因此实现Callable接口的类无法作为Target传入Thread类中。为此java5提供了Future接口来包装Callable接口创建线程，该接口有一个FutureTask实现类，该类同时也实现了Runnable接口，因此该类的对象可以作为Target传入Thread类中来创建线程。</p>\n<p>创建并启动有返回值的线程的步骤如下：</p>\n<ol>\n<li>创建Callable接口的实现类，并实现它的call方法。、</li>\n<li>创建FutureTask类来包装Callable接口的实现类的对象（Callable是函数式接口，这一步可以是Lambda表达式）</li>\n<li>将FutureTask对象作为Target传入Thread类中，创建线程。</li>\n<li>使用FutureTask对象的get方法得到call的返回值</li>\n</ol>\n<p>Callab接口实现线程与Runnable接口类似，因此它也有Runnable接口的优势。</p>\n<h5 id=\"4-创建线程的三种方式对比\"><a href=\"#4-创建线程的三种方式对比\" class=\"headerlink\" title=\"4. 创建线程的三种方式对比\"></a>4. 创建线程的三种方式对比</h5><p>使用Runnable和Callable接口创建线程的优势：</p>\n<ul>\n<li>因为是实现接口，还可以继承其他类，避免由于Java的单继承特性而带来的局限。</li>\n<li>这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而将CPU，代码和数据分开，更清晰。</li>\n</ul>\n<p>劣势：</p>\n<ul>\n<li>编程稍稍复杂，且要访问当前线程，需要使用Thread.currentThread()方法获取当前线程的实例</li>\n</ul>\n<p>使用继承Thread类的方式优势：</p>\n<ul>\n<li>编程简单</li>\n</ul>\n<p>劣势：</p>\n<p>因为已经继承了Thread类，无法再继承其他的类。</p>\n<h3 id=\"三-线程的生命周期\"><a href=\"#三-线程的生命周期\" class=\"headerlink\" title=\"三 线程的生命周期\"></a>三 线程的生命周期</h3><p>Java中的线程总结起来可以划分为5个生命周期：</p>\n<ul>\n<li>新建：创建Thread类或其子类对象</li>\n<li>就绪（可运行）：调用Thread类的start方法启动线程，此时线程处于可运行状态，但何时运行取决于JVM线程调度器的调度。一个就绪的线程只有获得CPU时间片才可以进入运行状态。</li>\n<li>运行：获得CPU时间片开始运行。现在的操作系统基本上都是抢占式调度策略（当然也有些小型设备是协作式调度策略），即当前时间片用完，即会被其他线程抢占（取决于优先级）。</li>\n<li>阻塞：有sleep、join或者IO造成的线程阻塞（调用suspend()也可以使线程挂起，但是该方法容易导致死锁，已不推荐使用）</li>\n<li>死亡：run结束或者异常。（调用stop方法也可以结束线程，但该方法容易造成死锁，已不推荐使用）</li>\n</ul>\n<p>下面是线程状态转换图：</p>\n<img src=\"/2017/03/16/Java基础之线程/Java线程状态转换图.png\" alt=\"Java线程状态转换图\" title=\"Java线程状态转换图\">\n<h3 id=\"四-Java中内置的用于线程控制的方法\"><a href=\"#四-Java中内置的用于线程控制的方法\" class=\"headerlink\" title=\"四 Java中内置的用于线程控制的方法\"></a>四 Java中内置的用于线程控制的方法</h3><p>常见的有以下几个方法：（详细请查看Thread源码）</p>\n<ul>\n<li>join：加入一个线程，是当前线程（调用join的线程所处的线程）阻塞，直到调用join的线程执行完。</li>\n<li>setDaemon：将一个线程设置为后台线程（守护线程），该方法必须在start方法前调用；isDaemon判断一个线程是否是后台线程。</li>\n<li>sleep：是当前正在执行的线程阻塞</li>\n<li>yield：使当前正在执行的线程进入就绪状态。将机会让给与它优先级相同或者比它高的线程，如其优先级很高，完全有可能被JVM的线程调度器再次调用</li>\n<li>setPriority：设置当前线程的优先级</li>\n</ul>\n<h3 id=\"五-线程同步\"><a href=\"#五-线程同步\" class=\"headerlink\" title=\"五 线程同步\"></a>五 线程同步</h3><h5 id=\"1-使用synchronized关键实现同步\"><a href=\"#1-使用synchronized关键实现同步\" class=\"headerlink\" title=\"1. 使用synchronized关键实现同步\"></a>1. 使用synchronized关键实现同步</h5><ul>\n<li>同步代码块<br>使用synchronized对对象进行加锁，如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">synchronized</span>（obj）&#123;</div><div class=\"line\">   </div><div class=\"line\">   <span class=\"comment\">//TODO</span></div><div class=\"line\">   ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>同步方法<br>使用synchronized对方法进行加锁</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> lock（Object obj）&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//TODO</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>synchronized关键字可以对代码块，方法加锁，但不能修饰构造器，成员变量等。</p>\n<p>使用synchronized加锁后，线程什么情况下会释放锁：</p>\n<ul>\n<li>同步方法，代码块执行完毕</li>\n<li>在同步方法，代码块执行中遇到了break，return</li>\n<li>出现了未处理的异常和Error</li>\n<li>调用wait方法</li>\n</ul>\n<p>下列情况下不会释放锁：</p>\n<ul>\n<li>调用sleep，yield方法</li>\n<li>调用suspend方法</li>\n</ul>\n<h5 id=\"2-同步锁\"><a href=\"#2-同步锁\" class=\"headerlink\" title=\"2. 同步锁\"></a>2. 同步锁</h5><p>从java5开始java提供了接口Lock和ReadWriteLock来实现锁同步。Lock接口有个实现类ReentrantLock，ReadWriteLock有个实现类ReentrantReadWriteLock。使用这两个类可以实现锁同步。如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">   lock.lock();</div><div class=\"line\">   <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">      <span class=\"comment\">//需要保证线程安全的代码</span></div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">finally</span>&#123;</div><div class=\"line\">      lock.unlock();</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Java8又新增了一个StampedLock类，在大多数情况下它可以替代ReentrantReadWriteLock。</p>\n<h3 id=\"六-线程通信\"><a href=\"#六-线程通信\" class=\"headerlink\" title=\"六 线程通信\"></a>六 线程通信</h3><h5 id=\"1-传统的线程通信\"><a href=\"#1-传统的线程通信\" class=\"headerlink\" title=\"1.传统的线程通信\"></a>1.传统的线程通信</h5><p>使用wait、notify、notifyAll实现线程通信，适用于使用synchronized关键字来保证线程同步的情况下。代码示例：</p>\n<h5 id=\"2-使用Contition实现线程通信\"><a href=\"#2-使用Contition实现线程通信\" class=\"headerlink\" title=\"2.使用Contition实现线程通信\"></a>2.使用Contition实现线程通信</h5><p>若是使用Lock对象实现线程同步，则无法使用上述的线程通信的方法，java5提供了一个Condition类来实现线程通信。可通过Lock对象的newCondition()方法获得Condition对象，Condition对象中有await，signal，signalAll方法分别对应传统的wait，notify，notifyAll方法，用于实现线程通信。</p>\n<h5 id=\"3-使用阻塞队列实现线程通信\"><a href=\"#3-使用阻塞队列实现线程通信\" class=\"headerlink\" title=\"3.使用阻塞队列实现线程通信\"></a>3.使用阻塞队列实现线程通信</h5><p>java5提供了一个BlockingQueue接口，它有一个特征：当生产者线程试图向BlockingQueue里放入元素时，若队列已满，则该线程被阻塞；当消费者试图从BlockingQueue里取出元素时，若队列为空，这该线程被阻塞。利用此原理可以实现线程通信。</p>\n<p>该接口有几个实现类，可用于构造线程池。</p>\n<h3 id=\"七-线程池\"><a href=\"#七-线程池\" class=\"headerlink\" title=\"七 线程池\"></a>七 线程池</h3><p>线程池即是一个对象池，传入的都是Runnable对象，底层使用数组或者集合来实现。java中内置了一个Executeors工厂类来实现线程池（它还有一个子类ForkjoinPool）,此外还可以使用其他的第三方框架，如ThreadPoolExecutor。</p>\n<h3 id=\"八-ThreadLocal类\"><a href=\"#八-ThreadLocal类\" class=\"headerlink\" title=\"八 ThreadLocal类\"></a>八 ThreadLocal类</h3><p>在处理多线程并发问题上还有一个解决方案，是使用ThreadLocal类将需要并发的资源封装起来，这样当多个线程并发访问这些资源时，ThreadLocal类会为没一个线程均复制一份该资源的副本，从根本上解决了资源的共享冲突问题。但是此方式虽解决了冲突，但多个线程之间也无法共享资源。</p>\n","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>所谓的多线程就是一个程序中存在多个顺序执行流，每个执行流便是一个线程。Java提供了优秀的多线程支持，下面将会详细介绍Java多线程编程的相关知识。</p>\n<h3 id=\"二-线程与进程的比较\"><a href=\"#二-线程与进程的比较\" class=\"headerlink\" title=\"二 线程与进程的比较\"></a>二 线程与进程的比较</h3><p>现在的操作系统基本都支持多进程，即可以同时运行多个任务，每个任务通常是一个程序，每个运行的程序便是一个进程。而一个程序运行时往往有多个顺序执行流，这每个顺序执行流便是一个线程。</p>\n<p>线程与进程的区别：</p>\n<ul>\n<li>线程比进程更轻，并发性更高</li>\n<li>线程可以共享进程的资源，便于实现相互之间的通信</li>\n<li>创建线程的代价比创建进程的代价小得多</li>\n<li>java内置了多线程编程支持，可以非常方便的操作线程</li>\n</ul>\n<p>并发与并行的区别：</p>\n<p>并行是某一时刻同时运行，并发是某一时刻只有一个指令运行，但是多个指令之间切换过快，所以看起来像是同时运行。</p>\n<h3 id=\"三-创建线程的三种方式\"><a href=\"#三-创建线程的三种方式\" class=\"headerlink\" title=\"三 创建线程的三种方式\"></a>三 创建线程的三种方式</h3><h5 id=\"1-继承Thread类创建线程\"><a href=\"#1-继承Thread类创建线程\" class=\"headerlink\" title=\"1.继承Thread类创建线程\"></a>1.继承Thread类创建线程</h5><p>使用Thread类创建线程的步骤如下：</p>\n<ol>\n<li>定义Thread的子类并重写它的run方法，run方法的方法体里面就是线程需要完成的任务</li>\n<li>创建Thread子类的实例，即创建了线程对象</li>\n<li>调用线程对象的start()方法来启动线程</li>\n</ol>\n<p>代码示例：</p>\n<p>抽空写</p>\n<h5 id=\"2-实现Runnable接口创建线程\"><a href=\"#2-实现Runnable接口创建线程\" class=\"headerlink\" title=\"2.实现Runnable接口创建线程\"></a>2.实现Runnable接口创建线程</h5><p>步骤如下：</p>\n<ol>\n<li>实现接口Runnable接口，并实现它的run方法。</li>\n<li>创建Runnable接口实现类的实例，并把它作为参数传给Thread的构造函数，创建Thread对象（即将该实例作为Thread类的Target），并调用它的start方法启动线程。（Runnable接口时函数式接口，可使用Lambda表达式）</li>\n</ol>\n<p>代码示例：</p>\n<ul>\n<li>使用Runnable创建线程的一个优势是多个线程之间可以共享线程类中的实例变量。这也是最常用的一种创建线程的方式，但一般都采用匿名内部类的方式简写。</li>\n</ul>\n<h5 id=\"3-使用Callable和Future创建线程\"><a href=\"#3-使用Callable和Future创建线程\" class=\"headerlink\" title=\"3. 使用Callable和Future创建线程\"></a>3. 使用Callable和Future创建线程</h5><p>从java5开始，java提供了一个Callable接口，接口中提供了一个call()方法来替代run()方法，它比run方法的功能更强大。主要有以下两点：</p>\n<ul>\n<li>call方法可以有返回值</li>\n<li>call方法可以声明抛出异常</li>\n</ul>\n<p>由于Callable接口没有继承Runnable接口，且call方法有返回值，因此实现Callable接口的类无法作为Target传入Thread类中。为此java5提供了Future接口来包装Callable接口创建线程，该接口有一个FutureTask实现类，该类同时也实现了Runnable接口，因此该类的对象可以作为Target传入Thread类中来创建线程。</p>\n<p>创建并启动有返回值的线程的步骤如下：</p>\n<ol>\n<li>创建Callable接口的实现类，并实现它的call方法。、</li>\n<li>创建FutureTask类来包装Callable接口的实现类的对象（Callable是函数式接口，这一步可以是Lambda表达式）</li>\n<li>将FutureTask对象作为Target传入Thread类中，创建线程。</li>\n<li>使用FutureTask对象的get方法得到call的返回值</li>\n</ol>\n<p>Callab接口实现线程与Runnable接口类似，因此它也有Runnable接口的优势。</p>\n<h5 id=\"4-创建线程的三种方式对比\"><a href=\"#4-创建线程的三种方式对比\" class=\"headerlink\" title=\"4. 创建线程的三种方式对比\"></a>4. 创建线程的三种方式对比</h5><p>使用Runnable和Callable接口创建线程的优势：</p>\n<ul>\n<li>因为是实现接口，还可以继承其他类，避免由于Java的单继承特性而带来的局限。</li>\n<li>这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而将CPU，代码和数据分开，更清晰。</li>\n</ul>\n<p>劣势：</p>\n<ul>\n<li>编程稍稍复杂，且要访问当前线程，需要使用Thread.currentThread()方法获取当前线程的实例</li>\n</ul>\n<p>使用继承Thread类的方式优势：</p>\n<ul>\n<li>编程简单</li>\n</ul>\n<p>劣势：</p>\n<p>因为已经继承了Thread类，无法再继承其他的类。</p>\n<h3 id=\"三-线程的生命周期\"><a href=\"#三-线程的生命周期\" class=\"headerlink\" title=\"三 线程的生命周期\"></a>三 线程的生命周期</h3><p>Java中的线程总结起来可以划分为5个生命周期：</p>\n<ul>\n<li>新建：创建Thread类或其子类对象</li>\n<li>就绪（可运行）：调用Thread类的start方法启动线程，此时线程处于可运行状态，但何时运行取决于JVM线程调度器的调度。一个就绪的线程只有获得CPU时间片才可以进入运行状态。</li>\n<li>运行：获得CPU时间片开始运行。现在的操作系统基本上都是抢占式调度策略（当然也有些小型设备是协作式调度策略），即当前时间片用完，即会被其他线程抢占（取决于优先级）。</li>\n<li>阻塞：有sleep、join或者IO造成的线程阻塞（调用suspend()也可以使线程挂起，但是该方法容易导致死锁，已不推荐使用）</li>\n<li>死亡：run结束或者异常。（调用stop方法也可以结束线程，但该方法容易造成死锁，已不推荐使用）</li>\n</ul>\n<p>下面是线程状态转换图：</p>\n<img src=\"/2017/03/16/Java基础之线程/Java线程状态转换图.png\" alt=\"Java线程状态转换图\" title=\"Java线程状态转换图\">\n<h3 id=\"四-Java中内置的用于线程控制的方法\"><a href=\"#四-Java中内置的用于线程控制的方法\" class=\"headerlink\" title=\"四 Java中内置的用于线程控制的方法\"></a>四 Java中内置的用于线程控制的方法</h3><p>常见的有以下几个方法：（详细请查看Thread源码）</p>\n<ul>\n<li>join：加入一个线程，是当前线程（调用join的线程所处的线程）阻塞，直到调用join的线程执行完。</li>\n<li>setDaemon：将一个线程设置为后台线程（守护线程），该方法必须在start方法前调用；isDaemon判断一个线程是否是后台线程。</li>\n<li>sleep：是当前正在执行的线程阻塞</li>\n<li>yield：使当前正在执行的线程进入就绪状态。将机会让给与它优先级相同或者比它高的线程，如其优先级很高，完全有可能被JVM的线程调度器再次调用</li>\n<li>setPriority：设置当前线程的优先级</li>\n</ul>\n<h3 id=\"五-线程同步\"><a href=\"#五-线程同步\" class=\"headerlink\" title=\"五 线程同步\"></a>五 线程同步</h3><h5 id=\"1-使用synchronized关键实现同步\"><a href=\"#1-使用synchronized关键实现同步\" class=\"headerlink\" title=\"1. 使用synchronized关键实现同步\"></a>1. 使用synchronized关键实现同步</h5><ul>\n<li>同步代码块<br>使用synchronized对对象进行加锁，如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">synchronized</span>（obj）&#123;</div><div class=\"line\">   </div><div class=\"line\">   <span class=\"comment\">//TODO</span></div><div class=\"line\">   ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>同步方法<br>使用synchronized对方法进行加锁</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> lock（Object obj）&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//TODO</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>synchronized关键字可以对代码块，方法加锁，但不能修饰构造器，成员变量等。</p>\n<p>使用synchronized加锁后，线程什么情况下会释放锁：</p>\n<ul>\n<li>同步方法，代码块执行完毕</li>\n<li>在同步方法，代码块执行中遇到了break，return</li>\n<li>出现了未处理的异常和Error</li>\n<li>调用wait方法</li>\n</ul>\n<p>下列情况下不会释放锁：</p>\n<ul>\n<li>调用sleep，yield方法</li>\n<li>调用suspend方法</li>\n</ul>\n<h5 id=\"2-同步锁\"><a href=\"#2-同步锁\" class=\"headerlink\" title=\"2. 同步锁\"></a>2. 同步锁</h5><p>从java5开始java提供了接口Lock和ReadWriteLock来实现锁同步。Lock接口有个实现类ReentrantLock，ReadWriteLock有个实现类ReentrantReadWriteLock。使用这两个类可以实现锁同步。如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">   lock.lock();</div><div class=\"line\">   <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">      <span class=\"comment\">//需要保证线程安全的代码</span></div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">finally</span>&#123;</div><div class=\"line\">      lock.unlock();</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Java8又新增了一个StampedLock类，在大多数情况下它可以替代ReentrantReadWriteLock。</p>\n<h3 id=\"六-线程通信\"><a href=\"#六-线程通信\" class=\"headerlink\" title=\"六 线程通信\"></a>六 线程通信</h3><h5 id=\"1-传统的线程通信\"><a href=\"#1-传统的线程通信\" class=\"headerlink\" title=\"1.传统的线程通信\"></a>1.传统的线程通信</h5><p>使用wait、notify、notifyAll实现线程通信，适用于使用synchronized关键字来保证线程同步的情况下。代码示例：</p>\n<h5 id=\"2-使用Contition实现线程通信\"><a href=\"#2-使用Contition实现线程通信\" class=\"headerlink\" title=\"2.使用Contition实现线程通信\"></a>2.使用Contition实现线程通信</h5><p>若是使用Lock对象实现线程同步，则无法使用上述的线程通信的方法，java5提供了一个Condition类来实现线程通信。可通过Lock对象的newCondition()方法获得Condition对象，Condition对象中有await，signal，signalAll方法分别对应传统的wait，notify，notifyAll方法，用于实现线程通信。</p>\n<h5 id=\"3-使用阻塞队列实现线程通信\"><a href=\"#3-使用阻塞队列实现线程通信\" class=\"headerlink\" title=\"3.使用阻塞队列实现线程通信\"></a>3.使用阻塞队列实现线程通信</h5><p>java5提供了一个BlockingQueue接口，它有一个特征：当生产者线程试图向BlockingQueue里放入元素时，若队列已满，则该线程被阻塞；当消费者试图从BlockingQueue里取出元素时，若队列为空，这该线程被阻塞。利用此原理可以实现线程通信。</p>\n<p>该接口有几个实现类，可用于构造线程池。</p>\n<h3 id=\"七-线程池\"><a href=\"#七-线程池\" class=\"headerlink\" title=\"七 线程池\"></a>七 线程池</h3><p>线程池即是一个对象池，传入的都是Runnable对象，底层使用数组或者集合来实现。java中内置了一个Executeors工厂类来实现线程池（它还有一个子类ForkjoinPool）,此外还可以使用其他的第三方框架，如ThreadPoolExecutor。</p>\n<h3 id=\"八-ThreadLocal类\"><a href=\"#八-ThreadLocal类\" class=\"headerlink\" title=\"八 ThreadLocal类\"></a>八 ThreadLocal类</h3><p>在处理多线程并发问题上还有一个解决方案，是使用ThreadLocal类将需要并发的资源封装起来，这样当多个线程并发访问这些资源时，ThreadLocal类会为没一个线程均复制一份该资源的副本，从根本上解决了资源的共享冲突问题。但是此方式虽解决了冲突，但多个线程之间也无法共享资源。</p>\n"},{"title":"Java基础语法","date":"2017-03-17T02:27:13.000Z","_content":"","source":"_posts/Java基础语法.md","raw":"---\ntitle: Java基础语法\ndate: 2017-03-17 10:27:13\ncategories:\ntags:\n---\n","slug":"Java基础语法","published":1,"updated":"2017-03-17T02:27:13.551Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk1e000gaknzhq4mo739","content":"","excerpt":"","more":""},{"title":"SQL基础","date":"2017-03-29T03:21:06.000Z","_content":"\n### 一 概述\n\nSQL是Structure Query Language的缩写，它是关系型数据库的应用语言。有IBM在20世纪70年代开发出来，作为IBM关系数据库原型System R的原型关系语言，实现了关系型数据库的信息检索。1986年，美国国家标准局（ANSI）制定出了SQL标准，目前绝大多数关系型数据库均支持SQL标准。本文的SQL语句是基于mysql的，有些语句在其他数据库上未必适用。\n\n### 二 SQL语句\n\nSQL语句不区分大小写，可以划分为3个类别：\n\n- DDL语句：数据定义语言。用于定义数据段，数据库，表，列，索引等数据库对象，如create，drop，alter等\n- DML语句：数据操纵语言。用于添加，删除，更新，查询数据库记录，并检查数据完整性，如insert，delete，update，select等\n- DCL语句：数据控制语句。用于定义数据库，表，字段，用户等的访问权限和安全级别，如grant，revoke等\n\n#### 1.DDL语句\n\n##### 创建数据库\n\n创建数据库\n\n```bash\ncreate database 数据库名;\n```\n\n使用数据库\n\n```bash\nuse 数据库名;\n```\n\n展示一个数据库中所有的表\n\n```bash\nshow tables;\n```\n\n##### 删除数据库\n \n删除数据库\n\n```bash\ndrop database 数据库名;\n```\n\n##### 创建表\n\n创建表\n\n```bash\ncreate table emp(\n\tename varchar(10),\n\thiredate date,\n\tsal decimal(10,2)\n\tdeptno int(2)\n);\n```\n\n展示表信息\n\n```bash\ndesc emp;\n```\n\n展示创建表的SQL语句信息\n\n```bash\nshow create table emp \\G;\n```\n\n##### 删除表（drop）\n\n删除表\n\n```bash\ndrop table emp;\n```\n\n##### 修改表（alter）\n\n修改表字段类型\n\n```bash\nalter table emp modify ename varchar(20);\n```\n\n增加表字段\n\n```bash\nalter table emp add columu age int(3);\n``` \n\n删除表字段\n\n```bash\nalter table emp drop columu age;\n``` \n\n字段改名(mysql在标准SQL上的扩展)\n\n```bash\nalter table emp change age age1 int(4); //同时将字段类型改为int(4)\n```\n\n修改字段排列顺序first/after(mysql在标准SQL上的扩展)\n\n```bash\nalter table emp add birth date after ename;\n```\n\n```bash\nalter table emp modify age int(3) first;\n```\n\n表改名\n\n```bash\nalter table emp rename emp1;\n```\n\n#### 2.DML语句\n\nDML语句用于操作表中的数据。\n\n##### 插入数据\n\n```bash\ninsert into emp (ename,hiredate,sal,deptno) values ('zzx1','2000-01-01','2000',1);\n//在数据库中单引号和双引号的效果相同\n```\n\n##### 更新数据\n\n```bash\nupdate emp set sal=4000 where ename='lisa'\n```\n\n更新多表\n\n```bash\nupdate emp a,dept b set a.sal=a.sal*b.deptno,b.deptname=a.ename where a.deptno=b.deptno;\n```\n\n##### 删除数据\n\n```bash\ndelete from  emp where ename='lisa'\n```\n\n删除多表\n\n```bash\ndelete a,b from emp a,dept b where a.deptno=b.deptno and a.deptno=3;\n```\n\n##### 查询数据\n\n```bash\nselect * from emp\n```\n\n查询不重复的数据\n\n```bash\nselect distinct deptno from emp\n```\n\n条件查询\n\n```bash\nselect * from emp where deptno=1\n```\n\n```bash\nselect * from emp where deptno=1 and sal>=3000\n```\n\n##### 排序\n\n```bash\nselect * from emp order by deptno;\n```\n\n限制显示条数（mysql特有，常用于分页操作）\n\n```bash\nselect * from emp order by deptno limit 3;\n```\n\n##### 聚合\n\n- 聚合函数：sum,count,max,min\n- group by:表示要分类聚合的字段\n- with rollup：可选，表示是否对分类聚合后的结果进行在汇总\n- having：表示对分类聚合后的结果在进行条件查询（having与where不同，where是对聚前的数据进行条件过滤而having是聚合后，通常如果可以聚合前进行过滤优先考虑聚合前，这样需要聚合的集合更小，性能更高）\n\n统计总人数\n\n```bash\nselect count(1) from emp;\n```\n\n统计各部门人数\n\n```bash\nselect deptno,count(1) from emp group by deptno;\n```\n\n统计各部门人数并汇总（汇总即是计算某一列所有数据的和）\n\n```bash\nselect deptno,count(1) from emp group by deptno with rollup;\n```\n\n统计人数大于1的部门\n\n```bash\nselect deptno,count(1) from emp group by deptno having count(1)>1;\n```\n\n##### 表连接\n\n当需要同时显示多个表中的字段时，就可以使用表连接来实现，表连接分为内连接和外连接。\n\n- 内连接：显示两张表中相匹配的数据\n- 外连接：显示两张表中不匹配的数据\n\n内连接（有一个特例自然连接，自动去除重复的记录）\n\n```bash\nselect ename,deptname from emp,dept where emp.deptno=dept.deptno;\n//ename是emp中的字段，deptname是dept中的字段\n```\n\n自然连接\n\n```bash\nselect ename,deptname from emp join dept where emp.deptno=dept.deptno;\n```\n\n外连接\n\n外连接又分为左连接和右连接\n\n- 左连接：包含两表相匹配的列和左边表中不匹配的记录\n- 右连接：包含两表中相匹配的列和右边表中不匹配的记录\n- 全连接：返回两表中的所有记录\n- 交叉连接：生成两表的笛卡尔积\n\n左连接\n\n```bash\nselect ename,deptname from emp left join dept on emp.deptno=dept.deptno;\n```\n\n右连接\n\n```bash\nselect ename,deptname from emp right join dept on emp.deptno=dept.deptno;\n```\n\n全连接\n\n```bash\nselect ename,deptname from emp outer join dept on emp.deptno=dept.deptno;\n```\n\n交叉连接\n\n```bash\nselect ename,deptname from emp cross join dept on emp.deptno=dept.deptno;\n```\n\n##### 子查询\n\n有时候当我们查询的时候需要的条件是另一个select语句的查询结果，这个时候就会用到子查询。子查询的关键字包括in，not in，=，！=，exits，not exits。\n\n```bash\nselect * from emp where deptno in(select deptno from dept);\n//如果子查询记录唯一应该用=代替，=的性能比in要好\n```\n\n有些子查询可以被表连接代替，如果可以被表连接代替使用表连接，表连接的性能比子查询要好。\n\n##### 记录联合\n\n有时候我们需要将两个select语句的查询结果合在一起显示，这是可以使用union和union all。\n\n```bash\nselect deptno from union all select deptno from dept;\n```\n\n若需要去重，则\n\n```bash\nselect deptno from union select deptno from dept;\n```\n\n#### DCL语句\n\n一般是DBA使用，一般开发人员很少接触。\n\n#### 查看帮助文档\n\n可以使用“？ 关键字”的形式来查询某个关键字的用法，如果不知道有哪些命令可以使用“？ contents”来查询所有可供查询的分类。\n\n### 三 mysql支持的数据类型\n\n各个关系型数据库可能不同，我们应该了解所使用数据库支持的数据类型，这样在设计表时才能选择合适的数据类型。\n\n### 四 函数\n\n各个数据库可能不同，如字符串函数，数值函数，流程函数等\n\n### 五 mysql存储引擎\n\n插件式存储引擎是mysql最大的特性之一，它支持多种存储引擎。这之后会单独写个博客\n\n### 六 字符集\n\n各个数据库支持的不同\n\n### 七 索引\n\n这方面之后要单独写博客。\n\n### 八 视图\n\n视图是一张虚表，即并非真实存在的表。通常我们会将那些经常查询的数据生成视图，这样便于查询，但是视图中并没有数据，数据仍然在表中。\n\n视图相对于普通表的优势有以下几点：\n\n- 简单：使用视图的用户完全不需要关心后面对应的表结构，关联条件和筛选条件，视图就是已经过滤好的复合条件的结果集。\n- 安全：可以只向用户提供所需查询的结果集的视图，而限制其对表结构的访问，保证了数据的安全。\n- 数据独立：一旦视图已经生成了，对表增加列并不会影响到视图（如果改表名的话，需要更改视图）。\n\n视图其实就是固化的一次select语句的结果集，之后每次查询这个结果集只需要查询视图即可。\n\n##### 创建视图\n\n```bash\ncreate view staff_list_view as\nselect s.staff_id,s.first_name,s.last_name,s.address\nfrom staff as s,address as a\nwhere s.address_id=a.sddress_id;\n```\n\nmysql的视图定义有一些限制，如：在from关键字后面不能包含子查询，只能使用视图（将该子查询定义成视图，再查询视图生成视图）代替。\n\n视图的可更新性与视图中查询的定义有关系，以下视图不可更新：\n\n- 包含下列关键字的sql语句：sum,max,min,count,distinct,group by,having,union,union all等\n- 常量视图\n- select中包含子查询\n- join\n- from一个不能更新的视图\n- where字句的子查询引用了from字句中的表\n\n#####  删除视图\n\n```bash\ndrop view staff_list_view;\n```\n\n##### 查看视图\n\n与查看表相同\n\n### 九 存储过程与函数\n\n存储过程和函数都是事先经过编译并存储在数据库中的一段sql语句的集合。这两者不同的是函数有返回值而存储过程没有。\n这里涉及到变量，条件，游标的使用，并且可使用流程函数（IF，CASE等）。这个在之后继续深入学习数据库时再详细介绍。\n\n### 十 触发器\n\n触发器也是sql语句的集合，但是它不需要手动执行，在达到某个条件时，它会自动执行相应的语句，即为触发。\n\n### 十一 事务控制与锁定语句\n\n锁，事务提交，回滚\n\n### 十二 SQL中的安全问题\n\nSQL注入。\n\n### 十三 SQL Model及其相关问题\n\n\n\n\n\n","source":"_posts/SQL基础.md","raw":"---\ntitle: SQL基础\ndate: 2017-03-29 11:21:06\ncategories: 数据库\ntags:\n- SQL\n---\n\n### 一 概述\n\nSQL是Structure Query Language的缩写，它是关系型数据库的应用语言。有IBM在20世纪70年代开发出来，作为IBM关系数据库原型System R的原型关系语言，实现了关系型数据库的信息检索。1986年，美国国家标准局（ANSI）制定出了SQL标准，目前绝大多数关系型数据库均支持SQL标准。本文的SQL语句是基于mysql的，有些语句在其他数据库上未必适用。\n\n### 二 SQL语句\n\nSQL语句不区分大小写，可以划分为3个类别：\n\n- DDL语句：数据定义语言。用于定义数据段，数据库，表，列，索引等数据库对象，如create，drop，alter等\n- DML语句：数据操纵语言。用于添加，删除，更新，查询数据库记录，并检查数据完整性，如insert，delete，update，select等\n- DCL语句：数据控制语句。用于定义数据库，表，字段，用户等的访问权限和安全级别，如grant，revoke等\n\n#### 1.DDL语句\n\n##### 创建数据库\n\n创建数据库\n\n```bash\ncreate database 数据库名;\n```\n\n使用数据库\n\n```bash\nuse 数据库名;\n```\n\n展示一个数据库中所有的表\n\n```bash\nshow tables;\n```\n\n##### 删除数据库\n \n删除数据库\n\n```bash\ndrop database 数据库名;\n```\n\n##### 创建表\n\n创建表\n\n```bash\ncreate table emp(\n\tename varchar(10),\n\thiredate date,\n\tsal decimal(10,2)\n\tdeptno int(2)\n);\n```\n\n展示表信息\n\n```bash\ndesc emp;\n```\n\n展示创建表的SQL语句信息\n\n```bash\nshow create table emp \\G;\n```\n\n##### 删除表（drop）\n\n删除表\n\n```bash\ndrop table emp;\n```\n\n##### 修改表（alter）\n\n修改表字段类型\n\n```bash\nalter table emp modify ename varchar(20);\n```\n\n增加表字段\n\n```bash\nalter table emp add columu age int(3);\n``` \n\n删除表字段\n\n```bash\nalter table emp drop columu age;\n``` \n\n字段改名(mysql在标准SQL上的扩展)\n\n```bash\nalter table emp change age age1 int(4); //同时将字段类型改为int(4)\n```\n\n修改字段排列顺序first/after(mysql在标准SQL上的扩展)\n\n```bash\nalter table emp add birth date after ename;\n```\n\n```bash\nalter table emp modify age int(3) first;\n```\n\n表改名\n\n```bash\nalter table emp rename emp1;\n```\n\n#### 2.DML语句\n\nDML语句用于操作表中的数据。\n\n##### 插入数据\n\n```bash\ninsert into emp (ename,hiredate,sal,deptno) values ('zzx1','2000-01-01','2000',1);\n//在数据库中单引号和双引号的效果相同\n```\n\n##### 更新数据\n\n```bash\nupdate emp set sal=4000 where ename='lisa'\n```\n\n更新多表\n\n```bash\nupdate emp a,dept b set a.sal=a.sal*b.deptno,b.deptname=a.ename where a.deptno=b.deptno;\n```\n\n##### 删除数据\n\n```bash\ndelete from  emp where ename='lisa'\n```\n\n删除多表\n\n```bash\ndelete a,b from emp a,dept b where a.deptno=b.deptno and a.deptno=3;\n```\n\n##### 查询数据\n\n```bash\nselect * from emp\n```\n\n查询不重复的数据\n\n```bash\nselect distinct deptno from emp\n```\n\n条件查询\n\n```bash\nselect * from emp where deptno=1\n```\n\n```bash\nselect * from emp where deptno=1 and sal>=3000\n```\n\n##### 排序\n\n```bash\nselect * from emp order by deptno;\n```\n\n限制显示条数（mysql特有，常用于分页操作）\n\n```bash\nselect * from emp order by deptno limit 3;\n```\n\n##### 聚合\n\n- 聚合函数：sum,count,max,min\n- group by:表示要分类聚合的字段\n- with rollup：可选，表示是否对分类聚合后的结果进行在汇总\n- having：表示对分类聚合后的结果在进行条件查询（having与where不同，where是对聚前的数据进行条件过滤而having是聚合后，通常如果可以聚合前进行过滤优先考虑聚合前，这样需要聚合的集合更小，性能更高）\n\n统计总人数\n\n```bash\nselect count(1) from emp;\n```\n\n统计各部门人数\n\n```bash\nselect deptno,count(1) from emp group by deptno;\n```\n\n统计各部门人数并汇总（汇总即是计算某一列所有数据的和）\n\n```bash\nselect deptno,count(1) from emp group by deptno with rollup;\n```\n\n统计人数大于1的部门\n\n```bash\nselect deptno,count(1) from emp group by deptno having count(1)>1;\n```\n\n##### 表连接\n\n当需要同时显示多个表中的字段时，就可以使用表连接来实现，表连接分为内连接和外连接。\n\n- 内连接：显示两张表中相匹配的数据\n- 外连接：显示两张表中不匹配的数据\n\n内连接（有一个特例自然连接，自动去除重复的记录）\n\n```bash\nselect ename,deptname from emp,dept where emp.deptno=dept.deptno;\n//ename是emp中的字段，deptname是dept中的字段\n```\n\n自然连接\n\n```bash\nselect ename,deptname from emp join dept where emp.deptno=dept.deptno;\n```\n\n外连接\n\n外连接又分为左连接和右连接\n\n- 左连接：包含两表相匹配的列和左边表中不匹配的记录\n- 右连接：包含两表中相匹配的列和右边表中不匹配的记录\n- 全连接：返回两表中的所有记录\n- 交叉连接：生成两表的笛卡尔积\n\n左连接\n\n```bash\nselect ename,deptname from emp left join dept on emp.deptno=dept.deptno;\n```\n\n右连接\n\n```bash\nselect ename,deptname from emp right join dept on emp.deptno=dept.deptno;\n```\n\n全连接\n\n```bash\nselect ename,deptname from emp outer join dept on emp.deptno=dept.deptno;\n```\n\n交叉连接\n\n```bash\nselect ename,deptname from emp cross join dept on emp.deptno=dept.deptno;\n```\n\n##### 子查询\n\n有时候当我们查询的时候需要的条件是另一个select语句的查询结果，这个时候就会用到子查询。子查询的关键字包括in，not in，=，！=，exits，not exits。\n\n```bash\nselect * from emp where deptno in(select deptno from dept);\n//如果子查询记录唯一应该用=代替，=的性能比in要好\n```\n\n有些子查询可以被表连接代替，如果可以被表连接代替使用表连接，表连接的性能比子查询要好。\n\n##### 记录联合\n\n有时候我们需要将两个select语句的查询结果合在一起显示，这是可以使用union和union all。\n\n```bash\nselect deptno from union all select deptno from dept;\n```\n\n若需要去重，则\n\n```bash\nselect deptno from union select deptno from dept;\n```\n\n#### DCL语句\n\n一般是DBA使用，一般开发人员很少接触。\n\n#### 查看帮助文档\n\n可以使用“？ 关键字”的形式来查询某个关键字的用法，如果不知道有哪些命令可以使用“？ contents”来查询所有可供查询的分类。\n\n### 三 mysql支持的数据类型\n\n各个关系型数据库可能不同，我们应该了解所使用数据库支持的数据类型，这样在设计表时才能选择合适的数据类型。\n\n### 四 函数\n\n各个数据库可能不同，如字符串函数，数值函数，流程函数等\n\n### 五 mysql存储引擎\n\n插件式存储引擎是mysql最大的特性之一，它支持多种存储引擎。这之后会单独写个博客\n\n### 六 字符集\n\n各个数据库支持的不同\n\n### 七 索引\n\n这方面之后要单独写博客。\n\n### 八 视图\n\n视图是一张虚表，即并非真实存在的表。通常我们会将那些经常查询的数据生成视图，这样便于查询，但是视图中并没有数据，数据仍然在表中。\n\n视图相对于普通表的优势有以下几点：\n\n- 简单：使用视图的用户完全不需要关心后面对应的表结构，关联条件和筛选条件，视图就是已经过滤好的复合条件的结果集。\n- 安全：可以只向用户提供所需查询的结果集的视图，而限制其对表结构的访问，保证了数据的安全。\n- 数据独立：一旦视图已经生成了，对表增加列并不会影响到视图（如果改表名的话，需要更改视图）。\n\n视图其实就是固化的一次select语句的结果集，之后每次查询这个结果集只需要查询视图即可。\n\n##### 创建视图\n\n```bash\ncreate view staff_list_view as\nselect s.staff_id,s.first_name,s.last_name,s.address\nfrom staff as s,address as a\nwhere s.address_id=a.sddress_id;\n```\n\nmysql的视图定义有一些限制，如：在from关键字后面不能包含子查询，只能使用视图（将该子查询定义成视图，再查询视图生成视图）代替。\n\n视图的可更新性与视图中查询的定义有关系，以下视图不可更新：\n\n- 包含下列关键字的sql语句：sum,max,min,count,distinct,group by,having,union,union all等\n- 常量视图\n- select中包含子查询\n- join\n- from一个不能更新的视图\n- where字句的子查询引用了from字句中的表\n\n#####  删除视图\n\n```bash\ndrop view staff_list_view;\n```\n\n##### 查看视图\n\n与查看表相同\n\n### 九 存储过程与函数\n\n存储过程和函数都是事先经过编译并存储在数据库中的一段sql语句的集合。这两者不同的是函数有返回值而存储过程没有。\n这里涉及到变量，条件，游标的使用，并且可使用流程函数（IF，CASE等）。这个在之后继续深入学习数据库时再详细介绍。\n\n### 十 触发器\n\n触发器也是sql语句的集合，但是它不需要手动执行，在达到某个条件时，它会自动执行相应的语句，即为触发。\n\n### 十一 事务控制与锁定语句\n\n锁，事务提交，回滚\n\n### 十二 SQL中的安全问题\n\nSQL注入。\n\n### 十三 SQL Model及其相关问题\n\n\n\n\n\n","slug":"SQL基础","published":1,"updated":"2017-03-30T07:13:32.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk1h000jaknzna7z366z","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>SQL是Structure Query Language的缩写，它是关系型数据库的应用语言。有IBM在20世纪70年代开发出来，作为IBM关系数据库原型System R的原型关系语言，实现了关系型数据库的信息检索。1986年，美国国家标准局（ANSI）制定出了SQL标准，目前绝大多数关系型数据库均支持SQL标准。本文的SQL语句是基于mysql的，有些语句在其他数据库上未必适用。</p>\n<h3 id=\"二-SQL语句\"><a href=\"#二-SQL语句\" class=\"headerlink\" title=\"二 SQL语句\"></a>二 SQL语句</h3><p>SQL语句不区分大小写，可以划分为3个类别：</p>\n<ul>\n<li>DDL语句：数据定义语言。用于定义数据段，数据库，表，列，索引等数据库对象，如create，drop，alter等</li>\n<li>DML语句：数据操纵语言。用于添加，删除，更新，查询数据库记录，并检查数据完整性，如insert，delete，update，select等</li>\n<li>DCL语句：数据控制语句。用于定义数据库，表，字段，用户等的访问权限和安全级别，如grant，revoke等</li>\n</ul>\n<h4 id=\"1-DDL语句\"><a href=\"#1-DDL语句\" class=\"headerlink\" title=\"1.DDL语句\"></a>1.DDL语句</h4><h5 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h5><p>创建数据库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">create database 数据库名;</div></pre></td></tr></table></figure>\n<p>使用数据库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">use 数据库名;</div></pre></td></tr></table></figure>\n<p>展示一个数据库中所有的表</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">show tables;</div></pre></td></tr></table></figure>\n<h5 id=\"删除数据库\"><a href=\"#删除数据库\" class=\"headerlink\" title=\"删除数据库\"></a>删除数据库</h5><p>删除数据库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">drop database 数据库名;</div></pre></td></tr></table></figure>\n<h5 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h5><p>创建表</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">create table emp(</div><div class=\"line\">\tename varchar(10),</div><div class=\"line\">\thiredate date,</div><div class=\"line\">\tsal decimal(10,2)</div><div class=\"line\">\tdeptno int(2)</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>展示表信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">desc emp;</div></pre></td></tr></table></figure>\n<p>展示创建表的SQL语句信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">show create table emp \\G;</div></pre></td></tr></table></figure>\n<h5 id=\"删除表（drop）\"><a href=\"#删除表（drop）\" class=\"headerlink\" title=\"删除表（drop）\"></a>删除表（drop）</h5><p>删除表</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">drop table emp;</div></pre></td></tr></table></figure>\n<h5 id=\"修改表（alter）\"><a href=\"#修改表（alter）\" class=\"headerlink\" title=\"修改表（alter）\"></a>修改表（alter）</h5><p>修改表字段类型</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">alter table emp modify ename varchar(20);</div></pre></td></tr></table></figure>\n<p>增加表字段</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">alter table emp add columu age int(3);</div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">删除表字段</div><div class=\"line\"></div><div class=\"line\">```bash</div><div class=\"line\">alter table emp drop columu age;</div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">字段改名(mysql在标准SQL上的扩展)</div><div class=\"line\"></div><div class=\"line\">```bash</div><div class=\"line\">alter table emp change age age1 int(4); //同时将字段类型改为int(4)</div></pre></td></tr></table></figure>\n<p>修改字段排列顺序first/after(mysql在标准SQL上的扩展)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">alter table emp add birth date after ename;</div></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">alter table emp modify age int(3) first;</div></pre></td></tr></table></figure>\n<p>表改名</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">alter table emp rename emp1;</div></pre></td></tr></table></figure>\n<h4 id=\"2-DML语句\"><a href=\"#2-DML语句\" class=\"headerlink\" title=\"2.DML语句\"></a>2.DML语句</h4><p>DML语句用于操作表中的数据。</p>\n<h5 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">insert into emp (ename,hiredate,sal,deptno) values (<span class=\"string\">'zzx1'</span>,<span class=\"string\">'2000-01-01'</span>,<span class=\"string\">'2000'</span>,1);</div><div class=\"line\">//在数据库中单引号和双引号的效果相同</div></pre></td></tr></table></figure>\n<h5 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">update emp <span class=\"built_in\">set</span> sal=4000 <span class=\"built_in\">where</span> ename=<span class=\"string\">'lisa'</span></div></pre></td></tr></table></figure>\n<p>更新多表</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">update emp a,dept b <span class=\"built_in\">set</span> a.sal=a.sal*b.deptno,b.deptname=a.ename <span class=\"built_in\">where</span> a.deptno=b.deptno;</div></pre></td></tr></table></figure>\n<h5 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">delete from  emp <span class=\"built_in\">where</span> ename=<span class=\"string\">'lisa'</span></div></pre></td></tr></table></figure>\n<p>删除多表</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">delete a,b from emp a,dept b <span class=\"built_in\">where</span> a.deptno=b.deptno and a.deptno=3;</div></pre></td></tr></table></figure>\n<h5 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select * from emp</div></pre></td></tr></table></figure>\n<p>查询不重复的数据</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select distinct deptno from emp</div></pre></td></tr></table></figure>\n<p>条件查询</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select * from emp <span class=\"built_in\">where</span> deptno=1</div></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select * from emp <span class=\"built_in\">where</span> deptno=1 and sal&gt;=3000</div></pre></td></tr></table></figure>\n<h5 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select * from emp order by deptno;</div></pre></td></tr></table></figure>\n<p>限制显示条数（mysql特有，常用于分页操作）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select * from emp order by deptno <span class=\"built_in\">limit</span> 3;</div></pre></td></tr></table></figure>\n<h5 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h5><ul>\n<li>聚合函数：sum,count,max,min</li>\n<li>group by:表示要分类聚合的字段</li>\n<li>with rollup：可选，表示是否对分类聚合后的结果进行在汇总</li>\n<li>having：表示对分类聚合后的结果在进行条件查询（having与where不同，where是对聚前的数据进行条件过滤而having是聚合后，通常如果可以聚合前进行过滤优先考虑聚合前，这样需要聚合的集合更小，性能更高）</li>\n</ul>\n<p>统计总人数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select count(1) from emp;</div></pre></td></tr></table></figure>\n<p>统计各部门人数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select deptno,count(1) from emp group by deptno;</div></pre></td></tr></table></figure>\n<p>统计各部门人数并汇总（汇总即是计算某一列所有数据的和）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select deptno,count(1) from emp group by deptno with rollup;</div></pre></td></tr></table></figure>\n<p>统计人数大于1的部门</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select deptno,count(1) from emp group by deptno having count(1)&gt;1;</div></pre></td></tr></table></figure>\n<h5 id=\"表连接\"><a href=\"#表连接\" class=\"headerlink\" title=\"表连接\"></a>表连接</h5><p>当需要同时显示多个表中的字段时，就可以使用表连接来实现，表连接分为内连接和外连接。</p>\n<ul>\n<li>内连接：显示两张表中相匹配的数据</li>\n<li>外连接：显示两张表中不匹配的数据</li>\n</ul>\n<p>内连接（有一个特例自然连接，自动去除重复的记录）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">select ename,deptname from emp,dept <span class=\"built_in\">where</span> emp.deptno=dept.deptno;</div><div class=\"line\">//ename是emp中的字段，deptname是dept中的字段</div></pre></td></tr></table></figure>\n<p>自然连接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select ename,deptname from emp join dept <span class=\"built_in\">where</span> emp.deptno=dept.deptno;</div></pre></td></tr></table></figure>\n<p>外连接</p>\n<p>外连接又分为左连接和右连接</p>\n<ul>\n<li>左连接：包含两表相匹配的列和左边表中不匹配的记录</li>\n<li>右连接：包含两表中相匹配的列和右边表中不匹配的记录</li>\n<li>全连接：返回两表中的所有记录</li>\n<li>交叉连接：生成两表的笛卡尔积</li>\n</ul>\n<p>左连接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select ename,deptname from emp left join dept on emp.deptno=dept.deptno;</div></pre></td></tr></table></figure>\n<p>右连接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select ename,deptname from emp right join dept on emp.deptno=dept.deptno;</div></pre></td></tr></table></figure>\n<p>全连接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select ename,deptname from emp outer join dept on emp.deptno=dept.deptno;</div></pre></td></tr></table></figure>\n<p>交叉连接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select ename,deptname from emp cross join dept on emp.deptno=dept.deptno;</div></pre></td></tr></table></figure>\n<h5 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h5><p>有时候当我们查询的时候需要的条件是另一个select语句的查询结果，这个时候就会用到子查询。子查询的关键字包括in，not in，=，！=，exits，not exits。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">select * from emp <span class=\"built_in\">where</span> deptno <span class=\"keyword\">in</span>(select deptno from dept);</div><div class=\"line\">//如果子查询记录唯一应该用=代替，=的性能比<span class=\"keyword\">in</span>要好</div></pre></td></tr></table></figure>\n<p>有些子查询可以被表连接代替，如果可以被表连接代替使用表连接，表连接的性能比子查询要好。</p>\n<h5 id=\"记录联合\"><a href=\"#记录联合\" class=\"headerlink\" title=\"记录联合\"></a>记录联合</h5><p>有时候我们需要将两个select语句的查询结果合在一起显示，这是可以使用union和union all。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select deptno from union all select deptno from dept;</div></pre></td></tr></table></figure>\n<p>若需要去重，则</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select deptno from union select deptno from dept;</div></pre></td></tr></table></figure>\n<h4 id=\"DCL语句\"><a href=\"#DCL语句\" class=\"headerlink\" title=\"DCL语句\"></a>DCL语句</h4><p>一般是DBA使用，一般开发人员很少接触。</p>\n<h4 id=\"查看帮助文档\"><a href=\"#查看帮助文档\" class=\"headerlink\" title=\"查看帮助文档\"></a>查看帮助文档</h4><p>可以使用“？ 关键字”的形式来查询某个关键字的用法，如果不知道有哪些命令可以使用“？ contents”来查询所有可供查询的分类。</p>\n<h3 id=\"三-mysql支持的数据类型\"><a href=\"#三-mysql支持的数据类型\" class=\"headerlink\" title=\"三 mysql支持的数据类型\"></a>三 mysql支持的数据类型</h3><p>各个关系型数据库可能不同，我们应该了解所使用数据库支持的数据类型，这样在设计表时才能选择合适的数据类型。</p>\n<h3 id=\"四-函数\"><a href=\"#四-函数\" class=\"headerlink\" title=\"四 函数\"></a>四 函数</h3><p>各个数据库可能不同，如字符串函数，数值函数，流程函数等</p>\n<h3 id=\"五-mysql存储引擎\"><a href=\"#五-mysql存储引擎\" class=\"headerlink\" title=\"五 mysql存储引擎\"></a>五 mysql存储引擎</h3><p>插件式存储引擎是mysql最大的特性之一，它支持多种存储引擎。这之后会单独写个博客</p>\n<h3 id=\"六-字符集\"><a href=\"#六-字符集\" class=\"headerlink\" title=\"六 字符集\"></a>六 字符集</h3><p>各个数据库支持的不同</p>\n<h3 id=\"七-索引\"><a href=\"#七-索引\" class=\"headerlink\" title=\"七 索引\"></a>七 索引</h3><p>这方面之后要单独写博客。</p>\n<h3 id=\"八-视图\"><a href=\"#八-视图\" class=\"headerlink\" title=\"八 视图\"></a>八 视图</h3><p>视图是一张虚表，即并非真实存在的表。通常我们会将那些经常查询的数据生成视图，这样便于查询，但是视图中并没有数据，数据仍然在表中。</p>\n<p>视图相对于普通表的优势有以下几点：</p>\n<ul>\n<li>简单：使用视图的用户完全不需要关心后面对应的表结构，关联条件和筛选条件，视图就是已经过滤好的复合条件的结果集。</li>\n<li>安全：可以只向用户提供所需查询的结果集的视图，而限制其对表结构的访问，保证了数据的安全。</li>\n<li>数据独立：一旦视图已经生成了，对表增加列并不会影响到视图（如果改表名的话，需要更改视图）。</li>\n</ul>\n<p>视图其实就是固化的一次select语句的结果集，之后每次查询这个结果集只需要查询视图即可。</p>\n<h5 id=\"创建视图\"><a href=\"#创建视图\" class=\"headerlink\" title=\"创建视图\"></a>创建视图</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">create view staff_list_view as</div><div class=\"line\">select s.staff_id,s.first_name,s.last_name,s.address</div><div class=\"line\">from staff as s,address as a</div><div class=\"line\"><span class=\"built_in\">where</span> s.address_id=a.sddress_id;</div></pre></td></tr></table></figure>\n<p>mysql的视图定义有一些限制，如：在from关键字后面不能包含子查询，只能使用视图（将该子查询定义成视图，再查询视图生成视图）代替。</p>\n<p>视图的可更新性与视图中查询的定义有关系，以下视图不可更新：</p>\n<ul>\n<li>包含下列关键字的sql语句：sum,max,min,count,distinct,group by,having,union,union all等</li>\n<li>常量视图</li>\n<li>select中包含子查询</li>\n<li>join</li>\n<li>from一个不能更新的视图</li>\n<li>where字句的子查询引用了from字句中的表</li>\n</ul>\n<h5 id=\"删除视图\"><a href=\"#删除视图\" class=\"headerlink\" title=\"删除视图\"></a>删除视图</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">drop view staff_list_view;</div></pre></td></tr></table></figure>\n<h5 id=\"查看视图\"><a href=\"#查看视图\" class=\"headerlink\" title=\"查看视图\"></a>查看视图</h5><p>与查看表相同</p>\n<h3 id=\"九-存储过程与函数\"><a href=\"#九-存储过程与函数\" class=\"headerlink\" title=\"九 存储过程与函数\"></a>九 存储过程与函数</h3><p>存储过程和函数都是事先经过编译并存储在数据库中的一段sql语句的集合。这两者不同的是函数有返回值而存储过程没有。<br>这里涉及到变量，条件，游标的使用，并且可使用流程函数（IF，CASE等）。这个在之后继续深入学习数据库时再详细介绍。</p>\n<h3 id=\"十-触发器\"><a href=\"#十-触发器\" class=\"headerlink\" title=\"十 触发器\"></a>十 触发器</h3><p>触发器也是sql语句的集合，但是它不需要手动执行，在达到某个条件时，它会自动执行相应的语句，即为触发。</p>\n<h3 id=\"十一-事务控制与锁定语句\"><a href=\"#十一-事务控制与锁定语句\" class=\"headerlink\" title=\"十一 事务控制与锁定语句\"></a>十一 事务控制与锁定语句</h3><p>锁，事务提交，回滚</p>\n<h3 id=\"十二-SQL中的安全问题\"><a href=\"#十二-SQL中的安全问题\" class=\"headerlink\" title=\"十二 SQL中的安全问题\"></a>十二 SQL中的安全问题</h3><p>SQL注入。</p>\n<h3 id=\"十三-SQL-Model及其相关问题\"><a href=\"#十三-SQL-Model及其相关问题\" class=\"headerlink\" title=\"十三 SQL Model及其相关问题\"></a>十三 SQL Model及其相关问题</h3>","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>SQL是Structure Query Language的缩写，它是关系型数据库的应用语言。有IBM在20世纪70年代开发出来，作为IBM关系数据库原型System R的原型关系语言，实现了关系型数据库的信息检索。1986年，美国国家标准局（ANSI）制定出了SQL标准，目前绝大多数关系型数据库均支持SQL标准。本文的SQL语句是基于mysql的，有些语句在其他数据库上未必适用。</p>\n<h3 id=\"二-SQL语句\"><a href=\"#二-SQL语句\" class=\"headerlink\" title=\"二 SQL语句\"></a>二 SQL语句</h3><p>SQL语句不区分大小写，可以划分为3个类别：</p>\n<ul>\n<li>DDL语句：数据定义语言。用于定义数据段，数据库，表，列，索引等数据库对象，如create，drop，alter等</li>\n<li>DML语句：数据操纵语言。用于添加，删除，更新，查询数据库记录，并检查数据完整性，如insert，delete，update，select等</li>\n<li>DCL语句：数据控制语句。用于定义数据库，表，字段，用户等的访问权限和安全级别，如grant，revoke等</li>\n</ul>\n<h4 id=\"1-DDL语句\"><a href=\"#1-DDL语句\" class=\"headerlink\" title=\"1.DDL语句\"></a>1.DDL语句</h4><h5 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h5><p>创建数据库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">create database 数据库名;</div></pre></td></tr></table></figure>\n<p>使用数据库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">use 数据库名;</div></pre></td></tr></table></figure>\n<p>展示一个数据库中所有的表</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">show tables;</div></pre></td></tr></table></figure>\n<h5 id=\"删除数据库\"><a href=\"#删除数据库\" class=\"headerlink\" title=\"删除数据库\"></a>删除数据库</h5><p>删除数据库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">drop database 数据库名;</div></pre></td></tr></table></figure>\n<h5 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h5><p>创建表</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">create table emp(</div><div class=\"line\">\tename varchar(10),</div><div class=\"line\">\thiredate date,</div><div class=\"line\">\tsal decimal(10,2)</div><div class=\"line\">\tdeptno int(2)</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>展示表信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">desc emp;</div></pre></td></tr></table></figure>\n<p>展示创建表的SQL语句信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">show create table emp \\G;</div></pre></td></tr></table></figure>\n<h5 id=\"删除表（drop）\"><a href=\"#删除表（drop）\" class=\"headerlink\" title=\"删除表（drop）\"></a>删除表（drop）</h5><p>删除表</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">drop table emp;</div></pre></td></tr></table></figure>\n<h5 id=\"修改表（alter）\"><a href=\"#修改表（alter）\" class=\"headerlink\" title=\"修改表（alter）\"></a>修改表（alter）</h5><p>修改表字段类型</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">alter table emp modify ename varchar(20);</div></pre></td></tr></table></figure>\n<p>增加表字段</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">alter table emp add columu age int(3);</div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">删除表字段</div><div class=\"line\"></div><div class=\"line\">```bash</div><div class=\"line\">alter table emp drop columu age;</div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">字段改名(mysql在标准SQL上的扩展)</div><div class=\"line\"></div><div class=\"line\">```bash</div><div class=\"line\">alter table emp change age age1 int(4); //同时将字段类型改为int(4)</div></pre></td></tr></table></figure>\n<p>修改字段排列顺序first/after(mysql在标准SQL上的扩展)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">alter table emp add birth date after ename;</div></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">alter table emp modify age int(3) first;</div></pre></td></tr></table></figure>\n<p>表改名</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">alter table emp rename emp1;</div></pre></td></tr></table></figure>\n<h4 id=\"2-DML语句\"><a href=\"#2-DML语句\" class=\"headerlink\" title=\"2.DML语句\"></a>2.DML语句</h4><p>DML语句用于操作表中的数据。</p>\n<h5 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">insert into emp (ename,hiredate,sal,deptno) values (<span class=\"string\">'zzx1'</span>,<span class=\"string\">'2000-01-01'</span>,<span class=\"string\">'2000'</span>,1);</div><div class=\"line\">//在数据库中单引号和双引号的效果相同</div></pre></td></tr></table></figure>\n<h5 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">update emp <span class=\"built_in\">set</span> sal=4000 <span class=\"built_in\">where</span> ename=<span class=\"string\">'lisa'</span></div></pre></td></tr></table></figure>\n<p>更新多表</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">update emp a,dept b <span class=\"built_in\">set</span> a.sal=a.sal*b.deptno,b.deptname=a.ename <span class=\"built_in\">where</span> a.deptno=b.deptno;</div></pre></td></tr></table></figure>\n<h5 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">delete from  emp <span class=\"built_in\">where</span> ename=<span class=\"string\">'lisa'</span></div></pre></td></tr></table></figure>\n<p>删除多表</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">delete a,b from emp a,dept b <span class=\"built_in\">where</span> a.deptno=b.deptno and a.deptno=3;</div></pre></td></tr></table></figure>\n<h5 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select * from emp</div></pre></td></tr></table></figure>\n<p>查询不重复的数据</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select distinct deptno from emp</div></pre></td></tr></table></figure>\n<p>条件查询</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select * from emp <span class=\"built_in\">where</span> deptno=1</div></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select * from emp <span class=\"built_in\">where</span> deptno=1 and sal&gt;=3000</div></pre></td></tr></table></figure>\n<h5 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select * from emp order by deptno;</div></pre></td></tr></table></figure>\n<p>限制显示条数（mysql特有，常用于分页操作）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select * from emp order by deptno <span class=\"built_in\">limit</span> 3;</div></pre></td></tr></table></figure>\n<h5 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h5><ul>\n<li>聚合函数：sum,count,max,min</li>\n<li>group by:表示要分类聚合的字段</li>\n<li>with rollup：可选，表示是否对分类聚合后的结果进行在汇总</li>\n<li>having：表示对分类聚合后的结果在进行条件查询（having与where不同，where是对聚前的数据进行条件过滤而having是聚合后，通常如果可以聚合前进行过滤优先考虑聚合前，这样需要聚合的集合更小，性能更高）</li>\n</ul>\n<p>统计总人数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select count(1) from emp;</div></pre></td></tr></table></figure>\n<p>统计各部门人数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select deptno,count(1) from emp group by deptno;</div></pre></td></tr></table></figure>\n<p>统计各部门人数并汇总（汇总即是计算某一列所有数据的和）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select deptno,count(1) from emp group by deptno with rollup;</div></pre></td></tr></table></figure>\n<p>统计人数大于1的部门</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select deptno,count(1) from emp group by deptno having count(1)&gt;1;</div></pre></td></tr></table></figure>\n<h5 id=\"表连接\"><a href=\"#表连接\" class=\"headerlink\" title=\"表连接\"></a>表连接</h5><p>当需要同时显示多个表中的字段时，就可以使用表连接来实现，表连接分为内连接和外连接。</p>\n<ul>\n<li>内连接：显示两张表中相匹配的数据</li>\n<li>外连接：显示两张表中不匹配的数据</li>\n</ul>\n<p>内连接（有一个特例自然连接，自动去除重复的记录）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">select ename,deptname from emp,dept <span class=\"built_in\">where</span> emp.deptno=dept.deptno;</div><div class=\"line\">//ename是emp中的字段，deptname是dept中的字段</div></pre></td></tr></table></figure>\n<p>自然连接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select ename,deptname from emp join dept <span class=\"built_in\">where</span> emp.deptno=dept.deptno;</div></pre></td></tr></table></figure>\n<p>外连接</p>\n<p>外连接又分为左连接和右连接</p>\n<ul>\n<li>左连接：包含两表相匹配的列和左边表中不匹配的记录</li>\n<li>右连接：包含两表中相匹配的列和右边表中不匹配的记录</li>\n<li>全连接：返回两表中的所有记录</li>\n<li>交叉连接：生成两表的笛卡尔积</li>\n</ul>\n<p>左连接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select ename,deptname from emp left join dept on emp.deptno=dept.deptno;</div></pre></td></tr></table></figure>\n<p>右连接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select ename,deptname from emp right join dept on emp.deptno=dept.deptno;</div></pre></td></tr></table></figure>\n<p>全连接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select ename,deptname from emp outer join dept on emp.deptno=dept.deptno;</div></pre></td></tr></table></figure>\n<p>交叉连接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select ename,deptname from emp cross join dept on emp.deptno=dept.deptno;</div></pre></td></tr></table></figure>\n<h5 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h5><p>有时候当我们查询的时候需要的条件是另一个select语句的查询结果，这个时候就会用到子查询。子查询的关键字包括in，not in，=，！=，exits，not exits。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">select * from emp <span class=\"built_in\">where</span> deptno <span class=\"keyword\">in</span>(select deptno from dept);</div><div class=\"line\">//如果子查询记录唯一应该用=代替，=的性能比<span class=\"keyword\">in</span>要好</div></pre></td></tr></table></figure>\n<p>有些子查询可以被表连接代替，如果可以被表连接代替使用表连接，表连接的性能比子查询要好。</p>\n<h5 id=\"记录联合\"><a href=\"#记录联合\" class=\"headerlink\" title=\"记录联合\"></a>记录联合</h5><p>有时候我们需要将两个select语句的查询结果合在一起显示，这是可以使用union和union all。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select deptno from union all select deptno from dept;</div></pre></td></tr></table></figure>\n<p>若需要去重，则</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select deptno from union select deptno from dept;</div></pre></td></tr></table></figure>\n<h4 id=\"DCL语句\"><a href=\"#DCL语句\" class=\"headerlink\" title=\"DCL语句\"></a>DCL语句</h4><p>一般是DBA使用，一般开发人员很少接触。</p>\n<h4 id=\"查看帮助文档\"><a href=\"#查看帮助文档\" class=\"headerlink\" title=\"查看帮助文档\"></a>查看帮助文档</h4><p>可以使用“？ 关键字”的形式来查询某个关键字的用法，如果不知道有哪些命令可以使用“？ contents”来查询所有可供查询的分类。</p>\n<h3 id=\"三-mysql支持的数据类型\"><a href=\"#三-mysql支持的数据类型\" class=\"headerlink\" title=\"三 mysql支持的数据类型\"></a>三 mysql支持的数据类型</h3><p>各个关系型数据库可能不同，我们应该了解所使用数据库支持的数据类型，这样在设计表时才能选择合适的数据类型。</p>\n<h3 id=\"四-函数\"><a href=\"#四-函数\" class=\"headerlink\" title=\"四 函数\"></a>四 函数</h3><p>各个数据库可能不同，如字符串函数，数值函数，流程函数等</p>\n<h3 id=\"五-mysql存储引擎\"><a href=\"#五-mysql存储引擎\" class=\"headerlink\" title=\"五 mysql存储引擎\"></a>五 mysql存储引擎</h3><p>插件式存储引擎是mysql最大的特性之一，它支持多种存储引擎。这之后会单独写个博客</p>\n<h3 id=\"六-字符集\"><a href=\"#六-字符集\" class=\"headerlink\" title=\"六 字符集\"></a>六 字符集</h3><p>各个数据库支持的不同</p>\n<h3 id=\"七-索引\"><a href=\"#七-索引\" class=\"headerlink\" title=\"七 索引\"></a>七 索引</h3><p>这方面之后要单独写博客。</p>\n<h3 id=\"八-视图\"><a href=\"#八-视图\" class=\"headerlink\" title=\"八 视图\"></a>八 视图</h3><p>视图是一张虚表，即并非真实存在的表。通常我们会将那些经常查询的数据生成视图，这样便于查询，但是视图中并没有数据，数据仍然在表中。</p>\n<p>视图相对于普通表的优势有以下几点：</p>\n<ul>\n<li>简单：使用视图的用户完全不需要关心后面对应的表结构，关联条件和筛选条件，视图就是已经过滤好的复合条件的结果集。</li>\n<li>安全：可以只向用户提供所需查询的结果集的视图，而限制其对表结构的访问，保证了数据的安全。</li>\n<li>数据独立：一旦视图已经生成了，对表增加列并不会影响到视图（如果改表名的话，需要更改视图）。</li>\n</ul>\n<p>视图其实就是固化的一次select语句的结果集，之后每次查询这个结果集只需要查询视图即可。</p>\n<h5 id=\"创建视图\"><a href=\"#创建视图\" class=\"headerlink\" title=\"创建视图\"></a>创建视图</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">create view staff_list_view as</div><div class=\"line\">select s.staff_id,s.first_name,s.last_name,s.address</div><div class=\"line\">from staff as s,address as a</div><div class=\"line\"><span class=\"built_in\">where</span> s.address_id=a.sddress_id;</div></pre></td></tr></table></figure>\n<p>mysql的视图定义有一些限制，如：在from关键字后面不能包含子查询，只能使用视图（将该子查询定义成视图，再查询视图生成视图）代替。</p>\n<p>视图的可更新性与视图中查询的定义有关系，以下视图不可更新：</p>\n<ul>\n<li>包含下列关键字的sql语句：sum,max,min,count,distinct,group by,having,union,union all等</li>\n<li>常量视图</li>\n<li>select中包含子查询</li>\n<li>join</li>\n<li>from一个不能更新的视图</li>\n<li>where字句的子查询引用了from字句中的表</li>\n</ul>\n<h5 id=\"删除视图\"><a href=\"#删除视图\" class=\"headerlink\" title=\"删除视图\"></a>删除视图</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">drop view staff_list_view;</div></pre></td></tr></table></figure>\n<h5 id=\"查看视图\"><a href=\"#查看视图\" class=\"headerlink\" title=\"查看视图\"></a>查看视图</h5><p>与查看表相同</p>\n<h3 id=\"九-存储过程与函数\"><a href=\"#九-存储过程与函数\" class=\"headerlink\" title=\"九 存储过程与函数\"></a>九 存储过程与函数</h3><p>存储过程和函数都是事先经过编译并存储在数据库中的一段sql语句的集合。这两者不同的是函数有返回值而存储过程没有。<br>这里涉及到变量，条件，游标的使用，并且可使用流程函数（IF，CASE等）。这个在之后继续深入学习数据库时再详细介绍。</p>\n<h3 id=\"十-触发器\"><a href=\"#十-触发器\" class=\"headerlink\" title=\"十 触发器\"></a>十 触发器</h3><p>触发器也是sql语句的集合，但是它不需要手动执行，在达到某个条件时，它会自动执行相应的语句，即为触发。</p>\n<h3 id=\"十一-事务控制与锁定语句\"><a href=\"#十一-事务控制与锁定语句\" class=\"headerlink\" title=\"十一 事务控制与锁定语句\"></a>十一 事务控制与锁定语句</h3><p>锁，事务提交，回滚</p>\n<h3 id=\"十二-SQL中的安全问题\"><a href=\"#十二-SQL中的安全问题\" class=\"headerlink\" title=\"十二 SQL中的安全问题\"></a>十二 SQL中的安全问题</h3><p>SQL注入。</p>\n<h3 id=\"十三-SQL-Model及其相关问题\"><a href=\"#十三-SQL-Model及其相关问题\" class=\"headerlink\" title=\"十三 SQL Model及其相关问题\"></a>十三 SQL Model及其相关问题</h3>"},{"title":"TCP协议与UDP协议","date":"2017-04-01T08:27:40.000Z","_content":"\n###　一　TCP协议简介（这篇博文之后会修改，现在先打个提纲）\n\n##### TCp协议的特点\n\n- 是面向连接的。应用程序在使用TCP协议时，必须进行连接；当然，数据传输结束后，要断开TCP连接。\n- TCP连接是点对点的。\n- TCP连接时可靠的。也就是说传输的数据时无差错的、不丢失、不重复、有序到达的。\n- 是全双工的。即TCP连接的两端都设有发送缓存和接收缓存，用来存放双向通信的数据。\n- 是面向字节流的。也就是说TCP将应用程序交下来的数据看成仅仅是一连串的无结构的字节流，其不知道这些字节流的具体含义。TCP协议无法保证发送的数据块的具体大小，因为TCP协议的发送的数据大小受到对方给出的窗口值和当前的网络拥塞度的影响。\nTCP的连接端点是套接字。套接字是IP地址拼接上端口号组成的，即点分方式的十进制后面是端口号，中间用逗号或冒号隔开。如下方式：  \n\n```bash\n\t套接字Socket=(IP地址：端口号)\n```\n\nTCP报文段的首部\nTCP协议的首部有20字节的固定长度，以及4N字节的变长段，因此TCP报文段首部最小为20字节。其格式如下：\n\n{% asset_img TCP报文结构.png TCP报文结构 %} \n\n- 分别占用两个字节的源端口和目的端口。\n    \n- 序号。占用4个字节。序号是循环的，当增加到最大值后又回到0。TCP是面向字节流的，这样会个发送的数据按顺序给每个字节编上号。在建立连接时，会指出发送的字节流的起始序号。首部中的序号表示发送的报文段的数据的第一个字节的序号，而报文的给字节的序号是顺序的。如第一个字节为401,报文的数据长度为100，则首部的序号为401，最后一个字节的序号为500，也就是说下一个报文的首部序号为501。\n    \n- 确认号。占用4个字节。表示期望收到下一个报文段的第一个数据字节的序号，也是下一个报文段的首部序号。如：B收到了A的200个字节数据的TCP报文段，而这个TCP报文段的首部序号为601，则B希望收到的下一个报文段确认号为801。也可以说如果确认号为N，则前面N-1为止的数据已经收到。\n    \n- 数据偏移。占用4位。其表示数据起始位置相对于报文段起始的位置的偏移量，也就是报文段首部的长度。其单位为32位字，也就是说其表示的值应该乘上4个字节。如：该字段的值为4，则其报文段首部长度为16个字节。其最大值只能表示15，也就是说报文段的首部最大只能为60个字节（即变长只能为20个字节）。其最小值为5，因为首部最小值为20。\n\n- 保留。占用6位。其值设为0。\n     \n- 紧急URG。其占用1位。如果URG设为1，表示首部中的紧急指针有效。表示其发送的报文段数据有紧急数据，其需要马上发送出去（也就是取得最高优先权），TCP会将紧急数据插入到该报文的最前端，后面任然为普通数据。\n     \n- 确认ACK。占用1位。当ACK=1时，表示首部中确认号字段有效，为0时，确认号字段无效。TCP规定，在连接建立后ACK字段必须为1。\n     \n- 推送PSH。占用1位。两个应用程序通信，有时应用程序希望键入一个命令马上能够得到对方回应，这是就可以使用这个字段。将PSH设为1，TCP会马上建立一个报文将其发送出去。接收端在收到该报文后，会尽快的将其交给应用程序，不用得到缓冲区满。\n    \n- 复位RST。占用1位。当RST=1时，表示连接出现严重错误，需要释放连接，然后重新进行连接。其还用于拒绝打开一个连接或拒绝非法报文。\n     \n- 同步SYN。占用1位。用于在连接建立时同步序号。当SYN=而ACK=0时，表示这是一个连接请求报文段。当SYN=1且ACK=1时，表示对方接收建立连接报文段。因此SYN=1，表示这是一个连接请求或连接接受报文段。\n     \n- 终止FIN。占用1位。当FIN=1时，表示发送方的数据发送完毕，并要求释放连接。\n      \n- 窗口。占用2个字节。表示发送该报文段的一方的接收窗口，表示允许对方发送的数据量。窗口值告诉对方：从报文段首部中的确认好算起，接收方目前允许对方发送的数据量。如：确认为801，窗口值为1000，则表示其还有接收1000个字节数据（801-1800）的接收缓存空间。\n      \n- 检验和。占2个字节。其也和UDP一样需要加上伪首部，但是其中的17会变为6。\n      \n- 紧急指针。占用2个字节。当URG=1时有效，其指出了紧急数据在报文端中的末尾位置。紧急数据在报文数据段的开始。\n      \n- 选项。可选，最大为40个字节。包括MSS、窗口扩大、时间戳、选择确认等。\n\n##### 可靠传输\n\n停止等待协议，连续ARQ协议，滑动窗口机制（重点）。（每一条数据都必须有确认回复，否则则超时重传）\n\n##### 流量控制\n\n通过流量控制，可以让发送窗口的发送速率不要太快，流量控制是通过滑动窗口来实现的，其需要用来TCP报文中的窗口字段，该字段会用于标识接收端接收窗口的接收能力，用于设定发送窗口的大小。\n\n解决发送时机的三个机制：\n\n- 设置一个变量，它等于最大报文段长度，这要缓存的数据达到MSS字节时，就发送出去。\n- 由发送方的应用程序指明要求发送报文段，通过报文的PUH字段来实现。\n- 给发送方设计一个计时器，达到该事件，就将数据发送出去（不能超过MSS）。\n\nNagle算法：若应用程序将数据逐个字节传送给TCP发送缓冲区，则TCP将第一个字节数据组装成一个报文发送出去。只有当收到该确认报文后，才将缓冲区的所有数据组装成一个报文发送出去。只有收到前一个报文确认才发送下一个报文。Nage算法还规定：当缓冲区的数据已达到发送缓冲区一般或超过报文最大长度时，就立即发送一个报文段。\n为了解决糊涂窗口综合症，可以让接受端等待一段时间、或者让接受缓存已有足够空间容纳一个最长报文段，或者等到接收缓冲已有一半空闲的空间，满足其一，就发送确认报文。\n\n##### 拥塞控制\n发送方会有一个拥塞窗口，用于和接收窗口一起控制发送窗口的大小。发送窗口的大小取拥塞窗口和接收窗口中值较小的一个。\n门阀值。\n慢开始算法：拥塞窗口的大小从1开始逐渐增加增加到一倍。\n拥塞避免算法：当执行慢开始算法时，拥塞窗口大于门阀值时，拥塞窗口的大小每次加一。\n不管是慢开始算法还是拥塞避免算法，当出现拥塞时（即没有按时收到确认），就将门阀值减半，拥塞窗口在变为1执行慢开始算法。\n快重传算法：是指接收方每收到一个失序的报文时，就发送一次重复确认（确认值为前面按序到达的报文最后一个数据值加1）。当发送方累计收到3次重复确认时，就立即再次发送未被确认的报文，而不必等待计时器到期在发送。\n快恢复算法：是指到收到上次重复确认时，就立即将门阀值减半，并执行拥塞避免算法，起始值为门阀值或门阀值+3*MSS。\n\n\n### 二 UDP协议简介\n\n### 三 TCP与UDP的区别\n\n","source":"_posts/TCP协议与UDP协议.md","raw":"---\ntitle: TCP协议与UDP协议\ndate: 2017-04-01 16:27:40\ncategories: 网络协议\ntags:\n- TCP\n- UDP\n---\n\n###　一　TCP协议简介（这篇博文之后会修改，现在先打个提纲）\n\n##### TCp协议的特点\n\n- 是面向连接的。应用程序在使用TCP协议时，必须进行连接；当然，数据传输结束后，要断开TCP连接。\n- TCP连接是点对点的。\n- TCP连接时可靠的。也就是说传输的数据时无差错的、不丢失、不重复、有序到达的。\n- 是全双工的。即TCP连接的两端都设有发送缓存和接收缓存，用来存放双向通信的数据。\n- 是面向字节流的。也就是说TCP将应用程序交下来的数据看成仅仅是一连串的无结构的字节流，其不知道这些字节流的具体含义。TCP协议无法保证发送的数据块的具体大小，因为TCP协议的发送的数据大小受到对方给出的窗口值和当前的网络拥塞度的影响。\nTCP的连接端点是套接字。套接字是IP地址拼接上端口号组成的，即点分方式的十进制后面是端口号，中间用逗号或冒号隔开。如下方式：  \n\n```bash\n\t套接字Socket=(IP地址：端口号)\n```\n\nTCP报文段的首部\nTCP协议的首部有20字节的固定长度，以及4N字节的变长段，因此TCP报文段首部最小为20字节。其格式如下：\n\n{% asset_img TCP报文结构.png TCP报文结构 %} \n\n- 分别占用两个字节的源端口和目的端口。\n    \n- 序号。占用4个字节。序号是循环的，当增加到最大值后又回到0。TCP是面向字节流的，这样会个发送的数据按顺序给每个字节编上号。在建立连接时，会指出发送的字节流的起始序号。首部中的序号表示发送的报文段的数据的第一个字节的序号，而报文的给字节的序号是顺序的。如第一个字节为401,报文的数据长度为100，则首部的序号为401，最后一个字节的序号为500，也就是说下一个报文的首部序号为501。\n    \n- 确认号。占用4个字节。表示期望收到下一个报文段的第一个数据字节的序号，也是下一个报文段的首部序号。如：B收到了A的200个字节数据的TCP报文段，而这个TCP报文段的首部序号为601，则B希望收到的下一个报文段确认号为801。也可以说如果确认号为N，则前面N-1为止的数据已经收到。\n    \n- 数据偏移。占用4位。其表示数据起始位置相对于报文段起始的位置的偏移量，也就是报文段首部的长度。其单位为32位字，也就是说其表示的值应该乘上4个字节。如：该字段的值为4，则其报文段首部长度为16个字节。其最大值只能表示15，也就是说报文段的首部最大只能为60个字节（即变长只能为20个字节）。其最小值为5，因为首部最小值为20。\n\n- 保留。占用6位。其值设为0。\n     \n- 紧急URG。其占用1位。如果URG设为1，表示首部中的紧急指针有效。表示其发送的报文段数据有紧急数据，其需要马上发送出去（也就是取得最高优先权），TCP会将紧急数据插入到该报文的最前端，后面任然为普通数据。\n     \n- 确认ACK。占用1位。当ACK=1时，表示首部中确认号字段有效，为0时，确认号字段无效。TCP规定，在连接建立后ACK字段必须为1。\n     \n- 推送PSH。占用1位。两个应用程序通信，有时应用程序希望键入一个命令马上能够得到对方回应，这是就可以使用这个字段。将PSH设为1，TCP会马上建立一个报文将其发送出去。接收端在收到该报文后，会尽快的将其交给应用程序，不用得到缓冲区满。\n    \n- 复位RST。占用1位。当RST=1时，表示连接出现严重错误，需要释放连接，然后重新进行连接。其还用于拒绝打开一个连接或拒绝非法报文。\n     \n- 同步SYN。占用1位。用于在连接建立时同步序号。当SYN=而ACK=0时，表示这是一个连接请求报文段。当SYN=1且ACK=1时，表示对方接收建立连接报文段。因此SYN=1，表示这是一个连接请求或连接接受报文段。\n     \n- 终止FIN。占用1位。当FIN=1时，表示发送方的数据发送完毕，并要求释放连接。\n      \n- 窗口。占用2个字节。表示发送该报文段的一方的接收窗口，表示允许对方发送的数据量。窗口值告诉对方：从报文段首部中的确认好算起，接收方目前允许对方发送的数据量。如：确认为801，窗口值为1000，则表示其还有接收1000个字节数据（801-1800）的接收缓存空间。\n      \n- 检验和。占2个字节。其也和UDP一样需要加上伪首部，但是其中的17会变为6。\n      \n- 紧急指针。占用2个字节。当URG=1时有效，其指出了紧急数据在报文端中的末尾位置。紧急数据在报文数据段的开始。\n      \n- 选项。可选，最大为40个字节。包括MSS、窗口扩大、时间戳、选择确认等。\n\n##### 可靠传输\n\n停止等待协议，连续ARQ协议，滑动窗口机制（重点）。（每一条数据都必须有确认回复，否则则超时重传）\n\n##### 流量控制\n\n通过流量控制，可以让发送窗口的发送速率不要太快，流量控制是通过滑动窗口来实现的，其需要用来TCP报文中的窗口字段，该字段会用于标识接收端接收窗口的接收能力，用于设定发送窗口的大小。\n\n解决发送时机的三个机制：\n\n- 设置一个变量，它等于最大报文段长度，这要缓存的数据达到MSS字节时，就发送出去。\n- 由发送方的应用程序指明要求发送报文段，通过报文的PUH字段来实现。\n- 给发送方设计一个计时器，达到该事件，就将数据发送出去（不能超过MSS）。\n\nNagle算法：若应用程序将数据逐个字节传送给TCP发送缓冲区，则TCP将第一个字节数据组装成一个报文发送出去。只有当收到该确认报文后，才将缓冲区的所有数据组装成一个报文发送出去。只有收到前一个报文确认才发送下一个报文。Nage算法还规定：当缓冲区的数据已达到发送缓冲区一般或超过报文最大长度时，就立即发送一个报文段。\n为了解决糊涂窗口综合症，可以让接受端等待一段时间、或者让接受缓存已有足够空间容纳一个最长报文段，或者等到接收缓冲已有一半空闲的空间，满足其一，就发送确认报文。\n\n##### 拥塞控制\n发送方会有一个拥塞窗口，用于和接收窗口一起控制发送窗口的大小。发送窗口的大小取拥塞窗口和接收窗口中值较小的一个。\n门阀值。\n慢开始算法：拥塞窗口的大小从1开始逐渐增加增加到一倍。\n拥塞避免算法：当执行慢开始算法时，拥塞窗口大于门阀值时，拥塞窗口的大小每次加一。\n不管是慢开始算法还是拥塞避免算法，当出现拥塞时（即没有按时收到确认），就将门阀值减半，拥塞窗口在变为1执行慢开始算法。\n快重传算法：是指接收方每收到一个失序的报文时，就发送一次重复确认（确认值为前面按序到达的报文最后一个数据值加1）。当发送方累计收到3次重复确认时，就立即再次发送未被确认的报文，而不必等待计时器到期在发送。\n快恢复算法：是指到收到上次重复确认时，就立即将门阀值减半，并执行拥塞避免算法，起始值为门阀值或门阀值+3*MSS。\n\n\n### 二 UDP协议简介\n\n### 三 TCP与UDP的区别\n\n","slug":"TCP协议与UDP协议","published":1,"updated":"2017-04-01T08:50:26.646Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk1k000naknzqkg3rci2","content":"<p>###　一　TCP协议简介（这篇博文之后会修改，现在先打个提纲）</p>\n<h5 id=\"TCp协议的特点\"><a href=\"#TCp协议的特点\" class=\"headerlink\" title=\"TCp协议的特点\"></a>TCp协议的特点</h5><ul>\n<li>是面向连接的。应用程序在使用TCP协议时，必须进行连接；当然，数据传输结束后，要断开TCP连接。</li>\n<li>TCP连接是点对点的。</li>\n<li>TCP连接时可靠的。也就是说传输的数据时无差错的、不丢失、不重复、有序到达的。</li>\n<li>是全双工的。即TCP连接的两端都设有发送缓存和接收缓存，用来存放双向通信的数据。</li>\n<li>是面向字节流的。也就是说TCP将应用程序交下来的数据看成仅仅是一连串的无结构的字节流，其不知道这些字节流的具体含义。TCP协议无法保证发送的数据块的具体大小，因为TCP协议的发送的数据大小受到对方给出的窗口值和当前的网络拥塞度的影响。<br>TCP的连接端点是套接字。套接字是IP地址拼接上端口号组成的，即点分方式的十进制后面是端口号，中间用逗号或冒号隔开。如下方式：  </li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">套接字Socket=(IP地址：端口号)</div></pre></td></tr></table></figure>\n<p>TCP报文段的首部<br>TCP协议的首部有20字节的固定长度，以及4N字节的变长段，因此TCP报文段首部最小为20字节。其格式如下：</p>\n<img src=\"/2017/04/01/TCP协议与UDP协议/TCP报文结构.png\" alt=\"TCP报文结构\" title=\"TCP报文结构\"> \n<ul>\n<li><p>分别占用两个字节的源端口和目的端口。</p>\n</li>\n<li><p>序号。占用4个字节。序号是循环的，当增加到最大值后又回到0。TCP是面向字节流的，这样会个发送的数据按顺序给每个字节编上号。在建立连接时，会指出发送的字节流的起始序号。首部中的序号表示发送的报文段的数据的第一个字节的序号，而报文的给字节的序号是顺序的。如第一个字节为401,报文的数据长度为100，则首部的序号为401，最后一个字节的序号为500，也就是说下一个报文的首部序号为501。</p>\n</li>\n<li><p>确认号。占用4个字节。表示期望收到下一个报文段的第一个数据字节的序号，也是下一个报文段的首部序号。如：B收到了A的200个字节数据的TCP报文段，而这个TCP报文段的首部序号为601，则B希望收到的下一个报文段确认号为801。也可以说如果确认号为N，则前面N-1为止的数据已经收到。</p>\n</li>\n<li><p>数据偏移。占用4位。其表示数据起始位置相对于报文段起始的位置的偏移量，也就是报文段首部的长度。其单位为32位字，也就是说其表示的值应该乘上4个字节。如：该字段的值为4，则其报文段首部长度为16个字节。其最大值只能表示15，也就是说报文段的首部最大只能为60个字节（即变长只能为20个字节）。其最小值为5，因为首部最小值为20。</p>\n</li>\n<li><p>保留。占用6位。其值设为0。</p>\n</li>\n<li><p>紧急URG。其占用1位。如果URG设为1，表示首部中的紧急指针有效。表示其发送的报文段数据有紧急数据，其需要马上发送出去（也就是取得最高优先权），TCP会将紧急数据插入到该报文的最前端，后面任然为普通数据。</p>\n</li>\n<li><p>确认ACK。占用1位。当ACK=1时，表示首部中确认号字段有效，为0时，确认号字段无效。TCP规定，在连接建立后ACK字段必须为1。</p>\n</li>\n<li><p>推送PSH。占用1位。两个应用程序通信，有时应用程序希望键入一个命令马上能够得到对方回应，这是就可以使用这个字段。将PSH设为1，TCP会马上建立一个报文将其发送出去。接收端在收到该报文后，会尽快的将其交给应用程序，不用得到缓冲区满。</p>\n</li>\n<li><p>复位RST。占用1位。当RST=1时，表示连接出现严重错误，需要释放连接，然后重新进行连接。其还用于拒绝打开一个连接或拒绝非法报文。</p>\n</li>\n<li><p>同步SYN。占用1位。用于在连接建立时同步序号。当SYN=而ACK=0时，表示这是一个连接请求报文段。当SYN=1且ACK=1时，表示对方接收建立连接报文段。因此SYN=1，表示这是一个连接请求或连接接受报文段。</p>\n</li>\n<li><p>终止FIN。占用1位。当FIN=1时，表示发送方的数据发送完毕，并要求释放连接。</p>\n</li>\n<li><p>窗口。占用2个字节。表示发送该报文段的一方的接收窗口，表示允许对方发送的数据量。窗口值告诉对方：从报文段首部中的确认好算起，接收方目前允许对方发送的数据量。如：确认为801，窗口值为1000，则表示其还有接收1000个字节数据（801-1800）的接收缓存空间。</p>\n</li>\n<li><p>检验和。占2个字节。其也和UDP一样需要加上伪首部，但是其中的17会变为6。</p>\n</li>\n<li><p>紧急指针。占用2个字节。当URG=1时有效，其指出了紧急数据在报文端中的末尾位置。紧急数据在报文数据段的开始。</p>\n</li>\n<li><p>选项。可选，最大为40个字节。包括MSS、窗口扩大、时间戳、选择确认等。</p>\n</li>\n</ul>\n<h5 id=\"可靠传输\"><a href=\"#可靠传输\" class=\"headerlink\" title=\"可靠传输\"></a>可靠传输</h5><p>停止等待协议，连续ARQ协议，滑动窗口机制（重点）。（每一条数据都必须有确认回复，否则则超时重传）</p>\n<h5 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a>流量控制</h5><p>通过流量控制，可以让发送窗口的发送速率不要太快，流量控制是通过滑动窗口来实现的，其需要用来TCP报文中的窗口字段，该字段会用于标识接收端接收窗口的接收能力，用于设定发送窗口的大小。</p>\n<p>解决发送时机的三个机制：</p>\n<ul>\n<li>设置一个变量，它等于最大报文段长度，这要缓存的数据达到MSS字节时，就发送出去。</li>\n<li>由发送方的应用程序指明要求发送报文段，通过报文的PUH字段来实现。</li>\n<li>给发送方设计一个计时器，达到该事件，就将数据发送出去（不能超过MSS）。</li>\n</ul>\n<p>Nagle算法：若应用程序将数据逐个字节传送给TCP发送缓冲区，则TCP将第一个字节数据组装成一个报文发送出去。只有当收到该确认报文后，才将缓冲区的所有数据组装成一个报文发送出去。只有收到前一个报文确认才发送下一个报文。Nage算法还规定：当缓冲区的数据已达到发送缓冲区一般或超过报文最大长度时，就立即发送一个报文段。<br>为了解决糊涂窗口综合症，可以让接受端等待一段时间、或者让接受缓存已有足够空间容纳一个最长报文段，或者等到接收缓冲已有一半空闲的空间，满足其一，就发送确认报文。</p>\n<h5 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h5><p>发送方会有一个拥塞窗口，用于和接收窗口一起控制发送窗口的大小。发送窗口的大小取拥塞窗口和接收窗口中值较小的一个。<br>门阀值。<br>慢开始算法：拥塞窗口的大小从1开始逐渐增加增加到一倍。<br>拥塞避免算法：当执行慢开始算法时，拥塞窗口大于门阀值时，拥塞窗口的大小每次加一。<br>不管是慢开始算法还是拥塞避免算法，当出现拥塞时（即没有按时收到确认），就将门阀值减半，拥塞窗口在变为1执行慢开始算法。<br>快重传算法：是指接收方每收到一个失序的报文时，就发送一次重复确认（确认值为前面按序到达的报文最后一个数据值加1）。当发送方累计收到3次重复确认时，就立即再次发送未被确认的报文，而不必等待计时器到期在发送。<br>快恢复算法：是指到收到上次重复确认时，就立即将门阀值减半，并执行拥塞避免算法，起始值为门阀值或门阀值+3*MSS。</p>\n<h3 id=\"二-UDP协议简介\"><a href=\"#二-UDP协议简介\" class=\"headerlink\" title=\"二 UDP协议简介\"></a>二 UDP协议简介</h3><h3 id=\"三-TCP与UDP的区别\"><a href=\"#三-TCP与UDP的区别\" class=\"headerlink\" title=\"三 TCP与UDP的区别\"></a>三 TCP与UDP的区别</h3>","excerpt":"","more":"<p>###　一　TCP协议简介（这篇博文之后会修改，现在先打个提纲）</p>\n<h5 id=\"TCp协议的特点\"><a href=\"#TCp协议的特点\" class=\"headerlink\" title=\"TCp协议的特点\"></a>TCp协议的特点</h5><ul>\n<li>是面向连接的。应用程序在使用TCP协议时，必须进行连接；当然，数据传输结束后，要断开TCP连接。</li>\n<li>TCP连接是点对点的。</li>\n<li>TCP连接时可靠的。也就是说传输的数据时无差错的、不丢失、不重复、有序到达的。</li>\n<li>是全双工的。即TCP连接的两端都设有发送缓存和接收缓存，用来存放双向通信的数据。</li>\n<li>是面向字节流的。也就是说TCP将应用程序交下来的数据看成仅仅是一连串的无结构的字节流，其不知道这些字节流的具体含义。TCP协议无法保证发送的数据块的具体大小，因为TCP协议的发送的数据大小受到对方给出的窗口值和当前的网络拥塞度的影响。<br>TCP的连接端点是套接字。套接字是IP地址拼接上端口号组成的，即点分方式的十进制后面是端口号，中间用逗号或冒号隔开。如下方式：  </li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">套接字Socket=(IP地址：端口号)</div></pre></td></tr></table></figure>\n<p>TCP报文段的首部<br>TCP协议的首部有20字节的固定长度，以及4N字节的变长段，因此TCP报文段首部最小为20字节。其格式如下：</p>\n<img src=\"/2017/04/01/TCP协议与UDP协议/TCP报文结构.png\" alt=\"TCP报文结构\" title=\"TCP报文结构\"> \n<ul>\n<li><p>分别占用两个字节的源端口和目的端口。</p>\n</li>\n<li><p>序号。占用4个字节。序号是循环的，当增加到最大值后又回到0。TCP是面向字节流的，这样会个发送的数据按顺序给每个字节编上号。在建立连接时，会指出发送的字节流的起始序号。首部中的序号表示发送的报文段的数据的第一个字节的序号，而报文的给字节的序号是顺序的。如第一个字节为401,报文的数据长度为100，则首部的序号为401，最后一个字节的序号为500，也就是说下一个报文的首部序号为501。</p>\n</li>\n<li><p>确认号。占用4个字节。表示期望收到下一个报文段的第一个数据字节的序号，也是下一个报文段的首部序号。如：B收到了A的200个字节数据的TCP报文段，而这个TCP报文段的首部序号为601，则B希望收到的下一个报文段确认号为801。也可以说如果确认号为N，则前面N-1为止的数据已经收到。</p>\n</li>\n<li><p>数据偏移。占用4位。其表示数据起始位置相对于报文段起始的位置的偏移量，也就是报文段首部的长度。其单位为32位字，也就是说其表示的值应该乘上4个字节。如：该字段的值为4，则其报文段首部长度为16个字节。其最大值只能表示15，也就是说报文段的首部最大只能为60个字节（即变长只能为20个字节）。其最小值为5，因为首部最小值为20。</p>\n</li>\n<li><p>保留。占用6位。其值设为0。</p>\n</li>\n<li><p>紧急URG。其占用1位。如果URG设为1，表示首部中的紧急指针有效。表示其发送的报文段数据有紧急数据，其需要马上发送出去（也就是取得最高优先权），TCP会将紧急数据插入到该报文的最前端，后面任然为普通数据。</p>\n</li>\n<li><p>确认ACK。占用1位。当ACK=1时，表示首部中确认号字段有效，为0时，确认号字段无效。TCP规定，在连接建立后ACK字段必须为1。</p>\n</li>\n<li><p>推送PSH。占用1位。两个应用程序通信，有时应用程序希望键入一个命令马上能够得到对方回应，这是就可以使用这个字段。将PSH设为1，TCP会马上建立一个报文将其发送出去。接收端在收到该报文后，会尽快的将其交给应用程序，不用得到缓冲区满。</p>\n</li>\n<li><p>复位RST。占用1位。当RST=1时，表示连接出现严重错误，需要释放连接，然后重新进行连接。其还用于拒绝打开一个连接或拒绝非法报文。</p>\n</li>\n<li><p>同步SYN。占用1位。用于在连接建立时同步序号。当SYN=而ACK=0时，表示这是一个连接请求报文段。当SYN=1且ACK=1时，表示对方接收建立连接报文段。因此SYN=1，表示这是一个连接请求或连接接受报文段。</p>\n</li>\n<li><p>终止FIN。占用1位。当FIN=1时，表示发送方的数据发送完毕，并要求释放连接。</p>\n</li>\n<li><p>窗口。占用2个字节。表示发送该报文段的一方的接收窗口，表示允许对方发送的数据量。窗口值告诉对方：从报文段首部中的确认好算起，接收方目前允许对方发送的数据量。如：确认为801，窗口值为1000，则表示其还有接收1000个字节数据（801-1800）的接收缓存空间。</p>\n</li>\n<li><p>检验和。占2个字节。其也和UDP一样需要加上伪首部，但是其中的17会变为6。</p>\n</li>\n<li><p>紧急指针。占用2个字节。当URG=1时有效，其指出了紧急数据在报文端中的末尾位置。紧急数据在报文数据段的开始。</p>\n</li>\n<li><p>选项。可选，最大为40个字节。包括MSS、窗口扩大、时间戳、选择确认等。</p>\n</li>\n</ul>\n<h5 id=\"可靠传输\"><a href=\"#可靠传输\" class=\"headerlink\" title=\"可靠传输\"></a>可靠传输</h5><p>停止等待协议，连续ARQ协议，滑动窗口机制（重点）。（每一条数据都必须有确认回复，否则则超时重传）</p>\n<h5 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a>流量控制</h5><p>通过流量控制，可以让发送窗口的发送速率不要太快，流量控制是通过滑动窗口来实现的，其需要用来TCP报文中的窗口字段，该字段会用于标识接收端接收窗口的接收能力，用于设定发送窗口的大小。</p>\n<p>解决发送时机的三个机制：</p>\n<ul>\n<li>设置一个变量，它等于最大报文段长度，这要缓存的数据达到MSS字节时，就发送出去。</li>\n<li>由发送方的应用程序指明要求发送报文段，通过报文的PUH字段来实现。</li>\n<li>给发送方设计一个计时器，达到该事件，就将数据发送出去（不能超过MSS）。</li>\n</ul>\n<p>Nagle算法：若应用程序将数据逐个字节传送给TCP发送缓冲区，则TCP将第一个字节数据组装成一个报文发送出去。只有当收到该确认报文后，才将缓冲区的所有数据组装成一个报文发送出去。只有收到前一个报文确认才发送下一个报文。Nage算法还规定：当缓冲区的数据已达到发送缓冲区一般或超过报文最大长度时，就立即发送一个报文段。<br>为了解决糊涂窗口综合症，可以让接受端等待一段时间、或者让接受缓存已有足够空间容纳一个最长报文段，或者等到接收缓冲已有一半空闲的空间，满足其一，就发送确认报文。</p>\n<h5 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h5><p>发送方会有一个拥塞窗口，用于和接收窗口一起控制发送窗口的大小。发送窗口的大小取拥塞窗口和接收窗口中值较小的一个。<br>门阀值。<br>慢开始算法：拥塞窗口的大小从1开始逐渐增加增加到一倍。<br>拥塞避免算法：当执行慢开始算法时，拥塞窗口大于门阀值时，拥塞窗口的大小每次加一。<br>不管是慢开始算法还是拥塞避免算法，当出现拥塞时（即没有按时收到确认），就将门阀值减半，拥塞窗口在变为1执行慢开始算法。<br>快重传算法：是指接收方每收到一个失序的报文时，就发送一次重复确认（确认值为前面按序到达的报文最后一个数据值加1）。当发送方累计收到3次重复确认时，就立即再次发送未被确认的报文，而不必等待计时器到期在发送。<br>快恢复算法：是指到收到上次重复确认时，就立即将门阀值减半，并执行拥塞避免算法，起始值为门阀值或门阀值+3*MSS。</p>\n<h3 id=\"二-UDP协议简介\"><a href=\"#二-UDP协议简介\" class=\"headerlink\" title=\"二 UDP协议简介\"></a>二 UDP协议简介</h3><h3 id=\"三-TCP与UDP的区别\"><a href=\"#三-TCP与UDP的区别\" class=\"headerlink\" title=\"三 TCP与UDP的区别\"></a>三 TCP与UDP的区别</h3>"},{"title":"android基础之Content Provider","date":"2017-02-27T06:32:42.000Z","_content":"\n### 一 概述\n\nContentProvider（内容提供者）是Android的四大组件之一，通过它可以向其他的应用程序共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。而且Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。\n\n但注意ContentProvider它也只是一个中间人，真正操作的数据源可能是数据库，也可以是文件、xml或网络等其他存储方式。\n\n### Uri类简介\n\n```java\nUri uri = Uri.parse(\"content://com.changcheng.provider.contactprovider/contact\")\n```\n\n在Content Provider中使用的查询字符串有别于标准的SQL查询。很多诸如select, add, delete, modify等操作我们都使用一种特殊的URI来进行，这种URI由3个部分组成， “content://”, 代表数据的路径，和一个可选的标识数据的ID。以下是一些示例URI:    \n\n```java\ncontent://media/internal/images  //这个URI将返回设备上存储的所有图片\ncontent://contacts/people/  //这个URI将返回设备上的所有联系人信息\ncontent://contacts/people/45  //这个URI返回单个结果（联系人信息中ID为45的联系人记录）\n```\n\n尽管这种查询字符串格式很常见，但是它看起来还是有点令人迷惑。为此，Android提供一系列的帮助类（在android.provider包下），里面包含了很多以类变量形式给出的查询字符串，这种方式更容易让我们理解一点，因此，如上面content://contacts/people/45这个URI就可以写成如下形式：\n\n```java\nUri person = ContentUris.withAppendedId(People.CONTENT_URI,  45);\n```\n\n然后执行数据查询:\n\n```java\nCursor cur = managedQuery(person, null, null, null);\n```\n\n这个查询返回一个包含所有数据字段的游标，我们可以通过迭代这个游标来获取所有的数据.\n\n### 三 ContentProvider类简介\n\n##### 1.主要方法\n\n- public boolean onCreate()   \nContentProvider创建后　或　打开系统后其它应用第一次访问该ContentProvider时调用。      \n- public Uri insert(Uri uri, ContentValues values)    \n外部应用向ContentProvider中添加数据。    \n- public int delete(Uri uri, String selection, String[] selectionArgs)     \n外部应用从ContentProvider删除数据。    \n- public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)         \n外部应用更新ContentProvider中的数据。    \n- public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)　    \n供外部应用从ContentProvider中获取数据。 　    \n- public String getType(Uri uri)     \n该方法用于返回当前Url所代表数据的MIME类型  \n\n##### 2.创建步骤\n\n要创建我们自己的Content Provider的话，我们需要遵循以下几步：\n\n1.创建一个继承了ContentProvider父类的类   \n2.定义一个名为CONTENT_URI，并且是public static final的Uri类型的类变量，你必须为其指定一个唯一的字符串值，最好的方案是以类的全名称， 如:\n\n\n```java\npublic static final Uri CONTENT_URI = Uri.parse( “content://com.google.android.MyContentProvider”);\n```\n\n3.定义你要返回给客户端的数据列名。如果你正在使用Android数据库，必须为其定义一个叫_id的列，它用来表示每条记录的唯一性。     \n4.创建你的数据存储系统。大多数Content Provider使用Android文件系统或SQLite数据库来保持数据，但是你也可以以任何你想要的方式来存储。      \n5.如果你要存储字节型数据，比如位图文件等，数据列其实是一个表示实际保存文件的URI字符串，通过它来读取对应的文件数据。处理这种数据类型的Content Provider需要实现一个名为_data的字段，_data字段列出了该文件在Android文件系统上的精确路径。这个字段不仅是供客户端使用，而且也可以供ContentResolver使用。客户端可以调用ContentResolver.openOutputStream()方法来处理该URI指向的文件资源；如果是ContentResolver本身的话，由于其持有的权限比客户端要高，所以它能直接访问该数据文件。    \n6.声明public static String型的变量，用于指定要从游标处返回的数据列。    \n7.查询返回一个Cursor类型的对象。所有执行写操作的方法如insert(), update() 以及delete()都将被监听。我们可以通过使用ContentResover().notifyChange()方法来通知监听器关于数据更新的信息。     \n8.在AndroidMenifest.xml中使用<provider>标签来设置Content Provider。    \n9.如果你要处理的数据类型是一种比较新的类型，你就必须先定义一个新的MIME类型，以供ContentProvider.geType(url)来返回。MIME类型有两种形式:一种是为指定的单个记录的，还有一种是为多条记录的。这里给出一种常用的格式：   \n- vnd.android.cursor.item/vnd.yourcompanyname.contenttype （单个记录的MIME类型）   \n比如, 一个请求列车信息的URI如content://com.example.transportationprovider/trains/122 可能就会返回typevnd.android.cursor.item/vnd.example.rail这样一个MIME类型。   \n- vnd.android.cursor.dir/vnd.yourcompanyname.contenttype （多个记录的MIME类型）     \n比如, 一个请求所有列车信息的URI如content://com.example.transportationprovider/trains 可能就会返回vnd.android.cursor.dir/vnd.example.rail这样一个MIME 类型。\n\n下面是一个Content Provider代码示例：\n\n\n> 代码\n\n一个名为MyContentProvider的Content Provider创建完成了，它用于从Sqlite数据库中添加和读取记录。\n\n### 四 ContentResolver\n\n一个ContentProvider新建好了之后，我们需要一个ContentResolver类来获取其共享出的数据。\n\n##### 1.ContentResolver的主要方法\n\n- public Uri insert(Uri uri, ContentValues values)　//添加\n- public int delete(Uri uri, String selection, String[] selectionArgs)　//删除\n- public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)　//更新\n- public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)//获取\n\n\n示例代码：\n\n```java\nContentResolver resolver =  getContentResolver();\nUri uri = Uri.parse(\"content://cn.scu.myprovider/user\");\n\n//插入\nContentValues values = new ContentValues();\nvalues.put(\"name\", \"fanrunqi\");\nvalues.put(\"age\", 24);\nresolver.insert(uri, values);  \n\n//查询\nCursor cursor = resolver.query(uri, null, null, null, \"userid desc\");\nwhile(cursor.moveToNext()){\n   //操作\n}\n\n//更新\nContentValues updateValues = new ContentValues();\nupdateValues.put(\"name\", \"finch\");\nUri updateIdUri = ContentUris.withAppendedId(uri, 1);\nresolver.update(updateIdUri, updateValues, null, null);\n\n//删除\nUri deleteIdUri = ContentUris.withAppendedId(uri, 2);\nresolver.delete(deleteIdUri, null, null);\n```\n\n##### 使用ContentResolver获取数据的步骤\n\n1. 通过getContentResolver()方法得到ContentResol1.ver对象。\n2. 调用ContentResolver类的query()方法查询数据，该方法会返回一个Cursor对象。\n3. 对得到的Cursor对象进行分析，得到需要的数据。\n4. 调用Cursor类的close()方法将Cursor对象关闭。\n\n示例代码（与上面ContentProvider处的代码相连）：\n\n> 代码\n\n\n### 五 总结\n\n\n\n\n      \n\n\n\n\n\n\n\n","source":"_posts/android基础之Content-Providers.md","raw":"---\ntitle: android基础之Content Provider\ndate: 2017-02-27 14:32:42\ncategories: android\ntags:\n- android\n- java\n- Content Provider\n---\n\n### 一 概述\n\nContentProvider（内容提供者）是Android的四大组件之一，通过它可以向其他的应用程序共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。而且Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。\n\n但注意ContentProvider它也只是一个中间人，真正操作的数据源可能是数据库，也可以是文件、xml或网络等其他存储方式。\n\n### Uri类简介\n\n```java\nUri uri = Uri.parse(\"content://com.changcheng.provider.contactprovider/contact\")\n```\n\n在Content Provider中使用的查询字符串有别于标准的SQL查询。很多诸如select, add, delete, modify等操作我们都使用一种特殊的URI来进行，这种URI由3个部分组成， “content://”, 代表数据的路径，和一个可选的标识数据的ID。以下是一些示例URI:    \n\n```java\ncontent://media/internal/images  //这个URI将返回设备上存储的所有图片\ncontent://contacts/people/  //这个URI将返回设备上的所有联系人信息\ncontent://contacts/people/45  //这个URI返回单个结果（联系人信息中ID为45的联系人记录）\n```\n\n尽管这种查询字符串格式很常见，但是它看起来还是有点令人迷惑。为此，Android提供一系列的帮助类（在android.provider包下），里面包含了很多以类变量形式给出的查询字符串，这种方式更容易让我们理解一点，因此，如上面content://contacts/people/45这个URI就可以写成如下形式：\n\n```java\nUri person = ContentUris.withAppendedId(People.CONTENT_URI,  45);\n```\n\n然后执行数据查询:\n\n```java\nCursor cur = managedQuery(person, null, null, null);\n```\n\n这个查询返回一个包含所有数据字段的游标，我们可以通过迭代这个游标来获取所有的数据.\n\n### 三 ContentProvider类简介\n\n##### 1.主要方法\n\n- public boolean onCreate()   \nContentProvider创建后　或　打开系统后其它应用第一次访问该ContentProvider时调用。      \n- public Uri insert(Uri uri, ContentValues values)    \n外部应用向ContentProvider中添加数据。    \n- public int delete(Uri uri, String selection, String[] selectionArgs)     \n外部应用从ContentProvider删除数据。    \n- public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)         \n外部应用更新ContentProvider中的数据。    \n- public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)　    \n供外部应用从ContentProvider中获取数据。 　    \n- public String getType(Uri uri)     \n该方法用于返回当前Url所代表数据的MIME类型  \n\n##### 2.创建步骤\n\n要创建我们自己的Content Provider的话，我们需要遵循以下几步：\n\n1.创建一个继承了ContentProvider父类的类   \n2.定义一个名为CONTENT_URI，并且是public static final的Uri类型的类变量，你必须为其指定一个唯一的字符串值，最好的方案是以类的全名称， 如:\n\n\n```java\npublic static final Uri CONTENT_URI = Uri.parse( “content://com.google.android.MyContentProvider”);\n```\n\n3.定义你要返回给客户端的数据列名。如果你正在使用Android数据库，必须为其定义一个叫_id的列，它用来表示每条记录的唯一性。     \n4.创建你的数据存储系统。大多数Content Provider使用Android文件系统或SQLite数据库来保持数据，但是你也可以以任何你想要的方式来存储。      \n5.如果你要存储字节型数据，比如位图文件等，数据列其实是一个表示实际保存文件的URI字符串，通过它来读取对应的文件数据。处理这种数据类型的Content Provider需要实现一个名为_data的字段，_data字段列出了该文件在Android文件系统上的精确路径。这个字段不仅是供客户端使用，而且也可以供ContentResolver使用。客户端可以调用ContentResolver.openOutputStream()方法来处理该URI指向的文件资源；如果是ContentResolver本身的话，由于其持有的权限比客户端要高，所以它能直接访问该数据文件。    \n6.声明public static String型的变量，用于指定要从游标处返回的数据列。    \n7.查询返回一个Cursor类型的对象。所有执行写操作的方法如insert(), update() 以及delete()都将被监听。我们可以通过使用ContentResover().notifyChange()方法来通知监听器关于数据更新的信息。     \n8.在AndroidMenifest.xml中使用<provider>标签来设置Content Provider。    \n9.如果你要处理的数据类型是一种比较新的类型，你就必须先定义一个新的MIME类型，以供ContentProvider.geType(url)来返回。MIME类型有两种形式:一种是为指定的单个记录的，还有一种是为多条记录的。这里给出一种常用的格式：   \n- vnd.android.cursor.item/vnd.yourcompanyname.contenttype （单个记录的MIME类型）   \n比如, 一个请求列车信息的URI如content://com.example.transportationprovider/trains/122 可能就会返回typevnd.android.cursor.item/vnd.example.rail这样一个MIME类型。   \n- vnd.android.cursor.dir/vnd.yourcompanyname.contenttype （多个记录的MIME类型）     \n比如, 一个请求所有列车信息的URI如content://com.example.transportationprovider/trains 可能就会返回vnd.android.cursor.dir/vnd.example.rail这样一个MIME 类型。\n\n下面是一个Content Provider代码示例：\n\n\n> 代码\n\n一个名为MyContentProvider的Content Provider创建完成了，它用于从Sqlite数据库中添加和读取记录。\n\n### 四 ContentResolver\n\n一个ContentProvider新建好了之后，我们需要一个ContentResolver类来获取其共享出的数据。\n\n##### 1.ContentResolver的主要方法\n\n- public Uri insert(Uri uri, ContentValues values)　//添加\n- public int delete(Uri uri, String selection, String[] selectionArgs)　//删除\n- public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)　//更新\n- public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)//获取\n\n\n示例代码：\n\n```java\nContentResolver resolver =  getContentResolver();\nUri uri = Uri.parse(\"content://cn.scu.myprovider/user\");\n\n//插入\nContentValues values = new ContentValues();\nvalues.put(\"name\", \"fanrunqi\");\nvalues.put(\"age\", 24);\nresolver.insert(uri, values);  \n\n//查询\nCursor cursor = resolver.query(uri, null, null, null, \"userid desc\");\nwhile(cursor.moveToNext()){\n   //操作\n}\n\n//更新\nContentValues updateValues = new ContentValues();\nupdateValues.put(\"name\", \"finch\");\nUri updateIdUri = ContentUris.withAppendedId(uri, 1);\nresolver.update(updateIdUri, updateValues, null, null);\n\n//删除\nUri deleteIdUri = ContentUris.withAppendedId(uri, 2);\nresolver.delete(deleteIdUri, null, null);\n```\n\n##### 使用ContentResolver获取数据的步骤\n\n1. 通过getContentResolver()方法得到ContentResol1.ver对象。\n2. 调用ContentResolver类的query()方法查询数据，该方法会返回一个Cursor对象。\n3. 对得到的Cursor对象进行分析，得到需要的数据。\n4. 调用Cursor类的close()方法将Cursor对象关闭。\n\n示例代码（与上面ContentProvider处的代码相连）：\n\n> 代码\n\n\n### 五 总结\n\n\n\n\n      \n\n\n\n\n\n\n\n","slug":"android基础之Content-Providers","published":1,"updated":"2017-03-07T10:26:50.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk1m000qaknz3yzojsld","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>ContentProvider（内容提供者）是Android的四大组件之一，通过它可以向其他的应用程序共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。而且Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。</p>\n<p>但注意ContentProvider它也只是一个中间人，真正操作的数据源可能是数据库，也可以是文件、xml或网络等其他存储方式。</p>\n<h3 id=\"Uri类简介\"><a href=\"#Uri类简介\" class=\"headerlink\" title=\"Uri类简介\"></a>Uri类简介</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri uri = Uri.parse(<span class=\"string\">\"content://com.changcheng.provider.contactprovider/contact\"</span>)</div></pre></td></tr></table></figure>\n<p>在Content Provider中使用的查询字符串有别于标准的SQL查询。很多诸如select, add, delete, modify等操作我们都使用一种特殊的URI来进行，这种URI由3个部分组成， “content://”, 代表数据的路径，和一个可选的标识数据的ID。以下是一些示例URI:    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">content:<span class=\"comment\">//media/internal/images  //这个URI将返回设备上存储的所有图片</span></div><div class=\"line\">content:<span class=\"comment\">//contacts/people/  //这个URI将返回设备上的所有联系人信息</span></div><div class=\"line\">content:<span class=\"comment\">//contacts/people/45  //这个URI返回单个结果（联系人信息中ID为45的联系人记录）</span></div></pre></td></tr></table></figure>\n<p>尽管这种查询字符串格式很常见，但是它看起来还是有点令人迷惑。为此，Android提供一系列的帮助类（在android.provider包下），里面包含了很多以类变量形式给出的查询字符串，这种方式更容易让我们理解一点，因此，如上面content://contacts/people/45这个URI就可以写成如下形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri person = ContentUris.withAppendedId(People.CONTENT_URI,  <span class=\"number\">45</span>);</div></pre></td></tr></table></figure>\n<p>然后执行数据查询:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cursor cur = managedQuery(person, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<p>这个查询返回一个包含所有数据字段的游标，我们可以通过迭代这个游标来获取所有的数据.</p>\n<h3 id=\"三-ContentProvider类简介\"><a href=\"#三-ContentProvider类简介\" class=\"headerlink\" title=\"三 ContentProvider类简介\"></a>三 ContentProvider类简介</h3><h5 id=\"1-主要方法\"><a href=\"#1-主要方法\" class=\"headerlink\" title=\"1.主要方法\"></a>1.主要方法</h5><ul>\n<li>public boolean onCreate()<br>ContentProvider创建后　或　打开系统后其它应用第一次访问该ContentProvider时调用。      </li>\n<li>public Uri insert(Uri uri, ContentValues values)<br>外部应用向ContentProvider中添加数据。    </li>\n<li>public int delete(Uri uri, String selection, String[] selectionArgs)<br>外部应用从ContentProvider删除数据。    </li>\n<li>public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)<br>外部应用更新ContentProvider中的数据。    </li>\n<li>public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)　<br>供外部应用从ContentProvider中获取数据。 　    </li>\n<li>public String getType(Uri uri)<br>该方法用于返回当前Url所代表数据的MIME类型  </li>\n</ul>\n<h5 id=\"2-创建步骤\"><a href=\"#2-创建步骤\" class=\"headerlink\" title=\"2.创建步骤\"></a>2.创建步骤</h5><p>要创建我们自己的Content Provider的话，我们需要遵循以下几步：</p>\n<p>1.创建一个继承了ContentProvider父类的类<br>2.定义一个名为CONTENT_URI，并且是public static final的Uri类型的类变量，你必须为其指定一个唯一的字符串值，最好的方案是以类的全名称， 如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Uri CONTENT_URI = Uri.parse( “content:<span class=\"comment\">//com.google.android.MyContentProvider”);</span></div></pre></td></tr></table></figure>\n<p>3.定义你要返回给客户端的数据列名。如果你正在使用Android数据库，必须为其定义一个叫_id的列，它用来表示每条记录的唯一性。<br>4.创建你的数据存储系统。大多数Content Provider使用Android文件系统或SQLite数据库来保持数据，但是你也可以以任何你想要的方式来存储。<br>5.如果你要存储字节型数据，比如位图文件等，数据列其实是一个表示实际保存文件的URI字符串，通过它来读取对应的文件数据。处理这种数据类型的Content Provider需要实现一个名为_data的字段，_data字段列出了该文件在Android文件系统上的精确路径。这个字段不仅是供客户端使用，而且也可以供ContentResolver使用。客户端可以调用ContentResolver.openOutputStream()方法来处理该URI指向的文件资源；如果是ContentResolver本身的话，由于其持有的权限比客户端要高，所以它能直接访问该数据文件。<br>6.声明public static String型的变量，用于指定要从游标处返回的数据列。<br>7.查询返回一个Cursor类型的对象。所有执行写操作的方法如insert(), update() 以及delete()都将被监听。我们可以通过使用ContentResover().notifyChange()方法来通知监听器关于数据更新的信息。<br>8.在AndroidMenifest.xml中使用<provider>标签来设置Content Provider。<br>9.如果你要处理的数据类型是一种比较新的类型，你就必须先定义一个新的MIME类型，以供ContentProvider.geType(url)来返回。MIME类型有两种形式:一种是为指定的单个记录的，还有一种是为多条记录的。这里给出一种常用的格式：   </provider></p>\n<ul>\n<li>vnd.android.cursor.item/vnd.yourcompanyname.contenttype （单个记录的MIME类型）<br>比如, 一个请求列车信息的URI如content://com.example.transportationprovider/trains/122 可能就会返回typevnd.android.cursor.item/vnd.example.rail这样一个MIME类型。   </li>\n<li>vnd.android.cursor.dir/vnd.yourcompanyname.contenttype （多个记录的MIME类型）<br>比如, 一个请求所有列车信息的URI如content://com.example.transportationprovider/trains 可能就会返回vnd.android.cursor.dir/vnd.example.rail这样一个MIME 类型。</li>\n</ul>\n<p>下面是一个Content Provider代码示例：</p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<p>一个名为MyContentProvider的Content Provider创建完成了，它用于从Sqlite数据库中添加和读取记录。</p>\n<h3 id=\"四-ContentResolver\"><a href=\"#四-ContentResolver\" class=\"headerlink\" title=\"四 ContentResolver\"></a>四 ContentResolver</h3><p>一个ContentProvider新建好了之后，我们需要一个ContentResolver类来获取其共享出的数据。</p>\n<h5 id=\"1-ContentResolver的主要方法\"><a href=\"#1-ContentResolver的主要方法\" class=\"headerlink\" title=\"1.ContentResolver的主要方法\"></a>1.ContentResolver的主要方法</h5><ul>\n<li>public Uri insert(Uri uri, ContentValues values)　//添加</li>\n<li>public int delete(Uri uri, String selection, String[] selectionArgs)　//删除</li>\n<li>public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)　//更新</li>\n<li>public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)//获取</li>\n</ul>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">ContentResolver resolver =  getContentResolver();</div><div class=\"line\">Uri uri = Uri.parse(<span class=\"string\">\"content://cn.scu.myprovider/user\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//插入</span></div><div class=\"line\">ContentValues values = <span class=\"keyword\">new</span> ContentValues();</div><div class=\"line\">values.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"fanrunqi\"</span>);</div><div class=\"line\">values.put(<span class=\"string\">\"age\"</span>, <span class=\"number\">24</span>);</div><div class=\"line\">resolver.insert(uri, values);  </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//查询</span></div><div class=\"line\">Cursor cursor = resolver.query(uri, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"string\">\"userid desc\"</span>);</div><div class=\"line\"><span class=\"keyword\">while</span>(cursor.moveToNext())&#123;</div><div class=\"line\">   <span class=\"comment\">//操作</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//更新</span></div><div class=\"line\">ContentValues updateValues = <span class=\"keyword\">new</span> ContentValues();</div><div class=\"line\">updateValues.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"finch\"</span>);</div><div class=\"line\">Uri updateIdUri = ContentUris.withAppendedId(uri, <span class=\"number\">1</span>);</div><div class=\"line\">resolver.update(updateIdUri, updateValues, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//删除</span></div><div class=\"line\">Uri deleteIdUri = ContentUris.withAppendedId(uri, <span class=\"number\">2</span>);</div><div class=\"line\">resolver.delete(deleteIdUri, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<h5 id=\"使用ContentResolver获取数据的步骤\"><a href=\"#使用ContentResolver获取数据的步骤\" class=\"headerlink\" title=\"使用ContentResolver获取数据的步骤\"></a>使用ContentResolver获取数据的步骤</h5><ol>\n<li>通过getContentResolver()方法得到ContentResol1.ver对象。</li>\n<li>调用ContentResolver类的query()方法查询数据，该方法会返回一个Cursor对象。</li>\n<li>对得到的Cursor对象进行分析，得到需要的数据。</li>\n<li>调用Cursor类的close()方法将Cursor对象关闭。</li>\n</ol>\n<p>示例代码（与上面ContentProvider处的代码相连）：</p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<h3 id=\"五-总结\"><a href=\"#五-总结\" class=\"headerlink\" title=\"五 总结\"></a>五 总结</h3>","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>ContentProvider（内容提供者）是Android的四大组件之一，通过它可以向其他的应用程序共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。而且Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。</p>\n<p>但注意ContentProvider它也只是一个中间人，真正操作的数据源可能是数据库，也可以是文件、xml或网络等其他存储方式。</p>\n<h3 id=\"Uri类简介\"><a href=\"#Uri类简介\" class=\"headerlink\" title=\"Uri类简介\"></a>Uri类简介</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri uri = Uri.parse(<span class=\"string\">\"content://com.changcheng.provider.contactprovider/contact\"</span>)</div></pre></td></tr></table></figure>\n<p>在Content Provider中使用的查询字符串有别于标准的SQL查询。很多诸如select, add, delete, modify等操作我们都使用一种特殊的URI来进行，这种URI由3个部分组成， “content://”, 代表数据的路径，和一个可选的标识数据的ID。以下是一些示例URI:    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">content:<span class=\"comment\">//media/internal/images  //这个URI将返回设备上存储的所有图片</span></div><div class=\"line\">content:<span class=\"comment\">//contacts/people/  //这个URI将返回设备上的所有联系人信息</span></div><div class=\"line\">content:<span class=\"comment\">//contacts/people/45  //这个URI返回单个结果（联系人信息中ID为45的联系人记录）</span></div></pre></td></tr></table></figure>\n<p>尽管这种查询字符串格式很常见，但是它看起来还是有点令人迷惑。为此，Android提供一系列的帮助类（在android.provider包下），里面包含了很多以类变量形式给出的查询字符串，这种方式更容易让我们理解一点，因此，如上面content://contacts/people/45这个URI就可以写成如下形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uri person = ContentUris.withAppendedId(People.CONTENT_URI,  <span class=\"number\">45</span>);</div></pre></td></tr></table></figure>\n<p>然后执行数据查询:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cursor cur = managedQuery(person, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<p>这个查询返回一个包含所有数据字段的游标，我们可以通过迭代这个游标来获取所有的数据.</p>\n<h3 id=\"三-ContentProvider类简介\"><a href=\"#三-ContentProvider类简介\" class=\"headerlink\" title=\"三 ContentProvider类简介\"></a>三 ContentProvider类简介</h3><h5 id=\"1-主要方法\"><a href=\"#1-主要方法\" class=\"headerlink\" title=\"1.主要方法\"></a>1.主要方法</h5><ul>\n<li>public boolean onCreate()<br>ContentProvider创建后　或　打开系统后其它应用第一次访问该ContentProvider时调用。      </li>\n<li>public Uri insert(Uri uri, ContentValues values)<br>外部应用向ContentProvider中添加数据。    </li>\n<li>public int delete(Uri uri, String selection, String[] selectionArgs)<br>外部应用从ContentProvider删除数据。    </li>\n<li>public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)<br>外部应用更新ContentProvider中的数据。    </li>\n<li>public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)　<br>供外部应用从ContentProvider中获取数据。 　    </li>\n<li>public String getType(Uri uri)<br>该方法用于返回当前Url所代表数据的MIME类型  </li>\n</ul>\n<h5 id=\"2-创建步骤\"><a href=\"#2-创建步骤\" class=\"headerlink\" title=\"2.创建步骤\"></a>2.创建步骤</h5><p>要创建我们自己的Content Provider的话，我们需要遵循以下几步：</p>\n<p>1.创建一个继承了ContentProvider父类的类<br>2.定义一个名为CONTENT_URI，并且是public static final的Uri类型的类变量，你必须为其指定一个唯一的字符串值，最好的方案是以类的全名称， 如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Uri CONTENT_URI = Uri.parse( “content:<span class=\"comment\">//com.google.android.MyContentProvider”);</span></div></pre></td></tr></table></figure>\n<p>3.定义你要返回给客户端的数据列名。如果你正在使用Android数据库，必须为其定义一个叫_id的列，它用来表示每条记录的唯一性。<br>4.创建你的数据存储系统。大多数Content Provider使用Android文件系统或SQLite数据库来保持数据，但是你也可以以任何你想要的方式来存储。<br>5.如果你要存储字节型数据，比如位图文件等，数据列其实是一个表示实际保存文件的URI字符串，通过它来读取对应的文件数据。处理这种数据类型的Content Provider需要实现一个名为_data的字段，_data字段列出了该文件在Android文件系统上的精确路径。这个字段不仅是供客户端使用，而且也可以供ContentResolver使用。客户端可以调用ContentResolver.openOutputStream()方法来处理该URI指向的文件资源；如果是ContentResolver本身的话，由于其持有的权限比客户端要高，所以它能直接访问该数据文件。<br>6.声明public static String型的变量，用于指定要从游标处返回的数据列。<br>7.查询返回一个Cursor类型的对象。所有执行写操作的方法如insert(), update() 以及delete()都将被监听。我们可以通过使用ContentResover().notifyChange()方法来通知监听器关于数据更新的信息。<br>8.在AndroidMenifest.xml中使用<provider>标签来设置Content Provider。<br>9.如果你要处理的数据类型是一种比较新的类型，你就必须先定义一个新的MIME类型，以供ContentProvider.geType(url)来返回。MIME类型有两种形式:一种是为指定的单个记录的，还有一种是为多条记录的。这里给出一种常用的格式：   </p>\n<ul>\n<li>vnd.android.cursor.item/vnd.yourcompanyname.contenttype （单个记录的MIME类型）<br>比如, 一个请求列车信息的URI如content://com.example.transportationprovider/trains/122 可能就会返回typevnd.android.cursor.item/vnd.example.rail这样一个MIME类型。   </li>\n<li>vnd.android.cursor.dir/vnd.yourcompanyname.contenttype （多个记录的MIME类型）<br>比如, 一个请求所有列车信息的URI如content://com.example.transportationprovider/trains 可能就会返回vnd.android.cursor.dir/vnd.example.rail这样一个MIME 类型。</li>\n</ul>\n<p>下面是一个Content Provider代码示例：</p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<p>一个名为MyContentProvider的Content Provider创建完成了，它用于从Sqlite数据库中添加和读取记录。</p>\n<h3 id=\"四-ContentResolver\"><a href=\"#四-ContentResolver\" class=\"headerlink\" title=\"四 ContentResolver\"></a>四 ContentResolver</h3><p>一个ContentProvider新建好了之后，我们需要一个ContentResolver类来获取其共享出的数据。</p>\n<h5 id=\"1-ContentResolver的主要方法\"><a href=\"#1-ContentResolver的主要方法\" class=\"headerlink\" title=\"1.ContentResolver的主要方法\"></a>1.ContentResolver的主要方法</h5><ul>\n<li>public Uri insert(Uri uri, ContentValues values)　//添加</li>\n<li>public int delete(Uri uri, String selection, String[] selectionArgs)　//删除</li>\n<li>public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)　//更新</li>\n<li>public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)//获取</li>\n</ul>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">ContentResolver resolver =  getContentResolver();</div><div class=\"line\">Uri uri = Uri.parse(<span class=\"string\">\"content://cn.scu.myprovider/user\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//插入</span></div><div class=\"line\">ContentValues values = <span class=\"keyword\">new</span> ContentValues();</div><div class=\"line\">values.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"fanrunqi\"</span>);</div><div class=\"line\">values.put(<span class=\"string\">\"age\"</span>, <span class=\"number\">24</span>);</div><div class=\"line\">resolver.insert(uri, values);  </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//查询</span></div><div class=\"line\">Cursor cursor = resolver.query(uri, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"string\">\"userid desc\"</span>);</div><div class=\"line\"><span class=\"keyword\">while</span>(cursor.moveToNext())&#123;</div><div class=\"line\">   <span class=\"comment\">//操作</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//更新</span></div><div class=\"line\">ContentValues updateValues = <span class=\"keyword\">new</span> ContentValues();</div><div class=\"line\">updateValues.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"finch\"</span>);</div><div class=\"line\">Uri updateIdUri = ContentUris.withAppendedId(uri, <span class=\"number\">1</span>);</div><div class=\"line\">resolver.update(updateIdUri, updateValues, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//删除</span></div><div class=\"line\">Uri deleteIdUri = ContentUris.withAppendedId(uri, <span class=\"number\">2</span>);</div><div class=\"line\">resolver.delete(deleteIdUri, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<h5 id=\"使用ContentResolver获取数据的步骤\"><a href=\"#使用ContentResolver获取数据的步骤\" class=\"headerlink\" title=\"使用ContentResolver获取数据的步骤\"></a>使用ContentResolver获取数据的步骤</h5><ol>\n<li>通过getContentResolver()方法得到ContentResol1.ver对象。</li>\n<li>调用ContentResolver类的query()方法查询数据，该方法会返回一个Cursor对象。</li>\n<li>对得到的Cursor对象进行分析，得到需要的数据。</li>\n<li>调用Cursor类的close()方法将Cursor对象关闭。</li>\n</ol>\n<p>示例代码（与上面ContentProvider处的代码相连）：</p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<h3 id=\"五-总结\"><a href=\"#五-总结\" class=\"headerlink\" title=\"五 总结\"></a>五 总结</h3>"},{"title":"Java基础之集合","date":"2017-03-13T08:42:33.000Z","_content":"\n### 一 概述\n\n为了保存数量不确定的数据，以及具有映射关心的数据（也被称为关联数组），java从1.2开始提供了集合类。集合与数组不同，数组必须保存有确定数目的数据，且数组即可以保存基本数据也可以保存对象，而集合只能保存对象。集合类主要负责保存，盛装其他数据，因此集合类也被称作容器类。所有的集合都保存在java.util包下，从java1.5开始还在java.util.concurrent下提供了一下线程安全的集合类。\n\njava中的集合类主要由两个接口派生而出：Collection和Map，它们是java集合框架的根接口。其继承结构如下：\n\n```java\nCollection\n├List\n│├LinkedList\n│├ArrayList\n│└Vector\n│　└Stack\n├Queue\n└Set\nMap\n├Hashtable\n├HashMap\n└WeakHashMap\n```\n\n### Collection集合\n\nCollection是List，Set，Queue的父接口，因此在Collection中定义的接口在List，Set，Queue中均可使用。对集合的操作除了添加和删除之外，还有一个重要的操作就是遍历集合。下面来看一下集合中多种多样的遍历方法：\n\n##### 1.使用Iterator遍历集合（推荐方法）\n\n使用Iterator遍历集合是集合遍历的传统方法，也是推荐方法。Iterator也是java集合框架中的一员，但是它不是用来盛装数据，它的作用主要就是用来遍历（迭代访问）Collection中的元素。我们可以通过Collection下的iterator()来获得这个集合的迭代器对象，并使用它的方法对集合进行遍历。Iterator中包含以下方法:\n\n- boolean hasNext()   \n判断集合中的元素是否已遍历完，返回true，则还没遍历完\n- E next()   \n获取集合中的下一个元素\n- void remove()  \n删除集合中上一次next方法返回的元素\n- void forEachRemaining(Consumer action)   \nJava8新增的方法，可使用Lambda表达式遍历集合\n\nIterator遍历集合代码示例：\n\n\n\n##### 2.使用foreach循环迭代集合\n\n这是Java5新增的用于变异集合和数组的循环。\n\nforeach遍历集合代码示例：\n\n\n\n##### 3.使用Lambda表达式遍历集合\n\nJava从Java8开始新增Lambda表达式，在很多方面都简化了操作。在遍历集合方面就可以使用Lambda表达式，如：\n\n- forEach(Consumer action)   \nJava8在Iterable接口中增加了一个forEach(Consumer action)方法，该方法的参数类型是一个函数式接口。而Iterable接口时Collection接口的父接口，因此可使用该方法遍历集合。\n\n- forEachRemaining(Consumer action)   \nJava8中为Iterator新增的方法，可用于遍历集合。\n\n同时我们还可以用Lambda表达式对集合进行其他的操作，比如：\n\nJava8中为Collection新增了一个removeIf（Predicate filter）方法，Predicate也是函数式接口，可用它来过滤集合。\n\nJava8中新增了Stream，IntStream，LongStream，DoubleStream等流式API，这些API中有大量的聚集函数，如求和，去平均值等。而Collection中亦提供了一个stream()，可返回该集合对应的流，然后再通过这些流式API操作集合。\n\n### 二 List\n\nList是一个有序的，可重复的集合。List默认以元素的添加顺序来设置元素的索引（从0开始），因此可以通过索引来查找元素，也因此List允许重复的元素（不会无法分辨这两个元素）。\n\n由于存在索引，List可以通过普通的for来迭代，同事List继承于Collection，可以使用Collection中的方法，同事它还有一个额外的方法listIterator用于List的迭代。\n\n##### 1. ArrayList与Vector\n\nArrayList和Vector均是基于数组实现的List集合类，皆继承于List。它们的内部封装了一个动态的，允许再分配的Object[]数组，并使用initialCapacity参数来设置数组的长度（initialCapacity参数可以随着元素的增多而自动增长，默认是10），可通过ensureCapacity（int minCapacity）来一次性设置数组的initialCapacity值，减少重新分配内存的次数，提高性能。\n\nVector是一种古老的集合类，里面有一些命名很长的方法，现在已不推荐使用。它与ArrayList不同的是，它是线程安全的，而ArrayList不是。\n\nVector还有一个子类Stack，用于模拟栈这种数据结构，它也是线程安全的。但Stack也是一个古老的类，现已不推荐使用，要模拟栈可使用下文中ArrayDeque。\n\n- 固定长度的ArrayList   \nJava中有一个操作数组的工具类：Arrays，这个类中有一个方法asList可以将数组转换为一个List集合，但是这个ArrayList与上述介绍的不同，它不是继承于List，而是Arrays的内部类，这个集合只能遍历，而不能插入，删除。因此不推荐使用该方法将一个数组转换为集合。\n\n##### 2. LinkedList\n\nLinkedList也是List的实现类，但它同时还实现了Deque接口，提供额外的get，remove，insert方法在LinkedList的尾部和首部操作数据，因此LinkedList也可以被用作队列，双端队列，栈来使用。\n\nLinkedList底层是用链表实现的，因此的它的访问性能较差，但插入、删除性能较好。一般迭代LinkedList时需要使用迭代器Iterator，而迭代ArrayList使用普通的for循环即可。\n\n### 三 Set\n\nSet集合是无序集合。它就像一个罐子，无法记住元素的添加顺序。通时它也不允许出现重复元素（因为Set是无序的，若出现重复元素，则无法区分），若试图将两个相同的元素添加到一个Set中，则添加操作失败，add()方法返回false，元素不会被加入。常见的Set有HashSet，TreeSet，EnumSet，它们均继承于Set。\n\n##### 1. HashSet\n\nHashSet继承于Set，因此它具有Set的所有特点。同时它是通过Hash算法来计算元素的存储位置，具有很好的存取和查找性能。因为集合中只能存放对象，因此它们的存储位置实际上是通过对象的hashCode方法得到的。\n\n但是HashSet的判重和Set的不同，Set判重是通过equals()方法比较两个元素的值是否相同，HashSet的判重不只用equals比较两个元素的值，还比较这两个对象hashCode方法的返回值是否相等。只有这两者都满足，HashSet才会判断这两个元素重复。如果equals满足二hashCode不满足，则HashSet会在两个不同的hashCode位置存放这两个对象，而不会判定其重复；如果equals不满足而hashCode满足，则两个元素会被计算到同一个存储位置，此时该位置则采取链式结构来存放这两个元素。此时会严重影响HashSet的性能。\n\n因此，如果我们要重写该对象对应类的equals方法，则也应该重写它的hashCode方法，使得：如果两个对象通过equals方法返回为true，则他们的hashCode返回值也应该相同。\n\n##### 2. LinkedHashSet\n\nLinkedHashSet继承于HashSet，它与HashSet的不同之处在于它以链表来维持元素的插入次序。即当遍历LinkedHashSet时，它会按照元素的添加顺序来访问集合里的元素。\n\n因为LinkedHashSet要维护元素的插入顺序，因此它的性能要低于HashSet,但是当迭代访问集合里的全部元素时它有很好的性能。\n\n##### 3. TreeSet\n\nTreeSet是SortedSet的实现类（SortedSet是Set的子接口），它的底层实现是红黑树，可以确保集合中的元素一直处于排序状态。TreeSet中的排序分为自然排序和定制排序。\n\n自然排序默认是升序，这也是TreeSet默认的排序方式。这种方式TreeSet中的元素要实现Comparable接口，并重写它的compareTo()方法，TreeSet在放入元素时会自动调用该元素中compareTo方法与集合中的元素比较大小。同时TreeSet中亦不允许重复元素，因此当compareTo返回0时，元素不会被放入集合中（返回正整数则说明a大约b，负整数则相反）。\n应当注意：当把一个对象放入TreeSet中时，应当保证该对象的equals方法与compareTo方法得到的结果一致，即若equals方法返回true，则compareTo方法应当返回0。\n\n定制排序：要实现定制排序，如降序排列，需要在创建TreeSet时传入一个Comparator对象负责集合元素的排序逻辑，由于Comparator也是函数式接口，因此可以使用Lambda表达式来代替Comparator对象。\n\n##### 4. EnumSet\n\nEnumSet是一个专门为枚举类设计的集合，其中的元素必须是指定枚举类型的枚举值。EnumSet集合是有序的，它安枚举类中枚举值的定义顺序来决定集合的元素顺序。EnumSet没有暴露任何构造器（即没有公有的构造器），要创建EnumSet需要调用它的类方法（静态方法）。\n\nEnumSet在内部以位向量的方式存储，这种存储方式非常紧凑，高效，占用内存小，运行效率高。\n\n##### 5. 各Set实现类的性能分析\n\n- HashSet和TreeSet是常用实现，HashSet的性能要比TreeSet好一些，因为TreeSet需要额外的红黑树来维持元素的次序。\n\n\n- LinkedHashSet与HashSet相比，在插入、删除方面，HashSet要快一些；但是在遍历时，LinkedHashSet要更快。\n\n- EnumSet是所有Set实现类中性能最好的，但它功能有限，只能保存同一个枚举类的枚举值作为集合元素。\n\n### 四 Queue\n\nQueue集合用于模拟队列这种数据结构，队列是先进先出（FIFO）的，头部保存存放时间最长的元素，尾部保存存放时间最短的元素，队尾插入，队首出。Queue还有一个子接口Deque，Deque表示一个双端队列，因此既可以模拟队列也可以模拟栈。Deque有ArrayDeque和LinkedList两个实现类。\n\n##### 1. PriorityQueue\n\nPriorityQueue并不是严格的队列。它的队列中的元素的顺序并不是按插入队列的顺序，而是按照队列中元素的大小排序。PriorityQueue有两种排序方式：自然排序和定制排序。这点和TreeSet基本一致，可参考上文中TreeSet的简介。\n\n##### 2. Deque和ArrayDeque\n\n上文已经介绍了Deque，它是Queue的子接口，是一个双端队列，里面定义一些可以在队尾和队首操作元素的方法，因此它既可以模拟栈，也可以模拟队列。它主要有两个实现类：ArrayDeque和LinkedList。\n\nArrayDeque底层结构和ArrayList类似，一般用它来模拟栈，而不用Stack。\n\n### 五 Map\n\nMap是一个key-value键值对。它的每个单元包含key和value两个数据，由key可以找到value。key可以为空但不可重复，其实将它们分开来看，key就是一个Set集合，而value可以看做List，事实上Map中也有相应的方法。可以把Map看做value均为空的Set，事实上要想遍历Map，就需要获取key的Set集合。\n\n##### 1. HashMap和HashTable\n\nHashMap和Hashtable均为Map接口的实现类，它们之间的关系类似于ArrayList和Vector的关系。Hashtable是一个古老的实现类，现在已不推荐使用。\n\nHashMap和Hashtable有两点区别：\n\n- Hashtable是线程安全的，而HashMap不是\n- Hashtable中的key和value均不能为空，而HashMap的可以\n\n同时放入key中的对象需要被hash，所以key中的元素均要实现equals和hashCode方法，且二者结果应当一致，即若equals结果为true，则这两个元素的hashCode值也要相等。（与HashSet相同，Java的要hash类均要实现hashCode方法）。\n\n##### 2. LinkedHashMap\n\nLinkedHashMap是HashMap的子类，这俩的关系就像LinkedHashSet和HashSet的关系。使用一个链表来维持key的插入顺序。因此你可以在外部对元素排好序，然后让其顺序进入集合，就可以得到一个有序的HashMap，而不需要再对其进行排序。\n\n##### 3. Properties\n\nProperties是Hashtable的子类，也是一个古老的集合类，该类在处理属性文件是特别方便（属性文件即“属性名=属性值”的文件，如Windows上的ini文件）。可以把Properties看做一个key和value均为String的Map。该类可以与XML文件交互。\n\n##### 4. SortedMap和TreeMap\n\nTreeMap,SortedMap和Map的关心可以参照Set。TreeMap的实现与TreeSet类似，只是其中的元素换成了键值对，而所有对Set中元素的约束在TreeMap中均换成对key的约束。事实上在Java源码中Set的实现即是通过value均为null的Map完成的，所有Java中的Set和Map有很多相通之处。\n\n##### 5. WeakHashMap\n\nWeakHashMap即是key是弱引用的HashMap。若key被回收，则WeakHashMap会自动删除对应的key-value键值对。可使用它来做缓存。\n\n##### 6. IdentityHashMap\n\nIdentityHashMap与HashMap不同处在于：IdentityHashMap在处理key相等问题的方式是使用“==”，而不是equals。\n\n##### 7. EnumMap\n\nEnumMap是使用枚举类实现的Map，它的key是枚举类中的枚举值，创建它时必须传入一个枚举类（类的class对象）。它有以下几个特点：\n\n- 内部以数组形式保存，紧凑，高效。\n- 以枚举类中枚举值的定义顺序来维持key的顺序\n- key不能为空\n\n### 六 线程安全的集合类\n\n##### 1. 集合工具类Collections\n\nJava提供了一个操作集合的工具类：Collections，里面提供了大量的类方法用于对集合元素进行排序，查询，修改，同步，设置集合不可变等。（工具类中一般都是类方法，即静态方法）。\n\n其中就有一种synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从而解决了多线程并发访问集合时的线程安全问题。读者可以通过查看Collections的源码来了解它的用法。\n\n##### 2. 线程安全的集合类\n\n从Java5开始，Java在java.util.concurrent包下面提供了大量线程安全的集合类，主要可分为以下两类：\n\n- 以Concurrent开头的集合类      \n如ConcurrentHashMap，ConcurrentSkipListMap，ConcurrentSkipListSet，ConcurrentLinkedQueue，ConcurrentLinkedDeque等\n\n- 以CopyOnWrite开头的集合类       \n如CopyOnWriteArrayList，，CopyOnWriteArraySet等\n\n### 六 总结\n\n","source":"_posts/Java基础之集合.md","raw":"---\ntitle: Java基础之集合\ndate: 2017-03-13 16:42:33\ncategories: Java\ntags:\n- Java\n- List\n- Map\n- Set\n- 集合\n---\n\n### 一 概述\n\n为了保存数量不确定的数据，以及具有映射关心的数据（也被称为关联数组），java从1.2开始提供了集合类。集合与数组不同，数组必须保存有确定数目的数据，且数组即可以保存基本数据也可以保存对象，而集合只能保存对象。集合类主要负责保存，盛装其他数据，因此集合类也被称作容器类。所有的集合都保存在java.util包下，从java1.5开始还在java.util.concurrent下提供了一下线程安全的集合类。\n\njava中的集合类主要由两个接口派生而出：Collection和Map，它们是java集合框架的根接口。其继承结构如下：\n\n```java\nCollection\n├List\n│├LinkedList\n│├ArrayList\n│└Vector\n│　└Stack\n├Queue\n└Set\nMap\n├Hashtable\n├HashMap\n└WeakHashMap\n```\n\n### Collection集合\n\nCollection是List，Set，Queue的父接口，因此在Collection中定义的接口在List，Set，Queue中均可使用。对集合的操作除了添加和删除之外，还有一个重要的操作就是遍历集合。下面来看一下集合中多种多样的遍历方法：\n\n##### 1.使用Iterator遍历集合（推荐方法）\n\n使用Iterator遍历集合是集合遍历的传统方法，也是推荐方法。Iterator也是java集合框架中的一员，但是它不是用来盛装数据，它的作用主要就是用来遍历（迭代访问）Collection中的元素。我们可以通过Collection下的iterator()来获得这个集合的迭代器对象，并使用它的方法对集合进行遍历。Iterator中包含以下方法:\n\n- boolean hasNext()   \n判断集合中的元素是否已遍历完，返回true，则还没遍历完\n- E next()   \n获取集合中的下一个元素\n- void remove()  \n删除集合中上一次next方法返回的元素\n- void forEachRemaining(Consumer action)   \nJava8新增的方法，可使用Lambda表达式遍历集合\n\nIterator遍历集合代码示例：\n\n\n\n##### 2.使用foreach循环迭代集合\n\n这是Java5新增的用于变异集合和数组的循环。\n\nforeach遍历集合代码示例：\n\n\n\n##### 3.使用Lambda表达式遍历集合\n\nJava从Java8开始新增Lambda表达式，在很多方面都简化了操作。在遍历集合方面就可以使用Lambda表达式，如：\n\n- forEach(Consumer action)   \nJava8在Iterable接口中增加了一个forEach(Consumer action)方法，该方法的参数类型是一个函数式接口。而Iterable接口时Collection接口的父接口，因此可使用该方法遍历集合。\n\n- forEachRemaining(Consumer action)   \nJava8中为Iterator新增的方法，可用于遍历集合。\n\n同时我们还可以用Lambda表达式对集合进行其他的操作，比如：\n\nJava8中为Collection新增了一个removeIf（Predicate filter）方法，Predicate也是函数式接口，可用它来过滤集合。\n\nJava8中新增了Stream，IntStream，LongStream，DoubleStream等流式API，这些API中有大量的聚集函数，如求和，去平均值等。而Collection中亦提供了一个stream()，可返回该集合对应的流，然后再通过这些流式API操作集合。\n\n### 二 List\n\nList是一个有序的，可重复的集合。List默认以元素的添加顺序来设置元素的索引（从0开始），因此可以通过索引来查找元素，也因此List允许重复的元素（不会无法分辨这两个元素）。\n\n由于存在索引，List可以通过普通的for来迭代，同事List继承于Collection，可以使用Collection中的方法，同事它还有一个额外的方法listIterator用于List的迭代。\n\n##### 1. ArrayList与Vector\n\nArrayList和Vector均是基于数组实现的List集合类，皆继承于List。它们的内部封装了一个动态的，允许再分配的Object[]数组，并使用initialCapacity参数来设置数组的长度（initialCapacity参数可以随着元素的增多而自动增长，默认是10），可通过ensureCapacity（int minCapacity）来一次性设置数组的initialCapacity值，减少重新分配内存的次数，提高性能。\n\nVector是一种古老的集合类，里面有一些命名很长的方法，现在已不推荐使用。它与ArrayList不同的是，它是线程安全的，而ArrayList不是。\n\nVector还有一个子类Stack，用于模拟栈这种数据结构，它也是线程安全的。但Stack也是一个古老的类，现已不推荐使用，要模拟栈可使用下文中ArrayDeque。\n\n- 固定长度的ArrayList   \nJava中有一个操作数组的工具类：Arrays，这个类中有一个方法asList可以将数组转换为一个List集合，但是这个ArrayList与上述介绍的不同，它不是继承于List，而是Arrays的内部类，这个集合只能遍历，而不能插入，删除。因此不推荐使用该方法将一个数组转换为集合。\n\n##### 2. LinkedList\n\nLinkedList也是List的实现类，但它同时还实现了Deque接口，提供额外的get，remove，insert方法在LinkedList的尾部和首部操作数据，因此LinkedList也可以被用作队列，双端队列，栈来使用。\n\nLinkedList底层是用链表实现的，因此的它的访问性能较差，但插入、删除性能较好。一般迭代LinkedList时需要使用迭代器Iterator，而迭代ArrayList使用普通的for循环即可。\n\n### 三 Set\n\nSet集合是无序集合。它就像一个罐子，无法记住元素的添加顺序。通时它也不允许出现重复元素（因为Set是无序的，若出现重复元素，则无法区分），若试图将两个相同的元素添加到一个Set中，则添加操作失败，add()方法返回false，元素不会被加入。常见的Set有HashSet，TreeSet，EnumSet，它们均继承于Set。\n\n##### 1. HashSet\n\nHashSet继承于Set，因此它具有Set的所有特点。同时它是通过Hash算法来计算元素的存储位置，具有很好的存取和查找性能。因为集合中只能存放对象，因此它们的存储位置实际上是通过对象的hashCode方法得到的。\n\n但是HashSet的判重和Set的不同，Set判重是通过equals()方法比较两个元素的值是否相同，HashSet的判重不只用equals比较两个元素的值，还比较这两个对象hashCode方法的返回值是否相等。只有这两者都满足，HashSet才会判断这两个元素重复。如果equals满足二hashCode不满足，则HashSet会在两个不同的hashCode位置存放这两个对象，而不会判定其重复；如果equals不满足而hashCode满足，则两个元素会被计算到同一个存储位置，此时该位置则采取链式结构来存放这两个元素。此时会严重影响HashSet的性能。\n\n因此，如果我们要重写该对象对应类的equals方法，则也应该重写它的hashCode方法，使得：如果两个对象通过equals方法返回为true，则他们的hashCode返回值也应该相同。\n\n##### 2. LinkedHashSet\n\nLinkedHashSet继承于HashSet，它与HashSet的不同之处在于它以链表来维持元素的插入次序。即当遍历LinkedHashSet时，它会按照元素的添加顺序来访问集合里的元素。\n\n因为LinkedHashSet要维护元素的插入顺序，因此它的性能要低于HashSet,但是当迭代访问集合里的全部元素时它有很好的性能。\n\n##### 3. TreeSet\n\nTreeSet是SortedSet的实现类（SortedSet是Set的子接口），它的底层实现是红黑树，可以确保集合中的元素一直处于排序状态。TreeSet中的排序分为自然排序和定制排序。\n\n自然排序默认是升序，这也是TreeSet默认的排序方式。这种方式TreeSet中的元素要实现Comparable接口，并重写它的compareTo()方法，TreeSet在放入元素时会自动调用该元素中compareTo方法与集合中的元素比较大小。同时TreeSet中亦不允许重复元素，因此当compareTo返回0时，元素不会被放入集合中（返回正整数则说明a大约b，负整数则相反）。\n应当注意：当把一个对象放入TreeSet中时，应当保证该对象的equals方法与compareTo方法得到的结果一致，即若equals方法返回true，则compareTo方法应当返回0。\n\n定制排序：要实现定制排序，如降序排列，需要在创建TreeSet时传入一个Comparator对象负责集合元素的排序逻辑，由于Comparator也是函数式接口，因此可以使用Lambda表达式来代替Comparator对象。\n\n##### 4. EnumSet\n\nEnumSet是一个专门为枚举类设计的集合，其中的元素必须是指定枚举类型的枚举值。EnumSet集合是有序的，它安枚举类中枚举值的定义顺序来决定集合的元素顺序。EnumSet没有暴露任何构造器（即没有公有的构造器），要创建EnumSet需要调用它的类方法（静态方法）。\n\nEnumSet在内部以位向量的方式存储，这种存储方式非常紧凑，高效，占用内存小，运行效率高。\n\n##### 5. 各Set实现类的性能分析\n\n- HashSet和TreeSet是常用实现，HashSet的性能要比TreeSet好一些，因为TreeSet需要额外的红黑树来维持元素的次序。\n\n\n- LinkedHashSet与HashSet相比，在插入、删除方面，HashSet要快一些；但是在遍历时，LinkedHashSet要更快。\n\n- EnumSet是所有Set实现类中性能最好的，但它功能有限，只能保存同一个枚举类的枚举值作为集合元素。\n\n### 四 Queue\n\nQueue集合用于模拟队列这种数据结构，队列是先进先出（FIFO）的，头部保存存放时间最长的元素，尾部保存存放时间最短的元素，队尾插入，队首出。Queue还有一个子接口Deque，Deque表示一个双端队列，因此既可以模拟队列也可以模拟栈。Deque有ArrayDeque和LinkedList两个实现类。\n\n##### 1. PriorityQueue\n\nPriorityQueue并不是严格的队列。它的队列中的元素的顺序并不是按插入队列的顺序，而是按照队列中元素的大小排序。PriorityQueue有两种排序方式：自然排序和定制排序。这点和TreeSet基本一致，可参考上文中TreeSet的简介。\n\n##### 2. Deque和ArrayDeque\n\n上文已经介绍了Deque，它是Queue的子接口，是一个双端队列，里面定义一些可以在队尾和队首操作元素的方法，因此它既可以模拟栈，也可以模拟队列。它主要有两个实现类：ArrayDeque和LinkedList。\n\nArrayDeque底层结构和ArrayList类似，一般用它来模拟栈，而不用Stack。\n\n### 五 Map\n\nMap是一个key-value键值对。它的每个单元包含key和value两个数据，由key可以找到value。key可以为空但不可重复，其实将它们分开来看，key就是一个Set集合，而value可以看做List，事实上Map中也有相应的方法。可以把Map看做value均为空的Set，事实上要想遍历Map，就需要获取key的Set集合。\n\n##### 1. HashMap和HashTable\n\nHashMap和Hashtable均为Map接口的实现类，它们之间的关系类似于ArrayList和Vector的关系。Hashtable是一个古老的实现类，现在已不推荐使用。\n\nHashMap和Hashtable有两点区别：\n\n- Hashtable是线程安全的，而HashMap不是\n- Hashtable中的key和value均不能为空，而HashMap的可以\n\n同时放入key中的对象需要被hash，所以key中的元素均要实现equals和hashCode方法，且二者结果应当一致，即若equals结果为true，则这两个元素的hashCode值也要相等。（与HashSet相同，Java的要hash类均要实现hashCode方法）。\n\n##### 2. LinkedHashMap\n\nLinkedHashMap是HashMap的子类，这俩的关系就像LinkedHashSet和HashSet的关系。使用一个链表来维持key的插入顺序。因此你可以在外部对元素排好序，然后让其顺序进入集合，就可以得到一个有序的HashMap，而不需要再对其进行排序。\n\n##### 3. Properties\n\nProperties是Hashtable的子类，也是一个古老的集合类，该类在处理属性文件是特别方便（属性文件即“属性名=属性值”的文件，如Windows上的ini文件）。可以把Properties看做一个key和value均为String的Map。该类可以与XML文件交互。\n\n##### 4. SortedMap和TreeMap\n\nTreeMap,SortedMap和Map的关心可以参照Set。TreeMap的实现与TreeSet类似，只是其中的元素换成了键值对，而所有对Set中元素的约束在TreeMap中均换成对key的约束。事实上在Java源码中Set的实现即是通过value均为null的Map完成的，所有Java中的Set和Map有很多相通之处。\n\n##### 5. WeakHashMap\n\nWeakHashMap即是key是弱引用的HashMap。若key被回收，则WeakHashMap会自动删除对应的key-value键值对。可使用它来做缓存。\n\n##### 6. IdentityHashMap\n\nIdentityHashMap与HashMap不同处在于：IdentityHashMap在处理key相等问题的方式是使用“==”，而不是equals。\n\n##### 7. EnumMap\n\nEnumMap是使用枚举类实现的Map，它的key是枚举类中的枚举值，创建它时必须传入一个枚举类（类的class对象）。它有以下几个特点：\n\n- 内部以数组形式保存，紧凑，高效。\n- 以枚举类中枚举值的定义顺序来维持key的顺序\n- key不能为空\n\n### 六 线程安全的集合类\n\n##### 1. 集合工具类Collections\n\nJava提供了一个操作集合的工具类：Collections，里面提供了大量的类方法用于对集合元素进行排序，查询，修改，同步，设置集合不可变等。（工具类中一般都是类方法，即静态方法）。\n\n其中就有一种synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从而解决了多线程并发访问集合时的线程安全问题。读者可以通过查看Collections的源码来了解它的用法。\n\n##### 2. 线程安全的集合类\n\n从Java5开始，Java在java.util.concurrent包下面提供了大量线程安全的集合类，主要可分为以下两类：\n\n- 以Concurrent开头的集合类      \n如ConcurrentHashMap，ConcurrentSkipListMap，ConcurrentSkipListSet，ConcurrentLinkedQueue，ConcurrentLinkedDeque等\n\n- 以CopyOnWrite开头的集合类       \n如CopyOnWriteArrayList，，CopyOnWriteArraySet等\n\n### 六 总结\n\n","slug":"Java基础之集合","published":1,"updated":"2017-03-15T08:53:59.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk1o000taknzt4bpv7qo","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>为了保存数量不确定的数据，以及具有映射关心的数据（也被称为关联数组），java从1.2开始提供了集合类。集合与数组不同，数组必须保存有确定数目的数据，且数组即可以保存基本数据也可以保存对象，而集合只能保存对象。集合类主要负责保存，盛装其他数据，因此集合类也被称作容器类。所有的集合都保存在java.util包下，从java1.5开始还在java.util.concurrent下提供了一下线程安全的集合类。</p>\n<p>java中的集合类主要由两个接口派生而出：Collection和Map，它们是java集合框架的根接口。其继承结构如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Collection</div><div class=\"line\">├List</div><div class=\"line\">│├LinkedList</div><div class=\"line\">│├ArrayList</div><div class=\"line\">│└Vector</div><div class=\"line\">│　└Stack</div><div class=\"line\">├Queue</div><div class=\"line\">└Set</div><div class=\"line\">Map</div><div class=\"line\">├Hashtable</div><div class=\"line\">├HashMap</div><div class=\"line\">└WeakHashMap</div></pre></td></tr></table></figure>\n<h3 id=\"Collection集合\"><a href=\"#Collection集合\" class=\"headerlink\" title=\"Collection集合\"></a>Collection集合</h3><p>Collection是List，Set，Queue的父接口，因此在Collection中定义的接口在List，Set，Queue中均可使用。对集合的操作除了添加和删除之外，还有一个重要的操作就是遍历集合。下面来看一下集合中多种多样的遍历方法：</p>\n<h5 id=\"1-使用Iterator遍历集合（推荐方法）\"><a href=\"#1-使用Iterator遍历集合（推荐方法）\" class=\"headerlink\" title=\"1.使用Iterator遍历集合（推荐方法）\"></a>1.使用Iterator遍历集合（推荐方法）</h5><p>使用Iterator遍历集合是集合遍历的传统方法，也是推荐方法。Iterator也是java集合框架中的一员，但是它不是用来盛装数据，它的作用主要就是用来遍历（迭代访问）Collection中的元素。我们可以通过Collection下的iterator()来获得这个集合的迭代器对象，并使用它的方法对集合进行遍历。Iterator中包含以下方法:</p>\n<ul>\n<li>boolean hasNext()<br>判断集合中的元素是否已遍历完，返回true，则还没遍历完</li>\n<li>E next()<br>获取集合中的下一个元素</li>\n<li>void remove()<br>删除集合中上一次next方法返回的元素</li>\n<li>void forEachRemaining(Consumer action)<br>Java8新增的方法，可使用Lambda表达式遍历集合</li>\n</ul>\n<p>Iterator遍历集合代码示例：</p>\n<h5 id=\"2-使用foreach循环迭代集合\"><a href=\"#2-使用foreach循环迭代集合\" class=\"headerlink\" title=\"2.使用foreach循环迭代集合\"></a>2.使用foreach循环迭代集合</h5><p>这是Java5新增的用于变异集合和数组的循环。</p>\n<p>foreach遍历集合代码示例：</p>\n<h5 id=\"3-使用Lambda表达式遍历集合\"><a href=\"#3-使用Lambda表达式遍历集合\" class=\"headerlink\" title=\"3.使用Lambda表达式遍历集合\"></a>3.使用Lambda表达式遍历集合</h5><p>Java从Java8开始新增Lambda表达式，在很多方面都简化了操作。在遍历集合方面就可以使用Lambda表达式，如：</p>\n<ul>\n<li><p>forEach(Consumer action)<br>Java8在Iterable接口中增加了一个forEach(Consumer action)方法，该方法的参数类型是一个函数式接口。而Iterable接口时Collection接口的父接口，因此可使用该方法遍历集合。</p>\n</li>\n<li><p>forEachRemaining(Consumer action)<br>Java8中为Iterator新增的方法，可用于遍历集合。</p>\n</li>\n</ul>\n<p>同时我们还可以用Lambda表达式对集合进行其他的操作，比如：</p>\n<p>Java8中为Collection新增了一个removeIf（Predicate filter）方法，Predicate也是函数式接口，可用它来过滤集合。</p>\n<p>Java8中新增了Stream，IntStream，LongStream，DoubleStream等流式API，这些API中有大量的聚集函数，如求和，去平均值等。而Collection中亦提供了一个stream()，可返回该集合对应的流，然后再通过这些流式API操作集合。</p>\n<h3 id=\"二-List\"><a href=\"#二-List\" class=\"headerlink\" title=\"二 List\"></a>二 List</h3><p>List是一个有序的，可重复的集合。List默认以元素的添加顺序来设置元素的索引（从0开始），因此可以通过索引来查找元素，也因此List允许重复的元素（不会无法分辨这两个元素）。</p>\n<p>由于存在索引，List可以通过普通的for来迭代，同事List继承于Collection，可以使用Collection中的方法，同事它还有一个额外的方法listIterator用于List的迭代。</p>\n<h5 id=\"1-ArrayList与Vector\"><a href=\"#1-ArrayList与Vector\" class=\"headerlink\" title=\"1. ArrayList与Vector\"></a>1. ArrayList与Vector</h5><p>ArrayList和Vector均是基于数组实现的List集合类，皆继承于List。它们的内部封装了一个动态的，允许再分配的Object[]数组，并使用initialCapacity参数来设置数组的长度（initialCapacity参数可以随着元素的增多而自动增长，默认是10），可通过ensureCapacity（int minCapacity）来一次性设置数组的initialCapacity值，减少重新分配内存的次数，提高性能。</p>\n<p>Vector是一种古老的集合类，里面有一些命名很长的方法，现在已不推荐使用。它与ArrayList不同的是，它是线程安全的，而ArrayList不是。</p>\n<p>Vector还有一个子类Stack，用于模拟栈这种数据结构，它也是线程安全的。但Stack也是一个古老的类，现已不推荐使用，要模拟栈可使用下文中ArrayDeque。</p>\n<ul>\n<li>固定长度的ArrayList<br>Java中有一个操作数组的工具类：Arrays，这个类中有一个方法asList可以将数组转换为一个List集合，但是这个ArrayList与上述介绍的不同，它不是继承于List，而是Arrays的内部类，这个集合只能遍历，而不能插入，删除。因此不推荐使用该方法将一个数组转换为集合。</li>\n</ul>\n<h5 id=\"2-LinkedList\"><a href=\"#2-LinkedList\" class=\"headerlink\" title=\"2. LinkedList\"></a>2. LinkedList</h5><p>LinkedList也是List的实现类，但它同时还实现了Deque接口，提供额外的get，remove，insert方法在LinkedList的尾部和首部操作数据，因此LinkedList也可以被用作队列，双端队列，栈来使用。</p>\n<p>LinkedList底层是用链表实现的，因此的它的访问性能较差，但插入、删除性能较好。一般迭代LinkedList时需要使用迭代器Iterator，而迭代ArrayList使用普通的for循环即可。</p>\n<h3 id=\"三-Set\"><a href=\"#三-Set\" class=\"headerlink\" title=\"三 Set\"></a>三 Set</h3><p>Set集合是无序集合。它就像一个罐子，无法记住元素的添加顺序。通时它也不允许出现重复元素（因为Set是无序的，若出现重复元素，则无法区分），若试图将两个相同的元素添加到一个Set中，则添加操作失败，add()方法返回false，元素不会被加入。常见的Set有HashSet，TreeSet，EnumSet，它们均继承于Set。</p>\n<h5 id=\"1-HashSet\"><a href=\"#1-HashSet\" class=\"headerlink\" title=\"1. HashSet\"></a>1. HashSet</h5><p>HashSet继承于Set，因此它具有Set的所有特点。同时它是通过Hash算法来计算元素的存储位置，具有很好的存取和查找性能。因为集合中只能存放对象，因此它们的存储位置实际上是通过对象的hashCode方法得到的。</p>\n<p>但是HashSet的判重和Set的不同，Set判重是通过equals()方法比较两个元素的值是否相同，HashSet的判重不只用equals比较两个元素的值，还比较这两个对象hashCode方法的返回值是否相等。只有这两者都满足，HashSet才会判断这两个元素重复。如果equals满足二hashCode不满足，则HashSet会在两个不同的hashCode位置存放这两个对象，而不会判定其重复；如果equals不满足而hashCode满足，则两个元素会被计算到同一个存储位置，此时该位置则采取链式结构来存放这两个元素。此时会严重影响HashSet的性能。</p>\n<p>因此，如果我们要重写该对象对应类的equals方法，则也应该重写它的hashCode方法，使得：如果两个对象通过equals方法返回为true，则他们的hashCode返回值也应该相同。</p>\n<h5 id=\"2-LinkedHashSet\"><a href=\"#2-LinkedHashSet\" class=\"headerlink\" title=\"2. LinkedHashSet\"></a>2. LinkedHashSet</h5><p>LinkedHashSet继承于HashSet，它与HashSet的不同之处在于它以链表来维持元素的插入次序。即当遍历LinkedHashSet时，它会按照元素的添加顺序来访问集合里的元素。</p>\n<p>因为LinkedHashSet要维护元素的插入顺序，因此它的性能要低于HashSet,但是当迭代访问集合里的全部元素时它有很好的性能。</p>\n<h5 id=\"3-TreeSet\"><a href=\"#3-TreeSet\" class=\"headerlink\" title=\"3. TreeSet\"></a>3. TreeSet</h5><p>TreeSet是SortedSet的实现类（SortedSet是Set的子接口），它的底层实现是红黑树，可以确保集合中的元素一直处于排序状态。TreeSet中的排序分为自然排序和定制排序。</p>\n<p>自然排序默认是升序，这也是TreeSet默认的排序方式。这种方式TreeSet中的元素要实现Comparable接口，并重写它的compareTo()方法，TreeSet在放入元素时会自动调用该元素中compareTo方法与集合中的元素比较大小。同时TreeSet中亦不允许重复元素，因此当compareTo返回0时，元素不会被放入集合中（返回正整数则说明a大约b，负整数则相反）。<br>应当注意：当把一个对象放入TreeSet中时，应当保证该对象的equals方法与compareTo方法得到的结果一致，即若equals方法返回true，则compareTo方法应当返回0。</p>\n<p>定制排序：要实现定制排序，如降序排列，需要在创建TreeSet时传入一个Comparator对象负责集合元素的排序逻辑，由于Comparator也是函数式接口，因此可以使用Lambda表达式来代替Comparator对象。</p>\n<h5 id=\"4-EnumSet\"><a href=\"#4-EnumSet\" class=\"headerlink\" title=\"4. EnumSet\"></a>4. EnumSet</h5><p>EnumSet是一个专门为枚举类设计的集合，其中的元素必须是指定枚举类型的枚举值。EnumSet集合是有序的，它安枚举类中枚举值的定义顺序来决定集合的元素顺序。EnumSet没有暴露任何构造器（即没有公有的构造器），要创建EnumSet需要调用它的类方法（静态方法）。</p>\n<p>EnumSet在内部以位向量的方式存储，这种存储方式非常紧凑，高效，占用内存小，运行效率高。</p>\n<h5 id=\"5-各Set实现类的性能分析\"><a href=\"#5-各Set实现类的性能分析\" class=\"headerlink\" title=\"5. 各Set实现类的性能分析\"></a>5. 各Set实现类的性能分析</h5><ul>\n<li>HashSet和TreeSet是常用实现，HashSet的性能要比TreeSet好一些，因为TreeSet需要额外的红黑树来维持元素的次序。</li>\n</ul>\n<ul>\n<li><p>LinkedHashSet与HashSet相比，在插入、删除方面，HashSet要快一些；但是在遍历时，LinkedHashSet要更快。</p>\n</li>\n<li><p>EnumSet是所有Set实现类中性能最好的，但它功能有限，只能保存同一个枚举类的枚举值作为集合元素。</p>\n</li>\n</ul>\n<h3 id=\"四-Queue\"><a href=\"#四-Queue\" class=\"headerlink\" title=\"四 Queue\"></a>四 Queue</h3><p>Queue集合用于模拟队列这种数据结构，队列是先进先出（FIFO）的，头部保存存放时间最长的元素，尾部保存存放时间最短的元素，队尾插入，队首出。Queue还有一个子接口Deque，Deque表示一个双端队列，因此既可以模拟队列也可以模拟栈。Deque有ArrayDeque和LinkedList两个实现类。</p>\n<h5 id=\"1-PriorityQueue\"><a href=\"#1-PriorityQueue\" class=\"headerlink\" title=\"1. PriorityQueue\"></a>1. PriorityQueue</h5><p>PriorityQueue并不是严格的队列。它的队列中的元素的顺序并不是按插入队列的顺序，而是按照队列中元素的大小排序。PriorityQueue有两种排序方式：自然排序和定制排序。这点和TreeSet基本一致，可参考上文中TreeSet的简介。</p>\n<h5 id=\"2-Deque和ArrayDeque\"><a href=\"#2-Deque和ArrayDeque\" class=\"headerlink\" title=\"2. Deque和ArrayDeque\"></a>2. Deque和ArrayDeque</h5><p>上文已经介绍了Deque，它是Queue的子接口，是一个双端队列，里面定义一些可以在队尾和队首操作元素的方法，因此它既可以模拟栈，也可以模拟队列。它主要有两个实现类：ArrayDeque和LinkedList。</p>\n<p>ArrayDeque底层结构和ArrayList类似，一般用它来模拟栈，而不用Stack。</p>\n<h3 id=\"五-Map\"><a href=\"#五-Map\" class=\"headerlink\" title=\"五 Map\"></a>五 Map</h3><p>Map是一个key-value键值对。它的每个单元包含key和value两个数据，由key可以找到value。key可以为空但不可重复，其实将它们分开来看，key就是一个Set集合，而value可以看做List，事实上Map中也有相应的方法。可以把Map看做value均为空的Set，事实上要想遍历Map，就需要获取key的Set集合。</p>\n<h5 id=\"1-HashMap和HashTable\"><a href=\"#1-HashMap和HashTable\" class=\"headerlink\" title=\"1. HashMap和HashTable\"></a>1. HashMap和HashTable</h5><p>HashMap和Hashtable均为Map接口的实现类，它们之间的关系类似于ArrayList和Vector的关系。Hashtable是一个古老的实现类，现在已不推荐使用。</p>\n<p>HashMap和Hashtable有两点区别：</p>\n<ul>\n<li>Hashtable是线程安全的，而HashMap不是</li>\n<li>Hashtable中的key和value均不能为空，而HashMap的可以</li>\n</ul>\n<p>同时放入key中的对象需要被hash，所以key中的元素均要实现equals和hashCode方法，且二者结果应当一致，即若equals结果为true，则这两个元素的hashCode值也要相等。（与HashSet相同，Java的要hash类均要实现hashCode方法）。</p>\n<h5 id=\"2-LinkedHashMap\"><a href=\"#2-LinkedHashMap\" class=\"headerlink\" title=\"2. LinkedHashMap\"></a>2. LinkedHashMap</h5><p>LinkedHashMap是HashMap的子类，这俩的关系就像LinkedHashSet和HashSet的关系。使用一个链表来维持key的插入顺序。因此你可以在外部对元素排好序，然后让其顺序进入集合，就可以得到一个有序的HashMap，而不需要再对其进行排序。</p>\n<h5 id=\"3-Properties\"><a href=\"#3-Properties\" class=\"headerlink\" title=\"3. Properties\"></a>3. Properties</h5><p>Properties是Hashtable的子类，也是一个古老的集合类，该类在处理属性文件是特别方便（属性文件即“属性名=属性值”的文件，如Windows上的ini文件）。可以把Properties看做一个key和value均为String的Map。该类可以与XML文件交互。</p>\n<h5 id=\"4-SortedMap和TreeMap\"><a href=\"#4-SortedMap和TreeMap\" class=\"headerlink\" title=\"4. SortedMap和TreeMap\"></a>4. SortedMap和TreeMap</h5><p>TreeMap,SortedMap和Map的关心可以参照Set。TreeMap的实现与TreeSet类似，只是其中的元素换成了键值对，而所有对Set中元素的约束在TreeMap中均换成对key的约束。事实上在Java源码中Set的实现即是通过value均为null的Map完成的，所有Java中的Set和Map有很多相通之处。</p>\n<h5 id=\"5-WeakHashMap\"><a href=\"#5-WeakHashMap\" class=\"headerlink\" title=\"5. WeakHashMap\"></a>5. WeakHashMap</h5><p>WeakHashMap即是key是弱引用的HashMap。若key被回收，则WeakHashMap会自动删除对应的key-value键值对。可使用它来做缓存。</p>\n<h5 id=\"6-IdentityHashMap\"><a href=\"#6-IdentityHashMap\" class=\"headerlink\" title=\"6. IdentityHashMap\"></a>6. IdentityHashMap</h5><p>IdentityHashMap与HashMap不同处在于：IdentityHashMap在处理key相等问题的方式是使用“==”，而不是equals。</p>\n<h5 id=\"7-EnumMap\"><a href=\"#7-EnumMap\" class=\"headerlink\" title=\"7. EnumMap\"></a>7. EnumMap</h5><p>EnumMap是使用枚举类实现的Map，它的key是枚举类中的枚举值，创建它时必须传入一个枚举类（类的class对象）。它有以下几个特点：</p>\n<ul>\n<li>内部以数组形式保存，紧凑，高效。</li>\n<li>以枚举类中枚举值的定义顺序来维持key的顺序</li>\n<li>key不能为空</li>\n</ul>\n<h3 id=\"六-线程安全的集合类\"><a href=\"#六-线程安全的集合类\" class=\"headerlink\" title=\"六 线程安全的集合类\"></a>六 线程安全的集合类</h3><h5 id=\"1-集合工具类Collections\"><a href=\"#1-集合工具类Collections\" class=\"headerlink\" title=\"1. 集合工具类Collections\"></a>1. 集合工具类Collections</h5><p>Java提供了一个操作集合的工具类：Collections，里面提供了大量的类方法用于对集合元素进行排序，查询，修改，同步，设置集合不可变等。（工具类中一般都是类方法，即静态方法）。</p>\n<p>其中就有一种synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从而解决了多线程并发访问集合时的线程安全问题。读者可以通过查看Collections的源码来了解它的用法。</p>\n<h5 id=\"2-线程安全的集合类\"><a href=\"#2-线程安全的集合类\" class=\"headerlink\" title=\"2. 线程安全的集合类\"></a>2. 线程安全的集合类</h5><p>从Java5开始，Java在java.util.concurrent包下面提供了大量线程安全的集合类，主要可分为以下两类：</p>\n<ul>\n<li><p>以Concurrent开头的集合类<br>如ConcurrentHashMap，ConcurrentSkipListMap，ConcurrentSkipListSet，ConcurrentLinkedQueue，ConcurrentLinkedDeque等</p>\n</li>\n<li><p>以CopyOnWrite开头的集合类<br>如CopyOnWriteArrayList，，CopyOnWriteArraySet等</p>\n</li>\n</ul>\n<h3 id=\"六-总结\"><a href=\"#六-总结\" class=\"headerlink\" title=\"六 总结\"></a>六 总结</h3>","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>为了保存数量不确定的数据，以及具有映射关心的数据（也被称为关联数组），java从1.2开始提供了集合类。集合与数组不同，数组必须保存有确定数目的数据，且数组即可以保存基本数据也可以保存对象，而集合只能保存对象。集合类主要负责保存，盛装其他数据，因此集合类也被称作容器类。所有的集合都保存在java.util包下，从java1.5开始还在java.util.concurrent下提供了一下线程安全的集合类。</p>\n<p>java中的集合类主要由两个接口派生而出：Collection和Map，它们是java集合框架的根接口。其继承结构如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Collection</div><div class=\"line\">├List</div><div class=\"line\">│├LinkedList</div><div class=\"line\">│├ArrayList</div><div class=\"line\">│└Vector</div><div class=\"line\">│　└Stack</div><div class=\"line\">├Queue</div><div class=\"line\">└Set</div><div class=\"line\">Map</div><div class=\"line\">├Hashtable</div><div class=\"line\">├HashMap</div><div class=\"line\">└WeakHashMap</div></pre></td></tr></table></figure>\n<h3 id=\"Collection集合\"><a href=\"#Collection集合\" class=\"headerlink\" title=\"Collection集合\"></a>Collection集合</h3><p>Collection是List，Set，Queue的父接口，因此在Collection中定义的接口在List，Set，Queue中均可使用。对集合的操作除了添加和删除之外，还有一个重要的操作就是遍历集合。下面来看一下集合中多种多样的遍历方法：</p>\n<h5 id=\"1-使用Iterator遍历集合（推荐方法）\"><a href=\"#1-使用Iterator遍历集合（推荐方法）\" class=\"headerlink\" title=\"1.使用Iterator遍历集合（推荐方法）\"></a>1.使用Iterator遍历集合（推荐方法）</h5><p>使用Iterator遍历集合是集合遍历的传统方法，也是推荐方法。Iterator也是java集合框架中的一员，但是它不是用来盛装数据，它的作用主要就是用来遍历（迭代访问）Collection中的元素。我们可以通过Collection下的iterator()来获得这个集合的迭代器对象，并使用它的方法对集合进行遍历。Iterator中包含以下方法:</p>\n<ul>\n<li>boolean hasNext()<br>判断集合中的元素是否已遍历完，返回true，则还没遍历完</li>\n<li>E next()<br>获取集合中的下一个元素</li>\n<li>void remove()<br>删除集合中上一次next方法返回的元素</li>\n<li>void forEachRemaining(Consumer action)<br>Java8新增的方法，可使用Lambda表达式遍历集合</li>\n</ul>\n<p>Iterator遍历集合代码示例：</p>\n<h5 id=\"2-使用foreach循环迭代集合\"><a href=\"#2-使用foreach循环迭代集合\" class=\"headerlink\" title=\"2.使用foreach循环迭代集合\"></a>2.使用foreach循环迭代集合</h5><p>这是Java5新增的用于变异集合和数组的循环。</p>\n<p>foreach遍历集合代码示例：</p>\n<h5 id=\"3-使用Lambda表达式遍历集合\"><a href=\"#3-使用Lambda表达式遍历集合\" class=\"headerlink\" title=\"3.使用Lambda表达式遍历集合\"></a>3.使用Lambda表达式遍历集合</h5><p>Java从Java8开始新增Lambda表达式，在很多方面都简化了操作。在遍历集合方面就可以使用Lambda表达式，如：</p>\n<ul>\n<li><p>forEach(Consumer action)<br>Java8在Iterable接口中增加了一个forEach(Consumer action)方法，该方法的参数类型是一个函数式接口。而Iterable接口时Collection接口的父接口，因此可使用该方法遍历集合。</p>\n</li>\n<li><p>forEachRemaining(Consumer action)<br>Java8中为Iterator新增的方法，可用于遍历集合。</p>\n</li>\n</ul>\n<p>同时我们还可以用Lambda表达式对集合进行其他的操作，比如：</p>\n<p>Java8中为Collection新增了一个removeIf（Predicate filter）方法，Predicate也是函数式接口，可用它来过滤集合。</p>\n<p>Java8中新增了Stream，IntStream，LongStream，DoubleStream等流式API，这些API中有大量的聚集函数，如求和，去平均值等。而Collection中亦提供了一个stream()，可返回该集合对应的流，然后再通过这些流式API操作集合。</p>\n<h3 id=\"二-List\"><a href=\"#二-List\" class=\"headerlink\" title=\"二 List\"></a>二 List</h3><p>List是一个有序的，可重复的集合。List默认以元素的添加顺序来设置元素的索引（从0开始），因此可以通过索引来查找元素，也因此List允许重复的元素（不会无法分辨这两个元素）。</p>\n<p>由于存在索引，List可以通过普通的for来迭代，同事List继承于Collection，可以使用Collection中的方法，同事它还有一个额外的方法listIterator用于List的迭代。</p>\n<h5 id=\"1-ArrayList与Vector\"><a href=\"#1-ArrayList与Vector\" class=\"headerlink\" title=\"1. ArrayList与Vector\"></a>1. ArrayList与Vector</h5><p>ArrayList和Vector均是基于数组实现的List集合类，皆继承于List。它们的内部封装了一个动态的，允许再分配的Object[]数组，并使用initialCapacity参数来设置数组的长度（initialCapacity参数可以随着元素的增多而自动增长，默认是10），可通过ensureCapacity（int minCapacity）来一次性设置数组的initialCapacity值，减少重新分配内存的次数，提高性能。</p>\n<p>Vector是一种古老的集合类，里面有一些命名很长的方法，现在已不推荐使用。它与ArrayList不同的是，它是线程安全的，而ArrayList不是。</p>\n<p>Vector还有一个子类Stack，用于模拟栈这种数据结构，它也是线程安全的。但Stack也是一个古老的类，现已不推荐使用，要模拟栈可使用下文中ArrayDeque。</p>\n<ul>\n<li>固定长度的ArrayList<br>Java中有一个操作数组的工具类：Arrays，这个类中有一个方法asList可以将数组转换为一个List集合，但是这个ArrayList与上述介绍的不同，它不是继承于List，而是Arrays的内部类，这个集合只能遍历，而不能插入，删除。因此不推荐使用该方法将一个数组转换为集合。</li>\n</ul>\n<h5 id=\"2-LinkedList\"><a href=\"#2-LinkedList\" class=\"headerlink\" title=\"2. LinkedList\"></a>2. LinkedList</h5><p>LinkedList也是List的实现类，但它同时还实现了Deque接口，提供额外的get，remove，insert方法在LinkedList的尾部和首部操作数据，因此LinkedList也可以被用作队列，双端队列，栈来使用。</p>\n<p>LinkedList底层是用链表实现的，因此的它的访问性能较差，但插入、删除性能较好。一般迭代LinkedList时需要使用迭代器Iterator，而迭代ArrayList使用普通的for循环即可。</p>\n<h3 id=\"三-Set\"><a href=\"#三-Set\" class=\"headerlink\" title=\"三 Set\"></a>三 Set</h3><p>Set集合是无序集合。它就像一个罐子，无法记住元素的添加顺序。通时它也不允许出现重复元素（因为Set是无序的，若出现重复元素，则无法区分），若试图将两个相同的元素添加到一个Set中，则添加操作失败，add()方法返回false，元素不会被加入。常见的Set有HashSet，TreeSet，EnumSet，它们均继承于Set。</p>\n<h5 id=\"1-HashSet\"><a href=\"#1-HashSet\" class=\"headerlink\" title=\"1. HashSet\"></a>1. HashSet</h5><p>HashSet继承于Set，因此它具有Set的所有特点。同时它是通过Hash算法来计算元素的存储位置，具有很好的存取和查找性能。因为集合中只能存放对象，因此它们的存储位置实际上是通过对象的hashCode方法得到的。</p>\n<p>但是HashSet的判重和Set的不同，Set判重是通过equals()方法比较两个元素的值是否相同，HashSet的判重不只用equals比较两个元素的值，还比较这两个对象hashCode方法的返回值是否相等。只有这两者都满足，HashSet才会判断这两个元素重复。如果equals满足二hashCode不满足，则HashSet会在两个不同的hashCode位置存放这两个对象，而不会判定其重复；如果equals不满足而hashCode满足，则两个元素会被计算到同一个存储位置，此时该位置则采取链式结构来存放这两个元素。此时会严重影响HashSet的性能。</p>\n<p>因此，如果我们要重写该对象对应类的equals方法，则也应该重写它的hashCode方法，使得：如果两个对象通过equals方法返回为true，则他们的hashCode返回值也应该相同。</p>\n<h5 id=\"2-LinkedHashSet\"><a href=\"#2-LinkedHashSet\" class=\"headerlink\" title=\"2. LinkedHashSet\"></a>2. LinkedHashSet</h5><p>LinkedHashSet继承于HashSet，它与HashSet的不同之处在于它以链表来维持元素的插入次序。即当遍历LinkedHashSet时，它会按照元素的添加顺序来访问集合里的元素。</p>\n<p>因为LinkedHashSet要维护元素的插入顺序，因此它的性能要低于HashSet,但是当迭代访问集合里的全部元素时它有很好的性能。</p>\n<h5 id=\"3-TreeSet\"><a href=\"#3-TreeSet\" class=\"headerlink\" title=\"3. TreeSet\"></a>3. TreeSet</h5><p>TreeSet是SortedSet的实现类（SortedSet是Set的子接口），它的底层实现是红黑树，可以确保集合中的元素一直处于排序状态。TreeSet中的排序分为自然排序和定制排序。</p>\n<p>自然排序默认是升序，这也是TreeSet默认的排序方式。这种方式TreeSet中的元素要实现Comparable接口，并重写它的compareTo()方法，TreeSet在放入元素时会自动调用该元素中compareTo方法与集合中的元素比较大小。同时TreeSet中亦不允许重复元素，因此当compareTo返回0时，元素不会被放入集合中（返回正整数则说明a大约b，负整数则相反）。<br>应当注意：当把一个对象放入TreeSet中时，应当保证该对象的equals方法与compareTo方法得到的结果一致，即若equals方法返回true，则compareTo方法应当返回0。</p>\n<p>定制排序：要实现定制排序，如降序排列，需要在创建TreeSet时传入一个Comparator对象负责集合元素的排序逻辑，由于Comparator也是函数式接口，因此可以使用Lambda表达式来代替Comparator对象。</p>\n<h5 id=\"4-EnumSet\"><a href=\"#4-EnumSet\" class=\"headerlink\" title=\"4. EnumSet\"></a>4. EnumSet</h5><p>EnumSet是一个专门为枚举类设计的集合，其中的元素必须是指定枚举类型的枚举值。EnumSet集合是有序的，它安枚举类中枚举值的定义顺序来决定集合的元素顺序。EnumSet没有暴露任何构造器（即没有公有的构造器），要创建EnumSet需要调用它的类方法（静态方法）。</p>\n<p>EnumSet在内部以位向量的方式存储，这种存储方式非常紧凑，高效，占用内存小，运行效率高。</p>\n<h5 id=\"5-各Set实现类的性能分析\"><a href=\"#5-各Set实现类的性能分析\" class=\"headerlink\" title=\"5. 各Set实现类的性能分析\"></a>5. 各Set实现类的性能分析</h5><ul>\n<li>HashSet和TreeSet是常用实现，HashSet的性能要比TreeSet好一些，因为TreeSet需要额外的红黑树来维持元素的次序。</li>\n</ul>\n<ul>\n<li><p>LinkedHashSet与HashSet相比，在插入、删除方面，HashSet要快一些；但是在遍历时，LinkedHashSet要更快。</p>\n</li>\n<li><p>EnumSet是所有Set实现类中性能最好的，但它功能有限，只能保存同一个枚举类的枚举值作为集合元素。</p>\n</li>\n</ul>\n<h3 id=\"四-Queue\"><a href=\"#四-Queue\" class=\"headerlink\" title=\"四 Queue\"></a>四 Queue</h3><p>Queue集合用于模拟队列这种数据结构，队列是先进先出（FIFO）的，头部保存存放时间最长的元素，尾部保存存放时间最短的元素，队尾插入，队首出。Queue还有一个子接口Deque，Deque表示一个双端队列，因此既可以模拟队列也可以模拟栈。Deque有ArrayDeque和LinkedList两个实现类。</p>\n<h5 id=\"1-PriorityQueue\"><a href=\"#1-PriorityQueue\" class=\"headerlink\" title=\"1. PriorityQueue\"></a>1. PriorityQueue</h5><p>PriorityQueue并不是严格的队列。它的队列中的元素的顺序并不是按插入队列的顺序，而是按照队列中元素的大小排序。PriorityQueue有两种排序方式：自然排序和定制排序。这点和TreeSet基本一致，可参考上文中TreeSet的简介。</p>\n<h5 id=\"2-Deque和ArrayDeque\"><a href=\"#2-Deque和ArrayDeque\" class=\"headerlink\" title=\"2. Deque和ArrayDeque\"></a>2. Deque和ArrayDeque</h5><p>上文已经介绍了Deque，它是Queue的子接口，是一个双端队列，里面定义一些可以在队尾和队首操作元素的方法，因此它既可以模拟栈，也可以模拟队列。它主要有两个实现类：ArrayDeque和LinkedList。</p>\n<p>ArrayDeque底层结构和ArrayList类似，一般用它来模拟栈，而不用Stack。</p>\n<h3 id=\"五-Map\"><a href=\"#五-Map\" class=\"headerlink\" title=\"五 Map\"></a>五 Map</h3><p>Map是一个key-value键值对。它的每个单元包含key和value两个数据，由key可以找到value。key可以为空但不可重复，其实将它们分开来看，key就是一个Set集合，而value可以看做List，事实上Map中也有相应的方法。可以把Map看做value均为空的Set，事实上要想遍历Map，就需要获取key的Set集合。</p>\n<h5 id=\"1-HashMap和HashTable\"><a href=\"#1-HashMap和HashTable\" class=\"headerlink\" title=\"1. HashMap和HashTable\"></a>1. HashMap和HashTable</h5><p>HashMap和Hashtable均为Map接口的实现类，它们之间的关系类似于ArrayList和Vector的关系。Hashtable是一个古老的实现类，现在已不推荐使用。</p>\n<p>HashMap和Hashtable有两点区别：</p>\n<ul>\n<li>Hashtable是线程安全的，而HashMap不是</li>\n<li>Hashtable中的key和value均不能为空，而HashMap的可以</li>\n</ul>\n<p>同时放入key中的对象需要被hash，所以key中的元素均要实现equals和hashCode方法，且二者结果应当一致，即若equals结果为true，则这两个元素的hashCode值也要相等。（与HashSet相同，Java的要hash类均要实现hashCode方法）。</p>\n<h5 id=\"2-LinkedHashMap\"><a href=\"#2-LinkedHashMap\" class=\"headerlink\" title=\"2. LinkedHashMap\"></a>2. LinkedHashMap</h5><p>LinkedHashMap是HashMap的子类，这俩的关系就像LinkedHashSet和HashSet的关系。使用一个链表来维持key的插入顺序。因此你可以在外部对元素排好序，然后让其顺序进入集合，就可以得到一个有序的HashMap，而不需要再对其进行排序。</p>\n<h5 id=\"3-Properties\"><a href=\"#3-Properties\" class=\"headerlink\" title=\"3. Properties\"></a>3. Properties</h5><p>Properties是Hashtable的子类，也是一个古老的集合类，该类在处理属性文件是特别方便（属性文件即“属性名=属性值”的文件，如Windows上的ini文件）。可以把Properties看做一个key和value均为String的Map。该类可以与XML文件交互。</p>\n<h5 id=\"4-SortedMap和TreeMap\"><a href=\"#4-SortedMap和TreeMap\" class=\"headerlink\" title=\"4. SortedMap和TreeMap\"></a>4. SortedMap和TreeMap</h5><p>TreeMap,SortedMap和Map的关心可以参照Set。TreeMap的实现与TreeSet类似，只是其中的元素换成了键值对，而所有对Set中元素的约束在TreeMap中均换成对key的约束。事实上在Java源码中Set的实现即是通过value均为null的Map完成的，所有Java中的Set和Map有很多相通之处。</p>\n<h5 id=\"5-WeakHashMap\"><a href=\"#5-WeakHashMap\" class=\"headerlink\" title=\"5. WeakHashMap\"></a>5. WeakHashMap</h5><p>WeakHashMap即是key是弱引用的HashMap。若key被回收，则WeakHashMap会自动删除对应的key-value键值对。可使用它来做缓存。</p>\n<h5 id=\"6-IdentityHashMap\"><a href=\"#6-IdentityHashMap\" class=\"headerlink\" title=\"6. IdentityHashMap\"></a>6. IdentityHashMap</h5><p>IdentityHashMap与HashMap不同处在于：IdentityHashMap在处理key相等问题的方式是使用“==”，而不是equals。</p>\n<h5 id=\"7-EnumMap\"><a href=\"#7-EnumMap\" class=\"headerlink\" title=\"7. EnumMap\"></a>7. EnumMap</h5><p>EnumMap是使用枚举类实现的Map，它的key是枚举类中的枚举值，创建它时必须传入一个枚举类（类的class对象）。它有以下几个特点：</p>\n<ul>\n<li>内部以数组形式保存，紧凑，高效。</li>\n<li>以枚举类中枚举值的定义顺序来维持key的顺序</li>\n<li>key不能为空</li>\n</ul>\n<h3 id=\"六-线程安全的集合类\"><a href=\"#六-线程安全的集合类\" class=\"headerlink\" title=\"六 线程安全的集合类\"></a>六 线程安全的集合类</h3><h5 id=\"1-集合工具类Collections\"><a href=\"#1-集合工具类Collections\" class=\"headerlink\" title=\"1. 集合工具类Collections\"></a>1. 集合工具类Collections</h5><p>Java提供了一个操作集合的工具类：Collections，里面提供了大量的类方法用于对集合元素进行排序，查询，修改，同步，设置集合不可变等。（工具类中一般都是类方法，即静态方法）。</p>\n<p>其中就有一种synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从而解决了多线程并发访问集合时的线程安全问题。读者可以通过查看Collections的源码来了解它的用法。</p>\n<h5 id=\"2-线程安全的集合类\"><a href=\"#2-线程安全的集合类\" class=\"headerlink\" title=\"2. 线程安全的集合类\"></a>2. 线程安全的集合类</h5><p>从Java5开始，Java在java.util.concurrent包下面提供了大量线程安全的集合类，主要可分为以下两类：</p>\n<ul>\n<li><p>以Concurrent开头的集合类<br>如ConcurrentHashMap，ConcurrentSkipListMap，ConcurrentSkipListSet，ConcurrentLinkedQueue，ConcurrentLinkedDeque等</p>\n</li>\n<li><p>以CopyOnWrite开头的集合类<br>如CopyOnWriteArrayList，，CopyOnWriteArraySet等</p>\n</li>\n</ul>\n<h3 id=\"六-总结\"><a href=\"#六-总结\" class=\"headerlink\" title=\"六 总结\"></a>六 总结</h3>"},{"title":"android基础之BroadcastReceiver","date":"2017-02-27T06:48:31.000Z","_content":"\n### 一 BroadcastReceiver简介\n\n广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。如：在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。\n\nBroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。\n\n当系统或应用发出广播时，将会扫描系统中的所有广播接收者，通过action匹配将广播发送给相应的接收者，接收者收到广播后将会产生一个广播接收者的实例，执行其中的onReceiver()这个方法；特别需要注意的是这个实例的生命周期只有10秒，如果10秒内没执行结束onReceiver()，系统将会报错。在onReceiver()执行完毕之后，该实例将会被销毁，所以不要在onReceiver()中执行耗时操作，也不要在里面创建子线程处理业务（因为可能子线程没处理完，接收者就被回收了，那么子线程也会跟着被回收掉）；正确的处理方法就是通过in调用activity或者service处理业务。\n\n### 二 BroadcastReceiver的两种注册方式\n\n##### 1.静态注册（推荐）\n\n静态注册的广播接收者是一个常驻在系统中的全局监听器，当你在应用中配置了一个静态的BroadcastReceiver，安装了应用后而无论应用是否处于运行状态，广播接收者都是已经常驻在系统中了。同时应用里的所有receiver都在清单文件里面，方便查看。　 　　 　　要销毁掉静态注册的广播接收者，可以通过调用PackageManager将Receiver禁用。\n\n在AndroidManifest.xml的application里面定义receiver并设置要接收的action。下面是代码示例：\n\n```java\n< receiver android:name = \".MyBroadcastReceiver\" > \n\n < intent-filter android:priority = \"777\" >             \n<action android:name = \"android.provider.Telephony.SMS_RECEIVED\" />\n</ intent-filter > \n\n</ receiver >\n```\n\n这里的priority取值是　-1000到1000，值越大优先级越高，同时注意加上系统接收短信的限权。\n\n```java\n< uses-permission android:name =\"android.permission.RECEIVE_SMS\" />\n```\n\n##### 2.动态注册\n\n在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载. \n\n```java\npublic class MainActivity extends Activity {\n    MyBroadcastReceiver receiver;\n    @Override\n     protected void onResume() {\n        // 动态注册广播 (代码执行到这才会开始监听广播消息，并对广播消息作为相应的处理)\n        receiver = new MyBroadcastReceiver();\n        IntentFilter intentFilter = new IntentFilter( \"android.provider.Telephony.SMS_RECEIVED\" );\n        registerReceiver( receiver , intentFilter);\n\n        super.onResume();\n    }\n    @Override\n    protected void onPause() {  \n        // 撤销注册 (撤销注册后广播接收者将不会再监听系统的广播消息)\n        unregisterReceiver(receiver);\n        super.onPause();\n    }\n}\n```\n\n接收广播示例：\n\n```java\npublic class MyBroadcastReceiver extends BroadcastReceiver {\n\n// action 名称\nString SMS_RECEIVED = \"android.provider.Telephony.SMS_RECEIVED\" ;\n\n    public void onReceive(Context context, Intent intent) {\n\n       if (intent.getAction().equals( SMS_RECEIVED )) {\n           // 一个receiver可以接收多个action的，即可以有多个intent-filter，需要在onReceive里面对intent.getAction(action name)进行判断。\n       }\n    }\n}\n```\n\n##### 3.静态注册和动态注册的区别\n\n1. 静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者； 　　动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。\n2. 当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。　 　　动态注册的广播接收者将会导致应用报错 　　而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。\n\n### 三 发送广播\n\n发送广播主要有两种类型：\n\n##### 1.普通广播\n\n应用在需要通知各个广播接收者的情况下使用，如 开机启动，使用方法：sendBroadcast()。\n\n```java\nIntent intent = new Intent(\"android.provider.Telephony.SMS_RECEIVED\"); \n//通过intent传递少量数据\nintent.putExtra(\"data\", \"finch\"); \n// 发送普通广播\nsendBroadcast(Intent); \n```\n\n普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，所有满足条件的 BroadcastReceiver 都会随机地执行其 onReceive() 方法。 　　同级别接收是先后是随机的；级别低的收到广播； 　　消息传递的效率比较高，并且无法中断广播的传播。\n\n##### 有序广播\n\n应用在需要有特定拦截的场景下使用，如黑名单短信、电话拦截。\n\n使用方法：\n\n```java\nsendOrderedBroadcast(intent, receiverPermission);\n```\n\nreceiverPermission ：一个接收器必须持以接收您的广播。如果为 null ，不经许可的要求（一般都为null）,如：\n\n\n```java\n//发送有序广播\nsendOrderedBroadcast(intent, null);\n```\n\n在有序广播中，我们可以在前一个广播接收者将处理好的数据传送给后面的广播接收者，也可以调用abortBroadcast()来终结广播的传播。\n\n```java\npublic void onReceive(Context arg0, Intent intent) {\n　　//获取上一个广播的bundle数据\n　　Bundle bundle = getResultExtras(true);//true：前一个广播没有结果时创建新的Bundle；false：不创建Bundle\n　　bundle.putString(\"key\", \"777\");\n　　//将bundle数据放入广播中传给下一个广播接收者\n　　setResultExtras(bundle);　\n　　\n　　//终止广播传给下一个广播接收者\n　　abortBroadcast();\n}\n```\n\n高级别的广播收到该广播后，可以决定把该广播是否截断掉。 　　同级别接收是先后是随机的，如果先接收到的把广播截断了，同级别的例外的接收者是无法收到该广播。 　\n\n##### 异步广播\n\n使用方法：sendStickyBroadcast() ：\n\n发出的Intent当接收Activity（动态注册）重新处于onResume状态之后就能重新接受到其Intent.（the Intent will be held to be re-broadcast to future receivers）。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Activity处于活跃的时候又会接受到它\n\n发这个广播需要权限：\n\n```java\n<uses-permission android:name=\"android.permission.BROADCAST_STICKY\" />\n```\n\n卸载该广播：\n\n```java\nremoveStickyBroadcast(intent);\n```\n\n在卸载之前该intent会保留，接收者在可接收状态都能获得。\n\n##### 异步有序广播\n\n使用方法：sendStickyOrderedBroadcast(intent, resultReceiver, scheduler, initialCode, initialData, initialExtras)：\n\n这个方法具有有序广播的特性也有异步广播的特性；同时需要限权：\n\n```java\n<uses-permission android:name=\"android.permission.BROADCAST_STICKY\" /> \n```\n\n### 四 安全性\n\nBroadcastReceiver的设计初衷就是从全局考虑的，可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言BroadcastReceiver是存在安全性问题的，相应问题及解决如下：   \n\n- 当应用程序发送某个广播时系统会将发送的Intent与系统中所有注册的BroadcastReceiver的IntentFilter进行匹配，若匹配成功则执行相应的onReceive函数。可以通过类似sendBroadcast(Intent, String)的接口在发送广播时指定接收者必须具备的permission。或通过Intent.setPackage设置广播仅对某个程序有效。\n- 当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。对于动态注册的广播可以通过类似registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)的接口指定发送者必须具备的permission，对于静态注册的广播可以通过android:exported=\"false\"属性表示接收者对外部应用程序不可用，即不接受来自外部的广播。\n- 上面两个问题其实都可以通过LocalBroadcastManager来解决，LocalBroadcastManager只会将广播限定在当前应用程序中。\n- 使用android:protectionLevel\n\nandroid引入了LocalBroadcastManager解决在第4部分安全性介绍的一些问题，LocalBroadcastManager除了能解决BroadcastReceiver进程间安全性问题外，相对Context操作的BroadcastReceiver而言还具有更高的运行效率。使用LocalBroadcastManager需要引入Android Support Library，如何引入见Add Support Package。\n本地广播通过LocalBroadcastManager.getInstance(context).sendBroadcast(intent)发送广播，LocalBroadcastManager.getInstance(context).registerReceiver注册服务，通过LocalBroadcastManager.getInstance(context).unregisterReceiver取消注册服务，其他同普通广播.\n\n### 五 一些常用的系统广播的action 和permission\n\n##### 1.开机启动\n\n```java\n<action android:name=\"android.intent.action.BOOT_COMPLETED\"/> \n\n<uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\" />  \n\n```\n\n##### 2.网络状态\n\n```java\n<action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\"/>  \n\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/> \n\n```\n\n网络是否可用的方法：\n\n```java\npublic static boolean isNetworkAvailable(Context context) {  \n        ConnectivityManager mgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);  \n        NetworkInfo[] info = mgr.getAllNetworkInfo();  \n        if (info != null) {  \n            for (int i = 0; i < info.length; i++) {  \n      if (info[i].getState() == NetworkInfo.State.CONNECTED) {  \n                    return true;  \n                }  \n            }  \n        }  \n        return false;  \n    } \n```\n\n##### 3.电量变化\n\n```java\n<action android:name=\"android.intent.action.BATTERY_CHANGED\"/>  \n```\n\nBroadcastReceiver 的onReceive方法：\n\n```java\npublic void onReceive(Context context, Intent intent) {  \n        int currLevel = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, 0);  //当前电量  　\n\n        int total = intent.getIntExtra(BatteryManager.EXTRA_SCALE, 1);    //总电量  \n        int percent = currLevel * 100 / total;  \n        Log.i(TAG, \"battery: \" + percent + \"%\");  \n    }  \n\n```\n\n\n\n### 六 总结\n\n- 静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。\n- 动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：1)这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。2)这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。\n- 广播发出的时候，广播接收者接收的顺序如下：    \n1)当广播为普通广播时，有如下的接收顺序：  \n\na、无视优先级   \nb、动态优先于静态    \nc、同优先级的动态广播接收器，先注册的大于后注册的   \nd、同优先级的静态广播接收器，先扫描的大于后扫描的　   \n\n2）如果广播为有序广播，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：　 \n   　　 　　\na、优先级高的先接收　 　  \nb、同优先级的动静态广播接收器，动态优先于静态 　　  \nc、同优先级的动态广播接收器，先注册的大于后注册的 　　  \nd、同优先级的静态广播接收器，先扫描的大于后扫描的　   ","source":"_posts/android基础之BroadcastReceiver.md","raw":"---\ntitle: android基础之BroadcastReceiver\ndate: 2017-02-27 14:48:31\ncategories: android\ntags:\n- android\n- java\n- BroadcastReceiver\n---\n\n### 一 BroadcastReceiver简介\n\n广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。如：在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。\n\nBroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。\n\n当系统或应用发出广播时，将会扫描系统中的所有广播接收者，通过action匹配将广播发送给相应的接收者，接收者收到广播后将会产生一个广播接收者的实例，执行其中的onReceiver()这个方法；特别需要注意的是这个实例的生命周期只有10秒，如果10秒内没执行结束onReceiver()，系统将会报错。在onReceiver()执行完毕之后，该实例将会被销毁，所以不要在onReceiver()中执行耗时操作，也不要在里面创建子线程处理业务（因为可能子线程没处理完，接收者就被回收了，那么子线程也会跟着被回收掉）；正确的处理方法就是通过in调用activity或者service处理业务。\n\n### 二 BroadcastReceiver的两种注册方式\n\n##### 1.静态注册（推荐）\n\n静态注册的广播接收者是一个常驻在系统中的全局监听器，当你在应用中配置了一个静态的BroadcastReceiver，安装了应用后而无论应用是否处于运行状态，广播接收者都是已经常驻在系统中了。同时应用里的所有receiver都在清单文件里面，方便查看。　 　　 　　要销毁掉静态注册的广播接收者，可以通过调用PackageManager将Receiver禁用。\n\n在AndroidManifest.xml的application里面定义receiver并设置要接收的action。下面是代码示例：\n\n```java\n< receiver android:name = \".MyBroadcastReceiver\" > \n\n < intent-filter android:priority = \"777\" >             \n<action android:name = \"android.provider.Telephony.SMS_RECEIVED\" />\n</ intent-filter > \n\n</ receiver >\n```\n\n这里的priority取值是　-1000到1000，值越大优先级越高，同时注意加上系统接收短信的限权。\n\n```java\n< uses-permission android:name =\"android.permission.RECEIVE_SMS\" />\n```\n\n##### 2.动态注册\n\n在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载. \n\n```java\npublic class MainActivity extends Activity {\n    MyBroadcastReceiver receiver;\n    @Override\n     protected void onResume() {\n        // 动态注册广播 (代码执行到这才会开始监听广播消息，并对广播消息作为相应的处理)\n        receiver = new MyBroadcastReceiver();\n        IntentFilter intentFilter = new IntentFilter( \"android.provider.Telephony.SMS_RECEIVED\" );\n        registerReceiver( receiver , intentFilter);\n\n        super.onResume();\n    }\n    @Override\n    protected void onPause() {  \n        // 撤销注册 (撤销注册后广播接收者将不会再监听系统的广播消息)\n        unregisterReceiver(receiver);\n        super.onPause();\n    }\n}\n```\n\n接收广播示例：\n\n```java\npublic class MyBroadcastReceiver extends BroadcastReceiver {\n\n// action 名称\nString SMS_RECEIVED = \"android.provider.Telephony.SMS_RECEIVED\" ;\n\n    public void onReceive(Context context, Intent intent) {\n\n       if (intent.getAction().equals( SMS_RECEIVED )) {\n           // 一个receiver可以接收多个action的，即可以有多个intent-filter，需要在onReceive里面对intent.getAction(action name)进行判断。\n       }\n    }\n}\n```\n\n##### 3.静态注册和动态注册的区别\n\n1. 静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者； 　　动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。\n2. 当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。　 　　动态注册的广播接收者将会导致应用报错 　　而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。\n\n### 三 发送广播\n\n发送广播主要有两种类型：\n\n##### 1.普通广播\n\n应用在需要通知各个广播接收者的情况下使用，如 开机启动，使用方法：sendBroadcast()。\n\n```java\nIntent intent = new Intent(\"android.provider.Telephony.SMS_RECEIVED\"); \n//通过intent传递少量数据\nintent.putExtra(\"data\", \"finch\"); \n// 发送普通广播\nsendBroadcast(Intent); \n```\n\n普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，所有满足条件的 BroadcastReceiver 都会随机地执行其 onReceive() 方法。 　　同级别接收是先后是随机的；级别低的收到广播； 　　消息传递的效率比较高，并且无法中断广播的传播。\n\n##### 有序广播\n\n应用在需要有特定拦截的场景下使用，如黑名单短信、电话拦截。\n\n使用方法：\n\n```java\nsendOrderedBroadcast(intent, receiverPermission);\n```\n\nreceiverPermission ：一个接收器必须持以接收您的广播。如果为 null ，不经许可的要求（一般都为null）,如：\n\n\n```java\n//发送有序广播\nsendOrderedBroadcast(intent, null);\n```\n\n在有序广播中，我们可以在前一个广播接收者将处理好的数据传送给后面的广播接收者，也可以调用abortBroadcast()来终结广播的传播。\n\n```java\npublic void onReceive(Context arg0, Intent intent) {\n　　//获取上一个广播的bundle数据\n　　Bundle bundle = getResultExtras(true);//true：前一个广播没有结果时创建新的Bundle；false：不创建Bundle\n　　bundle.putString(\"key\", \"777\");\n　　//将bundle数据放入广播中传给下一个广播接收者\n　　setResultExtras(bundle);　\n　　\n　　//终止广播传给下一个广播接收者\n　　abortBroadcast();\n}\n```\n\n高级别的广播收到该广播后，可以决定把该广播是否截断掉。 　　同级别接收是先后是随机的，如果先接收到的把广播截断了，同级别的例外的接收者是无法收到该广播。 　\n\n##### 异步广播\n\n使用方法：sendStickyBroadcast() ：\n\n发出的Intent当接收Activity（动态注册）重新处于onResume状态之后就能重新接受到其Intent.（the Intent will be held to be re-broadcast to future receivers）。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Activity处于活跃的时候又会接受到它\n\n发这个广播需要权限：\n\n```java\n<uses-permission android:name=\"android.permission.BROADCAST_STICKY\" />\n```\n\n卸载该广播：\n\n```java\nremoveStickyBroadcast(intent);\n```\n\n在卸载之前该intent会保留，接收者在可接收状态都能获得。\n\n##### 异步有序广播\n\n使用方法：sendStickyOrderedBroadcast(intent, resultReceiver, scheduler, initialCode, initialData, initialExtras)：\n\n这个方法具有有序广播的特性也有异步广播的特性；同时需要限权：\n\n```java\n<uses-permission android:name=\"android.permission.BROADCAST_STICKY\" /> \n```\n\n### 四 安全性\n\nBroadcastReceiver的设计初衷就是从全局考虑的，可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言BroadcastReceiver是存在安全性问题的，相应问题及解决如下：   \n\n- 当应用程序发送某个广播时系统会将发送的Intent与系统中所有注册的BroadcastReceiver的IntentFilter进行匹配，若匹配成功则执行相应的onReceive函数。可以通过类似sendBroadcast(Intent, String)的接口在发送广播时指定接收者必须具备的permission。或通过Intent.setPackage设置广播仅对某个程序有效。\n- 当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。对于动态注册的广播可以通过类似registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)的接口指定发送者必须具备的permission，对于静态注册的广播可以通过android:exported=\"false\"属性表示接收者对外部应用程序不可用，即不接受来自外部的广播。\n- 上面两个问题其实都可以通过LocalBroadcastManager来解决，LocalBroadcastManager只会将广播限定在当前应用程序中。\n- 使用android:protectionLevel\n\nandroid引入了LocalBroadcastManager解决在第4部分安全性介绍的一些问题，LocalBroadcastManager除了能解决BroadcastReceiver进程间安全性问题外，相对Context操作的BroadcastReceiver而言还具有更高的运行效率。使用LocalBroadcastManager需要引入Android Support Library，如何引入见Add Support Package。\n本地广播通过LocalBroadcastManager.getInstance(context).sendBroadcast(intent)发送广播，LocalBroadcastManager.getInstance(context).registerReceiver注册服务，通过LocalBroadcastManager.getInstance(context).unregisterReceiver取消注册服务，其他同普通广播.\n\n### 五 一些常用的系统广播的action 和permission\n\n##### 1.开机启动\n\n```java\n<action android:name=\"android.intent.action.BOOT_COMPLETED\"/> \n\n<uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\" />  \n\n```\n\n##### 2.网络状态\n\n```java\n<action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\"/>  \n\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/> \n\n```\n\n网络是否可用的方法：\n\n```java\npublic static boolean isNetworkAvailable(Context context) {  \n        ConnectivityManager mgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);  \n        NetworkInfo[] info = mgr.getAllNetworkInfo();  \n        if (info != null) {  \n            for (int i = 0; i < info.length; i++) {  \n      if (info[i].getState() == NetworkInfo.State.CONNECTED) {  \n                    return true;  \n                }  \n            }  \n        }  \n        return false;  \n    } \n```\n\n##### 3.电量变化\n\n```java\n<action android:name=\"android.intent.action.BATTERY_CHANGED\"/>  \n```\n\nBroadcastReceiver 的onReceive方法：\n\n```java\npublic void onReceive(Context context, Intent intent) {  \n        int currLevel = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, 0);  //当前电量  　\n\n        int total = intent.getIntExtra(BatteryManager.EXTRA_SCALE, 1);    //总电量  \n        int percent = currLevel * 100 / total;  \n        Log.i(TAG, \"battery: \" + percent + \"%\");  \n    }  \n\n```\n\n\n\n### 六 总结\n\n- 静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。\n- 动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：1)这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。2)这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。\n- 广播发出的时候，广播接收者接收的顺序如下：    \n1)当广播为普通广播时，有如下的接收顺序：  \n\na、无视优先级   \nb、动态优先于静态    \nc、同优先级的动态广播接收器，先注册的大于后注册的   \nd、同优先级的静态广播接收器，先扫描的大于后扫描的　   \n\n2）如果广播为有序广播，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：　 \n   　　 　　\na、优先级高的先接收　 　  \nb、同优先级的动静态广播接收器，动态优先于静态 　　  \nc、同优先级的动态广播接收器，先注册的大于后注册的 　　  \nd、同优先级的静态广播接收器，先扫描的大于后扫描的　   ","slug":"android基础之BroadcastReceiver","published":1,"updated":"2017-03-07T10:25:28.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk1p000vaknzebwczbek","content":"<h3 id=\"一-BroadcastReceiver简介\"><a href=\"#一-BroadcastReceiver简介\" class=\"headerlink\" title=\"一 BroadcastReceiver简介\"></a>一 BroadcastReceiver简介</h3><p>广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。如：在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。</p>\n<p>BroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。</p>\n<p>当系统或应用发出广播时，将会扫描系统中的所有广播接收者，通过action匹配将广播发送给相应的接收者，接收者收到广播后将会产生一个广播接收者的实例，执行其中的onReceiver()这个方法；特别需要注意的是这个实例的生命周期只有10秒，如果10秒内没执行结束onReceiver()，系统将会报错。在onReceiver()执行完毕之后，该实例将会被销毁，所以不要在onReceiver()中执行耗时操作，也不要在里面创建子线程处理业务（因为可能子线程没处理完，接收者就被回收了，那么子线程也会跟着被回收掉）；正确的处理方法就是通过in调用activity或者service处理业务。</p>\n<h3 id=\"二-BroadcastReceiver的两种注册方式\"><a href=\"#二-BroadcastReceiver的两种注册方式\" class=\"headerlink\" title=\"二 BroadcastReceiver的两种注册方式\"></a>二 BroadcastReceiver的两种注册方式</h3><h5 id=\"1-静态注册（推荐）\"><a href=\"#1-静态注册（推荐）\" class=\"headerlink\" title=\"1.静态注册（推荐）\"></a>1.静态注册（推荐）</h5><p>静态注册的广播接收者是一个常驻在系统中的全局监听器，当你在应用中配置了一个静态的BroadcastReceiver，安装了应用后而无论应用是否处于运行状态，广播接收者都是已经常驻在系统中了。同时应用里的所有receiver都在清单文件里面，方便查看。　 　　 　　要销毁掉静态注册的广播接收者，可以通过调用PackageManager将Receiver禁用。</p>\n<p>在AndroidManifest.xml的application里面定义receiver并设置要接收的action。下面是代码示例：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt; receiver android:name = \".MyBroadcastReceiver\" &gt; </div><div class=\"line\"></div><div class=\"line\"> &lt; intent-filter android:priority = \"777\" &gt;             </div><div class=\"line\">&lt;action android:name = \"android.provider.Telephony.SMS_RECEIVED\" /&gt;</div><div class=\"line\">&lt;/ intent-filter &gt; </div><div class=\"line\"></div><div class=\"line\">&lt;/ receiver &gt;</div></pre></td></tr></table></figure>\n<p>这里的priority取值是　-1000到1000，值越大优先级越高，同时注意加上系统接收短信的限权。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt; uses-permission android:name =<span class=\"string\">\"android.permission.RECEIVE_SMS\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"2-动态注册\"><a href=\"#2-动态注册\" class=\"headerlink\" title=\"2.动态注册\"></a>2.动态注册</h5><p>在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">    MyBroadcastReceiver receiver;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 动态注册广播 (代码执行到这才会开始监听广播消息，并对广播消息作为相应的处理)</span></div><div class=\"line\">        receiver = <span class=\"keyword\">new</span> MyBroadcastReceiver();</div><div class=\"line\">        IntentFilter intentFilter = <span class=\"keyword\">new</span> IntentFilter( <span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span> );</div><div class=\"line\">        registerReceiver( receiver , intentFilter);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">super</span>.onResume();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">// 撤销注册 (撤销注册后广播接收者将不会再监听系统的广播消息)</span></div><div class=\"line\">        unregisterReceiver(receiver);</div><div class=\"line\">        <span class=\"keyword\">super</span>.onPause();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接收广播示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBroadcastReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// action 名称</span></div><div class=\"line\">String SMS_RECEIVED = <span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span> ;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (intent.getAction().equals( SMS_RECEIVED )) &#123;</div><div class=\"line\">           <span class=\"comment\">// 一个receiver可以接收多个action的，即可以有多个intent-filter，需要在onReceive里面对intent.getAction(action name)进行判断。</span></div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"3-静态注册和动态注册的区别\"><a href=\"#3-静态注册和动态注册的区别\" class=\"headerlink\" title=\"3.静态注册和动态注册的区别\"></a>3.静态注册和动态注册的区别</h5><ol>\n<li>静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者； 　　动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。</li>\n<li>当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。　 　　动态注册的广播接收者将会导致应用报错 　　而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。</li>\n</ol>\n<h3 id=\"三-发送广播\"><a href=\"#三-发送广播\" class=\"headerlink\" title=\"三 发送广播\"></a>三 发送广播</h3><p>发送广播主要有两种类型：</p>\n<h5 id=\"1-普通广播\"><a href=\"#1-普通广播\" class=\"headerlink\" title=\"1.普通广播\"></a>1.普通广播</h5><p>应用在需要通知各个广播接收者的情况下使用，如 开机启动，使用方法：sendBroadcast()。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span>); </div><div class=\"line\"><span class=\"comment\">//通过intent传递少量数据</span></div><div class=\"line\">intent.putExtra(<span class=\"string\">\"data\"</span>, <span class=\"string\">\"finch\"</span>); </div><div class=\"line\"><span class=\"comment\">// 发送普通广播</span></div><div class=\"line\">sendBroadcast(Intent);</div></pre></td></tr></table></figure>\n<p>普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，所有满足条件的 BroadcastReceiver 都会随机地执行其 onReceive() 方法。 　　同级别接收是先后是随机的；级别低的收到广播； 　　消息传递的效率比较高，并且无法中断广播的传播。</p>\n<h5 id=\"有序广播\"><a href=\"#有序广播\" class=\"headerlink\" title=\"有序广播\"></a>有序广播</h5><p>应用在需要有特定拦截的场景下使用，如黑名单短信、电话拦截。</p>\n<p>使用方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sendOrderedBroadcast(intent, receiverPermission);</div></pre></td></tr></table></figure>\n<p>receiverPermission ：一个接收器必须持以接收您的广播。如果为 null ，不经许可的要求（一般都为null）,如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//发送有序广播</span></div><div class=\"line\">sendOrderedBroadcast(intent, <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<p>在有序广播中，我们可以在前一个广播接收者将处理好的数据传送给后面的广播接收者，也可以调用abortBroadcast()来终结广播的传播。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context arg0, Intent intent)</span> </span>&#123;</div><div class=\"line\">　　<span class=\"comment\">//获取上一个广播的bundle数据</span></div><div class=\"line\">　　Bundle bundle = getResultExtras(<span class=\"keyword\">true</span>);<span class=\"comment\">//true：前一个广播没有结果时创建新的Bundle；false：不创建Bundle</span></div><div class=\"line\">　　bundle.putString(<span class=\"string\">\"key\"</span>, <span class=\"string\">\"777\"</span>);</div><div class=\"line\">　　<span class=\"comment\">//将bundle数据放入广播中传给下一个广播接收者</span></div><div class=\"line\">　　setResultExtras(bundle);　</div><div class=\"line\">　　</div><div class=\"line\">　　<span class=\"comment\">//终止广播传给下一个广播接收者</span></div><div class=\"line\">　　abortBroadcast();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>高级别的广播收到该广播后，可以决定把该广播是否截断掉。 　　同级别接收是先后是随机的，如果先接收到的把广播截断了，同级别的例外的接收者是无法收到该广播。 　</p>\n<h5 id=\"异步广播\"><a href=\"#异步广播\" class=\"headerlink\" title=\"异步广播\"></a>异步广播</h5><p>使用方法：sendStickyBroadcast() ：</p>\n<p>发出的Intent当接收Activity（动态注册）重新处于onResume状态之后就能重新接受到其Intent.（the Intent will be held to be re-broadcast to future receivers）。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Activity处于活跃的时候又会接受到它</p>\n<p>发这个广播需要权限：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.BROADCAST_STICKY\"</span> /&gt;</div></pre></td></tr></table></figure>\n<p>卸载该广播：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">removeStickyBroadcast(intent);</div></pre></td></tr></table></figure>\n<p>在卸载之前该intent会保留，接收者在可接收状态都能获得。</p>\n<h5 id=\"异步有序广播\"><a href=\"#异步有序广播\" class=\"headerlink\" title=\"异步有序广播\"></a>异步有序广播</h5><p>使用方法：sendStickyOrderedBroadcast(intent, resultReceiver, scheduler, initialCode, initialData, initialExtras)：</p>\n<p>这个方法具有有序广播的特性也有异步广播的特性；同时需要限权：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.BROADCAST_STICKY\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"四-安全性\"><a href=\"#四-安全性\" class=\"headerlink\" title=\"四 安全性\"></a>四 安全性</h3><p>BroadcastReceiver的设计初衷就是从全局考虑的，可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言BroadcastReceiver是存在安全性问题的，相应问题及解决如下：   </p>\n<ul>\n<li>当应用程序发送某个广播时系统会将发送的Intent与系统中所有注册的BroadcastReceiver的IntentFilter进行匹配，若匹配成功则执行相应的onReceive函数。可以通过类似sendBroadcast(Intent, String)的接口在发送广播时指定接收者必须具备的permission。或通过Intent.setPackage设置广播仅对某个程序有效。</li>\n<li>当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。对于动态注册的广播可以通过类似registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)的接口指定发送者必须具备的permission，对于静态注册的广播可以通过android:exported=”false”属性表示接收者对外部应用程序不可用，即不接受来自外部的广播。</li>\n<li>上面两个问题其实都可以通过LocalBroadcastManager来解决，LocalBroadcastManager只会将广播限定在当前应用程序中。</li>\n<li>使用android:protectionLevel</li>\n</ul>\n<p>android引入了LocalBroadcastManager解决在第4部分安全性介绍的一些问题，LocalBroadcastManager除了能解决BroadcastReceiver进程间安全性问题外，相对Context操作的BroadcastReceiver而言还具有更高的运行效率。使用LocalBroadcastManager需要引入Android Support Library，如何引入见Add Support Package。<br>本地广播通过LocalBroadcastManager.getInstance(context).sendBroadcast(intent)发送广播，LocalBroadcastManager.getInstance(context).registerReceiver注册服务，通过LocalBroadcastManager.getInstance(context).unregisterReceiver取消注册服务，其他同普通广播.</p>\n<h3 id=\"五-一些常用的系统广播的action-和permission\"><a href=\"#五-一些常用的系统广播的action-和permission\" class=\"headerlink\" title=\"五 一些常用的系统广播的action 和permission\"></a>五 一些常用的系统广播的action 和permission</h3><h5 id=\"1-开机启动\"><a href=\"#1-开机启动\" class=\"headerlink\" title=\"1.开机启动\"></a>1.开机启动</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;action android:name=<span class=\"string\">\"android.intent.action.BOOT_COMPLETED\"</span>/&gt; </div><div class=\"line\"></div><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.RECEIVE_BOOT_COMPLETED\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"2-网络状态\"><a href=\"#2-网络状态\" class=\"headerlink\" title=\"2.网络状态\"></a>2.网络状态</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;action android:name=<span class=\"string\">\"android.net.conn.CONNECTIVITY_CHANGE\"</span>/&gt;  </div><div class=\"line\"></div><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.ACCESS_NETWORK_STATE\"</span>/&gt;</div></pre></td></tr></table></figure>\n<p>网络是否可用的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isNetworkAvailable</span><span class=\"params\">(Context context)</span> </span>&#123;  </div><div class=\"line\">        ConnectivityManager mgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);  </div><div class=\"line\">        NetworkInfo[] info = mgr.getAllNetworkInfo();  </div><div class=\"line\">        <span class=\"keyword\">if</span> (info != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; info.length; i++) &#123;  </div><div class=\"line\">      <span class=\"keyword\">if</span> (info[i].getState() == NetworkInfo.State.CONNECTED) &#123;  </div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h5 id=\"3-电量变化\"><a href=\"#3-电量变化\" class=\"headerlink\" title=\"3.电量变化\"></a>3.电量变化</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;action android:name=<span class=\"string\">\"android.intent.action.BATTERY_CHANGED\"</span>/&gt;</div></pre></td></tr></table></figure>\n<p>BroadcastReceiver 的onReceive方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">int</span> currLevel = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, <span class=\"number\">0</span>);  <span class=\"comment\">//当前电量  　</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> total = intent.getIntExtra(BatteryManager.EXTRA_SCALE, <span class=\"number\">1</span>);    <span class=\"comment\">//总电量  </span></div><div class=\"line\">        <span class=\"keyword\">int</span> percent = currLevel * <span class=\"number\">100</span> / total;  </div><div class=\"line\">        Log.i(TAG, <span class=\"string\">\"battery: \"</span> + percent + <span class=\"string\">\"%\"</span>);  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"六-总结\"><a href=\"#六-总结\" class=\"headerlink\" title=\"六 总结\"></a>六 总结</h3><ul>\n<li>静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。</li>\n<li>动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：1)这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。2)这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。</li>\n<li>广播发出的时候，广播接收者接收的顺序如下：<br>1)当广播为普通广播时，有如下的接收顺序：  </li>\n</ul>\n<p>a、无视优先级<br>b、动态优先于静态<br>c、同优先级的动态广播接收器，先注册的大于后注册的<br>d、同优先级的静态广播接收器，先扫描的大于后扫描的　   </p>\n<p>2）如果广播为有序广播，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：　<br>   　　 　　<br>a、优先级高的先接收　 　<br>b、同优先级的动静态广播接收器，动态优先于静态 　　<br>c、同优先级的动态广播接收器，先注册的大于后注册的 　　<br>d、同优先级的静态广播接收器，先扫描的大于后扫描的　   </p>\n","excerpt":"","more":"<h3 id=\"一-BroadcastReceiver简介\"><a href=\"#一-BroadcastReceiver简介\" class=\"headerlink\" title=\"一 BroadcastReceiver简介\"></a>一 BroadcastReceiver简介</h3><p>广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。如：在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。</p>\n<p>BroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。</p>\n<p>当系统或应用发出广播时，将会扫描系统中的所有广播接收者，通过action匹配将广播发送给相应的接收者，接收者收到广播后将会产生一个广播接收者的实例，执行其中的onReceiver()这个方法；特别需要注意的是这个实例的生命周期只有10秒，如果10秒内没执行结束onReceiver()，系统将会报错。在onReceiver()执行完毕之后，该实例将会被销毁，所以不要在onReceiver()中执行耗时操作，也不要在里面创建子线程处理业务（因为可能子线程没处理完，接收者就被回收了，那么子线程也会跟着被回收掉）；正确的处理方法就是通过in调用activity或者service处理业务。</p>\n<h3 id=\"二-BroadcastReceiver的两种注册方式\"><a href=\"#二-BroadcastReceiver的两种注册方式\" class=\"headerlink\" title=\"二 BroadcastReceiver的两种注册方式\"></a>二 BroadcastReceiver的两种注册方式</h3><h5 id=\"1-静态注册（推荐）\"><a href=\"#1-静态注册（推荐）\" class=\"headerlink\" title=\"1.静态注册（推荐）\"></a>1.静态注册（推荐）</h5><p>静态注册的广播接收者是一个常驻在系统中的全局监听器，当你在应用中配置了一个静态的BroadcastReceiver，安装了应用后而无论应用是否处于运行状态，广播接收者都是已经常驻在系统中了。同时应用里的所有receiver都在清单文件里面，方便查看。　 　　 　　要销毁掉静态注册的广播接收者，可以通过调用PackageManager将Receiver禁用。</p>\n<p>在AndroidManifest.xml的application里面定义receiver并设置要接收的action。下面是代码示例：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt; receiver android:name = \".MyBroadcastReceiver\" &gt; </div><div class=\"line\"></div><div class=\"line\"> &lt; intent-filter android:priority = \"777\" &gt;             </div><div class=\"line\">&lt;action android:name = \"android.provider.Telephony.SMS_RECEIVED\" /&gt;</div><div class=\"line\">&lt;/ intent-filter &gt; </div><div class=\"line\"></div><div class=\"line\">&lt;/ receiver &gt;</div></pre></td></tr></table></figure>\n<p>这里的priority取值是　-1000到1000，值越大优先级越高，同时注意加上系统接收短信的限权。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt; uses-permission android:name =<span class=\"string\">\"android.permission.RECEIVE_SMS\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"2-动态注册\"><a href=\"#2-动态注册\" class=\"headerlink\" title=\"2.动态注册\"></a>2.动态注册</h5><p>在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">    MyBroadcastReceiver receiver;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 动态注册广播 (代码执行到这才会开始监听广播消息，并对广播消息作为相应的处理)</span></div><div class=\"line\">        receiver = <span class=\"keyword\">new</span> MyBroadcastReceiver();</div><div class=\"line\">        IntentFilter intentFilter = <span class=\"keyword\">new</span> IntentFilter( <span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span> );</div><div class=\"line\">        registerReceiver( receiver , intentFilter);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">super</span>.onResume();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">// 撤销注册 (撤销注册后广播接收者将不会再监听系统的广播消息)</span></div><div class=\"line\">        unregisterReceiver(receiver);</div><div class=\"line\">        <span class=\"keyword\">super</span>.onPause();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接收广播示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBroadcastReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// action 名称</span></div><div class=\"line\">String SMS_RECEIVED = <span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span> ;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (intent.getAction().equals( SMS_RECEIVED )) &#123;</div><div class=\"line\">           <span class=\"comment\">// 一个receiver可以接收多个action的，即可以有多个intent-filter，需要在onReceive里面对intent.getAction(action name)进行判断。</span></div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"3-静态注册和动态注册的区别\"><a href=\"#3-静态注册和动态注册的区别\" class=\"headerlink\" title=\"3.静态注册和动态注册的区别\"></a>3.静态注册和动态注册的区别</h5><ol>\n<li>静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者； 　　动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。</li>\n<li>当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。　 　　动态注册的广播接收者将会导致应用报错 　　而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。</li>\n</ol>\n<h3 id=\"三-发送广播\"><a href=\"#三-发送广播\" class=\"headerlink\" title=\"三 发送广播\"></a>三 发送广播</h3><p>发送广播主要有两种类型：</p>\n<h5 id=\"1-普通广播\"><a href=\"#1-普通广播\" class=\"headerlink\" title=\"1.普通广播\"></a>1.普通广播</h5><p>应用在需要通知各个广播接收者的情况下使用，如 开机启动，使用方法：sendBroadcast()。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span>); </div><div class=\"line\"><span class=\"comment\">//通过intent传递少量数据</span></div><div class=\"line\">intent.putExtra(<span class=\"string\">\"data\"</span>, <span class=\"string\">\"finch\"</span>); </div><div class=\"line\"><span class=\"comment\">// 发送普通广播</span></div><div class=\"line\">sendBroadcast(Intent);</div></pre></td></tr></table></figure>\n<p>普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，所有满足条件的 BroadcastReceiver 都会随机地执行其 onReceive() 方法。 　　同级别接收是先后是随机的；级别低的收到广播； 　　消息传递的效率比较高，并且无法中断广播的传播。</p>\n<h5 id=\"有序广播\"><a href=\"#有序广播\" class=\"headerlink\" title=\"有序广播\"></a>有序广播</h5><p>应用在需要有特定拦截的场景下使用，如黑名单短信、电话拦截。</p>\n<p>使用方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sendOrderedBroadcast(intent, receiverPermission);</div></pre></td></tr></table></figure>\n<p>receiverPermission ：一个接收器必须持以接收您的广播。如果为 null ，不经许可的要求（一般都为null）,如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//发送有序广播</span></div><div class=\"line\">sendOrderedBroadcast(intent, <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<p>在有序广播中，我们可以在前一个广播接收者将处理好的数据传送给后面的广播接收者，也可以调用abortBroadcast()来终结广播的传播。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context arg0, Intent intent)</span> </span>&#123;</div><div class=\"line\">　　<span class=\"comment\">//获取上一个广播的bundle数据</span></div><div class=\"line\">　　Bundle bundle = getResultExtras(<span class=\"keyword\">true</span>);<span class=\"comment\">//true：前一个广播没有结果时创建新的Bundle；false：不创建Bundle</span></div><div class=\"line\">　　bundle.putString(<span class=\"string\">\"key\"</span>, <span class=\"string\">\"777\"</span>);</div><div class=\"line\">　　<span class=\"comment\">//将bundle数据放入广播中传给下一个广播接收者</span></div><div class=\"line\">　　setResultExtras(bundle);　</div><div class=\"line\">　　</div><div class=\"line\">　　<span class=\"comment\">//终止广播传给下一个广播接收者</span></div><div class=\"line\">　　abortBroadcast();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>高级别的广播收到该广播后，可以决定把该广播是否截断掉。 　　同级别接收是先后是随机的，如果先接收到的把广播截断了，同级别的例外的接收者是无法收到该广播。 　</p>\n<h5 id=\"异步广播\"><a href=\"#异步广播\" class=\"headerlink\" title=\"异步广播\"></a>异步广播</h5><p>使用方法：sendStickyBroadcast() ：</p>\n<p>发出的Intent当接收Activity（动态注册）重新处于onResume状态之后就能重新接受到其Intent.（the Intent will be held to be re-broadcast to future receivers）。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Activity处于活跃的时候又会接受到它</p>\n<p>发这个广播需要权限：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.BROADCAST_STICKY\"</span> /&gt;</div></pre></td></tr></table></figure>\n<p>卸载该广播：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">removeStickyBroadcast(intent);</div></pre></td></tr></table></figure>\n<p>在卸载之前该intent会保留，接收者在可接收状态都能获得。</p>\n<h5 id=\"异步有序广播\"><a href=\"#异步有序广播\" class=\"headerlink\" title=\"异步有序广播\"></a>异步有序广播</h5><p>使用方法：sendStickyOrderedBroadcast(intent, resultReceiver, scheduler, initialCode, initialData, initialExtras)：</p>\n<p>这个方法具有有序广播的特性也有异步广播的特性；同时需要限权：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.BROADCAST_STICKY\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"四-安全性\"><a href=\"#四-安全性\" class=\"headerlink\" title=\"四 安全性\"></a>四 安全性</h3><p>BroadcastReceiver的设计初衷就是从全局考虑的，可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言BroadcastReceiver是存在安全性问题的，相应问题及解决如下：   </p>\n<ul>\n<li>当应用程序发送某个广播时系统会将发送的Intent与系统中所有注册的BroadcastReceiver的IntentFilter进行匹配，若匹配成功则执行相应的onReceive函数。可以通过类似sendBroadcast(Intent, String)的接口在发送广播时指定接收者必须具备的permission。或通过Intent.setPackage设置广播仅对某个程序有效。</li>\n<li>当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。对于动态注册的广播可以通过类似registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)的接口指定发送者必须具备的permission，对于静态注册的广播可以通过android:exported=”false”属性表示接收者对外部应用程序不可用，即不接受来自外部的广播。</li>\n<li>上面两个问题其实都可以通过LocalBroadcastManager来解决，LocalBroadcastManager只会将广播限定在当前应用程序中。</li>\n<li>使用android:protectionLevel</li>\n</ul>\n<p>android引入了LocalBroadcastManager解决在第4部分安全性介绍的一些问题，LocalBroadcastManager除了能解决BroadcastReceiver进程间安全性问题外，相对Context操作的BroadcastReceiver而言还具有更高的运行效率。使用LocalBroadcastManager需要引入Android Support Library，如何引入见Add Support Package。<br>本地广播通过LocalBroadcastManager.getInstance(context).sendBroadcast(intent)发送广播，LocalBroadcastManager.getInstance(context).registerReceiver注册服务，通过LocalBroadcastManager.getInstance(context).unregisterReceiver取消注册服务，其他同普通广播.</p>\n<h3 id=\"五-一些常用的系统广播的action-和permission\"><a href=\"#五-一些常用的系统广播的action-和permission\" class=\"headerlink\" title=\"五 一些常用的系统广播的action 和permission\"></a>五 一些常用的系统广播的action 和permission</h3><h5 id=\"1-开机启动\"><a href=\"#1-开机启动\" class=\"headerlink\" title=\"1.开机启动\"></a>1.开机启动</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;action android:name=<span class=\"string\">\"android.intent.action.BOOT_COMPLETED\"</span>/&gt; </div><div class=\"line\"></div><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.RECEIVE_BOOT_COMPLETED\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h5 id=\"2-网络状态\"><a href=\"#2-网络状态\" class=\"headerlink\" title=\"2.网络状态\"></a>2.网络状态</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;action android:name=<span class=\"string\">\"android.net.conn.CONNECTIVITY_CHANGE\"</span>/&gt;  </div><div class=\"line\"></div><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.ACCESS_NETWORK_STATE\"</span>/&gt;</div></pre></td></tr></table></figure>\n<p>网络是否可用的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isNetworkAvailable</span><span class=\"params\">(Context context)</span> </span>&#123;  </div><div class=\"line\">        ConnectivityManager mgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);  </div><div class=\"line\">        NetworkInfo[] info = mgr.getAllNetworkInfo();  </div><div class=\"line\">        <span class=\"keyword\">if</span> (info != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; info.length; i++) &#123;  </div><div class=\"line\">      <span class=\"keyword\">if</span> (info[i].getState() == NetworkInfo.State.CONNECTED) &#123;  </div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h5 id=\"3-电量变化\"><a href=\"#3-电量变化\" class=\"headerlink\" title=\"3.电量变化\"></a>3.电量变化</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;action android:name=<span class=\"string\">\"android.intent.action.BATTERY_CHANGED\"</span>/&gt;</div></pre></td></tr></table></figure>\n<p>BroadcastReceiver 的onReceive方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">int</span> currLevel = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, <span class=\"number\">0</span>);  <span class=\"comment\">//当前电量  　</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> total = intent.getIntExtra(BatteryManager.EXTRA_SCALE, <span class=\"number\">1</span>);    <span class=\"comment\">//总电量  </span></div><div class=\"line\">        <span class=\"keyword\">int</span> percent = currLevel * <span class=\"number\">100</span> / total;  </div><div class=\"line\">        Log.i(TAG, <span class=\"string\">\"battery: \"</span> + percent + <span class=\"string\">\"%\"</span>);  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"六-总结\"><a href=\"#六-总结\" class=\"headerlink\" title=\"六 总结\"></a>六 总结</h3><ul>\n<li>静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。</li>\n<li>动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：1)这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。2)这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。</li>\n<li>广播发出的时候，广播接收者接收的顺序如下：<br>1)当广播为普通广播时，有如下的接收顺序：  </li>\n</ul>\n<p>a、无视优先级<br>b、动态优先于静态<br>c、同优先级的动态广播接收器，先注册的大于后注册的<br>d、同优先级的静态广播接收器，先扫描的大于后扫描的　   </p>\n<p>2）如果广播为有序广播，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：　<br>   　　 　　<br>a、优先级高的先接收　 　<br>b、同优先级的动静态广播接收器，动态优先于静态 　　<br>c、同优先级的动态广播接收器，先注册的大于后注册的 　　<br>d、同优先级的静态广播接收器，先扫描的大于后扫描的　   </p>\n"},{"title":"android基础之Fragments","date":"2017-02-27T06:31:31.000Z","_content":"\n### 一 概述   \nFragment表现Activity中用户界面的一个行为或者是一部分。你可以在一个单独的activity上把多个fragment组合成为一个多区域的UI，并且可以在多个activity中再使用。你可以认为fragment是activity的一个模块零件，它有自己的生命周期，接收它自己的输入事件，并且可以在activity运行时添加或者删除。\n\nFragment必须总是被嵌入到一个activity之中，并且fragment的生命周期直接受其宿主activity的生命周期的影响。例如，一旦activity被暂停，它里面所有的fragment也被暂停，一旦activity被销毁，它里面所有的fragment也被销毁。然而，当activity正在运行时（处于resumed的生命周期状态），你可以单独的操控每个fragment，比如添加或者删除。当你执行这样一项事务时，可以将它添加到后台的一个栈中，这个栈由activity管理着——activity里面的每个后台栈内容实体是fragment发生过的一条事务记录。这个后台栈允许用户通过按BACK键回退一项fragment事务（往后导航）。\n\n当你添加一个fragment作为某个activity布局的一部分时，它就存在于这个activity视图体系内部的ViewGroup之中，并且定义了它自己的视图布局。你可以通过在activity布局文件中声明fragment，用<fragment>元素把fragment插入到activity的布局中，或者是用应用程序源码将它添加到一个存在的ViewGroup中。然而，fragment并不是一个定要作为activity布局的一部分；fragment也可以为activity隐身工作。   \n\n### 二 Fragment的继承结构   \n继承 Object\n实现 ComponentCallbacks2 View.OnCreateContextMenuListener \n      \n```java \njava.lang.Object\n   ↳ \tandroid.app.Fragment\n```\n直接子类：\nDialogFragment, ListFragment, PreferenceFragment, WebViewFragment      \n\n### 三 Fragment设计哲学  \nFragment被设计出来主要为了适应平板等大屏幕移动设备。有了fragment，你可以不必去管理视图体系的复杂变化。通过将activity的布局分割成若干个fragment，可以在运行时编辑activity的呈现，并且那些变化会被保存在由activity管理的后台栈里面。  \n如下图所示，一个Activity中的两个Fragment分别在手机和平板的显示情况：    \n{% asset_img Fragment显示图.png Fragment显示图 %}     \n\n### 四 Fragment的生命周期   \n下面是Activity的生命周期：     \n{% asset_img Fragment生命周期图.png Fragment生命周期图 %}    \n管理fragment生命周期与管理activity生命周期很相像。像activity一样，fragment也有三种状态：    \n- Resumed    \nfragment在运行中的activity可见。    \n- Paused    \n 另一个activity处于前台且得到焦点，但是这个fragment所在的activity仍然可见（前台activity部分透明，或者没有覆盖全屏）。   \n- Stopped   \nfragment不可见。要么宿主activity已经停止，要么fragment已经从activity上移除，但已被添加到后台栈中。一个停止的fragment仍然活着（所有状态和成员信息仍然由系统保留着）。但是，它对用户来讲已经不再可见，并且如果activity被杀掉，它也将被杀掉。     \n同activity类似的还有，你也可以用Bundle保存fragment状态，万一activity的进程被杀掉了，并且在activity被重新创建时，你需要恢复fragment状态。在回调执行fragment的onSaveInstanceState()期间可以保存状态，在onCreate()，onCreateView()，或者onActvityCreate()中可以恢复状态。      \n在生命周期方面,activity与fragment之间一个很重要的不同，就是在各自的后台栈中是如何存储的。当activity停止时，默认情况下，activity被安置在由系统管理的activity后台栈中（因此用户可以按BACK键回退导航，就像在Tasks和后台栈中讨论的那样）。但是，仅当你在一个事务被移除时，通过显式调用addToBackStack()请求保存的实例，该fragment才被置于由宿主activity管理的后台栈。     \n除此之外，管理fragment的生命周期与管理activity的生命周期非常相似。所以，管理activity生命周期的实践同样也适用于fragment。你需要了解的，仅仅是activity的生命周期如何影响fragment的的。    \n\n### 五 与Activity生命周期协调合作 \n下面是Activity与Fragment生命周期图对比：    \n{% asset_img Fragment与Activity生命周期对比.png Fragment与Activity生命周期对比 %}      \nfragment所生存的activity生命周期直接影响着fragment的生命周期，由此针对activity的每一个生命周期回调都会引发一个fragment类似的回调。例如，当activity接收到onPause()时，这个activity之中的每个fragment都会接收到onPause()。     \nFragment有一些额外的生命周期回调方法，然而，为了处理像是创建和销毁fragment界面，它与activity进行独特的交互。这些额外的回调方法是：     \n- onAttach()     \n 当fragment被绑定到activity时调用（Activity会被传入）。 \n-  onCreateView()    \n创建与fragment相关的视图体系时被调用。     \n- onActivityCreated()     \n当activity的onCreate()函数返回时被调用。     \n- onDestroyView()     \n当与fragment关联的视图体系正被移除时被调用。     \n- onDetach()    \n当fragment正与activity解除关联时被调用。      \n\nfragment的生命周期流程实际上是受其宿主activity影响，如上图所示。在这张图中，可以看到activity的每个连续状态是如何决定fragment可能接收到哪个回调函数的。例如，当activity接收到它的onCreate()回调时，activity之中的fragment接收到的仅仅是onActivityCreated()回调。\n\n一旦activity处于resumed状态，则可以在activity中自由的添加或者移除fragment。因此，只有当activity处于resumed状态时，fragment的生命周期才可以独立变化。\n\n然而，当activity离开恢复状态时，fragment再一次被activity推入它的生命周期中。\n\n### 六 向Fragment中添加用户界面    \nfragment常被用作activity用户界面的一部分，并且将本身的布局构建到activity中去。     \n为了给fragment提供一个布局，你必须实现onCreateView()回调函数，在绘制fragment布局时Android系统会调用它。实现这个函数时需要返回fragment所属的根View。     \n\n> 注意：如果你的fragment时ListFragment的子类，默认实现从onCreateView()返回一个ListView，所以你不需要实现它。    \n   \n为了从onCreateView()返回一个布局，你可以从layout resource定义的XML文件inflate它。为了便于你这样做，onCreateView()提供一个LayoutInflater对象。   \n例如，下面是一个fragment子类，它的布局从example_fragment.xml载入的：    \n\n```java  \npublic static class ExampleFragment extends Fragment {\n\t\t@Override\n\t\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container,\n\t\t\t\t\t\t\t\t Bundle savedInstanceState) {\n\t\t\t// Inflate the layout for this fragment\n\t\t\treturn inflater.inflate(R.layout.example_fragment, container, false);\n\t\t}\n\t}\n```\n\n传入onCreateView()的参数container 是你的frament布局将要被插入的父ViewGroup（来自activity的布局）。如果fragment处于resumed状态（恢复状态在操纵fragment生命周期一节中将作更多讨论），参数savedInstanceState是属于Bundle类，它提供了fragment之前实例的相关数据。     \n\ninflate()函数需要以下三个参数：     \n- 要inflate的布局的资源ID。      \n- 被inflate的布局的父ViewGroup。传入container很重要，这是为了让系统将布局参数应用到被inflate的布局的根view中去，由其将要嵌入的父view指定。    \n- 一个布尔值，表明在inflate期间被infalte的布局是否应该附上ViewGroup（第二个参数）。（在这个例子中传入的是false，因为系统已经将被inflate的布局插入到容器中（container）——传入true会在最终的布局里创建一个多余的ViewGroup。）       \n\n现在你已经知道了如何创建一个有布局的fragment。下一步，则需要将fragment添加到activity中。      \n\n### 七 将Fragment添加到Activity中    \n通常，fragment构建了其宿主activity的部分界面，它被作为activity全部视图层次体系的一部分被嵌入进去。在acitivity布局中添加fragment有两种方法：     \n\n##### 在activity的布局文件里声明fragment\n\n像这样，你可以像为view一样为fragment指定布局属性。例如，下面含有两个fragment的布局文件：\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t\tandroid:orientation=\"horizontal\"\n\t\tandroid:layout_width=\"match_parent\"\n\t\tandroid:layout_height=\"match_parent\">\n\t\t<fragment android:name=\"com.example.news.ArticleListFragment\"\n\t\t\t\tandroid:id=\"@+id/list\"\n\t\t\t\tandroid:layout_weight=\"1\"\n\t\t\t\tandroid:layout_width=\"0dp\"\n\t\t\t\tandroid:layout_height=\"match_parent\" />\n\t\t<fragment android:name=\"com.example.news.ArticleReaderFragment\"\n\t\t\t\tandroid:id=\"@+id/viewer\"\n\t\t\t\tandroid:layout_weight=\"2\"\n\t\t\t\tandroid:layout_width=\"0dp\"\n\t\t\t\tandroid:layout_height=\"match_parent\" />\n\t</LinearLayout>\n```\n\n<fragment>中的android:name 属性指定了布局中实例化的Fragment类。\n\n当系统创建activity布局时，它实例化了布局文件中指定的每一个fragment，并为它们调用onCreateView()函数，以获取每一个fragment的布局。系统直接在<fragment>元素的位置插入fragment返回的View。\n\n> 注意：每个fragment都需要一个唯一的标识，如果重启activity，系统可用来恢复fragment（并且可用来捕捉fragment的事务处理，例如移除）。为fragment提供ID有三种方法：   \n- 用android:id属性提供一个唯一的标识。   \n- 用android:tag属性提供一个唯一的字符串。   \n- 如果上述两个属性都没有，系统会使用其容器视图（view）的ID。 \n\n##### 通过java代码将fragment添加到已存在的ViewGroup中\n\n在activity运行的任何时候，你都可以将fragment添加到activity布局中。你仅需要简单指定用来放置fragment的ViewGroup。\n\n你应当使用FragmentTransaction的API来对activity中的fragment进行操作（例如添加，移除，或者替换fragment）。你可以像下面这样从Activity中取得FragmentTransaction的实例：\n\n```java\nFragmentManager fragmentManager = getFragmentManager()\n\tFragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n```\n\n可以用add()函数添加fragment，并指定要添加的fragment以及要将其插入到哪个视图（view）之中：\n\n```java\nExampleFragment fragment = new ExampleFragment();\n\tfragmentTransaction.add(R.id.fragment_container, fragment);\n\tfragmentTransaction.commit();\n```\n\n传入add()函数的第一个参数是fragment被放置的ViewGroup，它由资源ID（resource ID）指定，第二个参数就是要添加的fragment。一旦通过FragmentTransaction 做了更改，都应当使用commit()使变化生效。\n\n##### 添加无界面的Fragment\n\n上面的例子是如何将fragment添加到activity中去，目的是提供一个用户界面。然而，也可以使用fragment为activity提供后台动作，却不呈现多余的用户界面。\n\n想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。\n\n想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。  \n\n\n### 八 Fragment事务后台栈     \n\n在activity中使用fragment的一大特点是具有添加、删除、替换，和执行其它动作的能力，以响应用户的互动。提交给activity的每一系列变化被称为事务，并且可以用FragmentTransaction 中的APIs处理。你也可以将每一个事务保存在由activity管理的后台栈中，并且允许用户导航回退fragment变更（类似于activity的导航回退）。  \n\n你可以从FragmentManager中获取FragmentTransaction实例，像这样：\n\n```java\nFragmentManager fragmentManager = getFragmentManager();\n FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n```\n\n每项事务是在同一时间内要执行的一系列的变更。你可以为一个给定的事务用相关方法设置想要执行的所有变化，例如add()，remove()，和replace()。然后，用commit()将事务提交给activity。然而，在调用commit()之前，为了将事务添加到fragment事务后台栈中，你可能会想调用addToBackStatck()。这个后台栈由activity管理，并且允许用户通过按BACK键回退到前一个fragment状态。   \n举个例子，下面的代码是如何使用另一个fragment代替一个fragment，并且将之前的状态保留在后台栈中：\n\n```java\n// Create new fragment and transaction\n Fragment newFragment = new ExampleFragment();\n FragmentTransaction transaction = getFragmentManager().beginTransaction();\n\n // Replace whatever is in the fragment_container view with this fragment,\n // and add the transaction to the back stack\n transaction.replace(R.id.fragment_container, newFragment);\n transaction.addToBackStack(null);\n\n // Commit the transaction\n transaction.commit();\n```\n\n在这个例子中，newFragment替换了当前在布局容器中用R.id.fragment_container标识的所有的fragment（如果有的话），替代的事务被保存在后台栈中，因此用户可以回退该事务，可通过按BACK键还原之前的fragment。如果添加多个变更事务（例如另一个add()或者remove()）并调用addToBackStack()，那么在调用commit()之前的所有应用的变更被作为一个单独的事务添加到后台栈中，并且BACK键可以将它们一起回退。\n\n将变更添加到FragmentTransaction中的顺序注意以下两点：     \n- 必须要在最后调用commit()   \n- 如果你正将多个fragment添加到同一个容器中，那么添加顺序决定了它们在视图层次（view hierarchy）里显示的顺序。 \n\n在执行删除fragment事务时，如果没有调用addToBackStack()，那么事务一提交fragment就会被销毁，而且用户也无法回退它。然而，当移除一个fragment时，如果调用了addToBackStack()，那么之后fragment会被停止，如果用户回退，它将被恢复过来。     \n> 提示：对于每一个fragment事务，在提交之前通过调用setTransition()来应用一系列事务动作。     \n\n调用commit()并不立刻执行事务，相反，而是采取预约方式，一旦activity的界面线程（主线程）准备好便可运行起来。然而，如果有必要的话，你可以从界面线程调用executePendingTransations()立即执行由commit()提交的事务。但这样做，通常是没有必要的，除非其它线程的工作依赖与该项事务。\n\n> 警告：只能在activity保存状态（当用户离开activity时）之前用commit()提交事务。如果你尝试在那时之后提交，会抛出一个异常。这是因为如果activity需要被恢复，提交后的状态会被丢失。对于这类丢失提交的情况，可使用commitAllowingStateLoss() \n\n\n### 九 与Activity交互      \n##### 1.Fragment可以得到宿主Activity的引用\n尽管Fragment被实现为一个对象，它独立于Activity并可以在多个Activity中使用，一个给定的fragment实例直接被捆绑在包含它的Activity中。特别是，fragment可以通过getActivity()函数访问Activity，并且很容易的执行类似于查找activity布局中的视图的任务：\n\n```java\nView listView = getActivity().findViewById(R.id.list);\n```\n\n##### 2.Activity获取Fragment的引用\n同样的，activity能够调用fragment的函数findFragmentById()或者findFragmentByTag()，从FragmentManager中获取Fragment的索引，例如：\n\n```java\nExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);\n```\n\n##### 3.创建Activity时间回调函数\n\n在一些情况下，你可能需要fragment与activity共享事件。这样做的一个好方法是在fragment内部定义一个回调接口，并需要宿主activity实现它。当activity通过接口接收到回调时，可以在必要时与布局中的其它fragment共享信息。    \n举个例子，如果新闻应用的actvity中有两个fragment——一个显示文章列表（fragment A），另一个显示一篇文章（fragment B）——然后fragment A 必须要告诉activity列表项何时被选种，这样，activity可以通知fragment B显示这篇文章。这种情况下，在fragment A内部声明接口OnArticleSelectedListener：\n\n```java\npublic static class FragmentA extends ListFragment {\n    ...\n    // Container Activity must implement this interface\n    public interface OnArticleSelectedListener {\n        public void onArticleSelected(Uri articleUri);\n    }\n    ...\n}\n```\n\n然后fragment的宿主activity实现了OnArticleSelectedListener接口，并且重写onArticleSelected()以通知fragment B来自于fragment A的事件。为了确保宿主activity实现了这个接口，fragment A的onAttach()回调函数（当添加fragment到activity中时系统会调用它）通过作为参数传入onAttach()的activity的类型转换来实例化一个OnArticleSelectedListener实例。\n\n```java\npublic static class FragmentA extends ListFragment {\n    OnArticleSelectedListener mListener;\n    ...\n    @Override\n    public void onAttach(Activity activity) {\n        super.onAttach(activity);\n        try {\n            mListener = (OnArticleSelectedListener) activity;\n        } catch (ClassCastException e) {\n            throw new ClassCastException(activity.toString() + \" must implement OnArticleSelectedListener\");\n        }\n    }\n    ...\n}\n```\n\n如果activity没有实现这个接口，那么fragment会抛出一个ClassCaseException异常。一旦成功，mListener成员会保留一个activity的OnArticleSelectedListener实现的引用，由此fragment A可以通过调用由OnArticleSelectedListener接口定义的方法与activity共享事件。例如，如果fragment A是ListFragment的子类，每次用户点击列表项时，系统都会调用fragment的onListItemClick()事件，然后fragment调用onArticleSelected()来与activity共享事件。\n\n```java\npublic static class FragmentA extends ListFragment {\n    OnArticleSelectedListener mListener;\n    ...\n    @Override\n    public void onListItemClick(ListView l, View v, int position, long id) {\n        // Append the clicked item's row ID with the content provider Uri\n        Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);\n        // Send the event and Uri to the host activity\n        mListener.onArticleSelected(noteUri);\n    }\n    ...\n}\n```\n\n传递给onListItemClick()的参数id是点击的列表项行id，activity（或者其它fragment）用以从应用的ContentProvider获取文章。\n\n#####　添加items到Action Bar\n\n你的fragments可以通过实现onCreateOptionsMenu()来构建菜单项到activity的Options Menu（因此Action Bar也一样）。为了使用这个方法接收到调用，不管怎样，你必须在onCreate()期间调用setHasOptionsMenu()，来指明想要添加项目到Options Menu的那个fragment（否则，fragment将接收不到onCreateOptionsMenu()的调用）。     \n任何想要在fragment中的Options Menu添加的项目都追加到已有的菜单项后面。当菜单项被选中时，fragment也会接收到对onOptionsItemSelected()的回调。    \n你也可以通过调用registerForContextMenu()在fragment布局中注册一个view以提供一个context menu。当用户打开context menu时，fragment接收到对onCreateContextMenu()的回调。当用户选中一个项目时，fragment接收到对onContextItemSelected()的回调。\n\n> 注意：尽管你的fragment会接收到为添加到每个菜单项被选择菜单项的回调，但当用户选择一个菜单项时，activity会首先接收到对应的回调。如果activity的选择菜单项回调的实现没有处理被选中的项目，那么该事件被传递给fragment的回调。这同样适用于Options Menu和context menu。\n\n### 十 总结\n\n\n\n","source":"_posts/android基础之Fragments.md","raw":"---\ntitle: android基础之Fragments\ndate: 2017-02-27 14:31:31\ncategories: android\ntags:\n- android\n- java\n- Fragment\n---\n\n### 一 概述   \nFragment表现Activity中用户界面的一个行为或者是一部分。你可以在一个单独的activity上把多个fragment组合成为一个多区域的UI，并且可以在多个activity中再使用。你可以认为fragment是activity的一个模块零件，它有自己的生命周期，接收它自己的输入事件，并且可以在activity运行时添加或者删除。\n\nFragment必须总是被嵌入到一个activity之中，并且fragment的生命周期直接受其宿主activity的生命周期的影响。例如，一旦activity被暂停，它里面所有的fragment也被暂停，一旦activity被销毁，它里面所有的fragment也被销毁。然而，当activity正在运行时（处于resumed的生命周期状态），你可以单独的操控每个fragment，比如添加或者删除。当你执行这样一项事务时，可以将它添加到后台的一个栈中，这个栈由activity管理着——activity里面的每个后台栈内容实体是fragment发生过的一条事务记录。这个后台栈允许用户通过按BACK键回退一项fragment事务（往后导航）。\n\n当你添加一个fragment作为某个activity布局的一部分时，它就存在于这个activity视图体系内部的ViewGroup之中，并且定义了它自己的视图布局。你可以通过在activity布局文件中声明fragment，用<fragment>元素把fragment插入到activity的布局中，或者是用应用程序源码将它添加到一个存在的ViewGroup中。然而，fragment并不是一个定要作为activity布局的一部分；fragment也可以为activity隐身工作。   \n\n### 二 Fragment的继承结构   \n继承 Object\n实现 ComponentCallbacks2 View.OnCreateContextMenuListener \n      \n```java \njava.lang.Object\n   ↳ \tandroid.app.Fragment\n```\n直接子类：\nDialogFragment, ListFragment, PreferenceFragment, WebViewFragment      \n\n### 三 Fragment设计哲学  \nFragment被设计出来主要为了适应平板等大屏幕移动设备。有了fragment，你可以不必去管理视图体系的复杂变化。通过将activity的布局分割成若干个fragment，可以在运行时编辑activity的呈现，并且那些变化会被保存在由activity管理的后台栈里面。  \n如下图所示，一个Activity中的两个Fragment分别在手机和平板的显示情况：    \n{% asset_img Fragment显示图.png Fragment显示图 %}     \n\n### 四 Fragment的生命周期   \n下面是Activity的生命周期：     \n{% asset_img Fragment生命周期图.png Fragment生命周期图 %}    \n管理fragment生命周期与管理activity生命周期很相像。像activity一样，fragment也有三种状态：    \n- Resumed    \nfragment在运行中的activity可见。    \n- Paused    \n 另一个activity处于前台且得到焦点，但是这个fragment所在的activity仍然可见（前台activity部分透明，或者没有覆盖全屏）。   \n- Stopped   \nfragment不可见。要么宿主activity已经停止，要么fragment已经从activity上移除，但已被添加到后台栈中。一个停止的fragment仍然活着（所有状态和成员信息仍然由系统保留着）。但是，它对用户来讲已经不再可见，并且如果activity被杀掉，它也将被杀掉。     \n同activity类似的还有，你也可以用Bundle保存fragment状态，万一activity的进程被杀掉了，并且在activity被重新创建时，你需要恢复fragment状态。在回调执行fragment的onSaveInstanceState()期间可以保存状态，在onCreate()，onCreateView()，或者onActvityCreate()中可以恢复状态。      \n在生命周期方面,activity与fragment之间一个很重要的不同，就是在各自的后台栈中是如何存储的。当activity停止时，默认情况下，activity被安置在由系统管理的activity后台栈中（因此用户可以按BACK键回退导航，就像在Tasks和后台栈中讨论的那样）。但是，仅当你在一个事务被移除时，通过显式调用addToBackStack()请求保存的实例，该fragment才被置于由宿主activity管理的后台栈。     \n除此之外，管理fragment的生命周期与管理activity的生命周期非常相似。所以，管理activity生命周期的实践同样也适用于fragment。你需要了解的，仅仅是activity的生命周期如何影响fragment的的。    \n\n### 五 与Activity生命周期协调合作 \n下面是Activity与Fragment生命周期图对比：    \n{% asset_img Fragment与Activity生命周期对比.png Fragment与Activity生命周期对比 %}      \nfragment所生存的activity生命周期直接影响着fragment的生命周期，由此针对activity的每一个生命周期回调都会引发一个fragment类似的回调。例如，当activity接收到onPause()时，这个activity之中的每个fragment都会接收到onPause()。     \nFragment有一些额外的生命周期回调方法，然而，为了处理像是创建和销毁fragment界面，它与activity进行独特的交互。这些额外的回调方法是：     \n- onAttach()     \n 当fragment被绑定到activity时调用（Activity会被传入）。 \n-  onCreateView()    \n创建与fragment相关的视图体系时被调用。     \n- onActivityCreated()     \n当activity的onCreate()函数返回时被调用。     \n- onDestroyView()     \n当与fragment关联的视图体系正被移除时被调用。     \n- onDetach()    \n当fragment正与activity解除关联时被调用。      \n\nfragment的生命周期流程实际上是受其宿主activity影响，如上图所示。在这张图中，可以看到activity的每个连续状态是如何决定fragment可能接收到哪个回调函数的。例如，当activity接收到它的onCreate()回调时，activity之中的fragment接收到的仅仅是onActivityCreated()回调。\n\n一旦activity处于resumed状态，则可以在activity中自由的添加或者移除fragment。因此，只有当activity处于resumed状态时，fragment的生命周期才可以独立变化。\n\n然而，当activity离开恢复状态时，fragment再一次被activity推入它的生命周期中。\n\n### 六 向Fragment中添加用户界面    \nfragment常被用作activity用户界面的一部分，并且将本身的布局构建到activity中去。     \n为了给fragment提供一个布局，你必须实现onCreateView()回调函数，在绘制fragment布局时Android系统会调用它。实现这个函数时需要返回fragment所属的根View。     \n\n> 注意：如果你的fragment时ListFragment的子类，默认实现从onCreateView()返回一个ListView，所以你不需要实现它。    \n   \n为了从onCreateView()返回一个布局，你可以从layout resource定义的XML文件inflate它。为了便于你这样做，onCreateView()提供一个LayoutInflater对象。   \n例如，下面是一个fragment子类，它的布局从example_fragment.xml载入的：    \n\n```java  \npublic static class ExampleFragment extends Fragment {\n\t\t@Override\n\t\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container,\n\t\t\t\t\t\t\t\t Bundle savedInstanceState) {\n\t\t\t// Inflate the layout for this fragment\n\t\t\treturn inflater.inflate(R.layout.example_fragment, container, false);\n\t\t}\n\t}\n```\n\n传入onCreateView()的参数container 是你的frament布局将要被插入的父ViewGroup（来自activity的布局）。如果fragment处于resumed状态（恢复状态在操纵fragment生命周期一节中将作更多讨论），参数savedInstanceState是属于Bundle类，它提供了fragment之前实例的相关数据。     \n\ninflate()函数需要以下三个参数：     \n- 要inflate的布局的资源ID。      \n- 被inflate的布局的父ViewGroup。传入container很重要，这是为了让系统将布局参数应用到被inflate的布局的根view中去，由其将要嵌入的父view指定。    \n- 一个布尔值，表明在inflate期间被infalte的布局是否应该附上ViewGroup（第二个参数）。（在这个例子中传入的是false，因为系统已经将被inflate的布局插入到容器中（container）——传入true会在最终的布局里创建一个多余的ViewGroup。）       \n\n现在你已经知道了如何创建一个有布局的fragment。下一步，则需要将fragment添加到activity中。      \n\n### 七 将Fragment添加到Activity中    \n通常，fragment构建了其宿主activity的部分界面，它被作为activity全部视图层次体系的一部分被嵌入进去。在acitivity布局中添加fragment有两种方法：     \n\n##### 在activity的布局文件里声明fragment\n\n像这样，你可以像为view一样为fragment指定布局属性。例如，下面含有两个fragment的布局文件：\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t\tandroid:orientation=\"horizontal\"\n\t\tandroid:layout_width=\"match_parent\"\n\t\tandroid:layout_height=\"match_parent\">\n\t\t<fragment android:name=\"com.example.news.ArticleListFragment\"\n\t\t\t\tandroid:id=\"@+id/list\"\n\t\t\t\tandroid:layout_weight=\"1\"\n\t\t\t\tandroid:layout_width=\"0dp\"\n\t\t\t\tandroid:layout_height=\"match_parent\" />\n\t\t<fragment android:name=\"com.example.news.ArticleReaderFragment\"\n\t\t\t\tandroid:id=\"@+id/viewer\"\n\t\t\t\tandroid:layout_weight=\"2\"\n\t\t\t\tandroid:layout_width=\"0dp\"\n\t\t\t\tandroid:layout_height=\"match_parent\" />\n\t</LinearLayout>\n```\n\n<fragment>中的android:name 属性指定了布局中实例化的Fragment类。\n\n当系统创建activity布局时，它实例化了布局文件中指定的每一个fragment，并为它们调用onCreateView()函数，以获取每一个fragment的布局。系统直接在<fragment>元素的位置插入fragment返回的View。\n\n> 注意：每个fragment都需要一个唯一的标识，如果重启activity，系统可用来恢复fragment（并且可用来捕捉fragment的事务处理，例如移除）。为fragment提供ID有三种方法：   \n- 用android:id属性提供一个唯一的标识。   \n- 用android:tag属性提供一个唯一的字符串。   \n- 如果上述两个属性都没有，系统会使用其容器视图（view）的ID。 \n\n##### 通过java代码将fragment添加到已存在的ViewGroup中\n\n在activity运行的任何时候，你都可以将fragment添加到activity布局中。你仅需要简单指定用来放置fragment的ViewGroup。\n\n你应当使用FragmentTransaction的API来对activity中的fragment进行操作（例如添加，移除，或者替换fragment）。你可以像下面这样从Activity中取得FragmentTransaction的实例：\n\n```java\nFragmentManager fragmentManager = getFragmentManager()\n\tFragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n```\n\n可以用add()函数添加fragment，并指定要添加的fragment以及要将其插入到哪个视图（view）之中：\n\n```java\nExampleFragment fragment = new ExampleFragment();\n\tfragmentTransaction.add(R.id.fragment_container, fragment);\n\tfragmentTransaction.commit();\n```\n\n传入add()函数的第一个参数是fragment被放置的ViewGroup，它由资源ID（resource ID）指定，第二个参数就是要添加的fragment。一旦通过FragmentTransaction 做了更改，都应当使用commit()使变化生效。\n\n##### 添加无界面的Fragment\n\n上面的例子是如何将fragment添加到activity中去，目的是提供一个用户界面。然而，也可以使用fragment为activity提供后台动作，却不呈现多余的用户界面。\n\n想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。\n\n想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。  \n\n\n### 八 Fragment事务后台栈     \n\n在activity中使用fragment的一大特点是具有添加、删除、替换，和执行其它动作的能力，以响应用户的互动。提交给activity的每一系列变化被称为事务，并且可以用FragmentTransaction 中的APIs处理。你也可以将每一个事务保存在由activity管理的后台栈中，并且允许用户导航回退fragment变更（类似于activity的导航回退）。  \n\n你可以从FragmentManager中获取FragmentTransaction实例，像这样：\n\n```java\nFragmentManager fragmentManager = getFragmentManager();\n FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n```\n\n每项事务是在同一时间内要执行的一系列的变更。你可以为一个给定的事务用相关方法设置想要执行的所有变化，例如add()，remove()，和replace()。然后，用commit()将事务提交给activity。然而，在调用commit()之前，为了将事务添加到fragment事务后台栈中，你可能会想调用addToBackStatck()。这个后台栈由activity管理，并且允许用户通过按BACK键回退到前一个fragment状态。   \n举个例子，下面的代码是如何使用另一个fragment代替一个fragment，并且将之前的状态保留在后台栈中：\n\n```java\n// Create new fragment and transaction\n Fragment newFragment = new ExampleFragment();\n FragmentTransaction transaction = getFragmentManager().beginTransaction();\n\n // Replace whatever is in the fragment_container view with this fragment,\n // and add the transaction to the back stack\n transaction.replace(R.id.fragment_container, newFragment);\n transaction.addToBackStack(null);\n\n // Commit the transaction\n transaction.commit();\n```\n\n在这个例子中，newFragment替换了当前在布局容器中用R.id.fragment_container标识的所有的fragment（如果有的话），替代的事务被保存在后台栈中，因此用户可以回退该事务，可通过按BACK键还原之前的fragment。如果添加多个变更事务（例如另一个add()或者remove()）并调用addToBackStack()，那么在调用commit()之前的所有应用的变更被作为一个单独的事务添加到后台栈中，并且BACK键可以将它们一起回退。\n\n将变更添加到FragmentTransaction中的顺序注意以下两点：     \n- 必须要在最后调用commit()   \n- 如果你正将多个fragment添加到同一个容器中，那么添加顺序决定了它们在视图层次（view hierarchy）里显示的顺序。 \n\n在执行删除fragment事务时，如果没有调用addToBackStack()，那么事务一提交fragment就会被销毁，而且用户也无法回退它。然而，当移除一个fragment时，如果调用了addToBackStack()，那么之后fragment会被停止，如果用户回退，它将被恢复过来。     \n> 提示：对于每一个fragment事务，在提交之前通过调用setTransition()来应用一系列事务动作。     \n\n调用commit()并不立刻执行事务，相反，而是采取预约方式，一旦activity的界面线程（主线程）准备好便可运行起来。然而，如果有必要的话，你可以从界面线程调用executePendingTransations()立即执行由commit()提交的事务。但这样做，通常是没有必要的，除非其它线程的工作依赖与该项事务。\n\n> 警告：只能在activity保存状态（当用户离开activity时）之前用commit()提交事务。如果你尝试在那时之后提交，会抛出一个异常。这是因为如果activity需要被恢复，提交后的状态会被丢失。对于这类丢失提交的情况，可使用commitAllowingStateLoss() \n\n\n### 九 与Activity交互      \n##### 1.Fragment可以得到宿主Activity的引用\n尽管Fragment被实现为一个对象，它独立于Activity并可以在多个Activity中使用，一个给定的fragment实例直接被捆绑在包含它的Activity中。特别是，fragment可以通过getActivity()函数访问Activity，并且很容易的执行类似于查找activity布局中的视图的任务：\n\n```java\nView listView = getActivity().findViewById(R.id.list);\n```\n\n##### 2.Activity获取Fragment的引用\n同样的，activity能够调用fragment的函数findFragmentById()或者findFragmentByTag()，从FragmentManager中获取Fragment的索引，例如：\n\n```java\nExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);\n```\n\n##### 3.创建Activity时间回调函数\n\n在一些情况下，你可能需要fragment与activity共享事件。这样做的一个好方法是在fragment内部定义一个回调接口，并需要宿主activity实现它。当activity通过接口接收到回调时，可以在必要时与布局中的其它fragment共享信息。    \n举个例子，如果新闻应用的actvity中有两个fragment——一个显示文章列表（fragment A），另一个显示一篇文章（fragment B）——然后fragment A 必须要告诉activity列表项何时被选种，这样，activity可以通知fragment B显示这篇文章。这种情况下，在fragment A内部声明接口OnArticleSelectedListener：\n\n```java\npublic static class FragmentA extends ListFragment {\n    ...\n    // Container Activity must implement this interface\n    public interface OnArticleSelectedListener {\n        public void onArticleSelected(Uri articleUri);\n    }\n    ...\n}\n```\n\n然后fragment的宿主activity实现了OnArticleSelectedListener接口，并且重写onArticleSelected()以通知fragment B来自于fragment A的事件。为了确保宿主activity实现了这个接口，fragment A的onAttach()回调函数（当添加fragment到activity中时系统会调用它）通过作为参数传入onAttach()的activity的类型转换来实例化一个OnArticleSelectedListener实例。\n\n```java\npublic static class FragmentA extends ListFragment {\n    OnArticleSelectedListener mListener;\n    ...\n    @Override\n    public void onAttach(Activity activity) {\n        super.onAttach(activity);\n        try {\n            mListener = (OnArticleSelectedListener) activity;\n        } catch (ClassCastException e) {\n            throw new ClassCastException(activity.toString() + \" must implement OnArticleSelectedListener\");\n        }\n    }\n    ...\n}\n```\n\n如果activity没有实现这个接口，那么fragment会抛出一个ClassCaseException异常。一旦成功，mListener成员会保留一个activity的OnArticleSelectedListener实现的引用，由此fragment A可以通过调用由OnArticleSelectedListener接口定义的方法与activity共享事件。例如，如果fragment A是ListFragment的子类，每次用户点击列表项时，系统都会调用fragment的onListItemClick()事件，然后fragment调用onArticleSelected()来与activity共享事件。\n\n```java\npublic static class FragmentA extends ListFragment {\n    OnArticleSelectedListener mListener;\n    ...\n    @Override\n    public void onListItemClick(ListView l, View v, int position, long id) {\n        // Append the clicked item's row ID with the content provider Uri\n        Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);\n        // Send the event and Uri to the host activity\n        mListener.onArticleSelected(noteUri);\n    }\n    ...\n}\n```\n\n传递给onListItemClick()的参数id是点击的列表项行id，activity（或者其它fragment）用以从应用的ContentProvider获取文章。\n\n#####　添加items到Action Bar\n\n你的fragments可以通过实现onCreateOptionsMenu()来构建菜单项到activity的Options Menu（因此Action Bar也一样）。为了使用这个方法接收到调用，不管怎样，你必须在onCreate()期间调用setHasOptionsMenu()，来指明想要添加项目到Options Menu的那个fragment（否则，fragment将接收不到onCreateOptionsMenu()的调用）。     \n任何想要在fragment中的Options Menu添加的项目都追加到已有的菜单项后面。当菜单项被选中时，fragment也会接收到对onOptionsItemSelected()的回调。    \n你也可以通过调用registerForContextMenu()在fragment布局中注册一个view以提供一个context menu。当用户打开context menu时，fragment接收到对onCreateContextMenu()的回调。当用户选中一个项目时，fragment接收到对onContextItemSelected()的回调。\n\n> 注意：尽管你的fragment会接收到为添加到每个菜单项被选择菜单项的回调，但当用户选择一个菜单项时，activity会首先接收到对应的回调。如果activity的选择菜单项回调的实现没有处理被选中的项目，那么该事件被传递给fragment的回调。这同样适用于Options Menu和context menu。\n\n### 十 总结\n\n\n\n","slug":"android基础之Fragments","published":1,"updated":"2017-03-07T04:00:35.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk1q000xaknz8qbbv83b","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Fragment表现Activity中用户界面的一个行为或者是一部分。你可以在一个单独的activity上把多个fragment组合成为一个多区域的UI，并且可以在多个activity中再使用。你可以认为fragment是activity的一个模块零件，它有自己的生命周期，接收它自己的输入事件，并且可以在activity运行时添加或者删除。</p>\n<p>Fragment必须总是被嵌入到一个activity之中，并且fragment的生命周期直接受其宿主activity的生命周期的影响。例如，一旦activity被暂停，它里面所有的fragment也被暂停，一旦activity被销毁，它里面所有的fragment也被销毁。然而，当activity正在运行时（处于resumed的生命周期状态），你可以单独的操控每个fragment，比如添加或者删除。当你执行这样一项事务时，可以将它添加到后台的一个栈中，这个栈由activity管理着——activity里面的每个后台栈内容实体是fragment发生过的一条事务记录。这个后台栈允许用户通过按BACK键回退一项fragment事务（往后导航）。</p>\n<p>当你添加一个fragment作为某个activity布局的一部分时，它就存在于这个activity视图体系内部的ViewGroup之中，并且定义了它自己的视图布局。你可以通过在activity布局文件中声明fragment，用<fragment>元素把fragment插入到activity的布局中，或者是用应用程序源码将它添加到一个存在的ViewGroup中。然而，fragment并不是一个定要作为activity布局的一部分；fragment也可以为activity隐身工作。   </fragment></p>\n<h3 id=\"二-Fragment的继承结构\"><a href=\"#二-Fragment的继承结构\" class=\"headerlink\" title=\"二 Fragment的继承结构\"></a>二 Fragment的继承结构</h3><p>继承 Object<br>实现 ComponentCallbacks2 View.OnCreateContextMenuListener </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.lang.Object</div><div class=\"line\">   ↳ \tandroid.app.Fragment</div></pre></td></tr></table></figure>\n<p>直接子类：<br>DialogFragment, ListFragment, PreferenceFragment, WebViewFragment      </p>\n<h3 id=\"三-Fragment设计哲学\"><a href=\"#三-Fragment设计哲学\" class=\"headerlink\" title=\"三 Fragment设计哲学\"></a>三 Fragment设计哲学</h3><p>Fragment被设计出来主要为了适应平板等大屏幕移动设备。有了fragment，你可以不必去管理视图体系的复杂变化。通过将activity的布局分割成若干个fragment，可以在运行时编辑activity的呈现，并且那些变化会被保存在由activity管理的后台栈里面。<br>如下图所示，一个Activity中的两个Fragment分别在手机和平板的显示情况：<br><img src=\"/2017/02/27/android基础之Fragments/Fragment显示图.png\" alt=\"Fragment显示图\" title=\"Fragment显示图\">     </p>\n<h3 id=\"四-Fragment的生命周期\"><a href=\"#四-Fragment的生命周期\" class=\"headerlink\" title=\"四 Fragment的生命周期\"></a>四 Fragment的生命周期</h3><p>下面是Activity的生命周期：<br><img src=\"/2017/02/27/android基础之Fragments/Fragment生命周期图.png\" alt=\"Fragment生命周期图\" title=\"Fragment生命周期图\"><br>管理fragment生命周期与管理activity生命周期很相像。像activity一样，fragment也有三种状态：    </p>\n<ul>\n<li>Resumed<br>fragment在运行中的activity可见。    </li>\n<li>Paused<br>另一个activity处于前台且得到焦点，但是这个fragment所在的activity仍然可见（前台activity部分透明，或者没有覆盖全屏）。   </li>\n<li>Stopped<br>fragment不可见。要么宿主activity已经停止，要么fragment已经从activity上移除，但已被添加到后台栈中。一个停止的fragment仍然活着（所有状态和成员信息仍然由系统保留着）。但是，它对用户来讲已经不再可见，并且如果activity被杀掉，它也将被杀掉。<br>同activity类似的还有，你也可以用Bundle保存fragment状态，万一activity的进程被杀掉了，并且在activity被重新创建时，你需要恢复fragment状态。在回调执行fragment的onSaveInstanceState()期间可以保存状态，在onCreate()，onCreateView()，或者onActvityCreate()中可以恢复状态。<br>在生命周期方面,activity与fragment之间一个很重要的不同，就是在各自的后台栈中是如何存储的。当activity停止时，默认情况下，activity被安置在由系统管理的activity后台栈中（因此用户可以按BACK键回退导航，就像在Tasks和后台栈中讨论的那样）。但是，仅当你在一个事务被移除时，通过显式调用addToBackStack()请求保存的实例，该fragment才被置于由宿主activity管理的后台栈。<br>除此之外，管理fragment的生命周期与管理activity的生命周期非常相似。所以，管理activity生命周期的实践同样也适用于fragment。你需要了解的，仅仅是activity的生命周期如何影响fragment的的。    </li>\n</ul>\n<h3 id=\"五-与Activity生命周期协调合作\"><a href=\"#五-与Activity生命周期协调合作\" class=\"headerlink\" title=\"五 与Activity生命周期协调合作\"></a>五 与Activity生命周期协调合作</h3><p>下面是Activity与Fragment生命周期图对比：<br><img src=\"/2017/02/27/android基础之Fragments/Fragment与Activity生命周期对比.png\" alt=\"Fragment与Activity生命周期对比\" title=\"Fragment与Activity生命周期对比\"><br>fragment所生存的activity生命周期直接影响着fragment的生命周期，由此针对activity的每一个生命周期回调都会引发一个fragment类似的回调。例如，当activity接收到onPause()时，这个activity之中的每个fragment都会接收到onPause()。<br>Fragment有一些额外的生命周期回调方法，然而，为了处理像是创建和销毁fragment界面，它与activity进行独特的交互。这些额外的回调方法是：     </p>\n<ul>\n<li>onAttach()<br>当fragment被绑定到activity时调用（Activity会被传入）。 </li>\n<li>onCreateView()<br>创建与fragment相关的视图体系时被调用。     </li>\n<li>onActivityCreated()<br>当activity的onCreate()函数返回时被调用。     </li>\n<li>onDestroyView()<br>当与fragment关联的视图体系正被移除时被调用。     </li>\n<li>onDetach()<br>当fragment正与activity解除关联时被调用。      </li>\n</ul>\n<p>fragment的生命周期流程实际上是受其宿主activity影响，如上图所示。在这张图中，可以看到activity的每个连续状态是如何决定fragment可能接收到哪个回调函数的。例如，当activity接收到它的onCreate()回调时，activity之中的fragment接收到的仅仅是onActivityCreated()回调。</p>\n<p>一旦activity处于resumed状态，则可以在activity中自由的添加或者移除fragment。因此，只有当activity处于resumed状态时，fragment的生命周期才可以独立变化。</p>\n<p>然而，当activity离开恢复状态时，fragment再一次被activity推入它的生命周期中。</p>\n<h3 id=\"六-向Fragment中添加用户界面\"><a href=\"#六-向Fragment中添加用户界面\" class=\"headerlink\" title=\"六 向Fragment中添加用户界面\"></a>六 向Fragment中添加用户界面</h3><p>fragment常被用作activity用户界面的一部分，并且将本身的布局构建到activity中去。<br>为了给fragment提供一个布局，你必须实现onCreateView()回调函数，在绘制fragment布局时Android系统会调用它。实现这个函数时需要返回fragment所属的根View。     </p>\n<blockquote>\n<p>注意：如果你的fragment时ListFragment的子类，默认实现从onCreateView()返回一个ListView，所以你不需要实现它。    </p>\n</blockquote>\n<p>为了从onCreateView()返回一个布局，你可以从layout resource定义的XML文件inflate它。为了便于你这样做，onCreateView()提供一个LayoutInflater对象。<br>例如，下面是一个fragment子类，它的布局从example_fragment.xml载入的：    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">onCreateView</span><span class=\"params\">(LayoutInflater inflater, ViewGroup container,</span></span></div><div class=\"line\">\t\t\t\t\t\t\t\t Bundle savedInstanceState) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// Inflate the layout for this fragment</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> inflater.inflate(R.layout.example_fragment, container, <span class=\"keyword\">false</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>传入onCreateView()的参数container 是你的frament布局将要被插入的父ViewGroup（来自activity的布局）。如果fragment处于resumed状态（恢复状态在操纵fragment生命周期一节中将作更多讨论），参数savedInstanceState是属于Bundle类，它提供了fragment之前实例的相关数据。     </p>\n<p>inflate()函数需要以下三个参数：     </p>\n<ul>\n<li>要inflate的布局的资源ID。      </li>\n<li>被inflate的布局的父ViewGroup。传入container很重要，这是为了让系统将布局参数应用到被inflate的布局的根view中去，由其将要嵌入的父view指定。    </li>\n<li>一个布尔值，表明在inflate期间被infalte的布局是否应该附上ViewGroup（第二个参数）。（在这个例子中传入的是false，因为系统已经将被inflate的布局插入到容器中（container）——传入true会在最终的布局里创建一个多余的ViewGroup。）       </li>\n</ul>\n<p>现在你已经知道了如何创建一个有布局的fragment。下一步，则需要将fragment添加到activity中。      </p>\n<h3 id=\"七-将Fragment添加到Activity中\"><a href=\"#七-将Fragment添加到Activity中\" class=\"headerlink\" title=\"七 将Fragment添加到Activity中\"></a>七 将Fragment添加到Activity中</h3><p>通常，fragment构建了其宿主activity的部分界面，它被作为activity全部视图层次体系的一部分被嵌入进去。在acitivity布局中添加fragment有两种方法：     </p>\n<h5 id=\"在activity的布局文件里声明fragment\"><a href=\"#在activity的布局文件里声明fragment\" class=\"headerlink\" title=\"在activity的布局文件里声明fragment\"></a>在activity的布局文件里声明fragment</h5><p>像这样，你可以像为view一样为fragment指定布局属性。例如，下面含有两个fragment的布局文件：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\">\t&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"</div><div class=\"line\">\t\tandroid:orientation=\"horizontal\"</div><div class=\"line\">\t\tandroid:layout_width=\"match_parent\"</div><div class=\"line\">\t\tandroid:layout_height=\"match_parent\"&gt;</div><div class=\"line\">\t\t&lt;fragment android:name=\"com.example.news.ArticleListFragment\"</div><div class=\"line\">\t\t\t\tandroid:id=\"@+id/list\"</div><div class=\"line\">\t\t\t\tandroid:layout_weight=\"1\"</div><div class=\"line\">\t\t\t\tandroid:layout_width=\"0dp\"</div><div class=\"line\">\t\t\t\tandroid:layout_height=\"match_parent\" /&gt;</div><div class=\"line\">\t\t&lt;fragment android:name=\"com.example.news.ArticleReaderFragment\"</div><div class=\"line\">\t\t\t\tandroid:id=\"@+id/viewer\"</div><div class=\"line\">\t\t\t\tandroid:layout_weight=\"2\"</div><div class=\"line\">\t\t\t\tandroid:layout_width=\"0dp\"</div><div class=\"line\">\t\t\t\tandroid:layout_height=\"match_parent\" /&gt;</div><div class=\"line\">\t&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>\n<p><fragment>中的android:name 属性指定了布局中实例化的Fragment类。</fragment></p>\n<p>当系统创建activity布局时，它实例化了布局文件中指定的每一个fragment，并为它们调用onCreateView()函数，以获取每一个fragment的布局。系统直接在<fragment>元素的位置插入fragment返回的View。</fragment></p>\n<blockquote>\n<p>注意：每个fragment都需要一个唯一的标识，如果重启activity，系统可用来恢复fragment（并且可用来捕捉fragment的事务处理，例如移除）。为fragment提供ID有三种方法：   </p>\n<ul>\n<li>用android:id属性提供一个唯一的标识。   </li>\n<li>用android:tag属性提供一个唯一的字符串。   </li>\n<li>如果上述两个属性都没有，系统会使用其容器视图（view）的ID。 </li>\n</ul>\n</blockquote>\n<h5 id=\"通过java代码将fragment添加到已存在的ViewGroup中\"><a href=\"#通过java代码将fragment添加到已存在的ViewGroup中\" class=\"headerlink\" title=\"通过java代码将fragment添加到已存在的ViewGroup中\"></a>通过java代码将fragment添加到已存在的ViewGroup中</h5><p>在activity运行的任何时候，你都可以将fragment添加到activity布局中。你仅需要简单指定用来放置fragment的ViewGroup。</p>\n<p>你应当使用FragmentTransaction的API来对activity中的fragment进行操作（例如添加，移除，或者替换fragment）。你可以像下面这样从Activity中取得FragmentTransaction的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">FragmentManager fragmentManager = getFragmentManager()</div><div class=\"line\">\tFragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</div></pre></td></tr></table></figure>\n<p>可以用add()函数添加fragment，并指定要添加的fragment以及要将其插入到哪个视图（view）之中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ExampleFragment fragment = <span class=\"keyword\">new</span> ExampleFragment();</div><div class=\"line\">\tfragmentTransaction.add(R.id.fragment_container, fragment);</div><div class=\"line\">\tfragmentTransaction.commit();</div></pre></td></tr></table></figure>\n<p>传入add()函数的第一个参数是fragment被放置的ViewGroup，它由资源ID（resource ID）指定，第二个参数就是要添加的fragment。一旦通过FragmentTransaction 做了更改，都应当使用commit()使变化生效。</p>\n<h5 id=\"添加无界面的Fragment\"><a href=\"#添加无界面的Fragment\" class=\"headerlink\" title=\"添加无界面的Fragment\"></a>添加无界面的Fragment</h5><p>上面的例子是如何将fragment添加到activity中去，目的是提供一个用户界面。然而，也可以使用fragment为activity提供后台动作，却不呈现多余的用户界面。</p>\n<p>想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。</p>\n<p>想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。  </p>\n<h3 id=\"八-Fragment事务后台栈\"><a href=\"#八-Fragment事务后台栈\" class=\"headerlink\" title=\"八 Fragment事务后台栈\"></a>八 Fragment事务后台栈</h3><p>在activity中使用fragment的一大特点是具有添加、删除、替换，和执行其它动作的能力，以响应用户的互动。提交给activity的每一系列变化被称为事务，并且可以用FragmentTransaction 中的APIs处理。你也可以将每一个事务保存在由activity管理的后台栈中，并且允许用户导航回退fragment变更（类似于activity的导航回退）。  </p>\n<p>你可以从FragmentManager中获取FragmentTransaction实例，像这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">FragmentManager fragmentManager = getFragmentManager();</div><div class=\"line\"> FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</div></pre></td></tr></table></figure>\n<p>每项事务是在同一时间内要执行的一系列的变更。你可以为一个给定的事务用相关方法设置想要执行的所有变化，例如add()，remove()，和replace()。然后，用commit()将事务提交给activity。然而，在调用commit()之前，为了将事务添加到fragment事务后台栈中，你可能会想调用addToBackStatck()。这个后台栈由activity管理，并且允许用户通过按BACK键回退到前一个fragment状态。<br>举个例子，下面的代码是如何使用另一个fragment代替一个fragment，并且将之前的状态保留在后台栈中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Create new fragment and transaction</span></div><div class=\"line\"> Fragment newFragment = <span class=\"keyword\">new</span> ExampleFragment();</div><div class=\"line\"> FragmentTransaction transaction = getFragmentManager().beginTransaction();</div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">// Replace whatever is in the fragment_container view with this fragment,</span></div><div class=\"line\"> <span class=\"comment\">// and add the transaction to the back stack</span></div><div class=\"line\"> transaction.replace(R.id.fragment_container, newFragment);</div><div class=\"line\"> transaction.addToBackStack(<span class=\"keyword\">null</span>);</div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">// Commit the transaction</span></div><div class=\"line\"> transaction.commit();</div></pre></td></tr></table></figure>\n<p>在这个例子中，newFragment替换了当前在布局容器中用R.id.fragment_container标识的所有的fragment（如果有的话），替代的事务被保存在后台栈中，因此用户可以回退该事务，可通过按BACK键还原之前的fragment。如果添加多个变更事务（例如另一个add()或者remove()）并调用addToBackStack()，那么在调用commit()之前的所有应用的变更被作为一个单独的事务添加到后台栈中，并且BACK键可以将它们一起回退。</p>\n<p>将变更添加到FragmentTransaction中的顺序注意以下两点：     </p>\n<ul>\n<li>必须要在最后调用commit()   </li>\n<li>如果你正将多个fragment添加到同一个容器中，那么添加顺序决定了它们在视图层次（view hierarchy）里显示的顺序。 </li>\n</ul>\n<p>在执行删除fragment事务时，如果没有调用addToBackStack()，那么事务一提交fragment就会被销毁，而且用户也无法回退它。然而，当移除一个fragment时，如果调用了addToBackStack()，那么之后fragment会被停止，如果用户回退，它将被恢复过来。     </p>\n<blockquote>\n<p>提示：对于每一个fragment事务，在提交之前通过调用setTransition()来应用一系列事务动作。     </p>\n</blockquote>\n<p>调用commit()并不立刻执行事务，相反，而是采取预约方式，一旦activity的界面线程（主线程）准备好便可运行起来。然而，如果有必要的话，你可以从界面线程调用executePendingTransations()立即执行由commit()提交的事务。但这样做，通常是没有必要的，除非其它线程的工作依赖与该项事务。</p>\n<blockquote>\n<p>警告：只能在activity保存状态（当用户离开activity时）之前用commit()提交事务。如果你尝试在那时之后提交，会抛出一个异常。这是因为如果activity需要被恢复，提交后的状态会被丢失。对于这类丢失提交的情况，可使用commitAllowingStateLoss() </p>\n</blockquote>\n<h3 id=\"九-与Activity交互\"><a href=\"#九-与Activity交互\" class=\"headerlink\" title=\"九 与Activity交互\"></a>九 与Activity交互</h3><h5 id=\"1-Fragment可以得到宿主Activity的引用\"><a href=\"#1-Fragment可以得到宿主Activity的引用\" class=\"headerlink\" title=\"1.Fragment可以得到宿主Activity的引用\"></a>1.Fragment可以得到宿主Activity的引用</h5><p>尽管Fragment被实现为一个对象，它独立于Activity并可以在多个Activity中使用，一个给定的fragment实例直接被捆绑在包含它的Activity中。特别是，fragment可以通过getActivity()函数访问Activity，并且很容易的执行类似于查找activity布局中的视图的任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">View listView = getActivity().findViewById(R.id.list);</div></pre></td></tr></table></figure>\n<h5 id=\"2-Activity获取Fragment的引用\"><a href=\"#2-Activity获取Fragment的引用\" class=\"headerlink\" title=\"2.Activity获取Fragment的引用\"></a>2.Activity获取Fragment的引用</h5><p>同样的，activity能够调用fragment的函数findFragmentById()或者findFragmentByTag()，从FragmentManager中获取Fragment的索引，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);</div></pre></td></tr></table></figure>\n<h5 id=\"3-创建Activity时间回调函数\"><a href=\"#3-创建Activity时间回调函数\" class=\"headerlink\" title=\"3.创建Activity时间回调函数\"></a>3.创建Activity时间回调函数</h5><p>在一些情况下，你可能需要fragment与activity共享事件。这样做的一个好方法是在fragment内部定义一个回调接口，并需要宿主activity实现它。当activity通过接口接收到回调时，可以在必要时与布局中的其它fragment共享信息。<br>举个例子，如果新闻应用的actvity中有两个fragment——一个显示文章列表（fragment A），另一个显示一篇文章（fragment B）——然后fragment A 必须要告诉activity列表项何时被选种，这样，activity可以通知fragment B显示这篇文章。这种情况下，在fragment A内部声明接口OnArticleSelectedListener：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentA</span> <span class=\"keyword\">extends</span> <span class=\"title\">ListFragment</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"comment\">// Container Activity must implement this interface</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnArticleSelectedListener</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onArticleSelected</span><span class=\"params\">(Uri articleUri)</span></span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后fragment的宿主activity实现了OnArticleSelectedListener接口，并且重写onArticleSelected()以通知fragment B来自于fragment A的事件。为了确保宿主activity实现了这个接口，fragment A的onAttach()回调函数（当添加fragment到activity中时系统会调用它）通过作为参数传入onAttach()的activity的类型转换来实例化一个OnArticleSelectedListener实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentA</span> <span class=\"keyword\">extends</span> <span class=\"title\">ListFragment</span> </span>&#123;</div><div class=\"line\">    OnArticleSelectedListener mListener;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAttach</span><span class=\"params\">(Activity activity)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onAttach(activity);</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            mListener = (OnArticleSelectedListener) activity;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassCastException e) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassCastException(activity.toString() + <span class=\"string\">\" must implement OnArticleSelectedListener\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果activity没有实现这个接口，那么fragment会抛出一个ClassCaseException异常。一旦成功，mListener成员会保留一个activity的OnArticleSelectedListener实现的引用，由此fragment A可以通过调用由OnArticleSelectedListener接口定义的方法与activity共享事件。例如，如果fragment A是ListFragment的子类，每次用户点击列表项时，系统都会调用fragment的onListItemClick()事件，然后fragment调用onArticleSelected()来与activity共享事件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentA</span> <span class=\"keyword\">extends</span> <span class=\"title\">ListFragment</span> </span>&#123;</div><div class=\"line\">    OnArticleSelectedListener mListener;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onListItemClick</span><span class=\"params\">(ListView l, View v, <span class=\"keyword\">int</span> position, <span class=\"keyword\">long</span> id)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Append the clicked item's row ID with the content provider Uri</span></div><div class=\"line\">        Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);</div><div class=\"line\">        <span class=\"comment\">// Send the event and Uri to the host activity</span></div><div class=\"line\">        mListener.onArticleSelected(noteUri);</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>传递给onListItemClick()的参数id是点击的列表项行id，activity（或者其它fragment）用以从应用的ContentProvider获取文章。</p>\n<p>#####　添加items到Action Bar</p>\n<p>你的fragments可以通过实现onCreateOptionsMenu()来构建菜单项到activity的Options Menu（因此Action Bar也一样）。为了使用这个方法接收到调用，不管怎样，你必须在onCreate()期间调用setHasOptionsMenu()，来指明想要添加项目到Options Menu的那个fragment（否则，fragment将接收不到onCreateOptionsMenu()的调用）。<br>任何想要在fragment中的Options Menu添加的项目都追加到已有的菜单项后面。当菜单项被选中时，fragment也会接收到对onOptionsItemSelected()的回调。<br>你也可以通过调用registerForContextMenu()在fragment布局中注册一个view以提供一个context menu。当用户打开context menu时，fragment接收到对onCreateContextMenu()的回调。当用户选中一个项目时，fragment接收到对onContextItemSelected()的回调。</p>\n<blockquote>\n<p>注意：尽管你的fragment会接收到为添加到每个菜单项被选择菜单项的回调，但当用户选择一个菜单项时，activity会首先接收到对应的回调。如果activity的选择菜单项回调的实现没有处理被选中的项目，那么该事件被传递给fragment的回调。这同样适用于Options Menu和context menu。</p>\n</blockquote>\n<h3 id=\"十-总结\"><a href=\"#十-总结\" class=\"headerlink\" title=\"十 总结\"></a>十 总结</h3>","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Fragment表现Activity中用户界面的一个行为或者是一部分。你可以在一个单独的activity上把多个fragment组合成为一个多区域的UI，并且可以在多个activity中再使用。你可以认为fragment是activity的一个模块零件，它有自己的生命周期，接收它自己的输入事件，并且可以在activity运行时添加或者删除。</p>\n<p>Fragment必须总是被嵌入到一个activity之中，并且fragment的生命周期直接受其宿主activity的生命周期的影响。例如，一旦activity被暂停，它里面所有的fragment也被暂停，一旦activity被销毁，它里面所有的fragment也被销毁。然而，当activity正在运行时（处于resumed的生命周期状态），你可以单独的操控每个fragment，比如添加或者删除。当你执行这样一项事务时，可以将它添加到后台的一个栈中，这个栈由activity管理着——activity里面的每个后台栈内容实体是fragment发生过的一条事务记录。这个后台栈允许用户通过按BACK键回退一项fragment事务（往后导航）。</p>\n<p>当你添加一个fragment作为某个activity布局的一部分时，它就存在于这个activity视图体系内部的ViewGroup之中，并且定义了它自己的视图布局。你可以通过在activity布局文件中声明fragment，用<fragment>元素把fragment插入到activity的布局中，或者是用应用程序源码将它添加到一个存在的ViewGroup中。然而，fragment并不是一个定要作为activity布局的一部分；fragment也可以为activity隐身工作。   </p>\n<h3 id=\"二-Fragment的继承结构\"><a href=\"#二-Fragment的继承结构\" class=\"headerlink\" title=\"二 Fragment的继承结构\"></a>二 Fragment的继承结构</h3><p>继承 Object<br>实现 ComponentCallbacks2 View.OnCreateContextMenuListener </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.lang.Object</div><div class=\"line\">   ↳ \tandroid.app.Fragment</div></pre></td></tr></table></figure>\n<p>直接子类：<br>DialogFragment, ListFragment, PreferenceFragment, WebViewFragment      </p>\n<h3 id=\"三-Fragment设计哲学\"><a href=\"#三-Fragment设计哲学\" class=\"headerlink\" title=\"三 Fragment设计哲学\"></a>三 Fragment设计哲学</h3><p>Fragment被设计出来主要为了适应平板等大屏幕移动设备。有了fragment，你可以不必去管理视图体系的复杂变化。通过将activity的布局分割成若干个fragment，可以在运行时编辑activity的呈现，并且那些变化会被保存在由activity管理的后台栈里面。<br>如下图所示，一个Activity中的两个Fragment分别在手机和平板的显示情况：<br><img src=\"/2017/02/27/android基础之Fragments/Fragment显示图.png\" alt=\"Fragment显示图\" title=\"Fragment显示图\">     </p>\n<h3 id=\"四-Fragment的生命周期\"><a href=\"#四-Fragment的生命周期\" class=\"headerlink\" title=\"四 Fragment的生命周期\"></a>四 Fragment的生命周期</h3><p>下面是Activity的生命周期：<br><img src=\"/2017/02/27/android基础之Fragments/Fragment生命周期图.png\" alt=\"Fragment生命周期图\" title=\"Fragment生命周期图\"><br>管理fragment生命周期与管理activity生命周期很相像。像activity一样，fragment也有三种状态：    </p>\n<ul>\n<li>Resumed<br>fragment在运行中的activity可见。    </li>\n<li>Paused<br>另一个activity处于前台且得到焦点，但是这个fragment所在的activity仍然可见（前台activity部分透明，或者没有覆盖全屏）。   </li>\n<li>Stopped<br>fragment不可见。要么宿主activity已经停止，要么fragment已经从activity上移除，但已被添加到后台栈中。一个停止的fragment仍然活着（所有状态和成员信息仍然由系统保留着）。但是，它对用户来讲已经不再可见，并且如果activity被杀掉，它也将被杀掉。<br>同activity类似的还有，你也可以用Bundle保存fragment状态，万一activity的进程被杀掉了，并且在activity被重新创建时，你需要恢复fragment状态。在回调执行fragment的onSaveInstanceState()期间可以保存状态，在onCreate()，onCreateView()，或者onActvityCreate()中可以恢复状态。<br>在生命周期方面,activity与fragment之间一个很重要的不同，就是在各自的后台栈中是如何存储的。当activity停止时，默认情况下，activity被安置在由系统管理的activity后台栈中（因此用户可以按BACK键回退导航，就像在Tasks和后台栈中讨论的那样）。但是，仅当你在一个事务被移除时，通过显式调用addToBackStack()请求保存的实例，该fragment才被置于由宿主activity管理的后台栈。<br>除此之外，管理fragment的生命周期与管理activity的生命周期非常相似。所以，管理activity生命周期的实践同样也适用于fragment。你需要了解的，仅仅是activity的生命周期如何影响fragment的的。    </li>\n</ul>\n<h3 id=\"五-与Activity生命周期协调合作\"><a href=\"#五-与Activity生命周期协调合作\" class=\"headerlink\" title=\"五 与Activity生命周期协调合作\"></a>五 与Activity生命周期协调合作</h3><p>下面是Activity与Fragment生命周期图对比：<br><img src=\"/2017/02/27/android基础之Fragments/Fragment与Activity生命周期对比.png\" alt=\"Fragment与Activity生命周期对比\" title=\"Fragment与Activity生命周期对比\"><br>fragment所生存的activity生命周期直接影响着fragment的生命周期，由此针对activity的每一个生命周期回调都会引发一个fragment类似的回调。例如，当activity接收到onPause()时，这个activity之中的每个fragment都会接收到onPause()。<br>Fragment有一些额外的生命周期回调方法，然而，为了处理像是创建和销毁fragment界面，它与activity进行独特的交互。这些额外的回调方法是：     </p>\n<ul>\n<li>onAttach()<br>当fragment被绑定到activity时调用（Activity会被传入）。 </li>\n<li>onCreateView()<br>创建与fragment相关的视图体系时被调用。     </li>\n<li>onActivityCreated()<br>当activity的onCreate()函数返回时被调用。     </li>\n<li>onDestroyView()<br>当与fragment关联的视图体系正被移除时被调用。     </li>\n<li>onDetach()<br>当fragment正与activity解除关联时被调用。      </li>\n</ul>\n<p>fragment的生命周期流程实际上是受其宿主activity影响，如上图所示。在这张图中，可以看到activity的每个连续状态是如何决定fragment可能接收到哪个回调函数的。例如，当activity接收到它的onCreate()回调时，activity之中的fragment接收到的仅仅是onActivityCreated()回调。</p>\n<p>一旦activity处于resumed状态，则可以在activity中自由的添加或者移除fragment。因此，只有当activity处于resumed状态时，fragment的生命周期才可以独立变化。</p>\n<p>然而，当activity离开恢复状态时，fragment再一次被activity推入它的生命周期中。</p>\n<h3 id=\"六-向Fragment中添加用户界面\"><a href=\"#六-向Fragment中添加用户界面\" class=\"headerlink\" title=\"六 向Fragment中添加用户界面\"></a>六 向Fragment中添加用户界面</h3><p>fragment常被用作activity用户界面的一部分，并且将本身的布局构建到activity中去。<br>为了给fragment提供一个布局，你必须实现onCreateView()回调函数，在绘制fragment布局时Android系统会调用它。实现这个函数时需要返回fragment所属的根View。     </p>\n<blockquote>\n<p>注意：如果你的fragment时ListFragment的子类，默认实现从onCreateView()返回一个ListView，所以你不需要实现它。    </p>\n</blockquote>\n<p>为了从onCreateView()返回一个布局，你可以从layout resource定义的XML文件inflate它。为了便于你这样做，onCreateView()提供一个LayoutInflater对象。<br>例如，下面是一个fragment子类，它的布局从example_fragment.xml载入的：    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">onCreateView</span><span class=\"params\">(LayoutInflater inflater, ViewGroup container,</div><div class=\"line\">\t\t\t\t\t\t\t\t Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// Inflate the layout for this fragment</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> inflater.inflate(R.layout.example_fragment, container, <span class=\"keyword\">false</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>传入onCreateView()的参数container 是你的frament布局将要被插入的父ViewGroup（来自activity的布局）。如果fragment处于resumed状态（恢复状态在操纵fragment生命周期一节中将作更多讨论），参数savedInstanceState是属于Bundle类，它提供了fragment之前实例的相关数据。     </p>\n<p>inflate()函数需要以下三个参数：     </p>\n<ul>\n<li>要inflate的布局的资源ID。      </li>\n<li>被inflate的布局的父ViewGroup。传入container很重要，这是为了让系统将布局参数应用到被inflate的布局的根view中去，由其将要嵌入的父view指定。    </li>\n<li>一个布尔值，表明在inflate期间被infalte的布局是否应该附上ViewGroup（第二个参数）。（在这个例子中传入的是false，因为系统已经将被inflate的布局插入到容器中（container）——传入true会在最终的布局里创建一个多余的ViewGroup。）       </li>\n</ul>\n<p>现在你已经知道了如何创建一个有布局的fragment。下一步，则需要将fragment添加到activity中。      </p>\n<h3 id=\"七-将Fragment添加到Activity中\"><a href=\"#七-将Fragment添加到Activity中\" class=\"headerlink\" title=\"七 将Fragment添加到Activity中\"></a>七 将Fragment添加到Activity中</h3><p>通常，fragment构建了其宿主activity的部分界面，它被作为activity全部视图层次体系的一部分被嵌入进去。在acitivity布局中添加fragment有两种方法：     </p>\n<h5 id=\"在activity的布局文件里声明fragment\"><a href=\"#在activity的布局文件里声明fragment\" class=\"headerlink\" title=\"在activity的布局文件里声明fragment\"></a>在activity的布局文件里声明fragment</h5><p>像这样，你可以像为view一样为fragment指定布局属性。例如，下面含有两个fragment的布局文件：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\">\t&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"</div><div class=\"line\">\t\tandroid:orientation=\"horizontal\"</div><div class=\"line\">\t\tandroid:layout_width=\"match_parent\"</div><div class=\"line\">\t\tandroid:layout_height=\"match_parent\"&gt;</div><div class=\"line\">\t\t&lt;fragment android:name=\"com.example.news.ArticleListFragment\"</div><div class=\"line\">\t\t\t\tandroid:id=\"@+id/list\"</div><div class=\"line\">\t\t\t\tandroid:layout_weight=\"1\"</div><div class=\"line\">\t\t\t\tandroid:layout_width=\"0dp\"</div><div class=\"line\">\t\t\t\tandroid:layout_height=\"match_parent\" /&gt;</div><div class=\"line\">\t\t&lt;fragment android:name=\"com.example.news.ArticleReaderFragment\"</div><div class=\"line\">\t\t\t\tandroid:id=\"@+id/viewer\"</div><div class=\"line\">\t\t\t\tandroid:layout_weight=\"2\"</div><div class=\"line\">\t\t\t\tandroid:layout_width=\"0dp\"</div><div class=\"line\">\t\t\t\tandroid:layout_height=\"match_parent\" /&gt;</div><div class=\"line\">\t&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>\n<p><fragment>中的android:name 属性指定了布局中实例化的Fragment类。</p>\n<p>当系统创建activity布局时，它实例化了布局文件中指定的每一个fragment，并为它们调用onCreateView()函数，以获取每一个fragment的布局。系统直接在<fragment>元素的位置插入fragment返回的View。</p>\n<blockquote>\n<p>注意：每个fragment都需要一个唯一的标识，如果重启activity，系统可用来恢复fragment（并且可用来捕捉fragment的事务处理，例如移除）。为fragment提供ID有三种方法：   </p>\n<ul>\n<li>用android:id属性提供一个唯一的标识。   </li>\n<li>用android:tag属性提供一个唯一的字符串。   </li>\n<li>如果上述两个属性都没有，系统会使用其容器视图（view）的ID。 </li>\n</ul>\n</blockquote>\n<h5 id=\"通过java代码将fragment添加到已存在的ViewGroup中\"><a href=\"#通过java代码将fragment添加到已存在的ViewGroup中\" class=\"headerlink\" title=\"通过java代码将fragment添加到已存在的ViewGroup中\"></a>通过java代码将fragment添加到已存在的ViewGroup中</h5><p>在activity运行的任何时候，你都可以将fragment添加到activity布局中。你仅需要简单指定用来放置fragment的ViewGroup。</p>\n<p>你应当使用FragmentTransaction的API来对activity中的fragment进行操作（例如添加，移除，或者替换fragment）。你可以像下面这样从Activity中取得FragmentTransaction的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">FragmentManager fragmentManager = getFragmentManager()</div><div class=\"line\">\tFragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</div></pre></td></tr></table></figure>\n<p>可以用add()函数添加fragment，并指定要添加的fragment以及要将其插入到哪个视图（view）之中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ExampleFragment fragment = <span class=\"keyword\">new</span> ExampleFragment();</div><div class=\"line\">\tfragmentTransaction.add(R.id.fragment_container, fragment);</div><div class=\"line\">\tfragmentTransaction.commit();</div></pre></td></tr></table></figure>\n<p>传入add()函数的第一个参数是fragment被放置的ViewGroup，它由资源ID（resource ID）指定，第二个参数就是要添加的fragment。一旦通过FragmentTransaction 做了更改，都应当使用commit()使变化生效。</p>\n<h5 id=\"添加无界面的Fragment\"><a href=\"#添加无界面的Fragment\" class=\"headerlink\" title=\"添加无界面的Fragment\"></a>添加无界面的Fragment</h5><p>上面的例子是如何将fragment添加到activity中去，目的是提供一个用户界面。然而，也可以使用fragment为activity提供后台动作，却不呈现多余的用户界面。</p>\n<p>想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。</p>\n<p>想要添加没有界面的fragment ，可以使用add(Fragment, String)（为fragment提供一个唯一的字符串“tag”，而不是视图（view）ID）。这样添加了fragment，但是，因为还没有关联到activity布局中的视图（view） ，收不到onCreateView()的调用。所以不需要实现这个方法。  </p>\n<h3 id=\"八-Fragment事务后台栈\"><a href=\"#八-Fragment事务后台栈\" class=\"headerlink\" title=\"八 Fragment事务后台栈\"></a>八 Fragment事务后台栈</h3><p>在activity中使用fragment的一大特点是具有添加、删除、替换，和执行其它动作的能力，以响应用户的互动。提交给activity的每一系列变化被称为事务，并且可以用FragmentTransaction 中的APIs处理。你也可以将每一个事务保存在由activity管理的后台栈中，并且允许用户导航回退fragment变更（类似于activity的导航回退）。  </p>\n<p>你可以从FragmentManager中获取FragmentTransaction实例，像这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">FragmentManager fragmentManager = getFragmentManager();</div><div class=\"line\"> FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</div></pre></td></tr></table></figure>\n<p>每项事务是在同一时间内要执行的一系列的变更。你可以为一个给定的事务用相关方法设置想要执行的所有变化，例如add()，remove()，和replace()。然后，用commit()将事务提交给activity。然而，在调用commit()之前，为了将事务添加到fragment事务后台栈中，你可能会想调用addToBackStatck()。这个后台栈由activity管理，并且允许用户通过按BACK键回退到前一个fragment状态。<br>举个例子，下面的代码是如何使用另一个fragment代替一个fragment，并且将之前的状态保留在后台栈中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Create new fragment and transaction</span></div><div class=\"line\"> Fragment newFragment = <span class=\"keyword\">new</span> ExampleFragment();</div><div class=\"line\"> FragmentTransaction transaction = getFragmentManager().beginTransaction();</div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">// Replace whatever is in the fragment_container view with this fragment,</span></div><div class=\"line\"> <span class=\"comment\">// and add the transaction to the back stack</span></div><div class=\"line\"> transaction.replace(R.id.fragment_container, newFragment);</div><div class=\"line\"> transaction.addToBackStack(<span class=\"keyword\">null</span>);</div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">// Commit the transaction</span></div><div class=\"line\"> transaction.commit();</div></pre></td></tr></table></figure>\n<p>在这个例子中，newFragment替换了当前在布局容器中用R.id.fragment_container标识的所有的fragment（如果有的话），替代的事务被保存在后台栈中，因此用户可以回退该事务，可通过按BACK键还原之前的fragment。如果添加多个变更事务（例如另一个add()或者remove()）并调用addToBackStack()，那么在调用commit()之前的所有应用的变更被作为一个单独的事务添加到后台栈中，并且BACK键可以将它们一起回退。</p>\n<p>将变更添加到FragmentTransaction中的顺序注意以下两点：     </p>\n<ul>\n<li>必须要在最后调用commit()   </li>\n<li>如果你正将多个fragment添加到同一个容器中，那么添加顺序决定了它们在视图层次（view hierarchy）里显示的顺序。 </li>\n</ul>\n<p>在执行删除fragment事务时，如果没有调用addToBackStack()，那么事务一提交fragment就会被销毁，而且用户也无法回退它。然而，当移除一个fragment时，如果调用了addToBackStack()，那么之后fragment会被停止，如果用户回退，它将被恢复过来。     </p>\n<blockquote>\n<p>提示：对于每一个fragment事务，在提交之前通过调用setTransition()来应用一系列事务动作。     </p>\n</blockquote>\n<p>调用commit()并不立刻执行事务，相反，而是采取预约方式，一旦activity的界面线程（主线程）准备好便可运行起来。然而，如果有必要的话，你可以从界面线程调用executePendingTransations()立即执行由commit()提交的事务。但这样做，通常是没有必要的，除非其它线程的工作依赖与该项事务。</p>\n<blockquote>\n<p>警告：只能在activity保存状态（当用户离开activity时）之前用commit()提交事务。如果你尝试在那时之后提交，会抛出一个异常。这是因为如果activity需要被恢复，提交后的状态会被丢失。对于这类丢失提交的情况，可使用commitAllowingStateLoss() </p>\n</blockquote>\n<h3 id=\"九-与Activity交互\"><a href=\"#九-与Activity交互\" class=\"headerlink\" title=\"九 与Activity交互\"></a>九 与Activity交互</h3><h5 id=\"1-Fragment可以得到宿主Activity的引用\"><a href=\"#1-Fragment可以得到宿主Activity的引用\" class=\"headerlink\" title=\"1.Fragment可以得到宿主Activity的引用\"></a>1.Fragment可以得到宿主Activity的引用</h5><p>尽管Fragment被实现为一个对象，它独立于Activity并可以在多个Activity中使用，一个给定的fragment实例直接被捆绑在包含它的Activity中。特别是，fragment可以通过getActivity()函数访问Activity，并且很容易的执行类似于查找activity布局中的视图的任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">View listView = getActivity().findViewById(R.id.list);</div></pre></td></tr></table></figure>\n<h5 id=\"2-Activity获取Fragment的引用\"><a href=\"#2-Activity获取Fragment的引用\" class=\"headerlink\" title=\"2.Activity获取Fragment的引用\"></a>2.Activity获取Fragment的引用</h5><p>同样的，activity能够调用fragment的函数findFragmentById()或者findFragmentByTag()，从FragmentManager中获取Fragment的索引，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);</div></pre></td></tr></table></figure>\n<h5 id=\"3-创建Activity时间回调函数\"><a href=\"#3-创建Activity时间回调函数\" class=\"headerlink\" title=\"3.创建Activity时间回调函数\"></a>3.创建Activity时间回调函数</h5><p>在一些情况下，你可能需要fragment与activity共享事件。这样做的一个好方法是在fragment内部定义一个回调接口，并需要宿主activity实现它。当activity通过接口接收到回调时，可以在必要时与布局中的其它fragment共享信息。<br>举个例子，如果新闻应用的actvity中有两个fragment——一个显示文章列表（fragment A），另一个显示一篇文章（fragment B）——然后fragment A 必须要告诉activity列表项何时被选种，这样，activity可以通知fragment B显示这篇文章。这种情况下，在fragment A内部声明接口OnArticleSelectedListener：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentA</span> <span class=\"keyword\">extends</span> <span class=\"title\">ListFragment</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"comment\">// Container Activity must implement this interface</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnArticleSelectedListener</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onArticleSelected</span><span class=\"params\">(Uri articleUri)</span></span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后fragment的宿主activity实现了OnArticleSelectedListener接口，并且重写onArticleSelected()以通知fragment B来自于fragment A的事件。为了确保宿主activity实现了这个接口，fragment A的onAttach()回调函数（当添加fragment到activity中时系统会调用它）通过作为参数传入onAttach()的activity的类型转换来实例化一个OnArticleSelectedListener实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentA</span> <span class=\"keyword\">extends</span> <span class=\"title\">ListFragment</span> </span>&#123;</div><div class=\"line\">    OnArticleSelectedListener mListener;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAttach</span><span class=\"params\">(Activity activity)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onAttach(activity);</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            mListener = (OnArticleSelectedListener) activity;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassCastException e) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassCastException(activity.toString() + <span class=\"string\">\" must implement OnArticleSelectedListener\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果activity没有实现这个接口，那么fragment会抛出一个ClassCaseException异常。一旦成功，mListener成员会保留一个activity的OnArticleSelectedListener实现的引用，由此fragment A可以通过调用由OnArticleSelectedListener接口定义的方法与activity共享事件。例如，如果fragment A是ListFragment的子类，每次用户点击列表项时，系统都会调用fragment的onListItemClick()事件，然后fragment调用onArticleSelected()来与activity共享事件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentA</span> <span class=\"keyword\">extends</span> <span class=\"title\">ListFragment</span> </span>&#123;</div><div class=\"line\">    OnArticleSelectedListener mListener;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onListItemClick</span><span class=\"params\">(ListView l, View v, <span class=\"keyword\">int</span> position, <span class=\"keyword\">long</span> id)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Append the clicked item's row ID with the content provider Uri</span></div><div class=\"line\">        Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);</div><div class=\"line\">        <span class=\"comment\">// Send the event and Uri to the host activity</span></div><div class=\"line\">        mListener.onArticleSelected(noteUri);</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>传递给onListItemClick()的参数id是点击的列表项行id，activity（或者其它fragment）用以从应用的ContentProvider获取文章。</p>\n<p>#####　添加items到Action Bar</p>\n<p>你的fragments可以通过实现onCreateOptionsMenu()来构建菜单项到activity的Options Menu（因此Action Bar也一样）。为了使用这个方法接收到调用，不管怎样，你必须在onCreate()期间调用setHasOptionsMenu()，来指明想要添加项目到Options Menu的那个fragment（否则，fragment将接收不到onCreateOptionsMenu()的调用）。<br>任何想要在fragment中的Options Menu添加的项目都追加到已有的菜单项后面。当菜单项被选中时，fragment也会接收到对onOptionsItemSelected()的回调。<br>你也可以通过调用registerForContextMenu()在fragment布局中注册一个view以提供一个context menu。当用户打开context menu时，fragment接收到对onCreateContextMenu()的回调。当用户选中一个项目时，fragment接收到对onContextItemSelected()的回调。</p>\n<blockquote>\n<p>注意：尽管你的fragment会接收到为添加到每个菜单项被选择菜单项的回调，但当用户选择一个菜单项时，activity会首先接收到对应的回调。如果activity的选择菜单项回调的实现没有处理被选中的项目，那么该事件被传递给fragment的回调。这同样适用于Options Menu和context menu。</p>\n</blockquote>\n<h3 id=\"十-总结\"><a href=\"#十-总结\" class=\"headerlink\" title=\"十 总结\"></a>十 总结</h3>"},{"title":"android基础之Handler与AsycTask","date":"2017-02-27T06:47:53.000Z","_content":"\n### 一 概述\n\nHandler是Android中用于线程间通信的机制。\n\n当程序第一次启动的时候，Android会同时启动一条主线程（ Main Thread）来负责处理与UI相关的事件，我们叫做UI线程。Android的UI操作并不是线程安全的（出于性能优化考虑），意味着如果多个线程并发操作UI线程，可能导致线程安全问题。为了解决Android应用多线程问题—Android平台只允许UI线程修改Activity里的UI，这样如果在主线程中执行耗时操作就会导致UI阻塞，若超过5秒就会造成ANR。\n\n因此我们需要另开线程来处理这些耗时操作，而处理的结果我们可能需要传给主线程用于UI更新，这是就需要线程间的通信。Handler即是Android中用于线程间通信的机制，现在市场一些android的线程通信框架基本上都是基于Handler实现的，如下文将要介绍的已经置于android源码中AsycTask，和现在比较流行的EventBus。\n\n### 二 Handler的主要作用\n\n通过翻看的Handler的源码可知，Handler主要有两个作用。\n\n##### 1.线程延时\n\nHandler中内置了线程延时的方法：\n\n- final boolean postAtTime(Runnable r, long uptimeMillis)\n- final boolean postDelayed(Runnable r, long delayMillis)\n\n##### 2.线程通信\n\n主要步骤：\n\n- 在新启动的线程中发送消息     \n使用Handler对象的sendMessage()方法或者SendEmptyMessage()方法发送消息。   \n\n- 在主线程中获取处理消息   \n重写Handler类中处理消息的方法（void handleMessage(Message msg)），当新启动的线程发送消息时，消息发送到与之关联的MessageQueue。而Hanlder不断地从MessageQueue中获取并处理消息。\n\n### 三 Handler与UI线程通信示例\n\n- 首先要进行Handler 申明，复写handleMessage方法( 放在主线程中)\n\n```java\nprivate Handler handler = new Handler() {\n\n        @Override\n        public void handleMessage(Message msg) {\n            // TODO 接收消息并且去更新UI线程上的控件内容\n            if (msg.what == UPDATE) {\n                // 更新界面上的textview\n                tv.setText(String.valueOf(msg.obj));\n            }\n            super.handleMessage(msg);\n        }\n    };\n```\n\n- 子线程发送Message给ui线程表示自己任务已经执行完成，主线程可以做相应的操作了。\n\n```java\nnew Thread() {\n            @Override\n            public void run() {\n                // TODO 子线程中通过handler发送消息给handler接收，由handler去更新TextView的值\n                try {\n                       //do something\n\n                        Message msg = new Message();\n                        msg.what = UPDATE;                  \n                        msg.obj = \"更新后的值\" ;\n                        handler.sendMessage(msg);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }.start();\n```\n\n### 四 Handler原理分析\n\n##### 1.Handler的构造函数\n\n1. public　Handler() \n2. public　Handler(Callbackcallback)\n3. public　Handler(Looperlooper)\n4. public　Handler(Looperlooper, Callbackcallback) \n\n\n- 第1个和第2个构造函数都没有传递Looper，这两个构造函数都将通过调用Looper.myLooper()获取当前线程绑定的Looper对象，然后将该Looper对象保存到名为mLooper的成员字段中。 　   \n下面来看1,2个函数源码：\n\n```java\n    public Handler() {\n        this(null, false);\n    }\n\n    public Handler(Callback callback) {\n        this(callback, false);\n    }\n\n    //他们会调用Handler的内部构造方法\n\n    public Handler(Callback callback, boolean async) {\n        if (FIND_POTENTIAL_LEAKS) {\n      final Class<? extends Handler> klass = getClass();\n      if ((klass.isAnonymousClass() ||klass.isMemberClass()\n         || klass.isLocalClass()) &&\n                    (klass.getModifiers() & Modifier.STATIC) == 0) {\n                Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +\n                    klass.getCanonicalName());\n            }\n        }\n     /************************************\n        mLooper = Looper.myLooper();\n        if (mLooper == null) {\n            throw new RuntimeException(\n                \"Can't create handler inside thread that has not called Looper.prepare()\");\n        }\n        mQueue = mLooper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n```\n\n通过Looper.myLooper()获取了当前线程保存的Looper实例，又通过这个Looper实例获取了其中保存的MessageQueue（消息队列）。每个Handler 对应一个Looper对象，产生一个MessageQueue\n\n- 第3个和第4个构造函数传递了Looper对象，这两个构造函数会将该Looper保存到名为mLooper的成员字段中。 　   \n下面来看3、4个函数源码： \n\n```java\n    public Handler(Looper looper) {\n        this(looper, null, false);\n    }　\n\n    public Handler(Looper looper, Callback callback) {\n        this(looper, callback, false);\n    }\n   //他们会调用Handler的内部构造方法\n\n    public Handler(Looper looper, Callback callback, boolean async) {\n        mLooper = looper;\n        mQueue = looper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n```\n\n- 第2个和第4个构造函数还传递了Callback对象，Callback是Handler中的内部接口，需要实现其内部的handleMessage方法，Callback代码如下:\n\n```java\n     public interface Callback {\n         public boolean More ...handleMessage(Message msg);\n     }\n```\n\nHandler.Callback是用来处理Message的一种手段，如果没有传递该参数，那么就应该重写Handler的handleMessage方法，也就是说为了使得Handler能够处理Message，我们有两种办法： 　　 \n\n　\n1. 向Hanlder的构造函数传入一个Handler.Callback对象，并实现Handler.Callback的handleMessage方法  　    \n2. 无需向Hanlder的构造函数传入Handler.Callback对象，但是需要重写Handler本身的handleMessage方法 　\n\n也就是说无论哪种方式，我们都得通过某种方式实现handleMessage方法，这点与Java中对Thread的设计有异曲同工之处。\n\n##### Handler发送消息的几个方法的源码\n\n```java\n   public final boolean sendMessage(Message msg)\n    {\n        return sendMessageDelayed(msg, 0);\n    }\n\n   public final boolean sendEmptyMessageDelayed(int what, long delayMillis) {\n        Message msg = Message.obtain();\n        msg.what = what;\n        return sendMessageDelayed(msg, delayMillis);\n    }\n\n public final boolean sendMessageDelayed(Message msg, long delayMillis)\n    {\n        if (delayMillis < 0) {\n            delayMillis = 0;\n        }\n        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n    }\n\n public boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        if (queue == null) {\n            RuntimeException e = new RuntimeException(\n                    this + \" sendMessageAtTime() called with no mQueue\");\n            Log.w(\"Looper\", e.getMessage(), e);\n            return false;\n        }\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n\n```\n\n我们可以看出他们最后都调用了sendMessageAtTime（），然后返回了enqueueMessage方法，下面看一下此方法源码：\n\n```java\n    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n　　　　　　//把当前的handler作为msg的target属性\n        msg.target = this;\n        if (mAsynchronous) {\n            msg.setAsynchronous(true);\n        }\n        return queue.enqueueMessage(msg, uptimeMillis);\n    }\n```\n\n在该方法中有两件事需要注意： \n\n- msg.target = this   \n该代码将Message的target绑定为当前的Handler\n- queue.enqueueMessage   \n变量queue表示的是Handler所绑定的消息队列MessageQueue，通过调用queue.enqueueMessage(msg, uptimeMillis)我们将Message放入到消息队列中。\n\n### 五 Looper原理分析\n\n我们一般在主线程申明Handler，有时我们需要继承Thread类实现自己的线程功能，当我们在里面申明Handler的时候会报错。其原因是主线程中已经实现了两个重要的Looper方法，下面看一看ActivityThread.java中main方法的源码：\n\n```java\npublic static void main(String[] args) {\n            //......省略\n        Looper.prepareMainLooper();//>\n\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false);\n\n        if (sMainThreadHandler == null) {\n            sMainThreadHandler = thread.getHandler();\n        }\n\n        AsyncTask.init();\n\n        if (false) {\n            Looper.myLooper().setMessageLogging(new\n   LogPrinter(Log.DEBUG, \"ActivityThread\"));\n        }\n\n        Looper.loop();//>\n\n        throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n    }\n}\n```\n\n首先看prepare()方法\n\n```java\n     public static void prepare() {\n         prepare(true);\n     }\n \n     private static void prepare(boolean quitAllowed) {\n　　　　　//证了一个线程中只有一个Looper实例\n         if (sThreadLocal.get() != null) {\n             throw new RuntimeException(\"Only one Looper may be created per thread\");\n         }\n         sThreadLocal.set(new Looper(quitAllowed));\n     }\n```\n\n该方法会调用Looper构造函数同时实例化出MessageQueue和当前thread.\n\n```java\n    private Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    } \n\n    public static MessageQueue myQueue() {\n        return myLooper().mQueue;\n    }\n```\n\nprepare()方法中通过ThreadLocal对象实现Looper实例与线程的绑定。\n\n再看loop()方法\n\n```java\n    public static void loop() {\n        final Looper me = myLooper();\n        if (me == null) {\n            throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n        }\n        final MessageQueue queue = me.mQueue;\n\n        Binder.clearCallingIdentity();\n        final long ident = Binder.clearCallingIdentity();\n\n        for (;;) {\n            Message msg = queue.next(); // might block\n            if (msg == null) {\n               \n                return;\n            }\n\n            Printer logging = me.mLogging;\n            if (logging != null) {\n                logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +\n                        msg.callback + \": \" + msg.what);\n            }\n       //重点****\n            msg.target.dispatchMessage(msg);\n\n            if (logging != null) {\n                logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n            }\n\n            // identity of the thread wasn't corrupted.\n            final long newIdent = Binder.clearCallingIdentity();\n            if (ident != newIdent) {\n                Log.wtf(TAG, \"Thread identity changed from 0x\"\n                        + Long.toHexString(ident) + \" to 0x\"\n                        + Long.toHexString(newIdent) + \" while dispatching to \"\n                        + msg.target.getClass().getName() + \" \"\n                        + msg.callback + \" what=\" + msg.what);\n            }\n\n            msg.recycleUnchecked();\n        }\n    }\n```\n\n首先looper对象不能为空，就是说loop()方法调用必须在prepare()方法的后面。\n\nLooper一直在不断的从消息队列中通过MessageQueue的next方法获取Message，然后通过代码msg.target.dispatchMessage(msg)让该msg所绑定的Handler（Message.target）执行dispatchMessage方法以实现对Message的处理。 \n\nHandler的dispatchMessage的源码如下：\n\n```java\n     public void dispatchMessage(Message msg) {\n         if (msg.callback != null) {\n             handleCallback(msg);\n         } else {\n             if (mCallback != null) {\n                 if (mCallback.handleMessage(msg)) {\n                     return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n\n我们可以看到Handler提供了三种途径处理Message，而且处理有前后优先级之分：首先尝试让postXXX中传递的Runnable执行，其次尝试让Handler构造函数中传入的Callback的handleMessage方法处理，最后才是让Handler自身的handleMessage方法处理Message。\n\n### 六 如何在子线程中使用Handler\n\nHandler本质是从当前的线程中获取到Looper来监听和操作MessageQueue，当其他线程执行完成后回调当前线程。\n\n子线程需要先prepare（）才能获取到Looper的，是因为在子线程只是一个普通的线程，其ThreadLoacl中没有设置过Looper，所以会抛出异常，而在Looper的prepare（）方法中sThreadLocal.set(new Looper())是设置了Looper的。\n\n示例代码：\n\n定义一个类实现Runnable接口或继承Thread类（一般不继承）。\n\n```java\nclass Rub implements Runnable {  \n\n        public Handler myHandler;  \n        // 实现Runnable接口的线程体 \n        @Override  \n        public void run() {  \n\n         /*①、调用Looper的prepare()方法为当前线程创建Looper对象并，\n          创建Looper对象时，它的构造器会自动的创建相对应的MessageQueue*/\n            Looper.prepare();  \n\n            /*.②、创建Handler子类的实例，重写HandleMessage()方法，该方法处理除当前线程以外线程的消息*/\n             myHandler = new Handler() {  \n                @Override  \n                public void handleMessage(Message msg) {  \n                    String ms = \"\";  \n                    if (msg.what == 0x777) {  \n\n                    }  \n                }  \n\n            };  \n            //③、调用Looper的loop()方法来启动Looper让消息队列转动起来\n            Looper.loop();  \n        }\n    }\n```\n\n注意分成三步：\n\n- 调用Looper的prepare()方法为当前线程创建Looper对象，创建Looper对象时，它的构造器会创建与之配套的MessageQueue。 　\n- 有了Looper之后，创建Handler子类实例，重写HanderMessage()方法，该方法负责处理来自于其他线程的消息。\n- 调用Looper的looper()方法启动Looper。然后使用这个handler实例在任何其他线程中发送消息，最终处理消息的代码都会在你创建Handler实例的线程中运行。\n\n### 七 Handler总结\n\n- Handler：     \n发送和处理消息，它把消息发送给Looper管理的MessageQueue，并负责处理Looper分发给它的消息。\n      \n- Message：    \nHandler接收和处理的消息对象。\n\n- Looper：     \n每个线程只有一个Looper，它负责管理对应的MessageQueue，会不断地从MessageQueue取出消息，并将消息分给对应的Hanlder处理。主线程中，系统已经初始化了一个Looper对象，因此可以直接创建Handler即可，就可以通过Handler来发送消息、处理消息。若是在子线程，必须手动创建一个Looper对象，并启动它，调用Looper.prepare()方法。\n\n- prapare()：    \n保证每个线程最多只有一个Looper对象。\n\n- looper()：\n启动Looper，使用一个死循环不断取出MessageQueue中的消息，并将取出的消息分给对应的Handler进行处理。 　\n\n- MessageQueue：    \n由Looper负责管理，它采用先进先出的方式来管理Message。Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue想关联。Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。\n\n### 八 Android中另一个线程通信机制AsycTask\n\n##### 1.AsycTask简介\n\nAsycTask是Android中另一个处理异步任务的机制，我们上面说了可以用Handler来处理异步任务，但如果耗时的操作太多，那么我们需要开启太多的子线程，这就会给系统带来巨大的负担，随之也会带来性能方面的问题。在这种情况下我们就可以考虑使用类AsyncTask来异步执行任务，不需要子线程和handler，就可以完成异步操作和刷新UI。\n\nAsyncTask主要有二个部分：一个是与主线程的交互，另一个就是线程的管理调度。虽然可能多个AsyncTask的子类的实例，但是AsyncTask的内部Handler和ThreadPoolExecutor都是进程范围内共享的，其都是static的（所以AsycTask是串行的，不支持并发），也即属于类的，类的属性的作用范围是CLASSPATH，因为一个进程一个VM，所以是AsyncTask控制着进程范围内所有的子类实例。AsyncTask内部会创建一个进程作用域的线程池来管理要运行的任务，也就就是说当你调用了AsyncTask的execute()方法后，AsyncTask会把任务交给线程池，由线程池来管理创建Thread和运行Therad。\n\nAndroid的AsyncTask比Handler更轻量级一些（只是代码上轻量一些，而实际上要比handler更耗资源），适用于简单的异步处理。\n\n注意：不要随意使用AsyncTask,除非你必须要与UI线程交互.默认情况下使用Thread即可,要注意需要将线程优先级调低.AsyncTask适合处理短时间的操作,长时间的操作,比如下载一个很大的视频,这就需要你使用自己的线程来下载,不管是断点下载还是其它的.\n\n##### 2.AsycTask使用步骤\n\nAsyncTask对线程间的通讯做了包装，使后台线程和UI线程可以简易通讯。后台线程执行异步任务，将result告知UI线程。\n\n使用AsycTask分为两步：\n\n- 继承AsyncTask类实现自己的类    \n\n```java\npublic abstract class AsyncTask<Params, Progress, Result> {\n\n    /* Params: 输入参数，对应excute()方法中传递的参数。如果不需要传递参数，则直接设为void即可。\n\n    ** Progress：后台任务执行的百分比\n\n    ** Result：返回值类型，和doInBackground（）方法的返回值类型保持一致。*/\n}\n```\n\n- 复写方法\n\n最少要重写以下这两个方法：\n\n**a.**doInBackground(Params…)      \n在子线程（其他方法都在主线程执行）中执行比较耗时的操作，不能更新ＵＩ，可以在该方法中调用publishProgress(Progress…)来更新任务的进度。Progress方法是AsycTask中一个final方法只能调用不能重写。\n\n**b.**onPostExecute(Result)     \n使用在doInBackground 得到的结果处理操作UI， 在主线程执行，任务执行的结果作为此方法的参数返回。\n\n有时根据需求还要实现以下三个方法：\n\n**c.**onProgressUpdate(Progress…)     \n可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。\n\n**d.**onPreExecute()     \n这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。  \n\n**e.**onCancelled()    \n用户调用取消时，要做的操作\n\n##### 3.AsycTask使用示例\n\n按照上面的步骤定义自己的异步类：\n\n```java\npublic class MyTask extends AsyncTask<String, Integer, String> {  \n    //执行的第一个方法用于在执行后台任务前做一些UI操作  \n    @Override  \n    protected void onPreExecute() {  \n\n    }  \n\n    //第二个执行方法,在onPreExecute()后执行，用于后台任务,不可在此方法内修改UI\n    @Override  \n    protected String doInBackground(String... params) {  \n         //处理耗时操作\n        return \"后台任务执行完毕\";  \n    }  \n\n   /*这个函数在doInBackground调用publishProgress(int i)时触发，虽然调用时只有一个参数  \n    但是这里取到的是一个数组,所以要用progesss[0]来取值  \n    第n个参数就用progress[n]来取值   */\n    @Override  \n    protected void onProgressUpdate(Integer... progresses) {  \n        //\"loading...\" + progresses[0] + \"%\"\n        super.onProgressUpdate(progress);  \n    }  \n\n    /*doInBackground返回时触发，换句话说，就是doInBackground执行完后触发  \n    这里的result就是上面doInBackground执行后的返回值，所以这里是\"后台任务执行完毕\"  */\n    @Override  \n    protected void onPostExecute(String result) { \n\n    }  \n\n    //onCancelled方法用于在取消执行中的任务时更改UI  \n    @Override  \n    protected void onCancelled() {  \n\n    }  \n}\n```\n\n在主线程申明该类的对象，调用对象的execute（）函数开始执行。\n\n```java\nMyTask ｔ= new MyTask();\nt.execute();//这里没有参数\n```\n\n##### 4.使用AsyncTask需要注意的地方 \n\n- AsnycTask内部的Handler需要和主线程交互，所以AsyncTask的实例必须在UI线程中创建\n\n- AsyncTaskResult的doInBackground(mParams)方法执行异步任务运行在子线程中，其他方法运行在主线程中，可以操作UI组件。\n\n- 一个AsyncTask任务只能被执行一次。\n\n- 运行中可以随时调用AsnycTask对象的cancel(boolean)方法取消任务，如果成功，调用isCancelled()会返回true，并且不会执行 onPostExecute() 方法了，而是执行 onCancelled() 方法。\n\n- 对于想要立即开始执行的异步任务，要么直接使用Thread，要么单独创建线程池提供给AsyncTask。默认的AsyncTask不一定会立即执行你的任务，除非你提供给他一个单独的线程池。如果不与主线程交互，直接创建一个Thread就可以了。","source":"_posts/android基础之Handler与AsycTask.md","raw":"---\ntitle: android基础之Handler与AsycTask\ndate: 2017-02-27 14:47:53\ncategories: android\ntags:\n- android\n- java\n- Handler\n- AsycTask\n---\n\n### 一 概述\n\nHandler是Android中用于线程间通信的机制。\n\n当程序第一次启动的时候，Android会同时启动一条主线程（ Main Thread）来负责处理与UI相关的事件，我们叫做UI线程。Android的UI操作并不是线程安全的（出于性能优化考虑），意味着如果多个线程并发操作UI线程，可能导致线程安全问题。为了解决Android应用多线程问题—Android平台只允许UI线程修改Activity里的UI，这样如果在主线程中执行耗时操作就会导致UI阻塞，若超过5秒就会造成ANR。\n\n因此我们需要另开线程来处理这些耗时操作，而处理的结果我们可能需要传给主线程用于UI更新，这是就需要线程间的通信。Handler即是Android中用于线程间通信的机制，现在市场一些android的线程通信框架基本上都是基于Handler实现的，如下文将要介绍的已经置于android源码中AsycTask，和现在比较流行的EventBus。\n\n### 二 Handler的主要作用\n\n通过翻看的Handler的源码可知，Handler主要有两个作用。\n\n##### 1.线程延时\n\nHandler中内置了线程延时的方法：\n\n- final boolean postAtTime(Runnable r, long uptimeMillis)\n- final boolean postDelayed(Runnable r, long delayMillis)\n\n##### 2.线程通信\n\n主要步骤：\n\n- 在新启动的线程中发送消息     \n使用Handler对象的sendMessage()方法或者SendEmptyMessage()方法发送消息。   \n\n- 在主线程中获取处理消息   \n重写Handler类中处理消息的方法（void handleMessage(Message msg)），当新启动的线程发送消息时，消息发送到与之关联的MessageQueue。而Hanlder不断地从MessageQueue中获取并处理消息。\n\n### 三 Handler与UI线程通信示例\n\n- 首先要进行Handler 申明，复写handleMessage方法( 放在主线程中)\n\n```java\nprivate Handler handler = new Handler() {\n\n        @Override\n        public void handleMessage(Message msg) {\n            // TODO 接收消息并且去更新UI线程上的控件内容\n            if (msg.what == UPDATE) {\n                // 更新界面上的textview\n                tv.setText(String.valueOf(msg.obj));\n            }\n            super.handleMessage(msg);\n        }\n    };\n```\n\n- 子线程发送Message给ui线程表示自己任务已经执行完成，主线程可以做相应的操作了。\n\n```java\nnew Thread() {\n            @Override\n            public void run() {\n                // TODO 子线程中通过handler发送消息给handler接收，由handler去更新TextView的值\n                try {\n                       //do something\n\n                        Message msg = new Message();\n                        msg.what = UPDATE;                  \n                        msg.obj = \"更新后的值\" ;\n                        handler.sendMessage(msg);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }.start();\n```\n\n### 四 Handler原理分析\n\n##### 1.Handler的构造函数\n\n1. public　Handler() \n2. public　Handler(Callbackcallback)\n3. public　Handler(Looperlooper)\n4. public　Handler(Looperlooper, Callbackcallback) \n\n\n- 第1个和第2个构造函数都没有传递Looper，这两个构造函数都将通过调用Looper.myLooper()获取当前线程绑定的Looper对象，然后将该Looper对象保存到名为mLooper的成员字段中。 　   \n下面来看1,2个函数源码：\n\n```java\n    public Handler() {\n        this(null, false);\n    }\n\n    public Handler(Callback callback) {\n        this(callback, false);\n    }\n\n    //他们会调用Handler的内部构造方法\n\n    public Handler(Callback callback, boolean async) {\n        if (FIND_POTENTIAL_LEAKS) {\n      final Class<? extends Handler> klass = getClass();\n      if ((klass.isAnonymousClass() ||klass.isMemberClass()\n         || klass.isLocalClass()) &&\n                    (klass.getModifiers() & Modifier.STATIC) == 0) {\n                Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +\n                    klass.getCanonicalName());\n            }\n        }\n     /************************************\n        mLooper = Looper.myLooper();\n        if (mLooper == null) {\n            throw new RuntimeException(\n                \"Can't create handler inside thread that has not called Looper.prepare()\");\n        }\n        mQueue = mLooper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n```\n\n通过Looper.myLooper()获取了当前线程保存的Looper实例，又通过这个Looper实例获取了其中保存的MessageQueue（消息队列）。每个Handler 对应一个Looper对象，产生一个MessageQueue\n\n- 第3个和第4个构造函数传递了Looper对象，这两个构造函数会将该Looper保存到名为mLooper的成员字段中。 　   \n下面来看3、4个函数源码： \n\n```java\n    public Handler(Looper looper) {\n        this(looper, null, false);\n    }　\n\n    public Handler(Looper looper, Callback callback) {\n        this(looper, callback, false);\n    }\n   //他们会调用Handler的内部构造方法\n\n    public Handler(Looper looper, Callback callback, boolean async) {\n        mLooper = looper;\n        mQueue = looper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n```\n\n- 第2个和第4个构造函数还传递了Callback对象，Callback是Handler中的内部接口，需要实现其内部的handleMessage方法，Callback代码如下:\n\n```java\n     public interface Callback {\n         public boolean More ...handleMessage(Message msg);\n     }\n```\n\nHandler.Callback是用来处理Message的一种手段，如果没有传递该参数，那么就应该重写Handler的handleMessage方法，也就是说为了使得Handler能够处理Message，我们有两种办法： 　　 \n\n　\n1. 向Hanlder的构造函数传入一个Handler.Callback对象，并实现Handler.Callback的handleMessage方法  　    \n2. 无需向Hanlder的构造函数传入Handler.Callback对象，但是需要重写Handler本身的handleMessage方法 　\n\n也就是说无论哪种方式，我们都得通过某种方式实现handleMessage方法，这点与Java中对Thread的设计有异曲同工之处。\n\n##### Handler发送消息的几个方法的源码\n\n```java\n   public final boolean sendMessage(Message msg)\n    {\n        return sendMessageDelayed(msg, 0);\n    }\n\n   public final boolean sendEmptyMessageDelayed(int what, long delayMillis) {\n        Message msg = Message.obtain();\n        msg.what = what;\n        return sendMessageDelayed(msg, delayMillis);\n    }\n\n public final boolean sendMessageDelayed(Message msg, long delayMillis)\n    {\n        if (delayMillis < 0) {\n            delayMillis = 0;\n        }\n        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n    }\n\n public boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        if (queue == null) {\n            RuntimeException e = new RuntimeException(\n                    this + \" sendMessageAtTime() called with no mQueue\");\n            Log.w(\"Looper\", e.getMessage(), e);\n            return false;\n        }\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n\n```\n\n我们可以看出他们最后都调用了sendMessageAtTime（），然后返回了enqueueMessage方法，下面看一下此方法源码：\n\n```java\n    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n　　　　　　//把当前的handler作为msg的target属性\n        msg.target = this;\n        if (mAsynchronous) {\n            msg.setAsynchronous(true);\n        }\n        return queue.enqueueMessage(msg, uptimeMillis);\n    }\n```\n\n在该方法中有两件事需要注意： \n\n- msg.target = this   \n该代码将Message的target绑定为当前的Handler\n- queue.enqueueMessage   \n变量queue表示的是Handler所绑定的消息队列MessageQueue，通过调用queue.enqueueMessage(msg, uptimeMillis)我们将Message放入到消息队列中。\n\n### 五 Looper原理分析\n\n我们一般在主线程申明Handler，有时我们需要继承Thread类实现自己的线程功能，当我们在里面申明Handler的时候会报错。其原因是主线程中已经实现了两个重要的Looper方法，下面看一看ActivityThread.java中main方法的源码：\n\n```java\npublic static void main(String[] args) {\n            //......省略\n        Looper.prepareMainLooper();//>\n\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false);\n\n        if (sMainThreadHandler == null) {\n            sMainThreadHandler = thread.getHandler();\n        }\n\n        AsyncTask.init();\n\n        if (false) {\n            Looper.myLooper().setMessageLogging(new\n   LogPrinter(Log.DEBUG, \"ActivityThread\"));\n        }\n\n        Looper.loop();//>\n\n        throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n    }\n}\n```\n\n首先看prepare()方法\n\n```java\n     public static void prepare() {\n         prepare(true);\n     }\n \n     private static void prepare(boolean quitAllowed) {\n　　　　　//证了一个线程中只有一个Looper实例\n         if (sThreadLocal.get() != null) {\n             throw new RuntimeException(\"Only one Looper may be created per thread\");\n         }\n         sThreadLocal.set(new Looper(quitAllowed));\n     }\n```\n\n该方法会调用Looper构造函数同时实例化出MessageQueue和当前thread.\n\n```java\n    private Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    } \n\n    public static MessageQueue myQueue() {\n        return myLooper().mQueue;\n    }\n```\n\nprepare()方法中通过ThreadLocal对象实现Looper实例与线程的绑定。\n\n再看loop()方法\n\n```java\n    public static void loop() {\n        final Looper me = myLooper();\n        if (me == null) {\n            throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n        }\n        final MessageQueue queue = me.mQueue;\n\n        Binder.clearCallingIdentity();\n        final long ident = Binder.clearCallingIdentity();\n\n        for (;;) {\n            Message msg = queue.next(); // might block\n            if (msg == null) {\n               \n                return;\n            }\n\n            Printer logging = me.mLogging;\n            if (logging != null) {\n                logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +\n                        msg.callback + \": \" + msg.what);\n            }\n       //重点****\n            msg.target.dispatchMessage(msg);\n\n            if (logging != null) {\n                logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n            }\n\n            // identity of the thread wasn't corrupted.\n            final long newIdent = Binder.clearCallingIdentity();\n            if (ident != newIdent) {\n                Log.wtf(TAG, \"Thread identity changed from 0x\"\n                        + Long.toHexString(ident) + \" to 0x\"\n                        + Long.toHexString(newIdent) + \" while dispatching to \"\n                        + msg.target.getClass().getName() + \" \"\n                        + msg.callback + \" what=\" + msg.what);\n            }\n\n            msg.recycleUnchecked();\n        }\n    }\n```\n\n首先looper对象不能为空，就是说loop()方法调用必须在prepare()方法的后面。\n\nLooper一直在不断的从消息队列中通过MessageQueue的next方法获取Message，然后通过代码msg.target.dispatchMessage(msg)让该msg所绑定的Handler（Message.target）执行dispatchMessage方法以实现对Message的处理。 \n\nHandler的dispatchMessage的源码如下：\n\n```java\n     public void dispatchMessage(Message msg) {\n         if (msg.callback != null) {\n             handleCallback(msg);\n         } else {\n             if (mCallback != null) {\n                 if (mCallback.handleMessage(msg)) {\n                     return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n\n我们可以看到Handler提供了三种途径处理Message，而且处理有前后优先级之分：首先尝试让postXXX中传递的Runnable执行，其次尝试让Handler构造函数中传入的Callback的handleMessage方法处理，最后才是让Handler自身的handleMessage方法处理Message。\n\n### 六 如何在子线程中使用Handler\n\nHandler本质是从当前的线程中获取到Looper来监听和操作MessageQueue，当其他线程执行完成后回调当前线程。\n\n子线程需要先prepare（）才能获取到Looper的，是因为在子线程只是一个普通的线程，其ThreadLoacl中没有设置过Looper，所以会抛出异常，而在Looper的prepare（）方法中sThreadLocal.set(new Looper())是设置了Looper的。\n\n示例代码：\n\n定义一个类实现Runnable接口或继承Thread类（一般不继承）。\n\n```java\nclass Rub implements Runnable {  \n\n        public Handler myHandler;  \n        // 实现Runnable接口的线程体 \n        @Override  \n        public void run() {  \n\n         /*①、调用Looper的prepare()方法为当前线程创建Looper对象并，\n          创建Looper对象时，它的构造器会自动的创建相对应的MessageQueue*/\n            Looper.prepare();  \n\n            /*.②、创建Handler子类的实例，重写HandleMessage()方法，该方法处理除当前线程以外线程的消息*/\n             myHandler = new Handler() {  \n                @Override  \n                public void handleMessage(Message msg) {  \n                    String ms = \"\";  \n                    if (msg.what == 0x777) {  \n\n                    }  \n                }  \n\n            };  \n            //③、调用Looper的loop()方法来启动Looper让消息队列转动起来\n            Looper.loop();  \n        }\n    }\n```\n\n注意分成三步：\n\n- 调用Looper的prepare()方法为当前线程创建Looper对象，创建Looper对象时，它的构造器会创建与之配套的MessageQueue。 　\n- 有了Looper之后，创建Handler子类实例，重写HanderMessage()方法，该方法负责处理来自于其他线程的消息。\n- 调用Looper的looper()方法启动Looper。然后使用这个handler实例在任何其他线程中发送消息，最终处理消息的代码都会在你创建Handler实例的线程中运行。\n\n### 七 Handler总结\n\n- Handler：     \n发送和处理消息，它把消息发送给Looper管理的MessageQueue，并负责处理Looper分发给它的消息。\n      \n- Message：    \nHandler接收和处理的消息对象。\n\n- Looper：     \n每个线程只有一个Looper，它负责管理对应的MessageQueue，会不断地从MessageQueue取出消息，并将消息分给对应的Hanlder处理。主线程中，系统已经初始化了一个Looper对象，因此可以直接创建Handler即可，就可以通过Handler来发送消息、处理消息。若是在子线程，必须手动创建一个Looper对象，并启动它，调用Looper.prepare()方法。\n\n- prapare()：    \n保证每个线程最多只有一个Looper对象。\n\n- looper()：\n启动Looper，使用一个死循环不断取出MessageQueue中的消息，并将取出的消息分给对应的Handler进行处理。 　\n\n- MessageQueue：    \n由Looper负责管理，它采用先进先出的方式来管理Message。Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue想关联。Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。\n\n### 八 Android中另一个线程通信机制AsycTask\n\n##### 1.AsycTask简介\n\nAsycTask是Android中另一个处理异步任务的机制，我们上面说了可以用Handler来处理异步任务，但如果耗时的操作太多，那么我们需要开启太多的子线程，这就会给系统带来巨大的负担，随之也会带来性能方面的问题。在这种情况下我们就可以考虑使用类AsyncTask来异步执行任务，不需要子线程和handler，就可以完成异步操作和刷新UI。\n\nAsyncTask主要有二个部分：一个是与主线程的交互，另一个就是线程的管理调度。虽然可能多个AsyncTask的子类的实例，但是AsyncTask的内部Handler和ThreadPoolExecutor都是进程范围内共享的，其都是static的（所以AsycTask是串行的，不支持并发），也即属于类的，类的属性的作用范围是CLASSPATH，因为一个进程一个VM，所以是AsyncTask控制着进程范围内所有的子类实例。AsyncTask内部会创建一个进程作用域的线程池来管理要运行的任务，也就就是说当你调用了AsyncTask的execute()方法后，AsyncTask会把任务交给线程池，由线程池来管理创建Thread和运行Therad。\n\nAndroid的AsyncTask比Handler更轻量级一些（只是代码上轻量一些，而实际上要比handler更耗资源），适用于简单的异步处理。\n\n注意：不要随意使用AsyncTask,除非你必须要与UI线程交互.默认情况下使用Thread即可,要注意需要将线程优先级调低.AsyncTask适合处理短时间的操作,长时间的操作,比如下载一个很大的视频,这就需要你使用自己的线程来下载,不管是断点下载还是其它的.\n\n##### 2.AsycTask使用步骤\n\nAsyncTask对线程间的通讯做了包装，使后台线程和UI线程可以简易通讯。后台线程执行异步任务，将result告知UI线程。\n\n使用AsycTask分为两步：\n\n- 继承AsyncTask类实现自己的类    \n\n```java\npublic abstract class AsyncTask<Params, Progress, Result> {\n\n    /* Params: 输入参数，对应excute()方法中传递的参数。如果不需要传递参数，则直接设为void即可。\n\n    ** Progress：后台任务执行的百分比\n\n    ** Result：返回值类型，和doInBackground（）方法的返回值类型保持一致。*/\n}\n```\n\n- 复写方法\n\n最少要重写以下这两个方法：\n\n**a.**doInBackground(Params…)      \n在子线程（其他方法都在主线程执行）中执行比较耗时的操作，不能更新ＵＩ，可以在该方法中调用publishProgress(Progress…)来更新任务的进度。Progress方法是AsycTask中一个final方法只能调用不能重写。\n\n**b.**onPostExecute(Result)     \n使用在doInBackground 得到的结果处理操作UI， 在主线程执行，任务执行的结果作为此方法的参数返回。\n\n有时根据需求还要实现以下三个方法：\n\n**c.**onProgressUpdate(Progress…)     \n可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。\n\n**d.**onPreExecute()     \n这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。  \n\n**e.**onCancelled()    \n用户调用取消时，要做的操作\n\n##### 3.AsycTask使用示例\n\n按照上面的步骤定义自己的异步类：\n\n```java\npublic class MyTask extends AsyncTask<String, Integer, String> {  \n    //执行的第一个方法用于在执行后台任务前做一些UI操作  \n    @Override  \n    protected void onPreExecute() {  \n\n    }  \n\n    //第二个执行方法,在onPreExecute()后执行，用于后台任务,不可在此方法内修改UI\n    @Override  \n    protected String doInBackground(String... params) {  \n         //处理耗时操作\n        return \"后台任务执行完毕\";  \n    }  \n\n   /*这个函数在doInBackground调用publishProgress(int i)时触发，虽然调用时只有一个参数  \n    但是这里取到的是一个数组,所以要用progesss[0]来取值  \n    第n个参数就用progress[n]来取值   */\n    @Override  \n    protected void onProgressUpdate(Integer... progresses) {  \n        //\"loading...\" + progresses[0] + \"%\"\n        super.onProgressUpdate(progress);  \n    }  \n\n    /*doInBackground返回时触发，换句话说，就是doInBackground执行完后触发  \n    这里的result就是上面doInBackground执行后的返回值，所以这里是\"后台任务执行完毕\"  */\n    @Override  \n    protected void onPostExecute(String result) { \n\n    }  \n\n    //onCancelled方法用于在取消执行中的任务时更改UI  \n    @Override  \n    protected void onCancelled() {  \n\n    }  \n}\n```\n\n在主线程申明该类的对象，调用对象的execute（）函数开始执行。\n\n```java\nMyTask ｔ= new MyTask();\nt.execute();//这里没有参数\n```\n\n##### 4.使用AsyncTask需要注意的地方 \n\n- AsnycTask内部的Handler需要和主线程交互，所以AsyncTask的实例必须在UI线程中创建\n\n- AsyncTaskResult的doInBackground(mParams)方法执行异步任务运行在子线程中，其他方法运行在主线程中，可以操作UI组件。\n\n- 一个AsyncTask任务只能被执行一次。\n\n- 运行中可以随时调用AsnycTask对象的cancel(boolean)方法取消任务，如果成功，调用isCancelled()会返回true，并且不会执行 onPostExecute() 方法了，而是执行 onCancelled() 方法。\n\n- 对于想要立即开始执行的异步任务，要么直接使用Thread，要么单独创建线程池提供给AsyncTask。默认的AsyncTask不一定会立即执行你的任务，除非你提供给他一个单独的线程池。如果不与主线程交互，直接创建一个Thread就可以了。","slug":"android基础之Handler与AsycTask","published":1,"updated":"2017-03-09T07:13:42.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk1r0011aknz3ay7jkr4","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Handler是Android中用于线程间通信的机制。</p>\n<p>当程序第一次启动的时候，Android会同时启动一条主线程（ Main Thread）来负责处理与UI相关的事件，我们叫做UI线程。Android的UI操作并不是线程安全的（出于性能优化考虑），意味着如果多个线程并发操作UI线程，可能导致线程安全问题。为了解决Android应用多线程问题—Android平台只允许UI线程修改Activity里的UI，这样如果在主线程中执行耗时操作就会导致UI阻塞，若超过5秒就会造成ANR。</p>\n<p>因此我们需要另开线程来处理这些耗时操作，而处理的结果我们可能需要传给主线程用于UI更新，这是就需要线程间的通信。Handler即是Android中用于线程间通信的机制，现在市场一些android的线程通信框架基本上都是基于Handler实现的，如下文将要介绍的已经置于android源码中AsycTask，和现在比较流行的EventBus。</p>\n<h3 id=\"二-Handler的主要作用\"><a href=\"#二-Handler的主要作用\" class=\"headerlink\" title=\"二 Handler的主要作用\"></a>二 Handler的主要作用</h3><p>通过翻看的Handler的源码可知，Handler主要有两个作用。</p>\n<h5 id=\"1-线程延时\"><a href=\"#1-线程延时\" class=\"headerlink\" title=\"1.线程延时\"></a>1.线程延时</h5><p>Handler中内置了线程延时的方法：</p>\n<ul>\n<li>final boolean postAtTime(Runnable r, long uptimeMillis)</li>\n<li>final boolean postDelayed(Runnable r, long delayMillis)</li>\n</ul>\n<h5 id=\"2-线程通信\"><a href=\"#2-线程通信\" class=\"headerlink\" title=\"2.线程通信\"></a>2.线程通信</h5><p>主要步骤：</p>\n<ul>\n<li><p>在新启动的线程中发送消息<br>使用Handler对象的sendMessage()方法或者SendEmptyMessage()方法发送消息。   </p>\n</li>\n<li><p>在主线程中获取处理消息<br>重写Handler类中处理消息的方法（void handleMessage(Message msg)），当新启动的线程发送消息时，消息发送到与之关联的MessageQueue。而Hanlder不断地从MessageQueue中获取并处理消息。</p>\n</li>\n</ul>\n<h3 id=\"三-Handler与UI线程通信示例\"><a href=\"#三-Handler与UI线程通信示例\" class=\"headerlink\" title=\"三 Handler与UI线程通信示例\"></a>三 Handler与UI线程通信示例</h3><ul>\n<li>首先要进行Handler 申明，复写handleMessage方法( 放在主线程中)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> Handler handler = <span class=\"keyword\">new</span> Handler() &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// TODO 接收消息并且去更新UI线程上的控件内容</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (msg.what == UPDATE) &#123;</div><div class=\"line\">                <span class=\"comment\">// 更新界面上的textview</span></div><div class=\"line\">                tv.setText(String.valueOf(msg.obj));</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">super</span>.handleMessage(msg);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<ul>\n<li>子线程发送Message给ui线程表示自己任务已经执行完成，主线程可以做相应的操作了。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Thread() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                <span class=\"comment\">// TODO 子线程中通过handler发送消息给handler接收，由handler去更新TextView的值</span></div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                       <span class=\"comment\">//do something</span></div><div class=\"line\"></div><div class=\"line\">                        Message msg = <span class=\"keyword\">new</span> Message();</div><div class=\"line\">                        msg.what = UPDATE;                  </div><div class=\"line\">                        msg.obj = <span class=\"string\">\"更新后的值\"</span> ;</div><div class=\"line\">                        handler.sendMessage(msg);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;.start();</div></pre></td></tr></table></figure>\n<h3 id=\"四-Handler原理分析\"><a href=\"#四-Handler原理分析\" class=\"headerlink\" title=\"四 Handler原理分析\"></a>四 Handler原理分析</h3><h5 id=\"1-Handler的构造函数\"><a href=\"#1-Handler的构造函数\" class=\"headerlink\" title=\"1.Handler的构造函数\"></a>1.Handler的构造函数</h5><ol>\n<li>public　Handler() </li>\n<li>public　Handler(Callbackcallback)</li>\n<li>public　Handler(Looperlooper)</li>\n<li>public　Handler(Looperlooper, Callbackcallback) </li>\n</ol>\n<ul>\n<li>第1个和第2个构造函数都没有传递Looper，这两个构造函数都将通过调用Looper.myLooper()获取当前线程绑定的Looper对象，然后将该Looper对象保存到名为mLooper的成员字段中。 　<br>下面来看1,2个函数源码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(callback, <span class=\"keyword\">false</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//他们会调用Handler的内部构造方法</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class=\"line\">  <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();</div><div class=\"line\">  <span class=\"keyword\">if</span> ((klass.isAnonymousClass() ||klass.isMemberClass()</div><div class=\"line\">     || klass.isLocalClass()) &amp;&amp;</div><div class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            Log.w(TAG, <span class=\"string\">\"The following Handler class should be static or leaks might occur: \"</span> +</div><div class=\"line\">                klass.getCanonicalName());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> <span class=\"comment\">/************************************</span></div><div class=\"line\">    mLooper = Looper.myLooper();</div><div class=\"line\">    if (mLooper == null) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">            \"Can't create handler inside thread that has not called Looper.prepare()\");</div><div class=\"line\">    &#125;</div><div class=\"line\">    mQueue = mLooper.mQueue;</div><div class=\"line\">    mCallback = callback;</div><div class=\"line\">    mAsynchronous = async;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过Looper.myLooper()获取了当前线程保存的Looper实例，又通过这个Looper实例获取了其中保存的MessageQueue（消息队列）。每个Handler 对应一个Looper对象，产生一个MessageQueue</p>\n<ul>\n<li>第3个和第4个构造函数传递了Looper对象，这两个构造函数会将该Looper保存到名为mLooper的成员字段中。 　<br>下面来看3、4个函数源码： </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Looper looper)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">this</span>(looper, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\"> &#125;　</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Looper looper, Callback callback)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">this</span>(looper, callback, <span class=\"keyword\">false</span>);</div><div class=\"line\"> &#125;</div><div class=\"line\"><span class=\"comment\">//他们会调用Handler的内部构造方法</span></div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Looper looper, Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</div><div class=\"line\">     mLooper = looper;</div><div class=\"line\">     mQueue = looper.mQueue;</div><div class=\"line\">     mCallback = callback;</div><div class=\"line\">     mAsynchronous = async;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第2个和第4个构造函数还传递了Callback对象，Callback是Handler中的内部接口，需要实现其内部的handleMessage方法，Callback代码如下:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callback</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> More ...handleMessage(Message msg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Handler.Callback是用来处理Message的一种手段，如果没有传递该参数，那么就应该重写Handler的handleMessage方法，也就是说为了使得Handler能够处理Message，我们有两种办法： 　　 </p>\n<p>　</p>\n<ol>\n<li>向Hanlder的构造函数传入一个Handler.Callback对象，并实现Handler.Callback的handleMessage方法  　    </li>\n<li>无需向Hanlder的构造函数传入Handler.Callback对象，但是需要重写Handler本身的handleMessage方法 　</li>\n</ol>\n<p>也就是说无论哪种方式，我们都得通过某种方式实现handleMessage方法，这点与Java中对Thread的设计有异曲同工之处。</p>\n<h5 id=\"Handler发送消息的几个方法的源码\"><a href=\"#Handler发送消息的几个方法的源码\" class=\"headerlink\" title=\"Handler发送消息的几个方法的源码\"></a>Handler发送消息的几个方法的源码</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessage</span><span class=\"params\">(Message msg)</span></span></div><div class=\"line\">   &#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> sendMessageDelayed(msg, <span class=\"number\">0</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendEmptyMessageDelayed</span><span class=\"params\">(<span class=\"keyword\">int</span> what, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</div><div class=\"line\">       Message msg = Message.obtain();</div><div class=\"line\">       msg.what = what;</div><div class=\"line\">       <span class=\"keyword\">return</span> sendMessageDelayed(msg, delayMillis);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageDelayed</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> delayMillis)</span></span></div><div class=\"line\">   &#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (delayMillis &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">           delayMillis = <span class=\"number\">0</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</div><div class=\"line\">       MessageQueue queue = mQueue;</div><div class=\"line\">       <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</div><div class=\"line\">                   <span class=\"keyword\">this</span> + <span class=\"string\">\" sendMessageAtTime() called with no mQueue\"</span>);</div><div class=\"line\">           Log.w(<span class=\"string\">\"Looper\"</span>, e.getMessage(), e);</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>我们可以看出他们最后都调用了sendMessageAtTime（），然后返回了enqueueMessage方法，下面看一下此方法源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(MessageQueue queue, Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</div><div class=\"line\">　　　　　　<span class=\"comment\">//把当前的handler作为msg的target属性</span></div><div class=\"line\">    msg.target = <span class=\"keyword\">this</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mAsynchronous) &#123;</div><div class=\"line\">        msg.setAsynchronous(<span class=\"keyword\">true</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在该方法中有两件事需要注意： </p>\n<ul>\n<li>msg.target = this<br>该代码将Message的target绑定为当前的Handler</li>\n<li>queue.enqueueMessage<br>变量queue表示的是Handler所绑定的消息队列MessageQueue，通过调用queue.enqueueMessage(msg, uptimeMillis)我们将Message放入到消息队列中。</li>\n</ul>\n<h3 id=\"五-Looper原理分析\"><a href=\"#五-Looper原理分析\" class=\"headerlink\" title=\"五 Looper原理分析\"></a>五 Looper原理分析</h3><p>我们一般在主线程申明Handler，有时我们需要继承Thread类实现自己的线程功能，当我们在里面申明Handler的时候会报错。其原因是主线程中已经实现了两个重要的Looper方法，下面看一看ActivityThread.java中main方法的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">//......省略</span></div><div class=\"line\">        Looper.prepareMainLooper();<span class=\"comment\">//&gt;</span></div><div class=\"line\"></div><div class=\"line\">        ActivityThread thread = <span class=\"keyword\">new</span> ActivityThread();</div><div class=\"line\">        thread.attach(<span class=\"keyword\">false</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (sMainThreadHandler == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            sMainThreadHandler = thread.getHandler();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        AsyncTask.init();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">false</span>) &#123;</div><div class=\"line\">            Looper.myLooper().setMessageLogging(<span class=\"keyword\">new</span></div><div class=\"line\">   LogPrinter(Log.DEBUG, <span class=\"string\">\"ActivityThread\"</span>));</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Looper.loop();<span class=\"comment\">//&gt;</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Main thread loop unexpectedly exited\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先看prepare()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    prepare(<span class=\"keyword\">true</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</div><div class=\"line\">　　　　　<span class=\"comment\">//证了一个线程中只有一个Looper实例</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>该方法会调用Looper构造函数同时实例化出MessageQueue和当前thread.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</div><div class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);</div><div class=\"line\">    mThread = Thread.currentThread();</div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> MessageQueue <span class=\"title\">myQueue</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> myLooper().mQueue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>prepare()方法中通过ThreadLocal对象实现Looper实例与线程的绑定。</p>\n<p>再看loop()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();</div><div class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</div><div class=\"line\"></div><div class=\"line\">    Binder.clearCallingIdentity();</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ident = Binder.clearCallingIdentity();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// might block</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           </div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Printer logging = me.mLogging;</div><div class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            logging.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt; Dispatching to \"</span> + msg.target + <span class=\"string\">\" \"</span> +</div><div class=\"line\">                    msg.callback + <span class=\"string\">\": \"</span> + msg.what);</div><div class=\"line\">        &#125;</div><div class=\"line\">   <span class=\"comment\">//重点****</span></div><div class=\"line\">        msg.target.dispatchMessage(msg);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            logging.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt; Finished to \"</span> + msg.target + <span class=\"string\">\" \"</span> + msg.callback);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// identity of the thread wasn't corrupted.</span></div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> newIdent = Binder.clearCallingIdentity();</div><div class=\"line\">        <span class=\"keyword\">if</span> (ident != newIdent) &#123;</div><div class=\"line\">            Log.wtf(TAG, <span class=\"string\">\"Thread identity changed from 0x\"</span></div><div class=\"line\">                    + Long.toHexString(ident) + <span class=\"string\">\" to 0x\"</span></div><div class=\"line\">                    + Long.toHexString(newIdent) + <span class=\"string\">\" while dispatching to \"</span></div><div class=\"line\">                    + msg.target.getClass().getName() + <span class=\"string\">\" \"</span></div><div class=\"line\">                    + msg.callback + <span class=\"string\">\" what=\"</span> + msg.what);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        msg.recycleUnchecked();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先looper对象不能为空，就是说loop()方法调用必须在prepare()方法的后面。</p>\n<p>Looper一直在不断的从消息队列中通过MessageQueue的next方法获取Message，然后通过代码msg.target.dispatchMessage(msg)让该msg所绑定的Handler（Message.target）执行dispatchMessage方法以实现对Message的处理。 </p>\n<p>Handler的dispatchMessage的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">         handleCallback(msg);</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">             <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class=\"line\">                 <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        handleMessage(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以看到Handler提供了三种途径处理Message，而且处理有前后优先级之分：首先尝试让postXXX中传递的Runnable执行，其次尝试让Handler构造函数中传入的Callback的handleMessage方法处理，最后才是让Handler自身的handleMessage方法处理Message。</p>\n<h3 id=\"六-如何在子线程中使用Handler\"><a href=\"#六-如何在子线程中使用Handler\" class=\"headerlink\" title=\"六 如何在子线程中使用Handler\"></a>六 如何在子线程中使用Handler</h3><p>Handler本质是从当前的线程中获取到Looper来监听和操作MessageQueue，当其他线程执行完成后回调当前线程。</p>\n<p>子线程需要先prepare（）才能获取到Looper的，是因为在子线程只是一个普通的线程，其ThreadLoacl中没有设置过Looper，所以会抛出异常，而在Looper的prepare（）方法中sThreadLocal.set(new Looper())是设置了Looper的。</p>\n<p>示例代码：</p>\n<p>定义一个类实现Runnable接口或继承Thread类（一般不继承）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rub</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">public</span> Handler myHandler;  </div><div class=\"line\">        <span class=\"comment\">// 实现Runnable接口的线程体 </span></div><div class=\"line\">        <span class=\"meta\">@Override</span>  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">         <span class=\"comment\">/*①、调用Looper的prepare()方法为当前线程创建Looper对象并，</span></div><div class=\"line\">          创建Looper对象时，它的构造器会自动的创建相对应的MessageQueue*/</div><div class=\"line\">            Looper.prepare();  </div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">/*.②、创建Handler子类的实例，重写HandleMessage()方法，该方法处理除当前线程以外线程的消息*/</span></div><div class=\"line\">             myHandler = <span class=\"keyword\">new</span> Handler() &#123;  </div><div class=\"line\">                <span class=\"meta\">@Override</span>  </div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;  </div><div class=\"line\">                    String ms = <span class=\"string\">\"\"</span>;  </div><div class=\"line\">                    <span class=\"keyword\">if</span> (msg.what == <span class=\"number\">0x777</span>) &#123;  </div><div class=\"line\"></div><div class=\"line\">                    &#125;  </div><div class=\"line\">                &#125;  </div><div class=\"line\"></div><div class=\"line\">            &#125;;  </div><div class=\"line\">            <span class=\"comment\">//③、调用Looper的loop()方法来启动Looper让消息队列转动起来</span></div><div class=\"line\">            Looper.loop();  </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>注意分成三步：</p>\n<ul>\n<li>调用Looper的prepare()方法为当前线程创建Looper对象，创建Looper对象时，它的构造器会创建与之配套的MessageQueue。 　</li>\n<li>有了Looper之后，创建Handler子类实例，重写HanderMessage()方法，该方法负责处理来自于其他线程的消息。</li>\n<li>调用Looper的looper()方法启动Looper。然后使用这个handler实例在任何其他线程中发送消息，最终处理消息的代码都会在你创建Handler实例的线程中运行。</li>\n</ul>\n<h3 id=\"七-Handler总结\"><a href=\"#七-Handler总结\" class=\"headerlink\" title=\"七 Handler总结\"></a>七 Handler总结</h3><ul>\n<li><p>Handler：<br>发送和处理消息，它把消息发送给Looper管理的MessageQueue，并负责处理Looper分发给它的消息。</p>\n</li>\n<li><p>Message：<br>Handler接收和处理的消息对象。</p>\n</li>\n<li><p>Looper：<br>每个线程只有一个Looper，它负责管理对应的MessageQueue，会不断地从MessageQueue取出消息，并将消息分给对应的Hanlder处理。主线程中，系统已经初始化了一个Looper对象，因此可以直接创建Handler即可，就可以通过Handler来发送消息、处理消息。若是在子线程，必须手动创建一个Looper对象，并启动它，调用Looper.prepare()方法。</p>\n</li>\n<li><p>prapare()：<br>保证每个线程最多只有一个Looper对象。</p>\n</li>\n<li><p>looper()：<br>启动Looper，使用一个死循环不断取出MessageQueue中的消息，并将取出的消息分给对应的Handler进行处理。 　</p>\n</li>\n<li><p>MessageQueue：<br>由Looper负责管理，它采用先进先出的方式来管理Message。Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue想关联。Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。</p>\n</li>\n</ul>\n<h3 id=\"八-Android中另一个线程通信机制AsycTask\"><a href=\"#八-Android中另一个线程通信机制AsycTask\" class=\"headerlink\" title=\"八 Android中另一个线程通信机制AsycTask\"></a>八 Android中另一个线程通信机制AsycTask</h3><h5 id=\"1-AsycTask简介\"><a href=\"#1-AsycTask简介\" class=\"headerlink\" title=\"1.AsycTask简介\"></a>1.AsycTask简介</h5><p>AsycTask是Android中另一个处理异步任务的机制，我们上面说了可以用Handler来处理异步任务，但如果耗时的操作太多，那么我们需要开启太多的子线程，这就会给系统带来巨大的负担，随之也会带来性能方面的问题。在这种情况下我们就可以考虑使用类AsyncTask来异步执行任务，不需要子线程和handler，就可以完成异步操作和刷新UI。</p>\n<p>AsyncTask主要有二个部分：一个是与主线程的交互，另一个就是线程的管理调度。虽然可能多个AsyncTask的子类的实例，但是AsyncTask的内部Handler和ThreadPoolExecutor都是进程范围内共享的，其都是static的（所以AsycTask是串行的，不支持并发），也即属于类的，类的属性的作用范围是CLASSPATH，因为一个进程一个VM，所以是AsyncTask控制着进程范围内所有的子类实例。AsyncTask内部会创建一个进程作用域的线程池来管理要运行的任务，也就就是说当你调用了AsyncTask的execute()方法后，AsyncTask会把任务交给线程池，由线程池来管理创建Thread和运行Therad。</p>\n<p>Android的AsyncTask比Handler更轻量级一些（只是代码上轻量一些，而实际上要比handler更耗资源），适用于简单的异步处理。</p>\n<p>注意：不要随意使用AsyncTask,除非你必须要与UI线程交互.默认情况下使用Thread即可,要注意需要将线程优先级调低.AsyncTask适合处理短时间的操作,长时间的操作,比如下载一个很大的视频,这就需要你使用自己的线程来下载,不管是断点下载还是其它的.</p>\n<h5 id=\"2-AsycTask使用步骤\"><a href=\"#2-AsycTask使用步骤\" class=\"headerlink\" title=\"2.AsycTask使用步骤\"></a>2.AsycTask使用步骤</h5><p>AsyncTask对线程间的通讯做了包装，使后台线程和UI线程可以简易通讯。后台线程执行异步任务，将result告知UI线程。</p>\n<p>使用AsycTask分为两步：</p>\n<ul>\n<li>继承AsyncTask类实现自己的类    </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncTask</span>&lt;<span class=\"title\">Params</span>, <span class=\"title\">Progress</span>, <span class=\"title\">Result</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/* Params: 输入参数，对应excute()方法中传递的参数。如果不需要传递参数，则直接设为void即可。</span></div><div class=\"line\"></div><div class=\"line\">    ** Progress：后台任务执行的百分比</div><div class=\"line\"></div><div class=\"line\">    ** Result：返回值类型，和doInBackground（）方法的返回值类型保持一致。*/</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>复写方法</li>\n</ul>\n<p>最少要重写以下这两个方法：</p>\n<p><strong>a.</strong>doInBackground(Params…)<br>在子线程（其他方法都在主线程执行）中执行比较耗时的操作，不能更新ＵＩ，可以在该方法中调用publishProgress(Progress…)来更新任务的进度。Progress方法是AsycTask中一个final方法只能调用不能重写。</p>\n<p><strong>b.</strong>onPostExecute(Result)<br>使用在doInBackground 得到的结果处理操作UI， 在主线程执行，任务执行的结果作为此方法的参数返回。</p>\n<p>有时根据需求还要实现以下三个方法：</p>\n<p><strong>c.</strong>onProgressUpdate(Progress…)<br>可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。</p>\n<p><strong>d.</strong>onPreExecute()<br>这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。  </p>\n<p><strong>e.</strong>onCancelled()<br>用户调用取消时，要做的操作</p>\n<h5 id=\"3-AsycTask使用示例\"><a href=\"#3-AsycTask使用示例\" class=\"headerlink\" title=\"3.AsycTask使用示例\"></a>3.AsycTask使用示例</h5><p>按照上面的步骤定义自己的异步类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">AsyncTask</span>&lt;<span class=\"title\">String</span>, <span class=\"title\">Integer</span>, <span class=\"title\">String</span>&gt; </span>&#123;  </div><div class=\"line\">    <span class=\"comment\">//执行的第一个方法用于在执行后台任务前做一些UI操作  </span></div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPreExecute</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//第二个执行方法,在onPreExecute()后执行，用于后台任务,不可在此方法内修改UI</span></div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">doInBackground</span><span class=\"params\">(String... params)</span> </span>&#123;  </div><div class=\"line\">         <span class=\"comment\">//处理耗时操作</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"后台任务执行完毕\"</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">/*这个函数在doInBackground调用publishProgress(int i)时触发，虽然调用时只有一个参数  </span></div><div class=\"line\">    但是这里取到的是一个数组,所以要用progesss[0]来取值  </div><div class=\"line\">    第n个参数就用progress[n]来取值   */</div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onProgressUpdate</span><span class=\"params\">(Integer... progresses)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">//\"loading...\" + progresses[0] + \"%\"</span></div><div class=\"line\">        <span class=\"keyword\">super</span>.onProgressUpdate(progress);  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/*doInBackground返回时触发，换句话说，就是doInBackground执行完后触发  </span></div><div class=\"line\">    这里的result就是上面doInBackground执行后的返回值，所以这里是\"后台任务执行完毕\"  */</div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPostExecute</span><span class=\"params\">(String result)</span> </span>&#123; </div><div class=\"line\"></div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//onCancelled方法用于在取消执行中的任务时更改UI  </span></div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在主线程申明该类的对象，调用对象的execute（）函数开始执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyTask ｔ= <span class=\"keyword\">new</span> MyTask();</div><div class=\"line\">t.execute();<span class=\"comment\">//这里没有参数</span></div></pre></td></tr></table></figure>\n<h5 id=\"4-使用AsyncTask需要注意的地方\"><a href=\"#4-使用AsyncTask需要注意的地方\" class=\"headerlink\" title=\"4.使用AsyncTask需要注意的地方\"></a>4.使用AsyncTask需要注意的地方</h5><ul>\n<li><p>AsnycTask内部的Handler需要和主线程交互，所以AsyncTask的实例必须在UI线程中创建</p>\n</li>\n<li><p>AsyncTaskResult的doInBackground(mParams)方法执行异步任务运行在子线程中，其他方法运行在主线程中，可以操作UI组件。</p>\n</li>\n<li><p>一个AsyncTask任务只能被执行一次。</p>\n</li>\n<li><p>运行中可以随时调用AsnycTask对象的cancel(boolean)方法取消任务，如果成功，调用isCancelled()会返回true，并且不会执行 onPostExecute() 方法了，而是执行 onCancelled() 方法。</p>\n</li>\n<li><p>对于想要立即开始执行的异步任务，要么直接使用Thread，要么单独创建线程池提供给AsyncTask。默认的AsyncTask不一定会立即执行你的任务，除非你提供给他一个单独的线程池。如果不与主线程交互，直接创建一个Thread就可以了。</p>\n</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Handler是Android中用于线程间通信的机制。</p>\n<p>当程序第一次启动的时候，Android会同时启动一条主线程（ Main Thread）来负责处理与UI相关的事件，我们叫做UI线程。Android的UI操作并不是线程安全的（出于性能优化考虑），意味着如果多个线程并发操作UI线程，可能导致线程安全问题。为了解决Android应用多线程问题—Android平台只允许UI线程修改Activity里的UI，这样如果在主线程中执行耗时操作就会导致UI阻塞，若超过5秒就会造成ANR。</p>\n<p>因此我们需要另开线程来处理这些耗时操作，而处理的结果我们可能需要传给主线程用于UI更新，这是就需要线程间的通信。Handler即是Android中用于线程间通信的机制，现在市场一些android的线程通信框架基本上都是基于Handler实现的，如下文将要介绍的已经置于android源码中AsycTask，和现在比较流行的EventBus。</p>\n<h3 id=\"二-Handler的主要作用\"><a href=\"#二-Handler的主要作用\" class=\"headerlink\" title=\"二 Handler的主要作用\"></a>二 Handler的主要作用</h3><p>通过翻看的Handler的源码可知，Handler主要有两个作用。</p>\n<h5 id=\"1-线程延时\"><a href=\"#1-线程延时\" class=\"headerlink\" title=\"1.线程延时\"></a>1.线程延时</h5><p>Handler中内置了线程延时的方法：</p>\n<ul>\n<li>final boolean postAtTime(Runnable r, long uptimeMillis)</li>\n<li>final boolean postDelayed(Runnable r, long delayMillis)</li>\n</ul>\n<h5 id=\"2-线程通信\"><a href=\"#2-线程通信\" class=\"headerlink\" title=\"2.线程通信\"></a>2.线程通信</h5><p>主要步骤：</p>\n<ul>\n<li><p>在新启动的线程中发送消息<br>使用Handler对象的sendMessage()方法或者SendEmptyMessage()方法发送消息。   </p>\n</li>\n<li><p>在主线程中获取处理消息<br>重写Handler类中处理消息的方法（void handleMessage(Message msg)），当新启动的线程发送消息时，消息发送到与之关联的MessageQueue。而Hanlder不断地从MessageQueue中获取并处理消息。</p>\n</li>\n</ul>\n<h3 id=\"三-Handler与UI线程通信示例\"><a href=\"#三-Handler与UI线程通信示例\" class=\"headerlink\" title=\"三 Handler与UI线程通信示例\"></a>三 Handler与UI线程通信示例</h3><ul>\n<li>首先要进行Handler 申明，复写handleMessage方法( 放在主线程中)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> Handler handler = <span class=\"keyword\">new</span> Handler() &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// TODO 接收消息并且去更新UI线程上的控件内容</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (msg.what == UPDATE) &#123;</div><div class=\"line\">                <span class=\"comment\">// 更新界面上的textview</span></div><div class=\"line\">                tv.setText(String.valueOf(msg.obj));</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">super</span>.handleMessage(msg);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<ul>\n<li>子线程发送Message给ui线程表示自己任务已经执行完成，主线程可以做相应的操作了。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Thread() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                <span class=\"comment\">// TODO 子线程中通过handler发送消息给handler接收，由handler去更新TextView的值</span></div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                       <span class=\"comment\">//do something</span></div><div class=\"line\"></div><div class=\"line\">                        Message msg = <span class=\"keyword\">new</span> Message();</div><div class=\"line\">                        msg.what = UPDATE;                  </div><div class=\"line\">                        msg.obj = <span class=\"string\">\"更新后的值\"</span> ;</div><div class=\"line\">                        handler.sendMessage(msg);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;.start();</div></pre></td></tr></table></figure>\n<h3 id=\"四-Handler原理分析\"><a href=\"#四-Handler原理分析\" class=\"headerlink\" title=\"四 Handler原理分析\"></a>四 Handler原理分析</h3><h5 id=\"1-Handler的构造函数\"><a href=\"#1-Handler的构造函数\" class=\"headerlink\" title=\"1.Handler的构造函数\"></a>1.Handler的构造函数</h5><ol>\n<li>public　Handler() </li>\n<li>public　Handler(Callbackcallback)</li>\n<li>public　Handler(Looperlooper)</li>\n<li>public　Handler(Looperlooper, Callbackcallback) </li>\n</ol>\n<ul>\n<li>第1个和第2个构造函数都没有传递Looper，这两个构造函数都将通过调用Looper.myLooper()获取当前线程绑定的Looper对象，然后将该Looper对象保存到名为mLooper的成员字段中。 　<br>下面来看1,2个函数源码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(callback, <span class=\"keyword\">false</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//他们会调用Handler的内部构造方法</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class=\"line\">  <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();</div><div class=\"line\">  <span class=\"keyword\">if</span> ((klass.isAnonymousClass() ||klass.isMemberClass()</div><div class=\"line\">     || klass.isLocalClass()) &amp;&amp;</div><div class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            Log.w(TAG, <span class=\"string\">\"The following Handler class should be static or leaks might occur: \"</span> +</div><div class=\"line\">                klass.getCanonicalName());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> <span class=\"comment\">/************************************</div><div class=\"line\">    mLooper = Looper.myLooper();</div><div class=\"line\">    if (mLooper == null) &#123;</div><div class=\"line\">        throw new RuntimeException(</div><div class=\"line\">            \"Can't create handler inside thread that has not called Looper.prepare()\");</div><div class=\"line\">    &#125;</div><div class=\"line\">    mQueue = mLooper.mQueue;</div><div class=\"line\">    mCallback = callback;</div><div class=\"line\">    mAsynchronous = async;</div><div class=\"line\">&#125;</span></div></pre></td></tr></table></figure>\n<p>通过Looper.myLooper()获取了当前线程保存的Looper实例，又通过这个Looper实例获取了其中保存的MessageQueue（消息队列）。每个Handler 对应一个Looper对象，产生一个MessageQueue</p>\n<ul>\n<li>第3个和第4个构造函数传递了Looper对象，这两个构造函数会将该Looper保存到名为mLooper的成员字段中。 　<br>下面来看3、4个函数源码： </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Looper looper)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">this</span>(looper, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\"> &#125;　</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Looper looper, Callback callback)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">this</span>(looper, callback, <span class=\"keyword\">false</span>);</div><div class=\"line\"> &#125;</div><div class=\"line\"><span class=\"comment\">//他们会调用Handler的内部构造方法</span></div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Looper looper, Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</div><div class=\"line\">     mLooper = looper;</div><div class=\"line\">     mQueue = looper.mQueue;</div><div class=\"line\">     mCallback = callback;</div><div class=\"line\">     mAsynchronous = async;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第2个和第4个构造函数还传递了Callback对象，Callback是Handler中的内部接口，需要实现其内部的handleMessage方法，Callback代码如下:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callback</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> More ...handleMessage(Message msg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Handler.Callback是用来处理Message的一种手段，如果没有传递该参数，那么就应该重写Handler的handleMessage方法，也就是说为了使得Handler能够处理Message，我们有两种办法： 　　 </p>\n<p>　</p>\n<ol>\n<li>向Hanlder的构造函数传入一个Handler.Callback对象，并实现Handler.Callback的handleMessage方法  　    </li>\n<li>无需向Hanlder的构造函数传入Handler.Callback对象，但是需要重写Handler本身的handleMessage方法 　</li>\n</ol>\n<p>也就是说无论哪种方式，我们都得通过某种方式实现handleMessage方法，这点与Java中对Thread的设计有异曲同工之处。</p>\n<h5 id=\"Handler发送消息的几个方法的源码\"><a href=\"#Handler发送消息的几个方法的源码\" class=\"headerlink\" title=\"Handler发送消息的几个方法的源码\"></a>Handler发送消息的几个方法的源码</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessage</span><span class=\"params\">(Message msg)</span></div><div class=\"line\">   </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> sendMessageDelayed(msg, <span class=\"number\">0</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendEmptyMessageDelayed</span><span class=\"params\">(<span class=\"keyword\">int</span> what, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</div><div class=\"line\">       Message msg = Message.obtain();</div><div class=\"line\">       msg.what = what;</div><div class=\"line\">       <span class=\"keyword\">return</span> sendMessageDelayed(msg, delayMillis);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageDelayed</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> delayMillis)</span></div><div class=\"line\">   </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (delayMillis &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">           delayMillis = <span class=\"number\">0</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</div><div class=\"line\">       MessageQueue queue = mQueue;</div><div class=\"line\">       <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</div><div class=\"line\">                   <span class=\"keyword\">this</span> + <span class=\"string\">\" sendMessageAtTime() called with no mQueue\"</span>);</div><div class=\"line\">           Log.w(<span class=\"string\">\"Looper\"</span>, e.getMessage(), e);</div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>我们可以看出他们最后都调用了sendMessageAtTime（），然后返回了enqueueMessage方法，下面看一下此方法源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(MessageQueue queue, Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</div><div class=\"line\">　　　　　　<span class=\"comment\">//把当前的handler作为msg的target属性</span></div><div class=\"line\">    msg.target = <span class=\"keyword\">this</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mAsynchronous) &#123;</div><div class=\"line\">        msg.setAsynchronous(<span class=\"keyword\">true</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在该方法中有两件事需要注意： </p>\n<ul>\n<li>msg.target = this<br>该代码将Message的target绑定为当前的Handler</li>\n<li>queue.enqueueMessage<br>变量queue表示的是Handler所绑定的消息队列MessageQueue，通过调用queue.enqueueMessage(msg, uptimeMillis)我们将Message放入到消息队列中。</li>\n</ul>\n<h3 id=\"五-Looper原理分析\"><a href=\"#五-Looper原理分析\" class=\"headerlink\" title=\"五 Looper原理分析\"></a>五 Looper原理分析</h3><p>我们一般在主线程申明Handler，有时我们需要继承Thread类实现自己的线程功能，当我们在里面申明Handler的时候会报错。其原因是主线程中已经实现了两个重要的Looper方法，下面看一看ActivityThread.java中main方法的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">//......省略</span></div><div class=\"line\">        Looper.prepareMainLooper();<span class=\"comment\">//&gt;</span></div><div class=\"line\"></div><div class=\"line\">        ActivityThread thread = <span class=\"keyword\">new</span> ActivityThread();</div><div class=\"line\">        thread.attach(<span class=\"keyword\">false</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (sMainThreadHandler == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            sMainThreadHandler = thread.getHandler();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        AsyncTask.init();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">false</span>) &#123;</div><div class=\"line\">            Looper.myLooper().setMessageLogging(<span class=\"keyword\">new</span></div><div class=\"line\">   LogPrinter(Log.DEBUG, <span class=\"string\">\"ActivityThread\"</span>));</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Looper.loop();<span class=\"comment\">//&gt;</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Main thread loop unexpectedly exited\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先看prepare()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    prepare(<span class=\"keyword\">true</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</div><div class=\"line\">　　　　　<span class=\"comment\">//证了一个线程中只有一个Looper实例</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>该方法会调用Looper构造函数同时实例化出MessageQueue和当前thread.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</div><div class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);</div><div class=\"line\">    mThread = Thread.currentThread();</div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> MessageQueue <span class=\"title\">myQueue</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> myLooper().mQueue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>prepare()方法中通过ThreadLocal对象实现Looper实例与线程的绑定。</p>\n<p>再看loop()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();</div><div class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</div><div class=\"line\"></div><div class=\"line\">    Binder.clearCallingIdentity();</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ident = Binder.clearCallingIdentity();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// might block</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           </div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Printer logging = me.mLogging;</div><div class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            logging.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt; Dispatching to \"</span> + msg.target + <span class=\"string\">\" \"</span> +</div><div class=\"line\">                    msg.callback + <span class=\"string\">\": \"</span> + msg.what);</div><div class=\"line\">        &#125;</div><div class=\"line\">   <span class=\"comment\">//重点****</span></div><div class=\"line\">        msg.target.dispatchMessage(msg);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            logging.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt; Finished to \"</span> + msg.target + <span class=\"string\">\" \"</span> + msg.callback);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// identity of the thread wasn't corrupted.</span></div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> newIdent = Binder.clearCallingIdentity();</div><div class=\"line\">        <span class=\"keyword\">if</span> (ident != newIdent) &#123;</div><div class=\"line\">            Log.wtf(TAG, <span class=\"string\">\"Thread identity changed from 0x\"</span></div><div class=\"line\">                    + Long.toHexString(ident) + <span class=\"string\">\" to 0x\"</span></div><div class=\"line\">                    + Long.toHexString(newIdent) + <span class=\"string\">\" while dispatching to \"</span></div><div class=\"line\">                    + msg.target.getClass().getName() + <span class=\"string\">\" \"</span></div><div class=\"line\">                    + msg.callback + <span class=\"string\">\" what=\"</span> + msg.what);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        msg.recycleUnchecked();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先looper对象不能为空，就是说loop()方法调用必须在prepare()方法的后面。</p>\n<p>Looper一直在不断的从消息队列中通过MessageQueue的next方法获取Message，然后通过代码msg.target.dispatchMessage(msg)让该msg所绑定的Handler（Message.target）执行dispatchMessage方法以实现对Message的处理。 </p>\n<p>Handler的dispatchMessage的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">         handleCallback(msg);</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">             <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class=\"line\">                 <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        handleMessage(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以看到Handler提供了三种途径处理Message，而且处理有前后优先级之分：首先尝试让postXXX中传递的Runnable执行，其次尝试让Handler构造函数中传入的Callback的handleMessage方法处理，最后才是让Handler自身的handleMessage方法处理Message。</p>\n<h3 id=\"六-如何在子线程中使用Handler\"><a href=\"#六-如何在子线程中使用Handler\" class=\"headerlink\" title=\"六 如何在子线程中使用Handler\"></a>六 如何在子线程中使用Handler</h3><p>Handler本质是从当前的线程中获取到Looper来监听和操作MessageQueue，当其他线程执行完成后回调当前线程。</p>\n<p>子线程需要先prepare（）才能获取到Looper的，是因为在子线程只是一个普通的线程，其ThreadLoacl中没有设置过Looper，所以会抛出异常，而在Looper的prepare（）方法中sThreadLocal.set(new Looper())是设置了Looper的。</p>\n<p>示例代码：</p>\n<p>定义一个类实现Runnable接口或继承Thread类（一般不继承）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rub</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">public</span> Handler myHandler;  </div><div class=\"line\">        <span class=\"comment\">// 实现Runnable接口的线程体 </span></div><div class=\"line\">        <span class=\"meta\">@Override</span>  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">         <span class=\"comment\">/*①、调用Looper的prepare()方法为当前线程创建Looper对象并，</div><div class=\"line\">          创建Looper对象时，它的构造器会自动的创建相对应的MessageQueue*/</span></div><div class=\"line\">            Looper.prepare();  </div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">/*.②、创建Handler子类的实例，重写HandleMessage()方法，该方法处理除当前线程以外线程的消息*/</span></div><div class=\"line\">             myHandler = <span class=\"keyword\">new</span> Handler() &#123;  </div><div class=\"line\">                <span class=\"meta\">@Override</span>  </div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;  </div><div class=\"line\">                    String ms = <span class=\"string\">\"\"</span>;  </div><div class=\"line\">                    <span class=\"keyword\">if</span> (msg.what == <span class=\"number\">0x777</span>) &#123;  </div><div class=\"line\"></div><div class=\"line\">                    &#125;  </div><div class=\"line\">                &#125;  </div><div class=\"line\"></div><div class=\"line\">            &#125;;  </div><div class=\"line\">            <span class=\"comment\">//③、调用Looper的loop()方法来启动Looper让消息队列转动起来</span></div><div class=\"line\">            Looper.loop();  </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>注意分成三步：</p>\n<ul>\n<li>调用Looper的prepare()方法为当前线程创建Looper对象，创建Looper对象时，它的构造器会创建与之配套的MessageQueue。 　</li>\n<li>有了Looper之后，创建Handler子类实例，重写HanderMessage()方法，该方法负责处理来自于其他线程的消息。</li>\n<li>调用Looper的looper()方法启动Looper。然后使用这个handler实例在任何其他线程中发送消息，最终处理消息的代码都会在你创建Handler实例的线程中运行。</li>\n</ul>\n<h3 id=\"七-Handler总结\"><a href=\"#七-Handler总结\" class=\"headerlink\" title=\"七 Handler总结\"></a>七 Handler总结</h3><ul>\n<li><p>Handler：<br>发送和处理消息，它把消息发送给Looper管理的MessageQueue，并负责处理Looper分发给它的消息。</p>\n</li>\n<li><p>Message：<br>Handler接收和处理的消息对象。</p>\n</li>\n<li><p>Looper：<br>每个线程只有一个Looper，它负责管理对应的MessageQueue，会不断地从MessageQueue取出消息，并将消息分给对应的Hanlder处理。主线程中，系统已经初始化了一个Looper对象，因此可以直接创建Handler即可，就可以通过Handler来发送消息、处理消息。若是在子线程，必须手动创建一个Looper对象，并启动它，调用Looper.prepare()方法。</p>\n</li>\n<li><p>prapare()：<br>保证每个线程最多只有一个Looper对象。</p>\n</li>\n<li><p>looper()：<br>启动Looper，使用一个死循环不断取出MessageQueue中的消息，并将取出的消息分给对应的Handler进行处理。 　</p>\n</li>\n<li><p>MessageQueue：<br>由Looper负责管理，它采用先进先出的方式来管理Message。Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue想关联。Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。</p>\n</li>\n</ul>\n<h3 id=\"八-Android中另一个线程通信机制AsycTask\"><a href=\"#八-Android中另一个线程通信机制AsycTask\" class=\"headerlink\" title=\"八 Android中另一个线程通信机制AsycTask\"></a>八 Android中另一个线程通信机制AsycTask</h3><h5 id=\"1-AsycTask简介\"><a href=\"#1-AsycTask简介\" class=\"headerlink\" title=\"1.AsycTask简介\"></a>1.AsycTask简介</h5><p>AsycTask是Android中另一个处理异步任务的机制，我们上面说了可以用Handler来处理异步任务，但如果耗时的操作太多，那么我们需要开启太多的子线程，这就会给系统带来巨大的负担，随之也会带来性能方面的问题。在这种情况下我们就可以考虑使用类AsyncTask来异步执行任务，不需要子线程和handler，就可以完成异步操作和刷新UI。</p>\n<p>AsyncTask主要有二个部分：一个是与主线程的交互，另一个就是线程的管理调度。虽然可能多个AsyncTask的子类的实例，但是AsyncTask的内部Handler和ThreadPoolExecutor都是进程范围内共享的，其都是static的（所以AsycTask是串行的，不支持并发），也即属于类的，类的属性的作用范围是CLASSPATH，因为一个进程一个VM，所以是AsyncTask控制着进程范围内所有的子类实例。AsyncTask内部会创建一个进程作用域的线程池来管理要运行的任务，也就就是说当你调用了AsyncTask的execute()方法后，AsyncTask会把任务交给线程池，由线程池来管理创建Thread和运行Therad。</p>\n<p>Android的AsyncTask比Handler更轻量级一些（只是代码上轻量一些，而实际上要比handler更耗资源），适用于简单的异步处理。</p>\n<p>注意：不要随意使用AsyncTask,除非你必须要与UI线程交互.默认情况下使用Thread即可,要注意需要将线程优先级调低.AsyncTask适合处理短时间的操作,长时间的操作,比如下载一个很大的视频,这就需要你使用自己的线程来下载,不管是断点下载还是其它的.</p>\n<h5 id=\"2-AsycTask使用步骤\"><a href=\"#2-AsycTask使用步骤\" class=\"headerlink\" title=\"2.AsycTask使用步骤\"></a>2.AsycTask使用步骤</h5><p>AsyncTask对线程间的通讯做了包装，使后台线程和UI线程可以简易通讯。后台线程执行异步任务，将result告知UI线程。</p>\n<p>使用AsycTask分为两步：</p>\n<ul>\n<li>继承AsyncTask类实现自己的类    </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncTask</span>&lt;<span class=\"title\">Params</span>, <span class=\"title\">Progress</span>, <span class=\"title\">Result</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/* Params: 输入参数，对应excute()方法中传递的参数。如果不需要传递参数，则直接设为void即可。</div><div class=\"line\"></div><div class=\"line\">    ** Progress：后台任务执行的百分比</div><div class=\"line\"></div><div class=\"line\">    ** Result：返回值类型，和doInBackground（）方法的返回值类型保持一致。*/</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>复写方法</li>\n</ul>\n<p>最少要重写以下这两个方法：</p>\n<p><strong>a.</strong>doInBackground(Params…)<br>在子线程（其他方法都在主线程执行）中执行比较耗时的操作，不能更新ＵＩ，可以在该方法中调用publishProgress(Progress…)来更新任务的进度。Progress方法是AsycTask中一个final方法只能调用不能重写。</p>\n<p><strong>b.</strong>onPostExecute(Result)<br>使用在doInBackground 得到的结果处理操作UI， 在主线程执行，任务执行的结果作为此方法的参数返回。</p>\n<p>有时根据需求还要实现以下三个方法：</p>\n<p><strong>c.</strong>onProgressUpdate(Progress…)<br>可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。</p>\n<p><strong>d.</strong>onPreExecute()<br>这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。  </p>\n<p><strong>e.</strong>onCancelled()<br>用户调用取消时，要做的操作</p>\n<h5 id=\"3-AsycTask使用示例\"><a href=\"#3-AsycTask使用示例\" class=\"headerlink\" title=\"3.AsycTask使用示例\"></a>3.AsycTask使用示例</h5><p>按照上面的步骤定义自己的异步类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">AsyncTask</span>&lt;<span class=\"title\">String</span>, <span class=\"title\">Integer</span>, <span class=\"title\">String</span>&gt; </span>&#123;  </div><div class=\"line\">    <span class=\"comment\">//执行的第一个方法用于在执行后台任务前做一些UI操作  </span></div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPreExecute</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//第二个执行方法,在onPreExecute()后执行，用于后台任务,不可在此方法内修改UI</span></div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">doInBackground</span><span class=\"params\">(String... params)</span> </span>&#123;  </div><div class=\"line\">         <span class=\"comment\">//处理耗时操作</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"后台任务执行完毕\"</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">/*这个函数在doInBackground调用publishProgress(int i)时触发，虽然调用时只有一个参数  </div><div class=\"line\">    但是这里取到的是一个数组,所以要用progesss[0]来取值  </div><div class=\"line\">    第n个参数就用progress[n]来取值   */</span></div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onProgressUpdate</span><span class=\"params\">(Integer... progresses)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">//\"loading...\" + progresses[0] + \"%\"</span></div><div class=\"line\">        <span class=\"keyword\">super</span>.onProgressUpdate(progress);  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/*doInBackground返回时触发，换句话说，就是doInBackground执行完后触发  </div><div class=\"line\">    这里的result就是上面doInBackground执行后的返回值，所以这里是\"后台任务执行完毕\"  */</span></div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPostExecute</span><span class=\"params\">(String result)</span> </span>&#123; </div><div class=\"line\"></div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//onCancelled方法用于在取消执行中的任务时更改UI  </span></div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在主线程申明该类的对象，调用对象的execute（）函数开始执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyTask ｔ= <span class=\"keyword\">new</span> MyTask();</div><div class=\"line\">t.execute();<span class=\"comment\">//这里没有参数</span></div></pre></td></tr></table></figure>\n<h5 id=\"4-使用AsyncTask需要注意的地方\"><a href=\"#4-使用AsyncTask需要注意的地方\" class=\"headerlink\" title=\"4.使用AsyncTask需要注意的地方\"></a>4.使用AsyncTask需要注意的地方</h5><ul>\n<li><p>AsnycTask内部的Handler需要和主线程交互，所以AsyncTask的实例必须在UI线程中创建</p>\n</li>\n<li><p>AsyncTaskResult的doInBackground(mParams)方法执行异步任务运行在子线程中，其他方法运行在主线程中，可以操作UI组件。</p>\n</li>\n<li><p>一个AsyncTask任务只能被执行一次。</p>\n</li>\n<li><p>运行中可以随时调用AsnycTask对象的cancel(boolean)方法取消任务，如果成功，调用isCancelled()会返回true，并且不会执行 onPostExecute() 方法了，而是执行 onCancelled() 方法。</p>\n</li>\n<li><p>对于想要立即开始执行的异步任务，要么直接使用Thread，要么单独创建线程池提供给AsyncTask。默认的AsyncTask不一定会立即执行你的任务，除非你提供给他一个单独的线程池。如果不与主线程交互，直接创建一个Thread就可以了。</p>\n</li>\n</ul>\n"},{"title":"android基础之Intents与Intent Filters","date":"2017-02-27T06:32:09.000Z","_content":"\n### 一 概述\n\nIntent是Android中组件之间传递消息的一种机制，这个组件可以是同一个应用程序的，也可以是不同的应用程序。Android四大组件中除了ContentProvider，其余三者皆可通过Intent来传递数据。而且Intent是一种运行时绑定机制。\n\nIntent在Android的三个组件中传递的机制是不同的：\n\n- 使用Context.startActivity() 或 Activity.startActivityForResult()，传入一个intent来启动一个activity。使用 Activity.setResult()，传入一个intent来从activity中返回结果。\n- 将intent对象传给Context.startService()来启动一个service或者传消息给一个运行的service。将intent对象传给 Context.bindService()来绑定一个service。\n- 将intent对象传给 Context.sendBroadcast()，Context.sendOrderedBroadcast()，或者Context.sendStickyBroadcast()等广播方法，则它们被传给 broadcast receiver。\n\n### 二 Intent的结构\n\nIntent主要包含以下属性：\n\n- component(组件)：目的组件    \nComponent属性明确指定Intent的目标组件的类名称。（属于直接Intent）。组件的名字通过函数setComponent()、setClass()、setClassName()设置，通过函数读取getComponent()。   \n\n- action（动作）：用来表现意图的行动  \nAction主要用来描述应用程序的组件，一个组件可以用于多个action，也可以多个组件拥有同一个action。\n\n\n- category（类别）：用来表现动作的类别     \ncategory通常和Action放在一起用的，用于描述这个action。一个action可以包含多个categoty，必须所有的categoty都匹配成功才算是与这个action匹配成功。如果一个action只有一个默认的categoty DEFAULT，则不需向Intent中添加categoty，系统会自动添加。addCategory() 放置一个intent里的类别，removeCategory()删除之前添加的，getCategories()获取当前所有的类别。      \n类别越多，动作越具体，意图越明确    \n\n\n- data（数据）：表示与动作要操纵的数据      \nData属性是Android要访问的数据，和action和Category声明方式相同，也是在<intent-filter>中。多个组件匹配成功显示优先级高的； 相同显示列表。Data是用一个uri对象来表示的，uri代表数据的地址，属于一种标识符。通常情况下，我们使用action+data属性的组合来描述一个意图：做什么    \n\n\n- type（数据类型）：对于data范例的描写     \n如果Intent对象中既包含Uri又包含Type，那么，在<intent-filter>中也必须二者都包含才能通过测试。Type属性用于明确指定Data属性的数据类型或MIME类型，但是通常来说，当Intent不指定Data属性时，Type属性才会起作用，否则Android系统将会根据Data属性值来分析数据的类型，所以无需指定Type属性。data和type属性一般只需要一个，通过setData方法会把type属性设置为null，相反设置setType方法会把data设置为null，如果想要两个属性同时设置，要使用Intent.setDataAndType()方法    \n\n\n- extras（扩展信息）：扩展信息     \n是其它所有附加信息的集合。以键值对的形式放入Intent中    \n\n\n- Flags（标志位）：期望这个意图的运行模式      \n用于指定Activity与task之间的关系。\n\n### 三 Intent发现组件的两种方式\n   \nIntent启动组件有两种方式：显示启动和隐式启动。\n\n上面Intent的Intent的7个属性中，只有component属于显示启动，action，category，data皆为隐式启动。\n\n##### 1.显示启动\n\n代码示例：\n\n```java\n    button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  //创建一个意图对象\n                  Intent intent = new Intent();\n                  //创建组件，通过组件来响应\n                  ComponentName component = new ComponentName(MainActivity.this, SecondActivity.class);\n                  intent.setComponent(component);                \n                  startActivity(intent);                \n             }\n         });\n```\n\n如果写的简单一点，监听事件onClick()方法里可以这样写：\n\n```java\n      Intent intent = new Intent();\n      //setClass函数的第一个参数是一个Context对象\n      //Context是一个类，Activity是Context类的子类，也就是说，所有的Activity对象，都可以向上转型为Context对象\n      //setClass函数的第二个参数是一个Class对象，在当前场景下，应该传入需要被启动的Activity类的class对象\n      intent.setClass(MainActivity.this, SecondActivity.class);\n      startActivity(intent);    \n```\n\n再简单一点，可以这样写：（当然，也是最常见的写法）\n\n```java\n                 Intent intent = new Intent(MainActivity.this,SecondActivity.class);\n                 startActivity(intent);\n```\n\n##### 2.隐式启动\n\n- action\n\n在Androidmanifest.xml中定义\n\n```java\n         <activity \n             android:name=\".SecondActivity\">\n             <intent-filter>\n                  <action android:name=\"com.example.smyh006intent01.MY_ACTION\"/>\n                  <category android:name=\"android.intent.category.DEFAULT\" />\n             </intent-filter>            \n         </activity>\n```\n\njava代码调用\n\n```java\n          button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  //启动另一个Activity，（通过action属性进行查找）\n                  Intent intent = new Intent();\n                  //设置动作（实际action属性就是一个字符串标记而已）\n                  intent.setAction(\"com.example.smyh006intent01.MY_ACTION\"); //方法：Intent android.content.Intent.setAction(String action)\n                  startActivity(intent);        \n              }\n         });\n```\n\n上面代码也可简写成\n\n```java\n         button1.setOnClickListener(new OnClickListener() {            \n             @Override\n             public void onClick(View v) {\n                 //启动另一个Activity，（通过action属性进行查找）\n                 Intent intent = new Intent(\"com.example.smyh006intent01.MY_ACTION\");//方法： android.content.Intent.Intent(String action)                \n                 startActivity(intent);        \n             }\n         });\n```\n\n- action+categoty\n\nAndroidmanifest.xml文件：\n\n```java\n         <activity\n             android:name=\".SecondActivity\">\n             <intent-filter>\n                  <action android:name=\"com.example.smyh006intent01.MY_ACTION\"/>\n                  <category android:name=\"android.intent.category.DEFAULT\" />\n                  <category android:name=\"com.example.smyh006intent01.MY_CATEGORY\" />\n             </intent-filter>            \n         </activity>\n```\n\njava文件中：\n\n```java\n         button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  //启动另一个Activity，（通过action属性进行查找）\n                  Intent intent = new Intent();\n                  //设置动作（实际action属性就是一个字符串标记而已）\n                  intent.setAction(\"com.example.smyh006intent01.MY_ACTION\"); //方法：Intent android.content.Intent.setAction(String action)\n                  intent.addCategory(\"com.example.smyh006intent01.MY_CATEGORY\");\n                  startActivity(intent);        \n             }\n         });\n```\n\n- action+data\n\n示例：打开指定网页\n\n```java\n         <activity \n             android:name=\".SecondActivity\">\n             <intent-filter>\n                  <action android:name=\"android.intent.action.VIEW\" />\n                  <category android:name=\"android.intent.category.DEFAULT\" />\n                  <data android:scheme=\"http\" android:host=\"www.baidu.com\"/>                 \n             </intent-filter>            \n         </activity>\n```\n\njava文件中：\n\n```java\n          button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  Intent intent = new Intent();\n                  intent.setAction(Intent.ACTION_VIEW);\n                  Uri data = Uri.parse(\"http://www.baidu.com\");\n                  intent.setData(data);                \n                  startActivity(intent);        \n              }\n         });\n```\n\n上面代码也可简写成：\n\n```java\n         button1.setOnClickListener(new OnClickListener() {            \n             @Override\n             public void onClick(View v) {\n                 Intent intent = new Intent(Intent.ACTION_VIEW);\n                 intent.setData(Uri.parse(\"http://www.baidu.com\"));                \n                 startActivity(intent);        \n             }\n         });\n```\n\n### 四 IntentFilter\n\nIntentFilter用于与Intent中的数据对比，来挑选出符合条件的组件。它分为静态注册（推荐）和动态注册两种方式。Intent与IntentFilter比较的步骤如下：\n\n1. 加载安装所有的IntentFilter到一个列表中\n2. 剔除所有action匹配失败的IntentFilter\n3. 剔除URI数据匹配失败的IntentFilter\n4. 剔除category匹配失败的IntentFilter\n5. 剩下的IntentFilter是否为0。是，查找失败，抛出异常；否将剩下的IntentFilter按优先级排列，返回优先级最高的IntentFilter\n\n代码示例：\n\n静态注册\n\n```java\n<receiver android:name=\".MyBroadCastReceiver\">  \n            <!-- android:priority属性是设置此接收者的优先级（从-1000到1000） -->\n            <intent-filter android:priority=\"20\">\n            <actionandroid:name=\"android.provider.Telephony.SMS_RECEIVED\"/>  \n            </intent-filter>  \n</receiver>\n```\n\n动态注册\n\n```java\nIntentFilter intentFilter = new IntentFilter(\"android.provider.Telephony.SMS_RECEIVED\");\n```\n\n\n### 五 总结","source":"_posts/android基础之Intents与Intent-Filters.md","raw":"---\ntitle: android基础之Intents与Intent Filters\ndate: 2017-02-27 14:32:09\ncategories: android\ntags:\n- android\n- java\n- Intent\n- IntentFilter\n---\n\n### 一 概述\n\nIntent是Android中组件之间传递消息的一种机制，这个组件可以是同一个应用程序的，也可以是不同的应用程序。Android四大组件中除了ContentProvider，其余三者皆可通过Intent来传递数据。而且Intent是一种运行时绑定机制。\n\nIntent在Android的三个组件中传递的机制是不同的：\n\n- 使用Context.startActivity() 或 Activity.startActivityForResult()，传入一个intent来启动一个activity。使用 Activity.setResult()，传入一个intent来从activity中返回结果。\n- 将intent对象传给Context.startService()来启动一个service或者传消息给一个运行的service。将intent对象传给 Context.bindService()来绑定一个service。\n- 将intent对象传给 Context.sendBroadcast()，Context.sendOrderedBroadcast()，或者Context.sendStickyBroadcast()等广播方法，则它们被传给 broadcast receiver。\n\n### 二 Intent的结构\n\nIntent主要包含以下属性：\n\n- component(组件)：目的组件    \nComponent属性明确指定Intent的目标组件的类名称。（属于直接Intent）。组件的名字通过函数setComponent()、setClass()、setClassName()设置，通过函数读取getComponent()。   \n\n- action（动作）：用来表现意图的行动  \nAction主要用来描述应用程序的组件，一个组件可以用于多个action，也可以多个组件拥有同一个action。\n\n\n- category（类别）：用来表现动作的类别     \ncategory通常和Action放在一起用的，用于描述这个action。一个action可以包含多个categoty，必须所有的categoty都匹配成功才算是与这个action匹配成功。如果一个action只有一个默认的categoty DEFAULT，则不需向Intent中添加categoty，系统会自动添加。addCategory() 放置一个intent里的类别，removeCategory()删除之前添加的，getCategories()获取当前所有的类别。      \n类别越多，动作越具体，意图越明确    \n\n\n- data（数据）：表示与动作要操纵的数据      \nData属性是Android要访问的数据，和action和Category声明方式相同，也是在<intent-filter>中。多个组件匹配成功显示优先级高的； 相同显示列表。Data是用一个uri对象来表示的，uri代表数据的地址，属于一种标识符。通常情况下，我们使用action+data属性的组合来描述一个意图：做什么    \n\n\n- type（数据类型）：对于data范例的描写     \n如果Intent对象中既包含Uri又包含Type，那么，在<intent-filter>中也必须二者都包含才能通过测试。Type属性用于明确指定Data属性的数据类型或MIME类型，但是通常来说，当Intent不指定Data属性时，Type属性才会起作用，否则Android系统将会根据Data属性值来分析数据的类型，所以无需指定Type属性。data和type属性一般只需要一个，通过setData方法会把type属性设置为null，相反设置setType方法会把data设置为null，如果想要两个属性同时设置，要使用Intent.setDataAndType()方法    \n\n\n- extras（扩展信息）：扩展信息     \n是其它所有附加信息的集合。以键值对的形式放入Intent中    \n\n\n- Flags（标志位）：期望这个意图的运行模式      \n用于指定Activity与task之间的关系。\n\n### 三 Intent发现组件的两种方式\n   \nIntent启动组件有两种方式：显示启动和隐式启动。\n\n上面Intent的Intent的7个属性中，只有component属于显示启动，action，category，data皆为隐式启动。\n\n##### 1.显示启动\n\n代码示例：\n\n```java\n    button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  //创建一个意图对象\n                  Intent intent = new Intent();\n                  //创建组件，通过组件来响应\n                  ComponentName component = new ComponentName(MainActivity.this, SecondActivity.class);\n                  intent.setComponent(component);                \n                  startActivity(intent);                \n             }\n         });\n```\n\n如果写的简单一点，监听事件onClick()方法里可以这样写：\n\n```java\n      Intent intent = new Intent();\n      //setClass函数的第一个参数是一个Context对象\n      //Context是一个类，Activity是Context类的子类，也就是说，所有的Activity对象，都可以向上转型为Context对象\n      //setClass函数的第二个参数是一个Class对象，在当前场景下，应该传入需要被启动的Activity类的class对象\n      intent.setClass(MainActivity.this, SecondActivity.class);\n      startActivity(intent);    \n```\n\n再简单一点，可以这样写：（当然，也是最常见的写法）\n\n```java\n                 Intent intent = new Intent(MainActivity.this,SecondActivity.class);\n                 startActivity(intent);\n```\n\n##### 2.隐式启动\n\n- action\n\n在Androidmanifest.xml中定义\n\n```java\n         <activity \n             android:name=\".SecondActivity\">\n             <intent-filter>\n                  <action android:name=\"com.example.smyh006intent01.MY_ACTION\"/>\n                  <category android:name=\"android.intent.category.DEFAULT\" />\n             </intent-filter>            \n         </activity>\n```\n\njava代码调用\n\n```java\n          button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  //启动另一个Activity，（通过action属性进行查找）\n                  Intent intent = new Intent();\n                  //设置动作（实际action属性就是一个字符串标记而已）\n                  intent.setAction(\"com.example.smyh006intent01.MY_ACTION\"); //方法：Intent android.content.Intent.setAction(String action)\n                  startActivity(intent);        \n              }\n         });\n```\n\n上面代码也可简写成\n\n```java\n         button1.setOnClickListener(new OnClickListener() {            \n             @Override\n             public void onClick(View v) {\n                 //启动另一个Activity，（通过action属性进行查找）\n                 Intent intent = new Intent(\"com.example.smyh006intent01.MY_ACTION\");//方法： android.content.Intent.Intent(String action)                \n                 startActivity(intent);        \n             }\n         });\n```\n\n- action+categoty\n\nAndroidmanifest.xml文件：\n\n```java\n         <activity\n             android:name=\".SecondActivity\">\n             <intent-filter>\n                  <action android:name=\"com.example.smyh006intent01.MY_ACTION\"/>\n                  <category android:name=\"android.intent.category.DEFAULT\" />\n                  <category android:name=\"com.example.smyh006intent01.MY_CATEGORY\" />\n             </intent-filter>            \n         </activity>\n```\n\njava文件中：\n\n```java\n         button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  //启动另一个Activity，（通过action属性进行查找）\n                  Intent intent = new Intent();\n                  //设置动作（实际action属性就是一个字符串标记而已）\n                  intent.setAction(\"com.example.smyh006intent01.MY_ACTION\"); //方法：Intent android.content.Intent.setAction(String action)\n                  intent.addCategory(\"com.example.smyh006intent01.MY_CATEGORY\");\n                  startActivity(intent);        \n             }\n         });\n```\n\n- action+data\n\n示例：打开指定网页\n\n```java\n         <activity \n             android:name=\".SecondActivity\">\n             <intent-filter>\n                  <action android:name=\"android.intent.action.VIEW\" />\n                  <category android:name=\"android.intent.category.DEFAULT\" />\n                  <data android:scheme=\"http\" android:host=\"www.baidu.com\"/>                 \n             </intent-filter>            \n         </activity>\n```\n\njava文件中：\n\n```java\n          button1.setOnClickListener(new OnClickListener() {            \n              @Override\n              public void onClick(View v) {\n                  Intent intent = new Intent();\n                  intent.setAction(Intent.ACTION_VIEW);\n                  Uri data = Uri.parse(\"http://www.baidu.com\");\n                  intent.setData(data);                \n                  startActivity(intent);        \n              }\n         });\n```\n\n上面代码也可简写成：\n\n```java\n         button1.setOnClickListener(new OnClickListener() {            \n             @Override\n             public void onClick(View v) {\n                 Intent intent = new Intent(Intent.ACTION_VIEW);\n                 intent.setData(Uri.parse(\"http://www.baidu.com\"));                \n                 startActivity(intent);        \n             }\n         });\n```\n\n### 四 IntentFilter\n\nIntentFilter用于与Intent中的数据对比，来挑选出符合条件的组件。它分为静态注册（推荐）和动态注册两种方式。Intent与IntentFilter比较的步骤如下：\n\n1. 加载安装所有的IntentFilter到一个列表中\n2. 剔除所有action匹配失败的IntentFilter\n3. 剔除URI数据匹配失败的IntentFilter\n4. 剔除category匹配失败的IntentFilter\n5. 剩下的IntentFilter是否为0。是，查找失败，抛出异常；否将剩下的IntentFilter按优先级排列，返回优先级最高的IntentFilter\n\n代码示例：\n\n静态注册\n\n```java\n<receiver android:name=\".MyBroadCastReceiver\">  \n            <!-- android:priority属性是设置此接收者的优先级（从-1000到1000） -->\n            <intent-filter android:priority=\"20\">\n            <actionandroid:name=\"android.provider.Telephony.SMS_RECEIVED\"/>  \n            </intent-filter>  \n</receiver>\n```\n\n动态注册\n\n```java\nIntentFilter intentFilter = new IntentFilter(\"android.provider.Telephony.SMS_RECEIVED\");\n```\n\n\n### 五 总结","slug":"android基础之Intents与Intent-Filters","published":1,"updated":"2017-03-08T04:03:37.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk1t0015aknzibyq4z5p","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Intent是Android中组件之间传递消息的一种机制，这个组件可以是同一个应用程序的，也可以是不同的应用程序。Android四大组件中除了ContentProvider，其余三者皆可通过Intent来传递数据。而且Intent是一种运行时绑定机制。</p>\n<p>Intent在Android的三个组件中传递的机制是不同的：</p>\n<ul>\n<li>使用Context.startActivity() 或 Activity.startActivityForResult()，传入一个intent来启动一个activity。使用 Activity.setResult()，传入一个intent来从activity中返回结果。</li>\n<li>将intent对象传给Context.startService()来启动一个service或者传消息给一个运行的service。将intent对象传给 Context.bindService()来绑定一个service。</li>\n<li>将intent对象传给 Context.sendBroadcast()，Context.sendOrderedBroadcast()，或者Context.sendStickyBroadcast()等广播方法，则它们被传给 broadcast receiver。</li>\n</ul>\n<h3 id=\"二-Intent的结构\"><a href=\"#二-Intent的结构\" class=\"headerlink\" title=\"二 Intent的结构\"></a>二 Intent的结构</h3><p>Intent主要包含以下属性：</p>\n<ul>\n<li><p>component(组件)：目的组件<br>Component属性明确指定Intent的目标组件的类名称。（属于直接Intent）。组件的名字通过函数setComponent()、setClass()、setClassName()设置，通过函数读取getComponent()。   </p>\n</li>\n<li><p>action（动作）：用来表现意图的行动<br>Action主要用来描述应用程序的组件，一个组件可以用于多个action，也可以多个组件拥有同一个action。</p>\n</li>\n</ul>\n<ul>\n<li>category（类别）：用来表现动作的类别<br>category通常和Action放在一起用的，用于描述这个action。一个action可以包含多个categoty，必须所有的categoty都匹配成功才算是与这个action匹配成功。如果一个action只有一个默认的categoty DEFAULT，则不需向Intent中添加categoty，系统会自动添加。addCategory() 放置一个intent里的类别，removeCategory()删除之前添加的，getCategories()获取当前所有的类别。<br>类别越多，动作越具体，意图越明确    </li>\n</ul>\n<ul>\n<li>data（数据）：表示与动作要操纵的数据<br>Data属性是Android要访问的数据，和action和Category声明方式相同，也是在<intent-filter>中。多个组件匹配成功显示优先级高的； 相同显示列表。Data是用一个uri对象来表示的，uri代表数据的地址，属于一种标识符。通常情况下，我们使用action+data属性的组合来描述一个意图：做什么    </intent-filter></li>\n</ul>\n<ul>\n<li>type（数据类型）：对于data范例的描写<br>如果Intent对象中既包含Uri又包含Type，那么，在<intent-filter>中也必须二者都包含才能通过测试。Type属性用于明确指定Data属性的数据类型或MIME类型，但是通常来说，当Intent不指定Data属性时，Type属性才会起作用，否则Android系统将会根据Data属性值来分析数据的类型，所以无需指定Type属性。data和type属性一般只需要一个，通过setData方法会把type属性设置为null，相反设置setType方法会把data设置为null，如果想要两个属性同时设置，要使用Intent.setDataAndType()方法    </intent-filter></li>\n</ul>\n<ul>\n<li>extras（扩展信息）：扩展信息<br>是其它所有附加信息的集合。以键值对的形式放入Intent中    </li>\n</ul>\n<ul>\n<li>Flags（标志位）：期望这个意图的运行模式<br>用于指定Activity与task之间的关系。</li>\n</ul>\n<h3 id=\"三-Intent发现组件的两种方式\"><a href=\"#三-Intent发现组件的两种方式\" class=\"headerlink\" title=\"三 Intent发现组件的两种方式\"></a>三 Intent发现组件的两种方式</h3><p>Intent启动组件有两种方式：显示启动和隐式启动。</p>\n<p>上面Intent的Intent的7个属性中，只有component属于显示启动，action，category，data皆为隐式启动。</p>\n<h5 id=\"1-显示启动\"><a href=\"#1-显示启动\" class=\"headerlink\" title=\"1.显示启动\"></a>1.显示启动</h5><p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">          <span class=\"meta\">@Override</span></div><div class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">              <span class=\"comment\">//创建一个意图对象</span></div><div class=\"line\">              Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">              <span class=\"comment\">//创建组件，通过组件来响应</span></div><div class=\"line\">              ComponentName component = <span class=\"keyword\">new</span> ComponentName(MainActivity.<span class=\"keyword\">this</span>, SecondActivity.class);</div><div class=\"line\">              intent.setComponent(component);                </div><div class=\"line\">              startActivity(intent);                </div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;);</div></pre></td></tr></table></figure>\n<p>如果写的简单一点，监听事件onClick()方法里可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\"><span class=\"comment\">//setClass函数的第一个参数是一个Context对象</span></div><div class=\"line\"><span class=\"comment\">//Context是一个类，Activity是Context类的子类，也就是说，所有的Activity对象，都可以向上转型为Context对象</span></div><div class=\"line\"><span class=\"comment\">//setClass函数的第二个参数是一个Class对象，在当前场景下，应该传入需要被启动的Activity类的class对象</span></div><div class=\"line\">intent.setClass(MainActivity.<span class=\"keyword\">this</span>, SecondActivity.class);</div><div class=\"line\">startActivity(intent);</div></pre></td></tr></table></figure>\n<p>再简单一点，可以这样写：（当然，也是最常见的写法）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(MainActivity.<span class=\"keyword\">this</span>,SecondActivity.class);</div><div class=\"line\">startActivity(intent);</div></pre></td></tr></table></figure>\n<h5 id=\"2-隐式启动\"><a href=\"#2-隐式启动\" class=\"headerlink\" title=\"2.隐式启动\"></a>2.隐式启动</h5><ul>\n<li>action</li>\n</ul>\n<p>在Androidmanifest.xml中定义</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;activity </div><div class=\"line\">    android:name=\".SecondActivity\"&gt;</div><div class=\"line\">    &lt;intent-filter&gt;</div><div class=\"line\">         &lt;action android:name=\"com.example.smyh006intent01.MY_ACTION\"/&gt;</div><div class=\"line\">         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</div><div class=\"line\">    &lt;/intent-filter&gt;            </div><div class=\"line\">&lt;/activity&gt;</div></pre></td></tr></table></figure>\n<p>java代码调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">         <span class=\"comment\">//启动另一个Activity，（通过action属性进行查找）</span></div><div class=\"line\">         Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">         <span class=\"comment\">//设置动作（实际action属性就是一个字符串标记而已）</span></div><div class=\"line\">         intent.setAction(<span class=\"string\">\"com.example.smyh006intent01.MY_ACTION\"</span>); <span class=\"comment\">//方法：Intent android.content.Intent.setAction(String action)</span></div><div class=\"line\">         startActivity(intent);        </div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>上面代码也可简写成</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//启动另一个Activity，（通过action属性进行查找）</span></div><div class=\"line\">        Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"string\">\"com.example.smyh006intent01.MY_ACTION\"</span>);<span class=\"comment\">//方法： android.content.Intent.Intent(String action)                </span></div><div class=\"line\">        startActivity(intent);        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>action+categoty</li>\n</ul>\n<p>Androidmanifest.xml文件：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;activity</div><div class=\"line\">    android:name=\".SecondActivity\"&gt;</div><div class=\"line\">    &lt;intent-filter&gt;</div><div class=\"line\">         &lt;action android:name=\"com.example.smyh006intent01.MY_ACTION\"/&gt;</div><div class=\"line\">         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</div><div class=\"line\">         &lt;category android:name=\"com.example.smyh006intent01.MY_CATEGORY\" /&gt;</div><div class=\"line\">    &lt;/intent-filter&gt;            </div><div class=\"line\">&lt;/activity&gt;</div></pre></td></tr></table></figure>\n<p>java文件中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">         <span class=\"comment\">//启动另一个Activity，（通过action属性进行查找）</span></div><div class=\"line\">         Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">         <span class=\"comment\">//设置动作（实际action属性就是一个字符串标记而已）</span></div><div class=\"line\">         intent.setAction(<span class=\"string\">\"com.example.smyh006intent01.MY_ACTION\"</span>); <span class=\"comment\">//方法：Intent android.content.Intent.setAction(String action)</span></div><div class=\"line\">         intent.addCategory(<span class=\"string\">\"com.example.smyh006intent01.MY_CATEGORY\"</span>);</div><div class=\"line\">         startActivity(intent);        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>action+data</li>\n</ul>\n<p>示例：打开指定网页</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;activity </div><div class=\"line\">    android:name=\".SecondActivity\"&gt;</div><div class=\"line\">    &lt;intent-filter&gt;</div><div class=\"line\">         &lt;action android:name=\"android.intent.action.VIEW\" /&gt;</div><div class=\"line\">         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</div><div class=\"line\">         &lt;data android:scheme=\"http\" android:host=\"www.baidu.com\"/&gt;                 </div><div class=\"line\">    &lt;/intent-filter&gt;            </div><div class=\"line\">&lt;/activity&gt;</div></pre></td></tr></table></figure>\n<p>java文件中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">         Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">         intent.setAction(Intent.ACTION_VIEW);</div><div class=\"line\">         Uri data = Uri.parse(<span class=\"string\">\"http://www.baidu.com\"</span>);</div><div class=\"line\">         intent.setData(data);                </div><div class=\"line\">         startActivity(intent);        </div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>上面代码也可简写成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">        Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_VIEW);</div><div class=\"line\">        intent.setData(Uri.parse(<span class=\"string\">\"http://www.baidu.com\"</span>));                </div><div class=\"line\">        startActivity(intent);        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"四-IntentFilter\"><a href=\"#四-IntentFilter\" class=\"headerlink\" title=\"四 IntentFilter\"></a>四 IntentFilter</h3><p>IntentFilter用于与Intent中的数据对比，来挑选出符合条件的组件。它分为静态注册（推荐）和动态注册两种方式。Intent与IntentFilter比较的步骤如下：</p>\n<ol>\n<li>加载安装所有的IntentFilter到一个列表中</li>\n<li>剔除所有action匹配失败的IntentFilter</li>\n<li>剔除URI数据匹配失败的IntentFilter</li>\n<li>剔除category匹配失败的IntentFilter</li>\n<li>剩下的IntentFilter是否为0。是，查找失败，抛出异常；否将剩下的IntentFilter按优先级排列，返回优先级最高的IntentFilter</li>\n</ol>\n<p>代码示例：</p>\n<p>静态注册</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;receiver android:name=\".MyBroadCastReceiver\"&gt;  </div><div class=\"line\">            &lt;!-- android:priority属性是设置此接收者的优先级（从-1000到1000） --&gt;</div><div class=\"line\">            &lt;intent-filter android:priority=\"20\"&gt;</div><div class=\"line\">            &lt;actionandroid:name=\"android.provider.Telephony.SMS_RECEIVED\"/&gt;  </div><div class=\"line\">            &lt;/intent-filter&gt;  </div><div class=\"line\">&lt;/receiver&gt;</div></pre></td></tr></table></figure>\n<p>动态注册</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">IntentFilter intentFilter = <span class=\"keyword\">new</span> IntentFilter(<span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span>);</div></pre></td></tr></table></figure>\n<h3 id=\"五-总结\"><a href=\"#五-总结\" class=\"headerlink\" title=\"五 总结\"></a>五 总结</h3>","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Intent是Android中组件之间传递消息的一种机制，这个组件可以是同一个应用程序的，也可以是不同的应用程序。Android四大组件中除了ContentProvider，其余三者皆可通过Intent来传递数据。而且Intent是一种运行时绑定机制。</p>\n<p>Intent在Android的三个组件中传递的机制是不同的：</p>\n<ul>\n<li>使用Context.startActivity() 或 Activity.startActivityForResult()，传入一个intent来启动一个activity。使用 Activity.setResult()，传入一个intent来从activity中返回结果。</li>\n<li>将intent对象传给Context.startService()来启动一个service或者传消息给一个运行的service。将intent对象传给 Context.bindService()来绑定一个service。</li>\n<li>将intent对象传给 Context.sendBroadcast()，Context.sendOrderedBroadcast()，或者Context.sendStickyBroadcast()等广播方法，则它们被传给 broadcast receiver。</li>\n</ul>\n<h3 id=\"二-Intent的结构\"><a href=\"#二-Intent的结构\" class=\"headerlink\" title=\"二 Intent的结构\"></a>二 Intent的结构</h3><p>Intent主要包含以下属性：</p>\n<ul>\n<li><p>component(组件)：目的组件<br>Component属性明确指定Intent的目标组件的类名称。（属于直接Intent）。组件的名字通过函数setComponent()、setClass()、setClassName()设置，通过函数读取getComponent()。   </p>\n</li>\n<li><p>action（动作）：用来表现意图的行动<br>Action主要用来描述应用程序的组件，一个组件可以用于多个action，也可以多个组件拥有同一个action。</p>\n</li>\n</ul>\n<ul>\n<li>category（类别）：用来表现动作的类别<br>category通常和Action放在一起用的，用于描述这个action。一个action可以包含多个categoty，必须所有的categoty都匹配成功才算是与这个action匹配成功。如果一个action只有一个默认的categoty DEFAULT，则不需向Intent中添加categoty，系统会自动添加。addCategory() 放置一个intent里的类别，removeCategory()删除之前添加的，getCategories()获取当前所有的类别。<br>类别越多，动作越具体，意图越明确    </li>\n</ul>\n<ul>\n<li>data（数据）：表示与动作要操纵的数据<br>Data属性是Android要访问的数据，和action和Category声明方式相同，也是在<intent-filter>中。多个组件匹配成功显示优先级高的； 相同显示列表。Data是用一个uri对象来表示的，uri代表数据的地址，属于一种标识符。通常情况下，我们使用action+data属性的组合来描述一个意图：做什么    </li>\n</ul>\n<ul>\n<li>type（数据类型）：对于data范例的描写<br>如果Intent对象中既包含Uri又包含Type，那么，在<intent-filter>中也必须二者都包含才能通过测试。Type属性用于明确指定Data属性的数据类型或MIME类型，但是通常来说，当Intent不指定Data属性时，Type属性才会起作用，否则Android系统将会根据Data属性值来分析数据的类型，所以无需指定Type属性。data和type属性一般只需要一个，通过setData方法会把type属性设置为null，相反设置setType方法会把data设置为null，如果想要两个属性同时设置，要使用Intent.setDataAndType()方法    </li>\n</ul>\n<ul>\n<li>extras（扩展信息）：扩展信息<br>是其它所有附加信息的集合。以键值对的形式放入Intent中    </li>\n</ul>\n<ul>\n<li>Flags（标志位）：期望这个意图的运行模式<br>用于指定Activity与task之间的关系。</li>\n</ul>\n<h3 id=\"三-Intent发现组件的两种方式\"><a href=\"#三-Intent发现组件的两种方式\" class=\"headerlink\" title=\"三 Intent发现组件的两种方式\"></a>三 Intent发现组件的两种方式</h3><p>Intent启动组件有两种方式：显示启动和隐式启动。</p>\n<p>上面Intent的Intent的7个属性中，只有component属于显示启动，action，category，data皆为隐式启动。</p>\n<h5 id=\"1-显示启动\"><a href=\"#1-显示启动\" class=\"headerlink\" title=\"1.显示启动\"></a>1.显示启动</h5><p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">          <span class=\"meta\">@Override</span></div><div class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">              <span class=\"comment\">//创建一个意图对象</span></div><div class=\"line\">              Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">              <span class=\"comment\">//创建组件，通过组件来响应</span></div><div class=\"line\">              ComponentName component = <span class=\"keyword\">new</span> ComponentName(MainActivity.<span class=\"keyword\">this</span>, SecondActivity.class);</div><div class=\"line\">              intent.setComponent(component);                </div><div class=\"line\">              startActivity(intent);                </div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;);</div></pre></td></tr></table></figure>\n<p>如果写的简单一点，监听事件onClick()方法里可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\"><span class=\"comment\">//setClass函数的第一个参数是一个Context对象</span></div><div class=\"line\"><span class=\"comment\">//Context是一个类，Activity是Context类的子类，也就是说，所有的Activity对象，都可以向上转型为Context对象</span></div><div class=\"line\"><span class=\"comment\">//setClass函数的第二个参数是一个Class对象，在当前场景下，应该传入需要被启动的Activity类的class对象</span></div><div class=\"line\">intent.setClass(MainActivity.<span class=\"keyword\">this</span>, SecondActivity.class);</div><div class=\"line\">startActivity(intent);</div></pre></td></tr></table></figure>\n<p>再简单一点，可以这样写：（当然，也是最常见的写法）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(MainActivity.<span class=\"keyword\">this</span>,SecondActivity.class);</div><div class=\"line\">startActivity(intent);</div></pre></td></tr></table></figure>\n<h5 id=\"2-隐式启动\"><a href=\"#2-隐式启动\" class=\"headerlink\" title=\"2.隐式启动\"></a>2.隐式启动</h5><ul>\n<li>action</li>\n</ul>\n<p>在Androidmanifest.xml中定义</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;activity </div><div class=\"line\">    android:name=\".SecondActivity\"&gt;</div><div class=\"line\">    &lt;intent-filter&gt;</div><div class=\"line\">         &lt;action android:name=\"com.example.smyh006intent01.MY_ACTION\"/&gt;</div><div class=\"line\">         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</div><div class=\"line\">    &lt;/intent-filter&gt;            </div><div class=\"line\">&lt;/activity&gt;</div></pre></td></tr></table></figure>\n<p>java代码调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">         <span class=\"comment\">//启动另一个Activity，（通过action属性进行查找）</span></div><div class=\"line\">         Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">         <span class=\"comment\">//设置动作（实际action属性就是一个字符串标记而已）</span></div><div class=\"line\">         intent.setAction(<span class=\"string\">\"com.example.smyh006intent01.MY_ACTION\"</span>); <span class=\"comment\">//方法：Intent android.content.Intent.setAction(String action)</span></div><div class=\"line\">         startActivity(intent);        </div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>上面代码也可简写成</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//启动另一个Activity，（通过action属性进行查找）</span></div><div class=\"line\">        Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"string\">\"com.example.smyh006intent01.MY_ACTION\"</span>);<span class=\"comment\">//方法： android.content.Intent.Intent(String action)                </span></div><div class=\"line\">        startActivity(intent);        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>action+categoty</li>\n</ul>\n<p>Androidmanifest.xml文件：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;activity</div><div class=\"line\">    android:name=\".SecondActivity\"&gt;</div><div class=\"line\">    &lt;intent-filter&gt;</div><div class=\"line\">         &lt;action android:name=\"com.example.smyh006intent01.MY_ACTION\"/&gt;</div><div class=\"line\">         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</div><div class=\"line\">         &lt;category android:name=\"com.example.smyh006intent01.MY_CATEGORY\" /&gt;</div><div class=\"line\">    &lt;/intent-filter&gt;            </div><div class=\"line\">&lt;/activity&gt;</div></pre></td></tr></table></figure>\n<p>java文件中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">         <span class=\"comment\">//启动另一个Activity，（通过action属性进行查找）</span></div><div class=\"line\">         Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">         <span class=\"comment\">//设置动作（实际action属性就是一个字符串标记而已）</span></div><div class=\"line\">         intent.setAction(<span class=\"string\">\"com.example.smyh006intent01.MY_ACTION\"</span>); <span class=\"comment\">//方法：Intent android.content.Intent.setAction(String action)</span></div><div class=\"line\">         intent.addCategory(<span class=\"string\">\"com.example.smyh006intent01.MY_CATEGORY\"</span>);</div><div class=\"line\">         startActivity(intent);        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>action+data</li>\n</ul>\n<p>示例：打开指定网页</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;activity </div><div class=\"line\">    android:name=\".SecondActivity\"&gt;</div><div class=\"line\">    &lt;intent-filter&gt;</div><div class=\"line\">         &lt;action android:name=\"android.intent.action.VIEW\" /&gt;</div><div class=\"line\">         &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</div><div class=\"line\">         &lt;data android:scheme=\"http\" android:host=\"www.baidu.com\"/&gt;                 </div><div class=\"line\">    &lt;/intent-filter&gt;            </div><div class=\"line\">&lt;/activity&gt;</div></pre></td></tr></table></figure>\n<p>java文件中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">         Intent intent = <span class=\"keyword\">new</span> Intent();</div><div class=\"line\">         intent.setAction(Intent.ACTION_VIEW);</div><div class=\"line\">         Uri data = Uri.parse(<span class=\"string\">\"http://www.baidu.com\"</span>);</div><div class=\"line\">         intent.setData(data);                </div><div class=\"line\">         startActivity(intent);        </div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>上面代码也可简写成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">button1.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;            </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">        Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_VIEW);</div><div class=\"line\">        intent.setData(Uri.parse(<span class=\"string\">\"http://www.baidu.com\"</span>));                </div><div class=\"line\">        startActivity(intent);        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"四-IntentFilter\"><a href=\"#四-IntentFilter\" class=\"headerlink\" title=\"四 IntentFilter\"></a>四 IntentFilter</h3><p>IntentFilter用于与Intent中的数据对比，来挑选出符合条件的组件。它分为静态注册（推荐）和动态注册两种方式。Intent与IntentFilter比较的步骤如下：</p>\n<ol>\n<li>加载安装所有的IntentFilter到一个列表中</li>\n<li>剔除所有action匹配失败的IntentFilter</li>\n<li>剔除URI数据匹配失败的IntentFilter</li>\n<li>剔除category匹配失败的IntentFilter</li>\n<li>剩下的IntentFilter是否为0。是，查找失败，抛出异常；否将剩下的IntentFilter按优先级排列，返回优先级最高的IntentFilter</li>\n</ol>\n<p>代码示例：</p>\n<p>静态注册</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;receiver android:name=\".MyBroadCastReceiver\"&gt;  </div><div class=\"line\">            &lt;!-- android:priority属性是设置此接收者的优先级（从-1000到1000） --&gt;</div><div class=\"line\">            &lt;intent-filter android:priority=\"20\"&gt;</div><div class=\"line\">            &lt;actionandroid:name=\"android.provider.Telephony.SMS_RECEIVED\"/&gt;  </div><div class=\"line\">            &lt;/intent-filter&gt;  </div><div class=\"line\">&lt;/receiver&gt;</div></pre></td></tr></table></figure>\n<p>动态注册</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">IntentFilter intentFilter = <span class=\"keyword\">new</span> IntentFilter(<span class=\"string\">\"android.provider.Telephony.SMS_RECEIVED\"</span>);</div></pre></td></tr></table></figure>\n<h3 id=\"五-总结\"><a href=\"#五-总结\" class=\"headerlink\" title=\"五 总结\"></a>五 总结</h3>"},{"title":"android基础之SQLite","date":"2017-02-28T10:03:32.000Z","_content":"\n### 一 概述\n\nSQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的SQL数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。从Android1.5开始，Android就自带SQLite数据库了。\n\n### 二 特性\n\n1. ACID事务 　\n2. 零配置 – 无需安装和管理配置 \n3. 储存在单一磁盘文件中的一个完整的数据库\n4. 数据库文件可以在不同字节顺序的机器间自由的共享\n5. 支持数据库大小至2TB\n6. 足够小, 大致3万行C代码, 250K\n7. 比一些流行的数据库在大部分普通数据库操作要快\n8. 简单, 轻松的API\n9. 包含TCL绑定, 同时通过Wrapper支持其他语言的绑定\n10. 良好注释的源代码, 并且有着90%以上的测试覆盖率  \n11. 独立: 没有额外依赖\n12. Source完全的Open, 你可以用于任何用途, 包括出售它\n13. 支持多种开发语言，C，PHP，Perl，Java，ASP.NET，Python　　\n\n### 在Android中使用SQLite\n\nActivites 可以通过 Content Provider 或者 Service 访问一个数据库。\n\n##### 1.创建数据库\n\nAndroid 不自动提供数据库。在 Android 应用程序中使用 SQLite，必须自己创建数据库，然后创建表、索引，填充数据。Android 提供了 SQLiteOpenHelper 帮助你创建一个数据库，你只要继承 SQLiteOpenHelper 类根据开发应用程序的需要，封装创建和更新数据库使用的逻辑就行了。　 \n\nSQLiteOpenHelper 的子类，至少需要实现三个方法：\n\n```java\npublic class DatabaseHelper extends SQLiteOpenHelper {\n\n    /**\n     * @param context  上下文环境（例如，一个 Activity）\n     * @param name   数据库名字\n     * @param factory  一个可选的游标工厂（通常是 Null）\n     * @param version  数据库模型版本的整数\n     * \n     * 会调用父类 SQLiteOpenHelper的构造函数\n     */ \n    public DatabaseHelper(Context context, String name, CursorFactory factory, int version) {\n        super(context, name, factory, version);\n\n    }\n\n    /**\n     *  在数据库第一次创建的时候会调用这个方法\n     *  \n     *根据需要对传入的SQLiteDatabase 对象填充表和初始化数据。\n     */\n    @Override\n    public void onCreate(SQLiteDatabase db) {\n\n    }\n\n    /**\n     * 当数据库需要修改的时候（两个数据库版本不同），Android系统会主动的调用这个方法。\n     * 一般我们在这个方法里边删除数据库表，并建立新的数据库表.\n     */\n    @Override\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n        //三个参数，一个 SQLiteDatabase 对象，一个旧的版本号和一个新的版本号\n\n    }\n\n    @Override\n    public void onOpen(SQLiteDatabase db) {\n        // 每次成功打开数据库后首先被执行\n        super.onOpen(db);\n    }\n}\n```\n\n继承SQLiteOpenHelper之后就拥有了以下两个方法：\n\n- getReadableDatabase() 　创建或者打开一个查询数据库\n- getWritableDatabase()　创建或者打开一个可写数据库\n\n创建一个数据库代码示例：\n\n```java\nDatabaseHelper database = new DatabaseHelper(context);//传入一个上下文参数\nSQLiteDatabase db = null;\ndb = database.getWritableDatabase();\n```\n\n上面这段代码会返回一个 SQLiteDatabase 类的实例，使用这个对象，你就可以查询或者修改数据库。SQLiteDatabase类为我们提供了很多种方法，而较常用的方法如下：\n\n删除数据行\n\n```java\n(int) delete(String table,String whereClause,String[] whereArgs)\n```\n\n添加数据行\n\n```java\n(long) insert(String table,String nullColumnHack,ContentValues values)\n```\n\n更新数据行\n\n```java\n(int) update(String table, ContentValues values, String whereClause, String[] whereArgs)\n```\n\n执行一个SQL语句，可以是一个select或其他的sql语句(没有返回值的sql语句)\n\n```java\n(void) execSQL(String sql)\n```\n\n关闭数据库\n\n```java\n(void) close()\n```\n\n查询指定的数据表返回一个带游标的数据集。\n\n```java\n/*各参数说明： table：表名称 colums：列名称数组 selection：条件子句，相当于where selectionArgs：条件//*语句的参数数组 groupBy：分组 having：分组条件 orderBy：排序类 limit：分页查询的限制 Cursor：返回值，相*当于结果集ResultSet*/\n(Cursor) query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit)\n```\n\n运行一个预置的SQL语句，返回带游标的数据集（与上面的语句最大的区别就是防止SQL注入）\n\n```java\n(Cursor) rawQuery(String sql, String[] selectionArgs)\n```\n\n当你完成了对数据库的操作（例如你的 Activity 已经关闭），需要调用 SQLiteDatabase 的 Close() 方法来释放掉数据库连接。\n\n##### 2.创建表和索引\n\n为了创建表和索引，需要调用 SQLiteDatabase 的 execSQL() 方法来执行 DDL 语句。如果没有异常，这个方法没有返回值。 　　\n\n例如，你可以执行如下代码：\n\n```java\n db.execSQL(\"CREATE TABLE user(_id INTEGER PRIMARY KEY   \n        AUTOINCREMENT, username TEXT, password TEXT);\");\n```\n\n这条语句会创建一个名为 user的表，表有一个列名为 _id，并且是主键，这列的值是会自动增长的整数。另外还有两列：username( 字符 ) 和 password( 字符 )。 SQLite 会自动为主键列创建索引。 　　\n\n通常情况下，第一次创建数据库时创建了表和索引。要 删除表和索引，需要使用 execSQL() 方法调用 DROP INDEX 和 DROP TABLE 语句。\n\n##### 3.添加数据\n\n有两种方法可以给表添加数据。\n\na. 可以使用 execSQL() 方法执行 INSERT, UPDATE, DELETE 等语句来更新表的数据。execSQL() 方法适用于所有不返回结果的 SQL 语句。例如：\n\n```java\nString sql = \"insert into user(username,password) values ('finch','123456');//插入操作的SQL语句\ndb.execSQL(sql);//执行SQL语句\n```\n\nb. 使用 SQLiteDatabase 对象的 insert()。\n\n```java\nContentValues cv = new ContentValues();\ncv.put(\"username\",\"finch\");//添加用户名\ncv.put(\"password\",\"123456\"); //添加密码\ndb.insert(\"user\",null,cv);//执行插入操作\n```\n\n##### 4.更新数据\n\na. 使用execSQL方式的实现\n\n```java\nString sql = \"update [user] set password = '654321' where username=\"finch\";//修改的SQL语句\ndb.execSQL(sql);//执行修改\n```\n\nb.使用SQLiteDatabase 对象的 update()方法。\n\n```java\nContentValues cv = new ContentValues();\ncv.put(\"password\",\"654321\");//添加要更改的字段及内容\nString whereClause = \"username=?\";//修改条件\nString[] whereArgs = {\"finch\"};//修改条件的参数\ndb.update(\"user\",cv,whereClause,whereArgs);//执行修改\n```\n\n该方法有四个参数：表名、列名和值的 ContentValues 对象、可选的 WHERE 条件、可选的填充 WHERE 语句的字符串，这些字符串会替换 WHERE 条件中的“？”标记，update() 根据条件，更新指定列的值。\n\n##### 5.删除数据\n\n使用execSQL方式的实现\n\n```java\nString sql = \"delete from user where username=\"finch\";//删除操作的SQL语句\ndb.execSQL(sql);//执行删除操作\n```\n\n使用SQLiteDatabase 对象的delete()方法\n\n```java\nString whereClause = \"username=?\";//删除的条件\nString[] whereArgs = {\"finch\"};//删除的条件参数\ndb.delete(\"user\",whereClause,whereArgs);//执行删除\n```\n\n##### 6.查询数据\n\n使用 rawQuery() 直接调用 SELECT 语句\n\n```java\nCursor c = db.rawQuery(\"select * from user where username=?\",new Stirng[]{\"finch\"});\n\nif(cursor.moveToFirst()) {\n    String password = c.getString(c.getColumnIndex(\"password\"));\n}\n```\n\n返回值是一个 cursor 对象，这个对象的方法可以迭代查询结果。 如果查询是动态的，使用这个方法就会非常复杂。例如，当你需要查询的列在程序编译的时候不能确定，这时候使用 query() 方法会方便很多。\n\n通过query实现查询\n\nquery() 方法用 SELECT 语句段构建查询。 　　SELECT 语句内容作为 query() 方法的参数，比如：要查询的表名，要获取的字段名，WHERE 条件，包含可选的位置参数，去替代 WHERE 条件中位置参数的值，GROUP BY 条件，HAVING 条件。 　　除了表名，其他参数可以是 null。所以代码可写成：\n\n```java\nCursor c = db.query(\"user\",null,null,null,null,null,null);//查询并获得游标\nif(c.moveToFirst()){//判断游标是否为空\n    for(int i=0;i<c.getCount();i++){　\nc.move(i);//移动到指定记录\nString username = c.getString(c.getColumnIndex(\"username\");\nString password = c.getString(c.getColumnIndex(\"password\"));\n    }\n}\n```\n\n##### 7.使用游标\n\n不管你如何执行查询，都会返回一个 Cursor，这是 Android 的 SQLite 数据库游标，使用游标，你可以：\n\n- 通过使用 getCount() 方法得到结果集中有多少记录；　\n- 通过 moveToFirst(), moveToNext(), 和 isAfterLast() 方法遍历所有记录；\n- 通过 getColumnNames() 得到字段名；\n- 通过 getColumnIndex() 转换成字段号；\n- 通过 getString()，getInt() 等方法得到给定字段当前记录的值；\n- 通过 requery() 方法重新执行查询得到游标；\n- 通过 close() 方法释放游标资源；\n\n例如，下面代码遍历 user表:\n\n```java\nCursor result=db.rawQuery(\"SELECT _id, username, password FROM user\"); \n    result.moveToFirst(); \n    while (!result.isAfterLast()) { \n        int id=result.getInt(0); \n        String name=result.getString(1); \n        String password =result.getString(2); \n        // do something useful with these \n        result.moveToNext(); \n      } \n      result.close();\n```\n\n### 总结\n\n\n","source":"_posts/android基础之SQLite.md","raw":"---\ntitle: android基础之SQLite\ndate: 2017-02-28 18:03:32\ncategories: android\ntags:\n- android\n- java\n- SQLite\n---\n\n### 一 概述\n\nSQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的SQL数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。从Android1.5开始，Android就自带SQLite数据库了。\n\n### 二 特性\n\n1. ACID事务 　\n2. 零配置 – 无需安装和管理配置 \n3. 储存在单一磁盘文件中的一个完整的数据库\n4. 数据库文件可以在不同字节顺序的机器间自由的共享\n5. 支持数据库大小至2TB\n6. 足够小, 大致3万行C代码, 250K\n7. 比一些流行的数据库在大部分普通数据库操作要快\n8. 简单, 轻松的API\n9. 包含TCL绑定, 同时通过Wrapper支持其他语言的绑定\n10. 良好注释的源代码, 并且有着90%以上的测试覆盖率  \n11. 独立: 没有额外依赖\n12. Source完全的Open, 你可以用于任何用途, 包括出售它\n13. 支持多种开发语言，C，PHP，Perl，Java，ASP.NET，Python　　\n\n### 在Android中使用SQLite\n\nActivites 可以通过 Content Provider 或者 Service 访问一个数据库。\n\n##### 1.创建数据库\n\nAndroid 不自动提供数据库。在 Android 应用程序中使用 SQLite，必须自己创建数据库，然后创建表、索引，填充数据。Android 提供了 SQLiteOpenHelper 帮助你创建一个数据库，你只要继承 SQLiteOpenHelper 类根据开发应用程序的需要，封装创建和更新数据库使用的逻辑就行了。　 \n\nSQLiteOpenHelper 的子类，至少需要实现三个方法：\n\n```java\npublic class DatabaseHelper extends SQLiteOpenHelper {\n\n    /**\n     * @param context  上下文环境（例如，一个 Activity）\n     * @param name   数据库名字\n     * @param factory  一个可选的游标工厂（通常是 Null）\n     * @param version  数据库模型版本的整数\n     * \n     * 会调用父类 SQLiteOpenHelper的构造函数\n     */ \n    public DatabaseHelper(Context context, String name, CursorFactory factory, int version) {\n        super(context, name, factory, version);\n\n    }\n\n    /**\n     *  在数据库第一次创建的时候会调用这个方法\n     *  \n     *根据需要对传入的SQLiteDatabase 对象填充表和初始化数据。\n     */\n    @Override\n    public void onCreate(SQLiteDatabase db) {\n\n    }\n\n    /**\n     * 当数据库需要修改的时候（两个数据库版本不同），Android系统会主动的调用这个方法。\n     * 一般我们在这个方法里边删除数据库表，并建立新的数据库表.\n     */\n    @Override\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n        //三个参数，一个 SQLiteDatabase 对象，一个旧的版本号和一个新的版本号\n\n    }\n\n    @Override\n    public void onOpen(SQLiteDatabase db) {\n        // 每次成功打开数据库后首先被执行\n        super.onOpen(db);\n    }\n}\n```\n\n继承SQLiteOpenHelper之后就拥有了以下两个方法：\n\n- getReadableDatabase() 　创建或者打开一个查询数据库\n- getWritableDatabase()　创建或者打开一个可写数据库\n\n创建一个数据库代码示例：\n\n```java\nDatabaseHelper database = new DatabaseHelper(context);//传入一个上下文参数\nSQLiteDatabase db = null;\ndb = database.getWritableDatabase();\n```\n\n上面这段代码会返回一个 SQLiteDatabase 类的实例，使用这个对象，你就可以查询或者修改数据库。SQLiteDatabase类为我们提供了很多种方法，而较常用的方法如下：\n\n删除数据行\n\n```java\n(int) delete(String table,String whereClause,String[] whereArgs)\n```\n\n添加数据行\n\n```java\n(long) insert(String table,String nullColumnHack,ContentValues values)\n```\n\n更新数据行\n\n```java\n(int) update(String table, ContentValues values, String whereClause, String[] whereArgs)\n```\n\n执行一个SQL语句，可以是一个select或其他的sql语句(没有返回值的sql语句)\n\n```java\n(void) execSQL(String sql)\n```\n\n关闭数据库\n\n```java\n(void) close()\n```\n\n查询指定的数据表返回一个带游标的数据集。\n\n```java\n/*各参数说明： table：表名称 colums：列名称数组 selection：条件子句，相当于where selectionArgs：条件//*语句的参数数组 groupBy：分组 having：分组条件 orderBy：排序类 limit：分页查询的限制 Cursor：返回值，相*当于结果集ResultSet*/\n(Cursor) query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit)\n```\n\n运行一个预置的SQL语句，返回带游标的数据集（与上面的语句最大的区别就是防止SQL注入）\n\n```java\n(Cursor) rawQuery(String sql, String[] selectionArgs)\n```\n\n当你完成了对数据库的操作（例如你的 Activity 已经关闭），需要调用 SQLiteDatabase 的 Close() 方法来释放掉数据库连接。\n\n##### 2.创建表和索引\n\n为了创建表和索引，需要调用 SQLiteDatabase 的 execSQL() 方法来执行 DDL 语句。如果没有异常，这个方法没有返回值。 　　\n\n例如，你可以执行如下代码：\n\n```java\n db.execSQL(\"CREATE TABLE user(_id INTEGER PRIMARY KEY   \n        AUTOINCREMENT, username TEXT, password TEXT);\");\n```\n\n这条语句会创建一个名为 user的表，表有一个列名为 _id，并且是主键，这列的值是会自动增长的整数。另外还有两列：username( 字符 ) 和 password( 字符 )。 SQLite 会自动为主键列创建索引。 　　\n\n通常情况下，第一次创建数据库时创建了表和索引。要 删除表和索引，需要使用 execSQL() 方法调用 DROP INDEX 和 DROP TABLE 语句。\n\n##### 3.添加数据\n\n有两种方法可以给表添加数据。\n\na. 可以使用 execSQL() 方法执行 INSERT, UPDATE, DELETE 等语句来更新表的数据。execSQL() 方法适用于所有不返回结果的 SQL 语句。例如：\n\n```java\nString sql = \"insert into user(username,password) values ('finch','123456');//插入操作的SQL语句\ndb.execSQL(sql);//执行SQL语句\n```\n\nb. 使用 SQLiteDatabase 对象的 insert()。\n\n```java\nContentValues cv = new ContentValues();\ncv.put(\"username\",\"finch\");//添加用户名\ncv.put(\"password\",\"123456\"); //添加密码\ndb.insert(\"user\",null,cv);//执行插入操作\n```\n\n##### 4.更新数据\n\na. 使用execSQL方式的实现\n\n```java\nString sql = \"update [user] set password = '654321' where username=\"finch\";//修改的SQL语句\ndb.execSQL(sql);//执行修改\n```\n\nb.使用SQLiteDatabase 对象的 update()方法。\n\n```java\nContentValues cv = new ContentValues();\ncv.put(\"password\",\"654321\");//添加要更改的字段及内容\nString whereClause = \"username=?\";//修改条件\nString[] whereArgs = {\"finch\"};//修改条件的参数\ndb.update(\"user\",cv,whereClause,whereArgs);//执行修改\n```\n\n该方法有四个参数：表名、列名和值的 ContentValues 对象、可选的 WHERE 条件、可选的填充 WHERE 语句的字符串，这些字符串会替换 WHERE 条件中的“？”标记，update() 根据条件，更新指定列的值。\n\n##### 5.删除数据\n\n使用execSQL方式的实现\n\n```java\nString sql = \"delete from user where username=\"finch\";//删除操作的SQL语句\ndb.execSQL(sql);//执行删除操作\n```\n\n使用SQLiteDatabase 对象的delete()方法\n\n```java\nString whereClause = \"username=?\";//删除的条件\nString[] whereArgs = {\"finch\"};//删除的条件参数\ndb.delete(\"user\",whereClause,whereArgs);//执行删除\n```\n\n##### 6.查询数据\n\n使用 rawQuery() 直接调用 SELECT 语句\n\n```java\nCursor c = db.rawQuery(\"select * from user where username=?\",new Stirng[]{\"finch\"});\n\nif(cursor.moveToFirst()) {\n    String password = c.getString(c.getColumnIndex(\"password\"));\n}\n```\n\n返回值是一个 cursor 对象，这个对象的方法可以迭代查询结果。 如果查询是动态的，使用这个方法就会非常复杂。例如，当你需要查询的列在程序编译的时候不能确定，这时候使用 query() 方法会方便很多。\n\n通过query实现查询\n\nquery() 方法用 SELECT 语句段构建查询。 　　SELECT 语句内容作为 query() 方法的参数，比如：要查询的表名，要获取的字段名，WHERE 条件，包含可选的位置参数，去替代 WHERE 条件中位置参数的值，GROUP BY 条件，HAVING 条件。 　　除了表名，其他参数可以是 null。所以代码可写成：\n\n```java\nCursor c = db.query(\"user\",null,null,null,null,null,null);//查询并获得游标\nif(c.moveToFirst()){//判断游标是否为空\n    for(int i=0;i<c.getCount();i++){　\nc.move(i);//移动到指定记录\nString username = c.getString(c.getColumnIndex(\"username\");\nString password = c.getString(c.getColumnIndex(\"password\"));\n    }\n}\n```\n\n##### 7.使用游标\n\n不管你如何执行查询，都会返回一个 Cursor，这是 Android 的 SQLite 数据库游标，使用游标，你可以：\n\n- 通过使用 getCount() 方法得到结果集中有多少记录；　\n- 通过 moveToFirst(), moveToNext(), 和 isAfterLast() 方法遍历所有记录；\n- 通过 getColumnNames() 得到字段名；\n- 通过 getColumnIndex() 转换成字段号；\n- 通过 getString()，getInt() 等方法得到给定字段当前记录的值；\n- 通过 requery() 方法重新执行查询得到游标；\n- 通过 close() 方法释放游标资源；\n\n例如，下面代码遍历 user表:\n\n```java\nCursor result=db.rawQuery(\"SELECT _id, username, password FROM user\"); \n    result.moveToFirst(); \n    while (!result.isAfterLast()) { \n        int id=result.getInt(0); \n        String name=result.getString(1); \n        String password =result.getString(2); \n        // do something useful with these \n        result.moveToNext(); \n      } \n      result.close();\n```\n\n### 总结\n\n\n","slug":"android基础之SQLite","published":1,"updated":"2017-03-08T08:14:38.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk1v0018aknzpsw0t5eu","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的SQL数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。从Android1.5开始，Android就自带SQLite数据库了。</p>\n<h3 id=\"二-特性\"><a href=\"#二-特性\" class=\"headerlink\" title=\"二 特性\"></a>二 特性</h3><ol>\n<li>ACID事务 　</li>\n<li>零配置 – 无需安装和管理配置 </li>\n<li>储存在单一磁盘文件中的一个完整的数据库</li>\n<li>数据库文件可以在不同字节顺序的机器间自由的共享</li>\n<li>支持数据库大小至2TB</li>\n<li>足够小, 大致3万行C代码, 250K</li>\n<li>比一些流行的数据库在大部分普通数据库操作要快</li>\n<li>简单, 轻松的API</li>\n<li>包含TCL绑定, 同时通过Wrapper支持其他语言的绑定</li>\n<li>良好注释的源代码, 并且有着90%以上的测试覆盖率  </li>\n<li>独立: 没有额外依赖</li>\n<li>Source完全的Open, 你可以用于任何用途, 包括出售它</li>\n<li>支持多种开发语言，C，PHP，Perl，Java，ASP.NET，Python　　</li>\n</ol>\n<h3 id=\"在Android中使用SQLite\"><a href=\"#在Android中使用SQLite\" class=\"headerlink\" title=\"在Android中使用SQLite\"></a>在Android中使用SQLite</h3><p>Activites 可以通过 Content Provider 或者 Service 访问一个数据库。</p>\n<h5 id=\"1-创建数据库\"><a href=\"#1-创建数据库\" class=\"headerlink\" title=\"1.创建数据库\"></a>1.创建数据库</h5><p>Android 不自动提供数据库。在 Android 应用程序中使用 SQLite，必须自己创建数据库，然后创建表、索引，填充数据。Android 提供了 SQLiteOpenHelper 帮助你创建一个数据库，你只要继承 SQLiteOpenHelper 类根据开发应用程序的需要，封装创建和更新数据库使用的逻辑就行了。　 </p>\n<p>SQLiteOpenHelper 的子类，至少需要实现三个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DatabaseHelper</span> <span class=\"keyword\">extends</span> <span class=\"title\">SQLiteOpenHelper</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * <span class=\"doctag\">@param</span> context  上下文环境（例如，一个 Activity）</div><div class=\"line\">     * <span class=\"doctag\">@param</span> name   数据库名字</div><div class=\"line\">     * <span class=\"doctag\">@param</span> factory  一个可选的游标工厂（通常是 Null）</div><div class=\"line\">     * <span class=\"doctag\">@param</span> version  数据库模型版本的整数</div><div class=\"line\">     * </div><div class=\"line\">     * 会调用父类 SQLiteOpenHelper的构造函数</div><div class=\"line\">     */ </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DatabaseHelper</span><span class=\"params\">(Context context, String name, CursorFactory factory, <span class=\"keyword\">int</span> version)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, name, factory, version);</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     *  在数据库第一次创建的时候会调用这个方法</div><div class=\"line\">     *  </div><div class=\"line\">     *根据需要对传入的SQLiteDatabase 对象填充表和初始化数据。</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(SQLiteDatabase db)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 当数据库需要修改的时候（两个数据库版本不同），Android系统会主动的调用这个方法。</div><div class=\"line\">     * 一般我们在这个方法里边删除数据库表，并建立新的数据库表.</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onUpgrade</span><span class=\"params\">(SQLiteDatabase db, <span class=\"keyword\">int</span> oldVersion, <span class=\"keyword\">int</span> newVersion)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//三个参数，一个 SQLiteDatabase 对象，一个旧的版本号和一个新的版本号</span></div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onOpen</span><span class=\"params\">(SQLiteDatabase db)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 每次成功打开数据库后首先被执行</span></div><div class=\"line\">        <span class=\"keyword\">super</span>.onOpen(db);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>继承SQLiteOpenHelper之后就拥有了以下两个方法：</p>\n<ul>\n<li>getReadableDatabase() 　创建或者打开一个查询数据库</li>\n<li>getWritableDatabase()　创建或者打开一个可写数据库</li>\n</ul>\n<p>创建一个数据库代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">DatabaseHelper database = <span class=\"keyword\">new</span> DatabaseHelper(context);<span class=\"comment\">//传入一个上下文参数</span></div><div class=\"line\">SQLiteDatabase db = <span class=\"keyword\">null</span>;</div><div class=\"line\">db = database.getWritableDatabase();</div></pre></td></tr></table></figure>\n<p>上面这段代码会返回一个 SQLiteDatabase 类的实例，使用这个对象，你就可以查询或者修改数据库。SQLiteDatabase类为我们提供了很多种方法，而较常用的方法如下：</p>\n<p>删除数据行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">int</span>) delete(String table,String whereClause,String[] whereArgs)</div></pre></td></tr></table></figure>\n<p>添加数据行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">long</span>) insert(String table,String nullColumnHack,ContentValues values)</div></pre></td></tr></table></figure>\n<p>更新数据行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">int</span>) update(String table, ContentValues values, String whereClause, String[] whereArgs)</div></pre></td></tr></table></figure>\n<p>执行一个SQL语句，可以是一个select或其他的sql语句(没有返回值的sql语句)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">void</span>) execSQL(String sql)</div></pre></td></tr></table></figure>\n<p>关闭数据库</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">void</span>) close()</div></pre></td></tr></table></figure>\n<p>查询指定的数据表返回一个带游标的数据集。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*各参数说明： table：表名称 colums：列名称数组 selection：条件子句，相当于where selectionArgs：条件//*语句的参数数组 groupBy：分组 having：分组条件 orderBy：排序类 limit：分页查询的限制 Cursor：返回值，相*当于结果集ResultSet*/</span></div><div class=\"line\">(Cursor) query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit)</div></pre></td></tr></table></figure>\n<p>运行一个预置的SQL语句，返回带游标的数据集（与上面的语句最大的区别就是防止SQL注入）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(Cursor) rawQuery(String sql, String[] selectionArgs)</div></pre></td></tr></table></figure>\n<p>当你完成了对数据库的操作（例如你的 Activity 已经关闭），需要调用 SQLiteDatabase 的 Close() 方法来释放掉数据库连接。</p>\n<h5 id=\"2-创建表和索引\"><a href=\"#2-创建表和索引\" class=\"headerlink\" title=\"2.创建表和索引\"></a>2.创建表和索引</h5><p>为了创建表和索引，需要调用 SQLiteDatabase 的 execSQL() 方法来执行 DDL 语句。如果没有异常，这个方法没有返回值。 　　</p>\n<p>例如，你可以执行如下代码：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">db.execSQL(\"CREATE TABLE user(_id INTEGER PRIMARY KEY   </div><div class=\"line\">       AUTOINCREMENT, username TEXT, password TEXT);\");</div></pre></td></tr></table></figure>\n<p>这条语句会创建一个名为 user的表，表有一个列名为 _id，并且是主键，这列的值是会自动增长的整数。另外还有两列：username( 字符 ) 和 password( 字符 )。 SQLite 会自动为主键列创建索引。 　　</p>\n<p>通常情况下，第一次创建数据库时创建了表和索引。要 删除表和索引，需要使用 execSQL() 方法调用 DROP INDEX 和 DROP TABLE 语句。</p>\n<h5 id=\"3-添加数据\"><a href=\"#3-添加数据\" class=\"headerlink\" title=\"3.添加数据\"></a>3.添加数据</h5><p>有两种方法可以给表添加数据。</p>\n<p>a. 可以使用 execSQL() 方法执行 INSERT, UPDATE, DELETE 等语句来更新表的数据。execSQL() 方法适用于所有不返回结果的 SQL 语句。例如：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">String sql = \"insert into user(username,password) values ('finch','123456');//插入操作的SQL语句</div><div class=\"line\">db.execSQL(sql);//执行SQL语句</div></pre></td></tr></table></figure>\n<p>b. 使用 SQLiteDatabase 对象的 insert()。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ContentValues cv = <span class=\"keyword\">new</span> ContentValues();</div><div class=\"line\">cv.put(<span class=\"string\">\"username\"</span>,<span class=\"string\">\"finch\"</span>);<span class=\"comment\">//添加用户名</span></div><div class=\"line\">cv.put(<span class=\"string\">\"password\"</span>,<span class=\"string\">\"123456\"</span>); <span class=\"comment\">//添加密码</span></div><div class=\"line\">db.insert(<span class=\"string\">\"user\"</span>,<span class=\"keyword\">null</span>,cv);<span class=\"comment\">//执行插入操作</span></div></pre></td></tr></table></figure>\n<h5 id=\"4-更新数据\"><a href=\"#4-更新数据\" class=\"headerlink\" title=\"4.更新数据\"></a>4.更新数据</h5><p>a. 使用execSQL方式的实现</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">String sql = \"update [user] set password = '654321' where username=\"finch\";//修改的SQL语句</div><div class=\"line\">db.execSQL(sql);//执行修改</div></pre></td></tr></table></figure>\n<p>b.使用SQLiteDatabase 对象的 update()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ContentValues cv = <span class=\"keyword\">new</span> ContentValues();</div><div class=\"line\">cv.put(<span class=\"string\">\"password\"</span>,<span class=\"string\">\"654321\"</span>);<span class=\"comment\">//添加要更改的字段及内容</span></div><div class=\"line\">String whereClause = <span class=\"string\">\"username=?\"</span>;<span class=\"comment\">//修改条件</span></div><div class=\"line\">String[] whereArgs = &#123;<span class=\"string\">\"finch\"</span>&#125;;<span class=\"comment\">//修改条件的参数</span></div><div class=\"line\">db.update(<span class=\"string\">\"user\"</span>,cv,whereClause,whereArgs);<span class=\"comment\">//执行修改</span></div></pre></td></tr></table></figure>\n<p>该方法有四个参数：表名、列名和值的 ContentValues 对象、可选的 WHERE 条件、可选的填充 WHERE 语句的字符串，这些字符串会替换 WHERE 条件中的“？”标记，update() 根据条件，更新指定列的值。</p>\n<h5 id=\"5-删除数据\"><a href=\"#5-删除数据\" class=\"headerlink\" title=\"5.删除数据\"></a>5.删除数据</h5><p>使用execSQL方式的实现</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">String sql = \"delete from user where username=\"finch\";//删除操作的SQL语句</div><div class=\"line\">db.execSQL(sql);//执行删除操作</div></pre></td></tr></table></figure>\n<p>使用SQLiteDatabase 对象的delete()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">String whereClause = <span class=\"string\">\"username=?\"</span>;<span class=\"comment\">//删除的条件</span></div><div class=\"line\">String[] whereArgs = &#123;<span class=\"string\">\"finch\"</span>&#125;;<span class=\"comment\">//删除的条件参数</span></div><div class=\"line\">db.delete(<span class=\"string\">\"user\"</span>,whereClause,whereArgs);<span class=\"comment\">//执行删除</span></div></pre></td></tr></table></figure>\n<h5 id=\"6-查询数据\"><a href=\"#6-查询数据\" class=\"headerlink\" title=\"6.查询数据\"></a>6.查询数据</h5><p>使用 rawQuery() 直接调用 SELECT 语句</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cursor c = db.rawQuery(<span class=\"string\">\"select * from user where username=?\"</span>,<span class=\"keyword\">new</span> Stirng[]&#123;<span class=\"string\">\"finch\"</span>&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span>(cursor.moveToFirst()) &#123;</div><div class=\"line\">    String password = c.getString(c.getColumnIndex(<span class=\"string\">\"password\"</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>返回值是一个 cursor 对象，这个对象的方法可以迭代查询结果。 如果查询是动态的，使用这个方法就会非常复杂。例如，当你需要查询的列在程序编译的时候不能确定，这时候使用 query() 方法会方便很多。</p>\n<p>通过query实现查询</p>\n<p>query() 方法用 SELECT 语句段构建查询。 　　SELECT 语句内容作为 query() 方法的参数，比如：要查询的表名，要获取的字段名，WHERE 条件，包含可选的位置参数，去替代 WHERE 条件中位置参数的值，GROUP BY 条件，HAVING 条件。 　　除了表名，其他参数可以是 null。所以代码可写成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cursor c = db.query(<span class=\"string\">\"user\"</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>);<span class=\"comment\">//查询并获得游标</span></div><div class=\"line\"><span class=\"keyword\">if</span>(c.moveToFirst())&#123;<span class=\"comment\">//判断游标是否为空</span></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;c.getCount();i++)&#123;　</div><div class=\"line\">c.move(i);<span class=\"comment\">//移动到指定记录</span></div><div class=\"line\">String username = c.getString(c.getColumnIndex(<span class=\"string\">\"username\"</span>);</div><div class=\"line\">String password = c.getString(c.getColumnIndex(<span class=\"string\">\"password\"</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"7-使用游标\"><a href=\"#7-使用游标\" class=\"headerlink\" title=\"7.使用游标\"></a>7.使用游标</h5><p>不管你如何执行查询，都会返回一个 Cursor，这是 Android 的 SQLite 数据库游标，使用游标，你可以：</p>\n<ul>\n<li>通过使用 getCount() 方法得到结果集中有多少记录；　</li>\n<li>通过 moveToFirst(), moveToNext(), 和 isAfterLast() 方法遍历所有记录；</li>\n<li>通过 getColumnNames() 得到字段名；</li>\n<li>通过 getColumnIndex() 转换成字段号；</li>\n<li>通过 getString()，getInt() 等方法得到给定字段当前记录的值；</li>\n<li>通过 requery() 方法重新执行查询得到游标；</li>\n<li>通过 close() 方法释放游标资源；</li>\n</ul>\n<p>例如，下面代码遍历 user表:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cursor result=db.rawQuery(<span class=\"string\">\"SELECT _id, username, password FROM user\"</span>); </div><div class=\"line\">    result.moveToFirst(); </div><div class=\"line\">    <span class=\"keyword\">while</span> (!result.isAfterLast()) &#123; </div><div class=\"line\">        <span class=\"keyword\">int</span> id=result.getInt(<span class=\"number\">0</span>); </div><div class=\"line\">        String name=result.getString(<span class=\"number\">1</span>); </div><div class=\"line\">        String password =result.getString(<span class=\"number\">2</span>); </div><div class=\"line\">        <span class=\"comment\">// do something useful with these </span></div><div class=\"line\">        result.moveToNext(); </div><div class=\"line\">      &#125; </div><div class=\"line\">      result.close();</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的SQL数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。从Android1.5开始，Android就自带SQLite数据库了。</p>\n<h3 id=\"二-特性\"><a href=\"#二-特性\" class=\"headerlink\" title=\"二 特性\"></a>二 特性</h3><ol>\n<li>ACID事务 　</li>\n<li>零配置 – 无需安装和管理配置 </li>\n<li>储存在单一磁盘文件中的一个完整的数据库</li>\n<li>数据库文件可以在不同字节顺序的机器间自由的共享</li>\n<li>支持数据库大小至2TB</li>\n<li>足够小, 大致3万行C代码, 250K</li>\n<li>比一些流行的数据库在大部分普通数据库操作要快</li>\n<li>简单, 轻松的API</li>\n<li>包含TCL绑定, 同时通过Wrapper支持其他语言的绑定</li>\n<li>良好注释的源代码, 并且有着90%以上的测试覆盖率  </li>\n<li>独立: 没有额外依赖</li>\n<li>Source完全的Open, 你可以用于任何用途, 包括出售它</li>\n<li>支持多种开发语言，C，PHP，Perl，Java，ASP.NET，Python　　</li>\n</ol>\n<h3 id=\"在Android中使用SQLite\"><a href=\"#在Android中使用SQLite\" class=\"headerlink\" title=\"在Android中使用SQLite\"></a>在Android中使用SQLite</h3><p>Activites 可以通过 Content Provider 或者 Service 访问一个数据库。</p>\n<h5 id=\"1-创建数据库\"><a href=\"#1-创建数据库\" class=\"headerlink\" title=\"1.创建数据库\"></a>1.创建数据库</h5><p>Android 不自动提供数据库。在 Android 应用程序中使用 SQLite，必须自己创建数据库，然后创建表、索引，填充数据。Android 提供了 SQLiteOpenHelper 帮助你创建一个数据库，你只要继承 SQLiteOpenHelper 类根据开发应用程序的需要，封装创建和更新数据库使用的逻辑就行了。　 </p>\n<p>SQLiteOpenHelper 的子类，至少需要实现三个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DatabaseHelper</span> <span class=\"keyword\">extends</span> <span class=\"title\">SQLiteOpenHelper</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * <span class=\"doctag\">@param</span> context  上下文环境（例如，一个 Activity）</div><div class=\"line\">     * <span class=\"doctag\">@param</span> name   数据库名字</div><div class=\"line\">     * <span class=\"doctag\">@param</span> factory  一个可选的游标工厂（通常是 Null）</div><div class=\"line\">     * <span class=\"doctag\">@param</span> version  数据库模型版本的整数</div><div class=\"line\">     * </div><div class=\"line\">     * 会调用父类 SQLiteOpenHelper的构造函数</div><div class=\"line\">     */</span> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DatabaseHelper</span><span class=\"params\">(Context context, String name, CursorFactory factory, <span class=\"keyword\">int</span> version)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, name, factory, version);</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     *  在数据库第一次创建的时候会调用这个方法</div><div class=\"line\">     *  </div><div class=\"line\">     *根据需要对传入的SQLiteDatabase 对象填充表和初始化数据。</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(SQLiteDatabase db)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 当数据库需要修改的时候（两个数据库版本不同），Android系统会主动的调用这个方法。</div><div class=\"line\">     * 一般我们在这个方法里边删除数据库表，并建立新的数据库表.</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onUpgrade</span><span class=\"params\">(SQLiteDatabase db, <span class=\"keyword\">int</span> oldVersion, <span class=\"keyword\">int</span> newVersion)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//三个参数，一个 SQLiteDatabase 对象，一个旧的版本号和一个新的版本号</span></div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onOpen</span><span class=\"params\">(SQLiteDatabase db)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 每次成功打开数据库后首先被执行</span></div><div class=\"line\">        <span class=\"keyword\">super</span>.onOpen(db);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>继承SQLiteOpenHelper之后就拥有了以下两个方法：</p>\n<ul>\n<li>getReadableDatabase() 　创建或者打开一个查询数据库</li>\n<li>getWritableDatabase()　创建或者打开一个可写数据库</li>\n</ul>\n<p>创建一个数据库代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">DatabaseHelper database = <span class=\"keyword\">new</span> DatabaseHelper(context);<span class=\"comment\">//传入一个上下文参数</span></div><div class=\"line\">SQLiteDatabase db = <span class=\"keyword\">null</span>;</div><div class=\"line\">db = database.getWritableDatabase();</div></pre></td></tr></table></figure>\n<p>上面这段代码会返回一个 SQLiteDatabase 类的实例，使用这个对象，你就可以查询或者修改数据库。SQLiteDatabase类为我们提供了很多种方法，而较常用的方法如下：</p>\n<p>删除数据行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">int</span>) delete(String table,String whereClause,String[] whereArgs)</div></pre></td></tr></table></figure>\n<p>添加数据行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">long</span>) insert(String table,String nullColumnHack,ContentValues values)</div></pre></td></tr></table></figure>\n<p>更新数据行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">int</span>) update(String table, ContentValues values, String whereClause, String[] whereArgs)</div></pre></td></tr></table></figure>\n<p>执行一个SQL语句，可以是一个select或其他的sql语句(没有返回值的sql语句)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">void</span>) execSQL(String sql)</div></pre></td></tr></table></figure>\n<p>关闭数据库</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">void</span>) close()</div></pre></td></tr></table></figure>\n<p>查询指定的数据表返回一个带游标的数据集。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*各参数说明： table：表名称 colums：列名称数组 selection：条件子句，相当于where selectionArgs：条件//*语句的参数数组 groupBy：分组 having：分组条件 orderBy：排序类 limit：分页查询的限制 Cursor：返回值，相*当于结果集ResultSet*/</span></div><div class=\"line\">(Cursor) query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit)</div></pre></td></tr></table></figure>\n<p>运行一个预置的SQL语句，返回带游标的数据集（与上面的语句最大的区别就是防止SQL注入）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(Cursor) rawQuery(String sql, String[] selectionArgs)</div></pre></td></tr></table></figure>\n<p>当你完成了对数据库的操作（例如你的 Activity 已经关闭），需要调用 SQLiteDatabase 的 Close() 方法来释放掉数据库连接。</p>\n<h5 id=\"2-创建表和索引\"><a href=\"#2-创建表和索引\" class=\"headerlink\" title=\"2.创建表和索引\"></a>2.创建表和索引</h5><p>为了创建表和索引，需要调用 SQLiteDatabase 的 execSQL() 方法来执行 DDL 语句。如果没有异常，这个方法没有返回值。 　　</p>\n<p>例如，你可以执行如下代码：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">db.execSQL(\"CREATE TABLE user(_id INTEGER PRIMARY KEY   </div><div class=\"line\">       AUTOINCREMENT, username TEXT, password TEXT);\");</div></pre></td></tr></table></figure>\n<p>这条语句会创建一个名为 user的表，表有一个列名为 _id，并且是主键，这列的值是会自动增长的整数。另外还有两列：username( 字符 ) 和 password( 字符 )。 SQLite 会自动为主键列创建索引。 　　</p>\n<p>通常情况下，第一次创建数据库时创建了表和索引。要 删除表和索引，需要使用 execSQL() 方法调用 DROP INDEX 和 DROP TABLE 语句。</p>\n<h5 id=\"3-添加数据\"><a href=\"#3-添加数据\" class=\"headerlink\" title=\"3.添加数据\"></a>3.添加数据</h5><p>有两种方法可以给表添加数据。</p>\n<p>a. 可以使用 execSQL() 方法执行 INSERT, UPDATE, DELETE 等语句来更新表的数据。execSQL() 方法适用于所有不返回结果的 SQL 语句。例如：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">String sql = \"insert into user(username,password) values ('finch','123456');//插入操作的SQL语句</div><div class=\"line\">db.execSQL(sql);//执行SQL语句</div></pre></td></tr></table></figure>\n<p>b. 使用 SQLiteDatabase 对象的 insert()。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ContentValues cv = <span class=\"keyword\">new</span> ContentValues();</div><div class=\"line\">cv.put(<span class=\"string\">\"username\"</span>,<span class=\"string\">\"finch\"</span>);<span class=\"comment\">//添加用户名</span></div><div class=\"line\">cv.put(<span class=\"string\">\"password\"</span>,<span class=\"string\">\"123456\"</span>); <span class=\"comment\">//添加密码</span></div><div class=\"line\">db.insert(<span class=\"string\">\"user\"</span>,<span class=\"keyword\">null</span>,cv);<span class=\"comment\">//执行插入操作</span></div></pre></td></tr></table></figure>\n<h5 id=\"4-更新数据\"><a href=\"#4-更新数据\" class=\"headerlink\" title=\"4.更新数据\"></a>4.更新数据</h5><p>a. 使用execSQL方式的实现</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">String sql = \"update [user] set password = '654321' where username=\"finch\";//修改的SQL语句</div><div class=\"line\">db.execSQL(sql);//执行修改</div></pre></td></tr></table></figure>\n<p>b.使用SQLiteDatabase 对象的 update()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ContentValues cv = <span class=\"keyword\">new</span> ContentValues();</div><div class=\"line\">cv.put(<span class=\"string\">\"password\"</span>,<span class=\"string\">\"654321\"</span>);<span class=\"comment\">//添加要更改的字段及内容</span></div><div class=\"line\">String whereClause = <span class=\"string\">\"username=?\"</span>;<span class=\"comment\">//修改条件</span></div><div class=\"line\">String[] whereArgs = &#123;<span class=\"string\">\"finch\"</span>&#125;;<span class=\"comment\">//修改条件的参数</span></div><div class=\"line\">db.update(<span class=\"string\">\"user\"</span>,cv,whereClause,whereArgs);<span class=\"comment\">//执行修改</span></div></pre></td></tr></table></figure>\n<p>该方法有四个参数：表名、列名和值的 ContentValues 对象、可选的 WHERE 条件、可选的填充 WHERE 语句的字符串，这些字符串会替换 WHERE 条件中的“？”标记，update() 根据条件，更新指定列的值。</p>\n<h5 id=\"5-删除数据\"><a href=\"#5-删除数据\" class=\"headerlink\" title=\"5.删除数据\"></a>5.删除数据</h5><p>使用execSQL方式的实现</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">String sql = \"delete from user where username=\"finch\";//删除操作的SQL语句</div><div class=\"line\">db.execSQL(sql);//执行删除操作</div></pre></td></tr></table></figure>\n<p>使用SQLiteDatabase 对象的delete()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">String whereClause = <span class=\"string\">\"username=?\"</span>;<span class=\"comment\">//删除的条件</span></div><div class=\"line\">String[] whereArgs = &#123;<span class=\"string\">\"finch\"</span>&#125;;<span class=\"comment\">//删除的条件参数</span></div><div class=\"line\">db.delete(<span class=\"string\">\"user\"</span>,whereClause,whereArgs);<span class=\"comment\">//执行删除</span></div></pre></td></tr></table></figure>\n<h5 id=\"6-查询数据\"><a href=\"#6-查询数据\" class=\"headerlink\" title=\"6.查询数据\"></a>6.查询数据</h5><p>使用 rawQuery() 直接调用 SELECT 语句</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cursor c = db.rawQuery(<span class=\"string\">\"select * from user where username=?\"</span>,<span class=\"keyword\">new</span> Stirng[]&#123;<span class=\"string\">\"finch\"</span>&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span>(cursor.moveToFirst()) &#123;</div><div class=\"line\">    String password = c.getString(c.getColumnIndex(<span class=\"string\">\"password\"</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>返回值是一个 cursor 对象，这个对象的方法可以迭代查询结果。 如果查询是动态的，使用这个方法就会非常复杂。例如，当你需要查询的列在程序编译的时候不能确定，这时候使用 query() 方法会方便很多。</p>\n<p>通过query实现查询</p>\n<p>query() 方法用 SELECT 语句段构建查询。 　　SELECT 语句内容作为 query() 方法的参数，比如：要查询的表名，要获取的字段名，WHERE 条件，包含可选的位置参数，去替代 WHERE 条件中位置参数的值，GROUP BY 条件，HAVING 条件。 　　除了表名，其他参数可以是 null。所以代码可写成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cursor c = db.query(<span class=\"string\">\"user\"</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>);<span class=\"comment\">//查询并获得游标</span></div><div class=\"line\"><span class=\"keyword\">if</span>(c.moveToFirst())&#123;<span class=\"comment\">//判断游标是否为空</span></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;c.getCount();i++)&#123;　</div><div class=\"line\">c.move(i);<span class=\"comment\">//移动到指定记录</span></div><div class=\"line\">String username = c.getString(c.getColumnIndex(<span class=\"string\">\"username\"</span>);</div><div class=\"line\">String password = c.getString(c.getColumnIndex(<span class=\"string\">\"password\"</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"7-使用游标\"><a href=\"#7-使用游标\" class=\"headerlink\" title=\"7.使用游标\"></a>7.使用游标</h5><p>不管你如何执行查询，都会返回一个 Cursor，这是 Android 的 SQLite 数据库游标，使用游标，你可以：</p>\n<ul>\n<li>通过使用 getCount() 方法得到结果集中有多少记录；　</li>\n<li>通过 moveToFirst(), moveToNext(), 和 isAfterLast() 方法遍历所有记录；</li>\n<li>通过 getColumnNames() 得到字段名；</li>\n<li>通过 getColumnIndex() 转换成字段号；</li>\n<li>通过 getString()，getInt() 等方法得到给定字段当前记录的值；</li>\n<li>通过 requery() 方法重新执行查询得到游标；</li>\n<li>通过 close() 方法释放游标资源；</li>\n</ul>\n<p>例如，下面代码遍历 user表:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cursor result=db.rawQuery(<span class=\"string\">\"SELECT _id, username, password FROM user\"</span>); </div><div class=\"line\">    result.moveToFirst(); </div><div class=\"line\">    <span class=\"keyword\">while</span> (!result.isAfterLast()) &#123; </div><div class=\"line\">        <span class=\"keyword\">int</span> id=result.getInt(<span class=\"number\">0</span>); </div><div class=\"line\">        String name=result.getString(<span class=\"number\">1</span>); </div><div class=\"line\">        String password =result.getString(<span class=\"number\">2</span>); </div><div class=\"line\">        <span class=\"comment\">// do something useful with these </span></div><div class=\"line\">        result.moveToNext(); </div><div class=\"line\">      &#125; </div><div class=\"line\">      result.close();</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>"},{"title":"android基础之Service","date":"2017-02-27T06:06:22.000Z","_content":"\n### 一 Service简介    \nService也是Android的四大组件之一，它并不提供用户界面，主要做一些即使该应用程序被调入后台也需要运行的事务。比如下载，音乐播放，执行文件I/O或者与content provider进行交互等。Service主要做的就是上面这些比较耗时的操作，但是由于Service也是运行在主线程中，因此最好在其中另开一个线程做这些耗时操作，否者可能会引起UI阻塞。       \n\n### 二 Service的两种启动方式     \nService有started和bound两种启动方式，当然也可以两种都启用。你可通过startService()启动服务后再通过bindService()将activity于Service绑定。     \n\n##### 1.startService()启动    \n通过startService()启动的Service，Service一旦启动即与它的调用者（通常是某个activity）不再关联，即使调用它的组件被销毁，它也能在后台一直运行下去。通常，该类服务执行单一的操作并且不会向调用者返回结果，比如它可以通过网络下载或上传文件。此类服务应该在其工作完成后通过重写stopSelf()使其自行终止，或者由其他组件调用stopService()来终止。       \n通过startService()启动的服务需要实现它的生命周期中onStartCommand()方法        \n\n\n\n##### 2.bindService()启动      \n通过bindService()启动的服务，该服务的生命周期将与启动它的组件相关联，即如果启动它的组件被销毁则该服务也会被销毁，或者通过调用unBindService()与服务解绑，解绑后服务被销毁。多个组件可以同时与一个服务绑定，当所有组件都与服务解绑后，该服务才会被销毁。    \nbind服务提供了一个客户端/服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至进行进程间通信（IPC）。       \n通过bindService()启动的服务需要实现Service中的onBind()方法。   \n\n\n\n\n### 三 Service的生命周期     \n两种Service的生命周期如下图：     \n{% asset_img Service生命周期图.png Service生命周期图 %}     \n其回调方法如下：     \n\n   \n```java       \npublic class ExampleService extends Service {\n    int mStartMode;       // indicates how to behave if the service is killed\n    IBinder mBinder;      // interface for clients that bind\n    boolean mAllowRebind; // indicates whether onRebind should be used\n\n    @Override\n    public void onCreate() {\n        // The service is being created\n    }\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        // The service is starting, due to a call to startService()\n        return mStartMode;\n    }\n    @Override\n    public IBinder onBind(Intent intent) {\n        // A client is binding to the service with bindService()\n        return mBinder;\n    }\n    @Override\n    public boolean onUnbind(Intent intent) {\n        // All clients have unbound with unbindService()\n        return mAllowRebind;\n    }\n    @Override\n    public void onRebind(Intent intent) {\n        // A client is binding to the service with bindService(),\n        // after onUnbind() has already been called\n    }\n    @Override\n    public void onDestroy() {\n        // The service is no longer used and is being destroyed\n    }\n}\n```         \n\n\n\n### 四 Service与线程的区别    \n- Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。     \n- Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。       \n其实谈Service和线程的区别毫无意义，它们本来就是毫无关联的两样东西，我觉得应该谈的是在什么情况下，什么地方使用线程更合适。   \n比如：如果你的线程主要用于对UI的更新，那么在Activity中新建即可。但是如果你的线程用于app和服务器之间的消息推送，你需要隔一段时间就要连接服务器做数据同步的话，那么就不能在Activity中新建线程。因为此时的线程在Activity被销毁时，它仍然需要运行。此时将面对一个问题，如果你是Activity中创建得线程，那么当该Activity被销毁时，你将失去该线程的实例。另一方面，你没办法在不同的Activity中对同一线程进行控制。这种情况你就需要在Service中创建它，一方面Service在Activity被销毁时仍然可以运行，另一方面其他的Activity重建后也可以通过与Service进行绑定获得Service的实例，进而控制该线程。\n\n### 五 保证Service不被杀死    \n- onStartCommand方法，返回START_STICKY   \n- 提升service优先级   \n- 提升service进程优先级,将其提升为前台服务    \n- onDestroy方法里重启service  \n- 监听系统广播判断Service状态    \n- 将APK安装到/system/app，变身系统级应用      \n\n\n### 六 IntentService    \n\n因为大多数started服务都不需要同时处理多个请求（这实际上是一个危险的多线程情况），所以最佳方式也许就是用IntentService类来实现你的服务。   \nIntentService将执行以下步骤：    　　\n- 创建一个缺省的工作（worker）线程，它独立于应用程序主线程来执行所有发送到onStartCommand()的intent。　　　\n- 创建一个工作队列，每次向你的onHandleIntent()传入一个intent，这样你就永远不必担心多线程问题了。　\n- 在处理完所有的启动请求后，终止服务，因此你就永远不需调用stopSelf()了。　　\n- 提供缺省的onBind()实现代码，它返回null。\n- 提供缺省的onStartCommand()实现代码，它把intent送入工作队列，稍后会再传给你的onHandleIntent()实现代码。　　　\n\n以上所有步骤将汇成一个结果：你要做的全部工作就是实现onHandleIntent()的代码，来完成客户端提交的任务。（当然你还需要为服务提供一小段构造方法。）       \n\n以下是个IntentService的实现例程：    \n\n```java    \n\npublic class HelloIntentService extends IntentService {\n\n  /** \n   * 构造方法是必需的，必须用工作线程名称作为参数\n   * 调用父类的[http://developer.android.com/reference/android/app/IntentService.html#IntentService(java.lang.String) IntentService(String)]构造方法。\n   */\n  public HelloIntentService() {\n      super(\"HelloIntentService\");\n  }\n\n  /**\n   * IntentService从缺省的工作线程中调用本方法，并用启动服务的intent作为参数。 \n   * 本方法返回后，IntentService将适时终止这个服务。\n   */\n  @Override\n  protected void onHandleIntent(Intent intent) {\n      // 通常我们会在这里执行一些工作，比如下载文件。\n      // 作为例子，我们只是睡5秒钟。\n      long endTime = System.currentTimeMillis() + 5*1000;\n      while (System.currentTimeMillis() < endTime) {\n          synchronized (this) {\n              try {\n                  wait(endTime - System.currentTimeMillis());\n              } catch (Exception e) {\n              }\n          }\n      }\n  }\n}  \n\n```    \n\n所有你需要做的就是：一个构造方法和一个onHandleIntent()方法的实现。\n\n如果你还决定重写其它的回调方法，比如onCreate()、onStartCommand()、onDestroy()， 请确保调用一下父类的实现代码，以便IntentService能正确处理工作线程的生命周期。\n\n比如说，onStartCommand()必须返回缺省实现代码的结果（缺省代码实现了如何获取传给onHandleIntent()的intent）：    \n\n```java  \n@Override\npublic int onStartCommand(Intent intent, int flags, int startId) {\n    Toast.makeText(this, \"service starting\", Toast.LENGTH_SHORT).show();\n    return super.onStartCommand(intent,flags,startId);\n}\n```   \n\n除了onHandleIntent()以外，唯一不需要调用父类实现代码的方法是onBind()（不过如果你的服务允许绑定，你还是需要实现它）。    \n\n\n### 七 扩展Service   \n\n如上节所述，利用IntentService来实现一个started服务非常简单。 不过，假如你的服务需要多线程运行（而不是通过一个工作队列来处理启动请求），那你可以扩展Service类来完成每个intent的处理。\n\n作为对照，以下例程实现了 Service 类，它执行的工作与上述使用IntentService的例子相同。确切地说，对于每一个启动请求，它都用一个工作线程来完成处理工作，并且每次只处理一个请求。    \n\n```java    \npublic class HelloService extends Service {\n  private Looper mServiceLooper;\n  private ServiceHandler mServiceHandler;\n\n  // 处理从线程接收的消息\n  private final class ServiceHandler extends Handler {\n      public ServiceHandler(Looper looper) {\n          super(looper);\n      }\n      @Override\n      public void handleMessage(Message msg) {\n          // 通常我们在这里执行一些工作，比如下载文件。\n          // 作为例子，我们只是睡个5秒钟。\n          long endTime = System.currentTimeMillis() + 5*1000;\n          while (System.currentTimeMillis() < endTime) {\n              synchronized (this) {\n                  try {\n                      wait(endTime - System.currentTimeMillis());\n                  } catch (Exception e) {\n                  }\n              }\n          }\n          // 根据startId终止服务，这样我们就不会在处理其它工作的过程中再来终止服务\n          stopSelf(msg.arg1);\n      }\n  }\n\n  @Override\n  public void onCreate() {\n    // 启动运行服务的线程。\n    // 请记住我们要创建一个单独的线程，因为服务通常运行于进程的主线程中，可我们不想阻塞主线程。\n    // 我们还要赋予它后台运行的优先级，以便计算密集的工作不会干扰我们的UI。\n    HandlerThread thread = new HandlerThread(\"ServiceStartArguments\",\n            Process.THREAD_PRIORITY_BACKGROUND);\n    thread.start();\n    \n    // 获得HandlerThread的Looper队列并用于Handler\n    mServiceLooper = thread.getLooper();\n    mServiceHandler = new ServiceHandler(mServiceLooper);\n  }\n\n  @Override\n  public int onStartCommand(Intent intent, int flags, int startId) {\n      Toast.makeText(this, \"service starting\", Toast.LENGTH_SHORT).show();\n\n      // 对于每一个启动请求，都发送一个消息来启动一个处理\n      // 同时传入启动ID，以便任务完成后我们知道该终止哪一个请求。\n      Message msg = mServiceHandler.obtainMessage();\n      msg.arg1 = startId;\n      mServiceHandler.sendMessage(msg);\n      \n      // 如果我们被杀死了，那从这里返回之后被重启\n      return START_STICKY;\n  }\n\n  @Override\n  public IBinder onBind(Intent intent) {\n      // 我们不支持绑定，所以返回null\n      return null;\n  }\n  \n  @Override\n  public void onDestroy() {\n    Toast.makeText(this, \"service done\", Toast.LENGTH_SHORT).show(); \n  }\n}\n```    \n\n如你所见，它要干的事情比用IntentService时多了很多。\n\n不过，因为是自行处理每个onStartCommand()调用，你可以同时处理多个请求。 本例中没有这么去实现，但只要你愿意，你就可以为每个请求创建一个新的线程，并立即运行它们（而不是等待前一个请求处理完毕）。\n\n请注意onStartCommand()方法必须返回一个整数。这个整数是描述系统在杀死服务之后应该如何继续运行（上一节中缺省的 IntentService 实现代码会替你处理这一点，当然那样你就无法修改这个处理过程）。onStartCommand()的返回值必须是以下常量之一：\n\n\n- START_NOT_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则不会重建服务了，除非还存在未发送的intent。 当服务不再是必需的，并且应用程序能够简单地重启那些未完成的工作时，这是避免服务运行的最安全的选项。 \n\n\n- START_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并调用onStartCommand()，但不会再次送入上一个intent， 而是用null intent来调用onStartCommand() 。除非还有启动服务的intent未发送完，那么这些剩下的intent会继续发送。 这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命。 \n\n\n- START_REDELIVER_INTENT: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并用上一个已送过的intent调用onStartCommand()。任何未发送完的intent也都会依次送入。这适用于那些需要立即恢复工作的活跃服务，比如下载文件。    ","source":"_posts/android基础之Service.md","raw":"---\ntitle: android基础之Service\ndate: 2017-02-27 14:06:22\ncategories: android\ntags:\n- android\n- java\n- service\n---\n\n### 一 Service简介    \nService也是Android的四大组件之一，它并不提供用户界面，主要做一些即使该应用程序被调入后台也需要运行的事务。比如下载，音乐播放，执行文件I/O或者与content provider进行交互等。Service主要做的就是上面这些比较耗时的操作，但是由于Service也是运行在主线程中，因此最好在其中另开一个线程做这些耗时操作，否者可能会引起UI阻塞。       \n\n### 二 Service的两种启动方式     \nService有started和bound两种启动方式，当然也可以两种都启用。你可通过startService()启动服务后再通过bindService()将activity于Service绑定。     \n\n##### 1.startService()启动    \n通过startService()启动的Service，Service一旦启动即与它的调用者（通常是某个activity）不再关联，即使调用它的组件被销毁，它也能在后台一直运行下去。通常，该类服务执行单一的操作并且不会向调用者返回结果，比如它可以通过网络下载或上传文件。此类服务应该在其工作完成后通过重写stopSelf()使其自行终止，或者由其他组件调用stopService()来终止。       \n通过startService()启动的服务需要实现它的生命周期中onStartCommand()方法        \n\n\n\n##### 2.bindService()启动      \n通过bindService()启动的服务，该服务的生命周期将与启动它的组件相关联，即如果启动它的组件被销毁则该服务也会被销毁，或者通过调用unBindService()与服务解绑，解绑后服务被销毁。多个组件可以同时与一个服务绑定，当所有组件都与服务解绑后，该服务才会被销毁。    \nbind服务提供了一个客户端/服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至进行进程间通信（IPC）。       \n通过bindService()启动的服务需要实现Service中的onBind()方法。   \n\n\n\n\n### 三 Service的生命周期     \n两种Service的生命周期如下图：     \n{% asset_img Service生命周期图.png Service生命周期图 %}     \n其回调方法如下：     \n\n   \n```java       \npublic class ExampleService extends Service {\n    int mStartMode;       // indicates how to behave if the service is killed\n    IBinder mBinder;      // interface for clients that bind\n    boolean mAllowRebind; // indicates whether onRebind should be used\n\n    @Override\n    public void onCreate() {\n        // The service is being created\n    }\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        // The service is starting, due to a call to startService()\n        return mStartMode;\n    }\n    @Override\n    public IBinder onBind(Intent intent) {\n        // A client is binding to the service with bindService()\n        return mBinder;\n    }\n    @Override\n    public boolean onUnbind(Intent intent) {\n        // All clients have unbound with unbindService()\n        return mAllowRebind;\n    }\n    @Override\n    public void onRebind(Intent intent) {\n        // A client is binding to the service with bindService(),\n        // after onUnbind() has already been called\n    }\n    @Override\n    public void onDestroy() {\n        // The service is no longer used and is being destroyed\n    }\n}\n```         \n\n\n\n### 四 Service与线程的区别    \n- Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。     \n- Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。       \n其实谈Service和线程的区别毫无意义，它们本来就是毫无关联的两样东西，我觉得应该谈的是在什么情况下，什么地方使用线程更合适。   \n比如：如果你的线程主要用于对UI的更新，那么在Activity中新建即可。但是如果你的线程用于app和服务器之间的消息推送，你需要隔一段时间就要连接服务器做数据同步的话，那么就不能在Activity中新建线程。因为此时的线程在Activity被销毁时，它仍然需要运行。此时将面对一个问题，如果你是Activity中创建得线程，那么当该Activity被销毁时，你将失去该线程的实例。另一方面，你没办法在不同的Activity中对同一线程进行控制。这种情况你就需要在Service中创建它，一方面Service在Activity被销毁时仍然可以运行，另一方面其他的Activity重建后也可以通过与Service进行绑定获得Service的实例，进而控制该线程。\n\n### 五 保证Service不被杀死    \n- onStartCommand方法，返回START_STICKY   \n- 提升service优先级   \n- 提升service进程优先级,将其提升为前台服务    \n- onDestroy方法里重启service  \n- 监听系统广播判断Service状态    \n- 将APK安装到/system/app，变身系统级应用      \n\n\n### 六 IntentService    \n\n因为大多数started服务都不需要同时处理多个请求（这实际上是一个危险的多线程情况），所以最佳方式也许就是用IntentService类来实现你的服务。   \nIntentService将执行以下步骤：    　　\n- 创建一个缺省的工作（worker）线程，它独立于应用程序主线程来执行所有发送到onStartCommand()的intent。　　　\n- 创建一个工作队列，每次向你的onHandleIntent()传入一个intent，这样你就永远不必担心多线程问题了。　\n- 在处理完所有的启动请求后，终止服务，因此你就永远不需调用stopSelf()了。　　\n- 提供缺省的onBind()实现代码，它返回null。\n- 提供缺省的onStartCommand()实现代码，它把intent送入工作队列，稍后会再传给你的onHandleIntent()实现代码。　　　\n\n以上所有步骤将汇成一个结果：你要做的全部工作就是实现onHandleIntent()的代码，来完成客户端提交的任务。（当然你还需要为服务提供一小段构造方法。）       \n\n以下是个IntentService的实现例程：    \n\n```java    \n\npublic class HelloIntentService extends IntentService {\n\n  /** \n   * 构造方法是必需的，必须用工作线程名称作为参数\n   * 调用父类的[http://developer.android.com/reference/android/app/IntentService.html#IntentService(java.lang.String) IntentService(String)]构造方法。\n   */\n  public HelloIntentService() {\n      super(\"HelloIntentService\");\n  }\n\n  /**\n   * IntentService从缺省的工作线程中调用本方法，并用启动服务的intent作为参数。 \n   * 本方法返回后，IntentService将适时终止这个服务。\n   */\n  @Override\n  protected void onHandleIntent(Intent intent) {\n      // 通常我们会在这里执行一些工作，比如下载文件。\n      // 作为例子，我们只是睡5秒钟。\n      long endTime = System.currentTimeMillis() + 5*1000;\n      while (System.currentTimeMillis() < endTime) {\n          synchronized (this) {\n              try {\n                  wait(endTime - System.currentTimeMillis());\n              } catch (Exception e) {\n              }\n          }\n      }\n  }\n}  \n\n```    \n\n所有你需要做的就是：一个构造方法和一个onHandleIntent()方法的实现。\n\n如果你还决定重写其它的回调方法，比如onCreate()、onStartCommand()、onDestroy()， 请确保调用一下父类的实现代码，以便IntentService能正确处理工作线程的生命周期。\n\n比如说，onStartCommand()必须返回缺省实现代码的结果（缺省代码实现了如何获取传给onHandleIntent()的intent）：    \n\n```java  \n@Override\npublic int onStartCommand(Intent intent, int flags, int startId) {\n    Toast.makeText(this, \"service starting\", Toast.LENGTH_SHORT).show();\n    return super.onStartCommand(intent,flags,startId);\n}\n```   \n\n除了onHandleIntent()以外，唯一不需要调用父类实现代码的方法是onBind()（不过如果你的服务允许绑定，你还是需要实现它）。    \n\n\n### 七 扩展Service   \n\n如上节所述，利用IntentService来实现一个started服务非常简单。 不过，假如你的服务需要多线程运行（而不是通过一个工作队列来处理启动请求），那你可以扩展Service类来完成每个intent的处理。\n\n作为对照，以下例程实现了 Service 类，它执行的工作与上述使用IntentService的例子相同。确切地说，对于每一个启动请求，它都用一个工作线程来完成处理工作，并且每次只处理一个请求。    \n\n```java    \npublic class HelloService extends Service {\n  private Looper mServiceLooper;\n  private ServiceHandler mServiceHandler;\n\n  // 处理从线程接收的消息\n  private final class ServiceHandler extends Handler {\n      public ServiceHandler(Looper looper) {\n          super(looper);\n      }\n      @Override\n      public void handleMessage(Message msg) {\n          // 通常我们在这里执行一些工作，比如下载文件。\n          // 作为例子，我们只是睡个5秒钟。\n          long endTime = System.currentTimeMillis() + 5*1000;\n          while (System.currentTimeMillis() < endTime) {\n              synchronized (this) {\n                  try {\n                      wait(endTime - System.currentTimeMillis());\n                  } catch (Exception e) {\n                  }\n              }\n          }\n          // 根据startId终止服务，这样我们就不会在处理其它工作的过程中再来终止服务\n          stopSelf(msg.arg1);\n      }\n  }\n\n  @Override\n  public void onCreate() {\n    // 启动运行服务的线程。\n    // 请记住我们要创建一个单独的线程，因为服务通常运行于进程的主线程中，可我们不想阻塞主线程。\n    // 我们还要赋予它后台运行的优先级，以便计算密集的工作不会干扰我们的UI。\n    HandlerThread thread = new HandlerThread(\"ServiceStartArguments\",\n            Process.THREAD_PRIORITY_BACKGROUND);\n    thread.start();\n    \n    // 获得HandlerThread的Looper队列并用于Handler\n    mServiceLooper = thread.getLooper();\n    mServiceHandler = new ServiceHandler(mServiceLooper);\n  }\n\n  @Override\n  public int onStartCommand(Intent intent, int flags, int startId) {\n      Toast.makeText(this, \"service starting\", Toast.LENGTH_SHORT).show();\n\n      // 对于每一个启动请求，都发送一个消息来启动一个处理\n      // 同时传入启动ID，以便任务完成后我们知道该终止哪一个请求。\n      Message msg = mServiceHandler.obtainMessage();\n      msg.arg1 = startId;\n      mServiceHandler.sendMessage(msg);\n      \n      // 如果我们被杀死了，那从这里返回之后被重启\n      return START_STICKY;\n  }\n\n  @Override\n  public IBinder onBind(Intent intent) {\n      // 我们不支持绑定，所以返回null\n      return null;\n  }\n  \n  @Override\n  public void onDestroy() {\n    Toast.makeText(this, \"service done\", Toast.LENGTH_SHORT).show(); \n  }\n}\n```    \n\n如你所见，它要干的事情比用IntentService时多了很多。\n\n不过，因为是自行处理每个onStartCommand()调用，你可以同时处理多个请求。 本例中没有这么去实现，但只要你愿意，你就可以为每个请求创建一个新的线程，并立即运行它们（而不是等待前一个请求处理完毕）。\n\n请注意onStartCommand()方法必须返回一个整数。这个整数是描述系统在杀死服务之后应该如何继续运行（上一节中缺省的 IntentService 实现代码会替你处理这一点，当然那样你就无法修改这个处理过程）。onStartCommand()的返回值必须是以下常量之一：\n\n\n- START_NOT_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则不会重建服务了，除非还存在未发送的intent。 当服务不再是必需的，并且应用程序能够简单地重启那些未完成的工作时，这是避免服务运行的最安全的选项。 \n\n\n- START_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并调用onStartCommand()，但不会再次送入上一个intent， 而是用null intent来调用onStartCommand() 。除非还有启动服务的intent未发送完，那么这些剩下的intent会继续发送。 这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命。 \n\n\n- START_REDELIVER_INTENT: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并用上一个已送过的intent调用onStartCommand()。任何未发送完的intent也都会依次送入。这适用于那些需要立即恢复工作的活跃服务，比如下载文件。    ","slug":"android基础之Service","published":1,"updated":"2017-03-06T09:17:22.399Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk1x001baknzgstr1erc","content":"<h3 id=\"一-Service简介\"><a href=\"#一-Service简介\" class=\"headerlink\" title=\"一 Service简介\"></a>一 Service简介</h3><p>Service也是Android的四大组件之一，它并不提供用户界面，主要做一些即使该应用程序被调入后台也需要运行的事务。比如下载，音乐播放，执行文件I/O或者与content provider进行交互等。Service主要做的就是上面这些比较耗时的操作，但是由于Service也是运行在主线程中，因此最好在其中另开一个线程做这些耗时操作，否者可能会引起UI阻塞。       </p>\n<h3 id=\"二-Service的两种启动方式\"><a href=\"#二-Service的两种启动方式\" class=\"headerlink\" title=\"二 Service的两种启动方式\"></a>二 Service的两种启动方式</h3><p>Service有started和bound两种启动方式，当然也可以两种都启用。你可通过startService()启动服务后再通过bindService()将activity于Service绑定。     </p>\n<h5 id=\"1-startService-启动\"><a href=\"#1-startService-启动\" class=\"headerlink\" title=\"1.startService()启动\"></a>1.startService()启动</h5><p>通过startService()启动的Service，Service一旦启动即与它的调用者（通常是某个activity）不再关联，即使调用它的组件被销毁，它也能在后台一直运行下去。通常，该类服务执行单一的操作并且不会向调用者返回结果，比如它可以通过网络下载或上传文件。此类服务应该在其工作完成后通过重写stopSelf()使其自行终止，或者由其他组件调用stopService()来终止。<br>通过startService()启动的服务需要实现它的生命周期中onStartCommand()方法        </p>\n<h5 id=\"2-bindService-启动\"><a href=\"#2-bindService-启动\" class=\"headerlink\" title=\"2.bindService()启动\"></a>2.bindService()启动</h5><p>通过bindService()启动的服务，该服务的生命周期将与启动它的组件相关联，即如果启动它的组件被销毁则该服务也会被销毁，或者通过调用unBindService()与服务解绑，解绑后服务被销毁。多个组件可以同时与一个服务绑定，当所有组件都与服务解绑后，该服务才会被销毁。<br>bind服务提供了一个客户端/服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至进行进程间通信（IPC）。<br>通过bindService()启动的服务需要实现Service中的onBind()方法。   </p>\n<h3 id=\"三-Service的生命周期\"><a href=\"#三-Service的生命周期\" class=\"headerlink\" title=\"三 Service的生命周期\"></a>三 Service的生命周期</h3><p>两种Service的生命周期如下图：<br><img src=\"/2017/02/27/android基础之Service/Service生命周期图.png\" alt=\"Service生命周期图\" title=\"Service生命周期图\"><br>其回调方法如下：     </p>\n<pre><code class=\"java\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>{\n    <span class=\"keyword\">int</span> mStartMode;       <span class=\"comment\">// indicates how to behave if the service is killed</span>\n    IBinder mBinder;      <span class=\"comment\">// interface for clients that bind</span>\n    <span class=\"keyword\">boolean</span> mAllowRebind; <span class=\"comment\">// indicates whether onRebind should be used</span>\n\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>{\n        <span class=\"comment\">// The service is being created</span>\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>{\n        <span class=\"comment\">// The service is starting, due to a call to startService()</span>\n        <span class=\"keyword\">return</span> mStartMode;\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>{\n        <span class=\"comment\">// A client is binding to the service with bindService()</span>\n        <span class=\"keyword\">return</span> mBinder;\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onUnbind</span><span class=\"params\">(Intent intent)</span> </span>{\n        <span class=\"comment\">// All clients have unbound with unbindService()</span>\n        <span class=\"keyword\">return</span> mAllowRebind;\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRebind</span><span class=\"params\">(Intent intent)</span> </span>{\n        <span class=\"comment\">// A client is binding to the service with bindService(),</span>\n        <span class=\"comment\">// after onUnbind() has already been called</span>\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>{\n        <span class=\"comment\">// The service is no longer used and is being destroyed</span>\n    }\n}\n</code></pre>\n<h3 id=\"四-Service与线程的区别\"><a href=\"#四-Service与线程的区别\" class=\"headerlink\" title=\"四 Service与线程的区别\"></a>四 Service与线程的区别</h3><ul>\n<li>Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。     </li>\n<li>Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。<br>其实谈Service和线程的区别毫无意义，它们本来就是毫无关联的两样东西，我觉得应该谈的是在什么情况下，什么地方使用线程更合适。<br>比如：如果你的线程主要用于对UI的更新，那么在Activity中新建即可。但是如果你的线程用于app和服务器之间的消息推送，你需要隔一段时间就要连接服务器做数据同步的话，那么就不能在Activity中新建线程。因为此时的线程在Activity被销毁时，它仍然需要运行。此时将面对一个问题，如果你是Activity中创建得线程，那么当该Activity被销毁时，你将失去该线程的实例。另一方面，你没办法在不同的Activity中对同一线程进行控制。这种情况你就需要在Service中创建它，一方面Service在Activity被销毁时仍然可以运行，另一方面其他的Activity重建后也可以通过与Service进行绑定获得Service的实例，进而控制该线程。</li>\n</ul>\n<h3 id=\"五-保证Service不被杀死\"><a href=\"#五-保证Service不被杀死\" class=\"headerlink\" title=\"五 保证Service不被杀死\"></a>五 保证Service不被杀死</h3><ul>\n<li>onStartCommand方法，返回START_STICKY   </li>\n<li>提升service优先级   </li>\n<li>提升service进程优先级,将其提升为前台服务    </li>\n<li>onDestroy方法里重启service  </li>\n<li>监听系统广播判断Service状态    </li>\n<li>将APK安装到/system/app，变身系统级应用      </li>\n</ul>\n<h3 id=\"六-IntentService\"><a href=\"#六-IntentService\" class=\"headerlink\" title=\"六 IntentService\"></a>六 IntentService</h3><p>因为大多数started服务都不需要同时处理多个请求（这实际上是一个危险的多线程情况），所以最佳方式也许就是用IntentService类来实现你的服务。<br>IntentService将执行以下步骤：    　　</p>\n<ul>\n<li>创建一个缺省的工作（worker）线程，它独立于应用程序主线程来执行所有发送到onStartCommand()的intent。　　　</li>\n<li>创建一个工作队列，每次向你的onHandleIntent()传入一个intent，这样你就永远不必担心多线程问题了。　</li>\n<li>在处理完所有的启动请求后，终止服务，因此你就永远不需调用stopSelf()了。　　</li>\n<li>提供缺省的onBind()实现代码，它返回null。</li>\n<li>提供缺省的onStartCommand()实现代码，它把intent送入工作队列，稍后会再传给你的onHandleIntent()实现代码。　　　</li>\n</ul>\n<p>以上所有步骤将汇成一个结果：你要做的全部工作就是实现onHandleIntent()的代码，来完成客户端提交的任务。（当然你还需要为服务提供一小段构造方法。）       </p>\n<p>以下是个IntentService的实现例程：    </p>\n<pre><code class=\"java\">\n<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloIntentService</span> <span class=\"keyword\">extends</span> <span class=\"title\">IntentService</span> </span>{\n\n  <span class=\"comment\">/** \n   * 构造方法是必需的，必须用工作线程名称作为参数\n   * 调用父类的[http://developer.android.com/reference/android/app/IntentService.html#IntentService(java.lang.String) IntentService(String)]构造方法。\n   */</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HelloIntentService</span><span class=\"params\">()</span> </span>{\n      <span class=\"keyword\">super</span>(<span class=\"string\">\"HelloIntentService\"</span>);\n  }\n\n  <span class=\"comment\">/**\n   * IntentService从缺省的工作线程中调用本方法，并用启动服务的intent作为参数。 \n   * 本方法返回后，IntentService将适时终止这个服务。\n   */</span>\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onHandleIntent</span><span class=\"params\">(Intent intent)</span> </span>{\n      <span class=\"comment\">// 通常我们会在这里执行一些工作，比如下载文件。</span>\n      <span class=\"comment\">// 作为例子，我们只是睡5秒钟。</span>\n      <span class=\"keyword\">long</span> endTime = System.currentTimeMillis() + <span class=\"number\">5</span>*<span class=\"number\">1000</span>;\n      <span class=\"keyword\">while</span> (System.currentTimeMillis() &lt; endTime) {\n          <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) {\n              <span class=\"keyword\">try</span> {\n                  wait(endTime - System.currentTimeMillis());\n              } <span class=\"keyword\">catch</span> (Exception e) {\n              }\n          }\n      }\n  }\n}\n</code></pre>\n<p>所有你需要做的就是：一个构造方法和一个onHandleIntent()方法的实现。</p>\n<p>如果你还决定重写其它的回调方法，比如onCreate()、onStartCommand()、onDestroy()， 请确保调用一下父类的实现代码，以便IntentService能正确处理工作线程的生命周期。</p>\n<p>比如说，onStartCommand()必须返回缺省实现代码的结果（缺省代码实现了如何获取传给onHandleIntent()的intent）：    </p>\n<pre><code class=\"java\"><span class=\"meta\">@Override</span>\n<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>{\n    Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"service starting\"</span>, Toast.LENGTH_SHORT).show();\n    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onStartCommand(intent,flags,startId);\n}\n</code></pre>\n<p>除了onHandleIntent()以外，唯一不需要调用父类实现代码的方法是onBind()（不过如果你的服务允许绑定，你还是需要实现它）。    </p>\n<h3 id=\"七-扩展Service\"><a href=\"#七-扩展Service\" class=\"headerlink\" title=\"七 扩展Service\"></a>七 扩展Service</h3><p>如上节所述，利用IntentService来实现一个started服务非常简单。 不过，假如你的服务需要多线程运行（而不是通过一个工作队列来处理启动请求），那你可以扩展Service类来完成每个intent的处理。</p>\n<p>作为对照，以下例程实现了 Service 类，它执行的工作与上述使用IntentService的例子相同。确切地说，对于每一个启动请求，它都用一个工作线程来完成处理工作，并且每次只处理一个请求。    </p>\n<pre><code class=\"java\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>{\n  <span class=\"keyword\">private</span> Looper mServiceLooper;\n  <span class=\"keyword\">private</span> ServiceHandler mServiceHandler;\n\n  <span class=\"comment\">// 处理从线程接收的消息</span>\n  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>{\n      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServiceHandler</span><span class=\"params\">(Looper looper)</span> </span>{\n          <span class=\"keyword\">super</span>(looper);\n      }\n      <span class=\"meta\">@Override</span>\n      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>{\n          <span class=\"comment\">// 通常我们在这里执行一些工作，比如下载文件。</span>\n          <span class=\"comment\">// 作为例子，我们只是睡个5秒钟。</span>\n          <span class=\"keyword\">long</span> endTime = System.currentTimeMillis() + <span class=\"number\">5</span>*<span class=\"number\">1000</span>;\n          <span class=\"keyword\">while</span> (System.currentTimeMillis() &lt; endTime) {\n              <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) {\n                  <span class=\"keyword\">try</span> {\n                      wait(endTime - System.currentTimeMillis());\n                  } <span class=\"keyword\">catch</span> (Exception e) {\n                  }\n              }\n          }\n          <span class=\"comment\">// 根据startId终止服务，这样我们就不会在处理其它工作的过程中再来终止服务</span>\n          stopSelf(msg.arg1);\n      }\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>{\n    <span class=\"comment\">// 启动运行服务的线程。</span>\n    <span class=\"comment\">// 请记住我们要创建一个单独的线程，因为服务通常运行于进程的主线程中，可我们不想阻塞主线程。</span>\n    <span class=\"comment\">// 我们还要赋予它后台运行的优先级，以便计算密集的工作不会干扰我们的UI。</span>\n    HandlerThread thread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">\"ServiceStartArguments\"</span>,\n            Process.THREAD_PRIORITY_BACKGROUND);\n    thread.start();\n\n    <span class=\"comment\">// 获得HandlerThread的Looper队列并用于Handler</span>\n    mServiceLooper = thread.getLooper();\n    mServiceHandler = <span class=\"keyword\">new</span> ServiceHandler(mServiceLooper);\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>{\n      Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"service starting\"</span>, Toast.LENGTH_SHORT).show();\n\n      <span class=\"comment\">// 对于每一个启动请求，都发送一个消息来启动一个处理</span>\n      <span class=\"comment\">// 同时传入启动ID，以便任务完成后我们知道该终止哪一个请求。</span>\n      Message msg = mServiceHandler.obtainMessage();\n      msg.arg1 = startId;\n      mServiceHandler.sendMessage(msg);\n\n      <span class=\"comment\">// 如果我们被杀死了，那从这里返回之后被重启</span>\n      <span class=\"keyword\">return</span> START_STICKY;\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>{\n      <span class=\"comment\">// 我们不支持绑定，所以返回null</span>\n      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>{\n    Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"service done\"</span>, Toast.LENGTH_SHORT).show(); \n  }\n}\n</code></pre>\n<p>如你所见，它要干的事情比用IntentService时多了很多。</p>\n<p>不过，因为是自行处理每个onStartCommand()调用，你可以同时处理多个请求。 本例中没有这么去实现，但只要你愿意，你就可以为每个请求创建一个新的线程，并立即运行它们（而不是等待前一个请求处理完毕）。</p>\n<p>请注意onStartCommand()方法必须返回一个整数。这个整数是描述系统在杀死服务之后应该如何继续运行（上一节中缺省的 IntentService 实现代码会替你处理这一点，当然那样你就无法修改这个处理过程）。onStartCommand()的返回值必须是以下常量之一：</p>\n<ul>\n<li>START_NOT_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则不会重建服务了，除非还存在未发送的intent。 当服务不再是必需的，并且应用程序能够简单地重启那些未完成的工作时，这是避免服务运行的最安全的选项。 </li>\n</ul>\n<ul>\n<li>START_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并调用onStartCommand()，但不会再次送入上一个intent， 而是用null intent来调用onStartCommand() 。除非还有启动服务的intent未发送完，那么这些剩下的intent会继续发送。 这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命。 </li>\n</ul>\n<ul>\n<li>START_REDELIVER_INTENT: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并用上一个已送过的intent调用onStartCommand()。任何未发送完的intent也都会依次送入。这适用于那些需要立即恢复工作的活跃服务，比如下载文件。    </li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一-Service简介\"><a href=\"#一-Service简介\" class=\"headerlink\" title=\"一 Service简介\"></a>一 Service简介</h3><p>Service也是Android的四大组件之一，它并不提供用户界面，主要做一些即使该应用程序被调入后台也需要运行的事务。比如下载，音乐播放，执行文件I/O或者与content provider进行交互等。Service主要做的就是上面这些比较耗时的操作，但是由于Service也是运行在主线程中，因此最好在其中另开一个线程做这些耗时操作，否者可能会引起UI阻塞。       </p>\n<h3 id=\"二-Service的两种启动方式\"><a href=\"#二-Service的两种启动方式\" class=\"headerlink\" title=\"二 Service的两种启动方式\"></a>二 Service的两种启动方式</h3><p>Service有started和bound两种启动方式，当然也可以两种都启用。你可通过startService()启动服务后再通过bindService()将activity于Service绑定。     </p>\n<h5 id=\"1-startService-启动\"><a href=\"#1-startService-启动\" class=\"headerlink\" title=\"1.startService()启动\"></a>1.startService()启动</h5><p>通过startService()启动的Service，Service一旦启动即与它的调用者（通常是某个activity）不再关联，即使调用它的组件被销毁，它也能在后台一直运行下去。通常，该类服务执行单一的操作并且不会向调用者返回结果，比如它可以通过网络下载或上传文件。此类服务应该在其工作完成后通过重写stopSelf()使其自行终止，或者由其他组件调用stopService()来终止。<br>通过startService()启动的服务需要实现它的生命周期中onStartCommand()方法        </p>\n<h5 id=\"2-bindService-启动\"><a href=\"#2-bindService-启动\" class=\"headerlink\" title=\"2.bindService()启动\"></a>2.bindService()启动</h5><p>通过bindService()启动的服务，该服务的生命周期将与启动它的组件相关联，即如果启动它的组件被销毁则该服务也会被销毁，或者通过调用unBindService()与服务解绑，解绑后服务被销毁。多个组件可以同时与一个服务绑定，当所有组件都与服务解绑后，该服务才会被销毁。<br>bind服务提供了一个客户端/服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至进行进程间通信（IPC）。<br>通过bindService()启动的服务需要实现Service中的onBind()方法。   </p>\n<h3 id=\"三-Service的生命周期\"><a href=\"#三-Service的生命周期\" class=\"headerlink\" title=\"三 Service的生命周期\"></a>三 Service的生命周期</h3><p>两种Service的生命周期如下图：<br><img src=\"/2017/02/27/android基础之Service/Service生命周期图.png\" alt=\"Service生命周期图\" title=\"Service生命周期图\"><br>其回调方法如下：     </p>\n<pre><code class=\"java\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>{\n    <span class=\"keyword\">int</span> mStartMode;       <span class=\"comment\">// indicates how to behave if the service is killed</span>\n    IBinder mBinder;      <span class=\"comment\">// interface for clients that bind</span>\n    <span class=\"keyword\">boolean</span> mAllowRebind; <span class=\"comment\">// indicates whether onRebind should be used</span>\n\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>{\n        <span class=\"comment\">// The service is being created</span>\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>{\n        <span class=\"comment\">// The service is starting, due to a call to startService()</span>\n        <span class=\"keyword\">return</span> mStartMode;\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>{\n        <span class=\"comment\">// A client is binding to the service with bindService()</span>\n        <span class=\"keyword\">return</span> mBinder;\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onUnbind</span><span class=\"params\">(Intent intent)</span> </span>{\n        <span class=\"comment\">// All clients have unbound with unbindService()</span>\n        <span class=\"keyword\">return</span> mAllowRebind;\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRebind</span><span class=\"params\">(Intent intent)</span> </span>{\n        <span class=\"comment\">// A client is binding to the service with bindService(),</span>\n        <span class=\"comment\">// after onUnbind() has already been called</span>\n    }\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>{\n        <span class=\"comment\">// The service is no longer used and is being destroyed</span>\n    }\n}\n</code></pre>\n<h3 id=\"四-Service与线程的区别\"><a href=\"#四-Service与线程的区别\" class=\"headerlink\" title=\"四 Service与线程的区别\"></a>四 Service与线程的区别</h3><ul>\n<li>Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。     </li>\n<li>Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。<br>其实谈Service和线程的区别毫无意义，它们本来就是毫无关联的两样东西，我觉得应该谈的是在什么情况下，什么地方使用线程更合适。<br>比如：如果你的线程主要用于对UI的更新，那么在Activity中新建即可。但是如果你的线程用于app和服务器之间的消息推送，你需要隔一段时间就要连接服务器做数据同步的话，那么就不能在Activity中新建线程。因为此时的线程在Activity被销毁时，它仍然需要运行。此时将面对一个问题，如果你是Activity中创建得线程，那么当该Activity被销毁时，你将失去该线程的实例。另一方面，你没办法在不同的Activity中对同一线程进行控制。这种情况你就需要在Service中创建它，一方面Service在Activity被销毁时仍然可以运行，另一方面其他的Activity重建后也可以通过与Service进行绑定获得Service的实例，进而控制该线程。</li>\n</ul>\n<h3 id=\"五-保证Service不被杀死\"><a href=\"#五-保证Service不被杀死\" class=\"headerlink\" title=\"五 保证Service不被杀死\"></a>五 保证Service不被杀死</h3><ul>\n<li>onStartCommand方法，返回START_STICKY   </li>\n<li>提升service优先级   </li>\n<li>提升service进程优先级,将其提升为前台服务    </li>\n<li>onDestroy方法里重启service  </li>\n<li>监听系统广播判断Service状态    </li>\n<li>将APK安装到/system/app，变身系统级应用      </li>\n</ul>\n<h3 id=\"六-IntentService\"><a href=\"#六-IntentService\" class=\"headerlink\" title=\"六 IntentService\"></a>六 IntentService</h3><p>因为大多数started服务都不需要同时处理多个请求（这实际上是一个危险的多线程情况），所以最佳方式也许就是用IntentService类来实现你的服务。<br>IntentService将执行以下步骤：    　　</p>\n<ul>\n<li>创建一个缺省的工作（worker）线程，它独立于应用程序主线程来执行所有发送到onStartCommand()的intent。　　　</li>\n<li>创建一个工作队列，每次向你的onHandleIntent()传入一个intent，这样你就永远不必担心多线程问题了。　</li>\n<li>在处理完所有的启动请求后，终止服务，因此你就永远不需调用stopSelf()了。　　</li>\n<li>提供缺省的onBind()实现代码，它返回null。</li>\n<li>提供缺省的onStartCommand()实现代码，它把intent送入工作队列，稍后会再传给你的onHandleIntent()实现代码。　　　</li>\n</ul>\n<p>以上所有步骤将汇成一个结果：你要做的全部工作就是实现onHandleIntent()的代码，来完成客户端提交的任务。（当然你还需要为服务提供一小段构造方法。）       </p>\n<p>以下是个IntentService的实现例程：    </p>\n<pre><code class=\"java\">\n<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloIntentService</span> <span class=\"keyword\">extends</span> <span class=\"title\">IntentService</span> </span>{\n\n  <span class=\"comment\">/** \n   * 构造方法是必需的，必须用工作线程名称作为参数\n   * 调用父类的[http://developer.android.com/reference/android/app/IntentService.html#IntentService(java.lang.String) IntentService(String)]构造方法。\n   */</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HelloIntentService</span><span class=\"params\">()</span> </span>{\n      <span class=\"keyword\">super</span>(<span class=\"string\">\"HelloIntentService\"</span>);\n  }\n\n  <span class=\"comment\">/**\n   * IntentService从缺省的工作线程中调用本方法，并用启动服务的intent作为参数。 \n   * 本方法返回后，IntentService将适时终止这个服务。\n   */</span>\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onHandleIntent</span><span class=\"params\">(Intent intent)</span> </span>{\n      <span class=\"comment\">// 通常我们会在这里执行一些工作，比如下载文件。</span>\n      <span class=\"comment\">// 作为例子，我们只是睡5秒钟。</span>\n      <span class=\"keyword\">long</span> endTime = System.currentTimeMillis() + <span class=\"number\">5</span>*<span class=\"number\">1000</span>;\n      <span class=\"keyword\">while</span> (System.currentTimeMillis() &lt; endTime) {\n          <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) {\n              <span class=\"keyword\">try</span> {\n                  wait(endTime - System.currentTimeMillis());\n              } <span class=\"keyword\">catch</span> (Exception e) {\n              }\n          }\n      }\n  }\n}\n</code></pre>\n<p>所有你需要做的就是：一个构造方法和一个onHandleIntent()方法的实现。</p>\n<p>如果你还决定重写其它的回调方法，比如onCreate()、onStartCommand()、onDestroy()， 请确保调用一下父类的实现代码，以便IntentService能正确处理工作线程的生命周期。</p>\n<p>比如说，onStartCommand()必须返回缺省实现代码的结果（缺省代码实现了如何获取传给onHandleIntent()的intent）：    </p>\n<pre><code class=\"java\"><span class=\"meta\">@Override</span>\n<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>{\n    Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"service starting\"</span>, Toast.LENGTH_SHORT).show();\n    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onStartCommand(intent,flags,startId);\n}\n</code></pre>\n<p>除了onHandleIntent()以外，唯一不需要调用父类实现代码的方法是onBind()（不过如果你的服务允许绑定，你还是需要实现它）。    </p>\n<h3 id=\"七-扩展Service\"><a href=\"#七-扩展Service\" class=\"headerlink\" title=\"七 扩展Service\"></a>七 扩展Service</h3><p>如上节所述，利用IntentService来实现一个started服务非常简单。 不过，假如你的服务需要多线程运行（而不是通过一个工作队列来处理启动请求），那你可以扩展Service类来完成每个intent的处理。</p>\n<p>作为对照，以下例程实现了 Service 类，它执行的工作与上述使用IntentService的例子相同。确切地说，对于每一个启动请求，它都用一个工作线程来完成处理工作，并且每次只处理一个请求。    </p>\n<pre><code class=\"java\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>{\n  <span class=\"keyword\">private</span> Looper mServiceLooper;\n  <span class=\"keyword\">private</span> ServiceHandler mServiceHandler;\n\n  <span class=\"comment\">// 处理从线程接收的消息</span>\n  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>{\n      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServiceHandler</span><span class=\"params\">(Looper looper)</span> </span>{\n          <span class=\"keyword\">super</span>(looper);\n      }\n      <span class=\"meta\">@Override</span>\n      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>{\n          <span class=\"comment\">// 通常我们在这里执行一些工作，比如下载文件。</span>\n          <span class=\"comment\">// 作为例子，我们只是睡个5秒钟。</span>\n          <span class=\"keyword\">long</span> endTime = System.currentTimeMillis() + <span class=\"number\">5</span>*<span class=\"number\">1000</span>;\n          <span class=\"keyword\">while</span> (System.currentTimeMillis() &lt; endTime) {\n              <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) {\n                  <span class=\"keyword\">try</span> {\n                      wait(endTime - System.currentTimeMillis());\n                  } <span class=\"keyword\">catch</span> (Exception e) {\n                  }\n              }\n          }\n          <span class=\"comment\">// 根据startId终止服务，这样我们就不会在处理其它工作的过程中再来终止服务</span>\n          stopSelf(msg.arg1);\n      }\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>{\n    <span class=\"comment\">// 启动运行服务的线程。</span>\n    <span class=\"comment\">// 请记住我们要创建一个单独的线程，因为服务通常运行于进程的主线程中，可我们不想阻塞主线程。</span>\n    <span class=\"comment\">// 我们还要赋予它后台运行的优先级，以便计算密集的工作不会干扰我们的UI。</span>\n    HandlerThread thread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">\"ServiceStartArguments\"</span>,\n            Process.THREAD_PRIORITY_BACKGROUND);\n    thread.start();\n\n    <span class=\"comment\">// 获得HandlerThread的Looper队列并用于Handler</span>\n    mServiceLooper = thread.getLooper();\n    mServiceHandler = <span class=\"keyword\">new</span> ServiceHandler(mServiceLooper);\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>{\n      Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"service starting\"</span>, Toast.LENGTH_SHORT).show();\n\n      <span class=\"comment\">// 对于每一个启动请求，都发送一个消息来启动一个处理</span>\n      <span class=\"comment\">// 同时传入启动ID，以便任务完成后我们知道该终止哪一个请求。</span>\n      Message msg = mServiceHandler.obtainMessage();\n      msg.arg1 = startId;\n      mServiceHandler.sendMessage(msg);\n\n      <span class=\"comment\">// 如果我们被杀死了，那从这里返回之后被重启</span>\n      <span class=\"keyword\">return</span> START_STICKY;\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>{\n      <span class=\"comment\">// 我们不支持绑定，所以返回null</span>\n      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;\n  }\n\n  <span class=\"meta\">@Override</span>\n  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>{\n    Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"service done\"</span>, Toast.LENGTH_SHORT).show(); \n  }\n}\n</code></pre>\n<p>如你所见，它要干的事情比用IntentService时多了很多。</p>\n<p>不过，因为是自行处理每个onStartCommand()调用，你可以同时处理多个请求。 本例中没有这么去实现，但只要你愿意，你就可以为每个请求创建一个新的线程，并立即运行它们（而不是等待前一个请求处理完毕）。</p>\n<p>请注意onStartCommand()方法必须返回一个整数。这个整数是描述系统在杀死服务之后应该如何继续运行（上一节中缺省的 IntentService 实现代码会替你处理这一点，当然那样你就无法修改这个处理过程）。onStartCommand()的返回值必须是以下常量之一：</p>\n<ul>\n<li>START_NOT_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则不会重建服务了，除非还存在未发送的intent。 当服务不再是必需的，并且应用程序能够简单地重启那些未完成的工作时，这是避免服务运行的最安全的选项。 </li>\n</ul>\n<ul>\n<li>START_STICKY: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并调用onStartCommand()，但不会再次送入上一个intent， 而是用null intent来调用onStartCommand() 。除非还有启动服务的intent未发送完，那么这些剩下的intent会继续发送。 这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命。 </li>\n</ul>\n<ul>\n<li>START_REDELIVER_INTENT: 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并用上一个已送过的intent调用onStartCommand()。任何未发送完的intent也都会依次送入。这适用于那些需要立即恢复工作的活跃服务，比如下载文件。    </li>\n</ul>\n"},{"title":"android基础之activity","date":"2017-02-27T02:35:34.000Z","_content":"\n### 一 Activity简介   \nactivity是android四大组件之一，用于android app的界面显示。activity中包含一个window，window中则包含包含相应的view。\n\n### 二 Activity类的层次结构    \n继承的抽象类： ContextThemeWrapper\n实现的接口： ComponentCallbacks2 KeyEvent.Callback LayoutInflater.Factory2 View.OnCreateContextMenuListener Window.Callback      \n\n```java   \njava.lang.Object   \n\tandroid.content.Context\n\t\tandroid.content.ContextWrapper\n\t\t\tandroid.content.ContextThemeWrapper\n\t\t\t\tandroid.app.Activity\n```\n\n直接子类： AccountAuthenticatorActivity, ActivityGroup, AliasActivity, ExpandableListActivity, FragmentActivity, ListActivity, NativeActivity 　　　\n间接子类： ActionBarActivity, LauncherActivity, PreferenceActivity, TabActivity 　　　\n\n### 三 Activity的生命周期   　\nActivity在它的一生中有以下四种状态：  \n- running：此时Activity处于屏幕的前台并且拥有焦点，位于回退栈的顶部（回退栈将在下面介绍）。   \n- paused： 此时另一个Activity位于前台并拥有焦点，也就是说另一个Activity覆盖在本Activity的上面，但是这个Activity是透明的或者没有占据全屏，即从屏幕上还可以看到下面的Activity（比如弹出个红包）。一个paused的activity是完全存活的（Activity 对象仍然保留在内存里，它保持着所有的状态和成员信息，并且保持与window manager的联接），但在系统内存严重不足的情况下它能被杀死。    \n- stopped： 本Activity被其他Activity完全覆盖了，看不见了。一个stopped的activity也仍然是存活的（Activity 对象仍然保留在内存中，它保持着所有的状态和成员信息，但是不再与window manager联接了）。 但是，对于用户而言它已经不再可见了，并且当其它地方需要内存时它将会被杀死。    \n- killed： 当Activity处于paused或者stopped时，若内存不足，它将可能被干掉。当它被再次创建处于前台时，需要调用onCreate方法重新创建并恢复之前的状态    \n下面是activity的生命周期图：      \n{% asset_img activity生命周期图.png activity生命周期图 %}       \n由上图可以看出activity有三种不同的生命周期：　　\n- 完整生命周期： onCreate--onDestroy    \n- 可见生命周期： onResume到onPause之间循环    \n- 前台生命周期： onStart-onStop-onRestart三者之间循环    \nActivity中的回调方法    \n\n```java\npublic class ExampleActivity extends Activity {\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        // The activity is being created.\n    }\n    @Override\n    protected void onStart() {\n        super.onStart();\n        // The activity is about to become visible.\n    }\n    @Override\n    protected void onResume() {\n        super.onResume();\n        // The activity has become visible (it is now \"resumed\").\n    }\n    @Override\n    protected void onPause() {\n        super.onPause();\n        // Another activity is taking focus (this activity is about to be \"paused\").\n    }\n    @Override\n    protected void onStop() {\n        super.onStop();\n        // The activity is no longer visible (it is now \"stopped\")\n    }\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        // The activity is about to be destroyed.\n    }\n}\n```\n \nActivity回调方法汇总：       \n{% asset_img activity回调方法汇总.png activity回调方法汇总 %}       \n标为“之后可否被杀死？”的列指明了系统是否可以在这个方法返回之后的任意时刻杀掉这个activity的宿主进程， 而不再执行其它流程上的activity代码。 有三个方法是标为“可以”：（ onPause()、 onStop()、 和onDestroy()）。 因为onPause()是三个方法中的第一个， 一旦activity被创建， onPause() 就是进程可以被杀死之前最后一个能确保被调用的方法 ——如果系统在某种紧急情况下必须回收内存，则 onStop() 和onDestroy() 可能就不会被调用了。因此，你应该使用 onPause() 来把至关重要的需长期保存的数据写入存储器（比如用户所编辑的内容）。 不过，应该对必须通过 onPause() 方法进行保存的信息有所选择，因为该方法中所有的阻塞操作都会让切换到下一个activity的停滞，并使用户感觉到迟缓。\n\n“之后可否被杀死？”列中标为“否”的方法，在它们被调用时的那一刻起，就会保护本activity的宿主进程不被杀掉。 因此，只有在 onPause() 方法返回时至 onResume() 方法被调用时之间，activity才会被杀掉。直到 onPause() 再次被调用并返回时，activity都不会再次允许被杀死。\n\nNote:表1中标明的技术上不“可杀”的activity仍然有可能会被系统杀死——但那只有在没有任何资源的极端情况下才会发生。     \n\n### 四 保存Activity的状态    \n上一节中已简单提到，当一个activity被paused或者stopped时，activity的状态可以被保存。 的确如此，因为 Activity 对象在paused或者stopped时仍然被保留在内存之中——它所有的成员信息和当前状态都仍然存活。 这样用户在activity里所作的改动全都还保存着，所以当activity返回到前台时（当它“resume“），那些改动仍然有效。\n\n不过，如果系统是为了回收内存而销毁activity，则这个 Activity 对象就会被销毁，这样系统就无法简单地resume一下就能还原完整状态的activity。 如果用户要返回到这个activity的话，系统必须重新创建这个Activity 对象。可是用户并不知道系统是先销毁activity再重新创建了它的，所以，他很可能希望activity完全保持原样。 这种情况下，你可以保证activity状态的相关重要信息都由另一个回调方法保存下来了，此方法让你能保存activity状态的相关信息： onSaveInstanceState()。\n\n在activity变得很容易被销毁之前，系统会调用 onSaveInstanceState()方法。 调用时系统会传入一个Bundle对象， 你可以利用 putString() 之类的方法，以键值对的方式来把activity状态信息保存到该Bundle对象中。 然后，如果系统杀掉了你的application进程并且用户又返回到你的activity，系统就会重建activity并将这个 Bundle 传入onCreate() 和onRestoreInstanceState() 中，你就可以从 Bundle 中解析出已保存信息并恢复activity状态。如果没有储存状态信息，那么传入的 Bundle 将为null（当activity第一次被创建时就是如此）。     \n下图是Activity状态保存示意图：      \n{% asset_img Activity状态保存示意图.png activity状态保存示意图 %}  \n### 五 配置改动后的处理   \n设备的某些配置可能会在运行时发生变化（比如屏幕方向、键盘可用性以及语言）。 当发生这些变化时，Android会重建这个运行中的activity（系统会调用 onDestroy() ，然后再马上调用 onCreate() ）。这种设计有助于应用程序适用新的参数配置，通过把你预置的可替换资源（比如对应各种屏幕方向和尺寸的layout）自动重新装载进入应用程序的方式来实现。\n\n如果你采取了适当的设计，让activity能够正确地处理这些因为屏幕方向而引起的重启，并能如上所述地恢复activity状态， 那么你的应用程序将对生命周期中其它的意外事件更具适应能力。\n\n处理这类重启的最佳方式，就是利用 onSaveInstanceState() 和onRestoreInstanceState() （或者 onCreate() ）进行状态的保存和恢复，如上节所述。   \n\n### 六 Activity的启动方式   \nantivity的启动方式可以通过两种方式定义：     \n\n##### Androidmanifest文件       \nAndroidmanifest文件是android的清单文件，android的四大组件与相应权限皆需在这里设置。在这里你可以利用 <activity> 元素的 launchMode 属性来设定 activity 与 task 的关系。       \n可通过Androidmanifest文件设置的启动模式有：      \n- standard\n- singleTop\n- singleTask\n- singleInstance       \n\n##### Intent标志     \nIntent标志中有以下几种Activity的启动方式:       \n- FLAG_ACTIVITY_NEW_TASK\n- FLAG_ACTIVITY_SINGLE_TOP\n- FLAG_ACTIVITY_CLEAR_TOP       \n通过Intent标志的方式来启动Activity，优先级比manifest的高。    \n\n> **警告**： 大多数应用不应该改变 activity 和 task 默认的工作方式。 如果你确定有必要修改默认方式，请保持\n谨慎，并确保 activity 在启动和从其它 activity 用回退键返回时的可用性。 请确保对可能与用户预期的导航方式\n相冲突的地方进行测试。      \n\n### 七 启动Activity  \n要启动一个activity需要使用Intent，实际上android中组件之前的通信皆由Intent完成（如果你不了解Intent，请看我之后的博客[android基础之Intents与Intent-Filters.md](android基础之Intents与Intent-Filters.md \"android基础之Intents与Intent-Filters\")），而使用Intent启动activity有显示和隐式两种方式。   \n\n\n##### 显示启动      \n\n     \n```java\nIntent intent = new Intent(this, SignInActivity.class);\nstartActivity(intent);//显示启动一个叫SignInActivity的Activity    \n\n```   \n\n\n\n#####  隐式启动    \n要想隐式启动一个activity，你需要使用intent-filter来暴露你的activity。使用filter有java代码和xml文件两种方式，推荐使用第二种方式，你只需在Androidmanifest.xml文件中的activit元素中加入intent-filter属性，并声明一个action即可。但是如果你想使你的activity更独立，那么就不要为你的activity设置filter。那么什么时候使用这种方式呢？    \n如果，你的程序可能想要展示某些动作，例如发邮件，短信，微博，或者使用你activity中的数据。 这时候，你就不应该使用自己的activity来做这些工作。你应该调用系统中其他程序提供的响应功能。 这是intent真正体现其价值的地方。你可以创建一个描述了响应动作的intent,然后系统来为你挑选完成任务的程序。 如果有多个选择，系统会提示用户进行选择。例如你想让用户发邮件，你可以创建下面的intent：        \n\n\n```java\nIntent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_EMAIL, recipientArray);//recipientArray即你想发送过去的联系人信息\nstartActivity(intent);    \n\n```       \n\n##### 启动一个带返回结果的Activity    \n有时候，你想要启动一个activity,并从这个activty获得一个结果。 这时，要通过 startActivityForResult() (取代startActivity()) 来启动activity。 然后通过实现onActivityResult()回调方法来获得返回后的结果。 当这个后续的activity被关闭，它将发送一个 Intent 给 onActivityResult() 方法。     \n  \n例如，你可能想要取一个联系人的信息。下面介绍怎么创建intent并处理结果:         \n\n\n```java\nprivate void pickContact() {\n    // Create an intent to \"pick\" a contact, as defined by the content provider URI\n    Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);\n    startActivityForResult(intent, PICK_CONTACT_REQUEST);\n}\n\n@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    // If the request went well (OK) and the request was PICK_CONTACT_REQUEST\n    if (resultCode == Activity.RESULT_OK && requestCode == PICK_CONTACT_REQUEST) {\n        // Perform a query to the contact's content provider for the contact's name\n        Cursor cursor = getContentResolver().query(data.getData(),\n        new String[] {Contacts.DISPLAY_NAME}, null, null, null);\n        if (cursor.moveToFirst()) { // True if the cursor is not empty\n            int columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);\n            String name = cursor.getString(columnIndex);\n            // Do something with the selected contact's name...\n        }\n    }\n}       \n\n```      \n\n\n这个例子展示了使用onActivityResult() 来获取结果的基本方法。 第一步要判断请求是否被成功响应，通过判断resultCode 是不是RESULT_OK—， 然后判断这个响应是不是针对相应的请求— ，此时只要判断requestCode 和发送时提供的第二个参数 startActivityForResult() 是否相匹配。 最后，查询 Intent中的data信息。 (data 参数)。\n\n这个过程中，ContentResolver 开启了一个查询而不是content provider, 它返回一个 Cursor ，这将允许数据被读取。更多content provider相关信息，请阅读我之后的博客[android基础之Content-Providers.md](android基础之Content-Providers.md \"android基础之Content-Providers\")。     \n\n##### 关闭activity    \n你可以通过调用finish() 来终止activity。 你也可以调用finishActivity() 来终止你之前启动了的一个独立activity。    \n\n> **注意**: 多数情况下，你不应该明确地通过这些方式来关闭acitivity。 就像下面要讨论的activity的生命周期。系统会为你管理。所以你不必关闭他们。 调用这些方法将有悖于用户体验。它们仅用于你绝对不想让用户再返回这个activity的实例。   \n\n\n### 八 Task和back stack    \n一个app通常包含多个activity，android使用task来管理这些activity。当你在手机上没点开一个app，android即为这个app创建一个task，task中有一个back stack，你多点开的activity将依次入栈或者出栈，若你的activity调用别的应用的activity，它也会被压入本activity中。（activity与back stack的关系可阅读上文的activity的启动方式，它定义了activity在back stack中的存在方式）。    \n一个app即对应一个task，若你点开一个新的app，则该新app会进入前台，而之前的会被调入后台。当android的内存不足时，后台的task则可能被销毁。    \n\n其实，activity所处的task可以通过<activity>元素的taskAffinity属性指定，taskAffinity 属性是一个字符串值，必须与<manifest> 元素定义的包名称保证唯一性，因为系统把这个包名称用于标识应用的默认 task affinity值。但是，注意，一般情况下如无必要，不要去修改taskAffinity的值。    \n### 九 总结    \n到这里，android的activity相关的知识已经介绍的差不多了，但是这其中还有很多细节需要读者自己去发现。我所说的并不全面，有些地方可能还有谬误，万不可全信，这些仅仅是我个人的理解。其实博客的功能也只是让你对一个陌生的事物知道个大概，要想最终精通还需要多写多做。这些东西你只有自己经历了，研究了它才能成为你自己的东西，否则不过是镜花水月。   \n作为一个程序员最重要的是勤劳，最后以一句话与大家共勉：慈不掌兵，义不行贾，懒不撸码。\n   \n\n","source":"_posts/android基础之activity.md","raw":"---\ntitle: android基础之activity\ndate: 2017-02-27 10:35:34\ncategories: android\ntags:\n- java\n- android\n- activity\n---\n\n### 一 Activity简介   \nactivity是android四大组件之一，用于android app的界面显示。activity中包含一个window，window中则包含包含相应的view。\n\n### 二 Activity类的层次结构    \n继承的抽象类： ContextThemeWrapper\n实现的接口： ComponentCallbacks2 KeyEvent.Callback LayoutInflater.Factory2 View.OnCreateContextMenuListener Window.Callback      \n\n```java   \njava.lang.Object   \n\tandroid.content.Context\n\t\tandroid.content.ContextWrapper\n\t\t\tandroid.content.ContextThemeWrapper\n\t\t\t\tandroid.app.Activity\n```\n\n直接子类： AccountAuthenticatorActivity, ActivityGroup, AliasActivity, ExpandableListActivity, FragmentActivity, ListActivity, NativeActivity 　　　\n间接子类： ActionBarActivity, LauncherActivity, PreferenceActivity, TabActivity 　　　\n\n### 三 Activity的生命周期   　\nActivity在它的一生中有以下四种状态：  \n- running：此时Activity处于屏幕的前台并且拥有焦点，位于回退栈的顶部（回退栈将在下面介绍）。   \n- paused： 此时另一个Activity位于前台并拥有焦点，也就是说另一个Activity覆盖在本Activity的上面，但是这个Activity是透明的或者没有占据全屏，即从屏幕上还可以看到下面的Activity（比如弹出个红包）。一个paused的activity是完全存活的（Activity 对象仍然保留在内存里，它保持着所有的状态和成员信息，并且保持与window manager的联接），但在系统内存严重不足的情况下它能被杀死。    \n- stopped： 本Activity被其他Activity完全覆盖了，看不见了。一个stopped的activity也仍然是存活的（Activity 对象仍然保留在内存中，它保持着所有的状态和成员信息，但是不再与window manager联接了）。 但是，对于用户而言它已经不再可见了，并且当其它地方需要内存时它将会被杀死。    \n- killed： 当Activity处于paused或者stopped时，若内存不足，它将可能被干掉。当它被再次创建处于前台时，需要调用onCreate方法重新创建并恢复之前的状态    \n下面是activity的生命周期图：      \n{% asset_img activity生命周期图.png activity生命周期图 %}       \n由上图可以看出activity有三种不同的生命周期：　　\n- 完整生命周期： onCreate--onDestroy    \n- 可见生命周期： onResume到onPause之间循环    \n- 前台生命周期： onStart-onStop-onRestart三者之间循环    \nActivity中的回调方法    \n\n```java\npublic class ExampleActivity extends Activity {\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        // The activity is being created.\n    }\n    @Override\n    protected void onStart() {\n        super.onStart();\n        // The activity is about to become visible.\n    }\n    @Override\n    protected void onResume() {\n        super.onResume();\n        // The activity has become visible (it is now \"resumed\").\n    }\n    @Override\n    protected void onPause() {\n        super.onPause();\n        // Another activity is taking focus (this activity is about to be \"paused\").\n    }\n    @Override\n    protected void onStop() {\n        super.onStop();\n        // The activity is no longer visible (it is now \"stopped\")\n    }\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        // The activity is about to be destroyed.\n    }\n}\n```\n \nActivity回调方法汇总：       \n{% asset_img activity回调方法汇总.png activity回调方法汇总 %}       \n标为“之后可否被杀死？”的列指明了系统是否可以在这个方法返回之后的任意时刻杀掉这个activity的宿主进程， 而不再执行其它流程上的activity代码。 有三个方法是标为“可以”：（ onPause()、 onStop()、 和onDestroy()）。 因为onPause()是三个方法中的第一个， 一旦activity被创建， onPause() 就是进程可以被杀死之前最后一个能确保被调用的方法 ——如果系统在某种紧急情况下必须回收内存，则 onStop() 和onDestroy() 可能就不会被调用了。因此，你应该使用 onPause() 来把至关重要的需长期保存的数据写入存储器（比如用户所编辑的内容）。 不过，应该对必须通过 onPause() 方法进行保存的信息有所选择，因为该方法中所有的阻塞操作都会让切换到下一个activity的停滞，并使用户感觉到迟缓。\n\n“之后可否被杀死？”列中标为“否”的方法，在它们被调用时的那一刻起，就会保护本activity的宿主进程不被杀掉。 因此，只有在 onPause() 方法返回时至 onResume() 方法被调用时之间，activity才会被杀掉。直到 onPause() 再次被调用并返回时，activity都不会再次允许被杀死。\n\nNote:表1中标明的技术上不“可杀”的activity仍然有可能会被系统杀死——但那只有在没有任何资源的极端情况下才会发生。     \n\n### 四 保存Activity的状态    \n上一节中已简单提到，当一个activity被paused或者stopped时，activity的状态可以被保存。 的确如此，因为 Activity 对象在paused或者stopped时仍然被保留在内存之中——它所有的成员信息和当前状态都仍然存活。 这样用户在activity里所作的改动全都还保存着，所以当activity返回到前台时（当它“resume“），那些改动仍然有效。\n\n不过，如果系统是为了回收内存而销毁activity，则这个 Activity 对象就会被销毁，这样系统就无法简单地resume一下就能还原完整状态的activity。 如果用户要返回到这个activity的话，系统必须重新创建这个Activity 对象。可是用户并不知道系统是先销毁activity再重新创建了它的，所以，他很可能希望activity完全保持原样。 这种情况下，你可以保证activity状态的相关重要信息都由另一个回调方法保存下来了，此方法让你能保存activity状态的相关信息： onSaveInstanceState()。\n\n在activity变得很容易被销毁之前，系统会调用 onSaveInstanceState()方法。 调用时系统会传入一个Bundle对象， 你可以利用 putString() 之类的方法，以键值对的方式来把activity状态信息保存到该Bundle对象中。 然后，如果系统杀掉了你的application进程并且用户又返回到你的activity，系统就会重建activity并将这个 Bundle 传入onCreate() 和onRestoreInstanceState() 中，你就可以从 Bundle 中解析出已保存信息并恢复activity状态。如果没有储存状态信息，那么传入的 Bundle 将为null（当activity第一次被创建时就是如此）。     \n下图是Activity状态保存示意图：      \n{% asset_img Activity状态保存示意图.png activity状态保存示意图 %}  \n### 五 配置改动后的处理   \n设备的某些配置可能会在运行时发生变化（比如屏幕方向、键盘可用性以及语言）。 当发生这些变化时，Android会重建这个运行中的activity（系统会调用 onDestroy() ，然后再马上调用 onCreate() ）。这种设计有助于应用程序适用新的参数配置，通过把你预置的可替换资源（比如对应各种屏幕方向和尺寸的layout）自动重新装载进入应用程序的方式来实现。\n\n如果你采取了适当的设计，让activity能够正确地处理这些因为屏幕方向而引起的重启，并能如上所述地恢复activity状态， 那么你的应用程序将对生命周期中其它的意外事件更具适应能力。\n\n处理这类重启的最佳方式，就是利用 onSaveInstanceState() 和onRestoreInstanceState() （或者 onCreate() ）进行状态的保存和恢复，如上节所述。   \n\n### 六 Activity的启动方式   \nantivity的启动方式可以通过两种方式定义：     \n\n##### Androidmanifest文件       \nAndroidmanifest文件是android的清单文件，android的四大组件与相应权限皆需在这里设置。在这里你可以利用 <activity> 元素的 launchMode 属性来设定 activity 与 task 的关系。       \n可通过Androidmanifest文件设置的启动模式有：      \n- standard\n- singleTop\n- singleTask\n- singleInstance       \n\n##### Intent标志     \nIntent标志中有以下几种Activity的启动方式:       \n- FLAG_ACTIVITY_NEW_TASK\n- FLAG_ACTIVITY_SINGLE_TOP\n- FLAG_ACTIVITY_CLEAR_TOP       \n通过Intent标志的方式来启动Activity，优先级比manifest的高。    \n\n> **警告**： 大多数应用不应该改变 activity 和 task 默认的工作方式。 如果你确定有必要修改默认方式，请保持\n谨慎，并确保 activity 在启动和从其它 activity 用回退键返回时的可用性。 请确保对可能与用户预期的导航方式\n相冲突的地方进行测试。      \n\n### 七 启动Activity  \n要启动一个activity需要使用Intent，实际上android中组件之前的通信皆由Intent完成（如果你不了解Intent，请看我之后的博客[android基础之Intents与Intent-Filters.md](android基础之Intents与Intent-Filters.md \"android基础之Intents与Intent-Filters\")），而使用Intent启动activity有显示和隐式两种方式。   \n\n\n##### 显示启动      \n\n     \n```java\nIntent intent = new Intent(this, SignInActivity.class);\nstartActivity(intent);//显示启动一个叫SignInActivity的Activity    \n\n```   \n\n\n\n#####  隐式启动    \n要想隐式启动一个activity，你需要使用intent-filter来暴露你的activity。使用filter有java代码和xml文件两种方式，推荐使用第二种方式，你只需在Androidmanifest.xml文件中的activit元素中加入intent-filter属性，并声明一个action即可。但是如果你想使你的activity更独立，那么就不要为你的activity设置filter。那么什么时候使用这种方式呢？    \n如果，你的程序可能想要展示某些动作，例如发邮件，短信，微博，或者使用你activity中的数据。 这时候，你就不应该使用自己的activity来做这些工作。你应该调用系统中其他程序提供的响应功能。 这是intent真正体现其价值的地方。你可以创建一个描述了响应动作的intent,然后系统来为你挑选完成任务的程序。 如果有多个选择，系统会提示用户进行选择。例如你想让用户发邮件，你可以创建下面的intent：        \n\n\n```java\nIntent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_EMAIL, recipientArray);//recipientArray即你想发送过去的联系人信息\nstartActivity(intent);    \n\n```       \n\n##### 启动一个带返回结果的Activity    \n有时候，你想要启动一个activity,并从这个activty获得一个结果。 这时，要通过 startActivityForResult() (取代startActivity()) 来启动activity。 然后通过实现onActivityResult()回调方法来获得返回后的结果。 当这个后续的activity被关闭，它将发送一个 Intent 给 onActivityResult() 方法。     \n  \n例如，你可能想要取一个联系人的信息。下面介绍怎么创建intent并处理结果:         \n\n\n```java\nprivate void pickContact() {\n    // Create an intent to \"pick\" a contact, as defined by the content provider URI\n    Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);\n    startActivityForResult(intent, PICK_CONTACT_REQUEST);\n}\n\n@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    // If the request went well (OK) and the request was PICK_CONTACT_REQUEST\n    if (resultCode == Activity.RESULT_OK && requestCode == PICK_CONTACT_REQUEST) {\n        // Perform a query to the contact's content provider for the contact's name\n        Cursor cursor = getContentResolver().query(data.getData(),\n        new String[] {Contacts.DISPLAY_NAME}, null, null, null);\n        if (cursor.moveToFirst()) { // True if the cursor is not empty\n            int columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);\n            String name = cursor.getString(columnIndex);\n            // Do something with the selected contact's name...\n        }\n    }\n}       \n\n```      \n\n\n这个例子展示了使用onActivityResult() 来获取结果的基本方法。 第一步要判断请求是否被成功响应，通过判断resultCode 是不是RESULT_OK—， 然后判断这个响应是不是针对相应的请求— ，此时只要判断requestCode 和发送时提供的第二个参数 startActivityForResult() 是否相匹配。 最后，查询 Intent中的data信息。 (data 参数)。\n\n这个过程中，ContentResolver 开启了一个查询而不是content provider, 它返回一个 Cursor ，这将允许数据被读取。更多content provider相关信息，请阅读我之后的博客[android基础之Content-Providers.md](android基础之Content-Providers.md \"android基础之Content-Providers\")。     \n\n##### 关闭activity    \n你可以通过调用finish() 来终止activity。 你也可以调用finishActivity() 来终止你之前启动了的一个独立activity。    \n\n> **注意**: 多数情况下，你不应该明确地通过这些方式来关闭acitivity。 就像下面要讨论的activity的生命周期。系统会为你管理。所以你不必关闭他们。 调用这些方法将有悖于用户体验。它们仅用于你绝对不想让用户再返回这个activity的实例。   \n\n\n### 八 Task和back stack    \n一个app通常包含多个activity，android使用task来管理这些activity。当你在手机上没点开一个app，android即为这个app创建一个task，task中有一个back stack，你多点开的activity将依次入栈或者出栈，若你的activity调用别的应用的activity，它也会被压入本activity中。（activity与back stack的关系可阅读上文的activity的启动方式，它定义了activity在back stack中的存在方式）。    \n一个app即对应一个task，若你点开一个新的app，则该新app会进入前台，而之前的会被调入后台。当android的内存不足时，后台的task则可能被销毁。    \n\n其实，activity所处的task可以通过<activity>元素的taskAffinity属性指定，taskAffinity 属性是一个字符串值，必须与<manifest> 元素定义的包名称保证唯一性，因为系统把这个包名称用于标识应用的默认 task affinity值。但是，注意，一般情况下如无必要，不要去修改taskAffinity的值。    \n### 九 总结    \n到这里，android的activity相关的知识已经介绍的差不多了，但是这其中还有很多细节需要读者自己去发现。我所说的并不全面，有些地方可能还有谬误，万不可全信，这些仅仅是我个人的理解。其实博客的功能也只是让你对一个陌生的事物知道个大概，要想最终精通还需要多写多做。这些东西你只有自己经历了，研究了它才能成为你自己的东西，否则不过是镜花水月。   \n作为一个程序员最重要的是勤劳，最后以一句话与大家共勉：慈不掌兵，义不行贾，懒不撸码。\n   \n\n","slug":"android基础之activity","published":1,"updated":"2017-03-03T07:09:28.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk1z001eaknz5d9i713z","content":"<h3 id=\"一-Activity简介\"><a href=\"#一-Activity简介\" class=\"headerlink\" title=\"一 Activity简介\"></a>一 Activity简介</h3><p>activity是android四大组件之一，用于android app的界面显示。activity中包含一个window，window中则包含包含相应的view。</p>\n<h3 id=\"二-Activity类的层次结构\"><a href=\"#二-Activity类的层次结构\" class=\"headerlink\" title=\"二 Activity类的层次结构\"></a>二 Activity类的层次结构</h3><p>继承的抽象类： ContextThemeWrapper<br>实现的接口： ComponentCallbacks2 KeyEvent.Callback LayoutInflater.Factory2 View.OnCreateContextMenuListener Window.Callback      </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.lang.Object   </div><div class=\"line\">\tandroid.content.Context</div><div class=\"line\">\t\tandroid.content.ContextWrapper</div><div class=\"line\">\t\t\tandroid.content.ContextThemeWrapper</div><div class=\"line\">\t\t\t\tandroid.app.Activity</div></pre></td></tr></table></figure>\n<p>直接子类： AccountAuthenticatorActivity, ActivityGroup, AliasActivity, ExpandableListActivity, FragmentActivity, ListActivity, NativeActivity 　　　<br>间接子类： ActionBarActivity, LauncherActivity, PreferenceActivity, TabActivity 　　　</p>\n<h3 id=\"三-Activity的生命周期\"><a href=\"#三-Activity的生命周期\" class=\"headerlink\" title=\"三 Activity的生命周期   　\"></a>三 Activity的生命周期   　</h3><p>Activity在它的一生中有以下四种状态：  </p>\n<ul>\n<li>running：此时Activity处于屏幕的前台并且拥有焦点，位于回退栈的顶部（回退栈将在下面介绍）。   </li>\n<li>paused： 此时另一个Activity位于前台并拥有焦点，也就是说另一个Activity覆盖在本Activity的上面，但是这个Activity是透明的或者没有占据全屏，即从屏幕上还可以看到下面的Activity（比如弹出个红包）。一个paused的activity是完全存活的（Activity 对象仍然保留在内存里，它保持着所有的状态和成员信息，并且保持与window manager的联接），但在系统内存严重不足的情况下它能被杀死。    </li>\n<li>stopped： 本Activity被其他Activity完全覆盖了，看不见了。一个stopped的activity也仍然是存活的（Activity 对象仍然保留在内存中，它保持着所有的状态和成员信息，但是不再与window manager联接了）。 但是，对于用户而言它已经不再可见了，并且当其它地方需要内存时它将会被杀死。    </li>\n<li>killed： 当Activity处于paused或者stopped时，若内存不足，它将可能被干掉。当它被再次创建处于前台时，需要调用onCreate方法重新创建并恢复之前的状态<br>下面是activity的生命周期图：      <img src=\"/2017/02/27/android基础之activity/activity生命周期图.png\" alt=\"activity生命周期图\" title=\"activity生命周期图\">       \n由上图可以看出activity有三种不同的生命周期：　　</li>\n<li>完整生命周期： onCreate–onDestroy    </li>\n<li>可见生命周期： onResume到onPause之间循环    </li>\n<li>前台生命周期： onStart-onStop-onRestart三者之间循环<br>Activity中的回调方法    </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        <span class=\"comment\">// The activity is being created.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onStart();</div><div class=\"line\">        <span class=\"comment\">// The activity is about to become visible.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onResume();</div><div class=\"line\">        <span class=\"comment\">// The activity has become visible (it is now \"resumed\").</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onPause();</div><div class=\"line\">        <span class=\"comment\">// Another activity is taking focus (this activity is about to be \"paused\").</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onStop();</div><div class=\"line\">        <span class=\"comment\">// The activity is no longer visible (it is now \"stopped\")</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</div><div class=\"line\">        <span class=\"comment\">// The activity is about to be destroyed.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Activity回调方法汇总：<br><img src=\"/2017/02/27/android基础之activity/activity回调方法汇总.png\" alt=\"activity回调方法汇总\" title=\"activity回调方法汇总\"><br>标为“之后可否被杀死？”的列指明了系统是否可以在这个方法返回之后的任意时刻杀掉这个activity的宿主进程， 而不再执行其它流程上的activity代码。 有三个方法是标为“可以”：（ onPause()、 onStop()、 和onDestroy()）。 因为onPause()是三个方法中的第一个， 一旦activity被创建， onPause() 就是进程可以被杀死之前最后一个能确保被调用的方法 ——如果系统在某种紧急情况下必须回收内存，则 onStop() 和onDestroy() 可能就不会被调用了。因此，你应该使用 onPause() 来把至关重要的需长期保存的数据写入存储器（比如用户所编辑的内容）。 不过，应该对必须通过 onPause() 方法进行保存的信息有所选择，因为该方法中所有的阻塞操作都会让切换到下一个activity的停滞，并使用户感觉到迟缓。</p>\n<p>“之后可否被杀死？”列中标为“否”的方法，在它们被调用时的那一刻起，就会保护本activity的宿主进程不被杀掉。 因此，只有在 onPause() 方法返回时至 onResume() 方法被调用时之间，activity才会被杀掉。直到 onPause() 再次被调用并返回时，activity都不会再次允许被杀死。</p>\n<p>Note:表1中标明的技术上不“可杀”的activity仍然有可能会被系统杀死——但那只有在没有任何资源的极端情况下才会发生。     </p>\n<h3 id=\"四-保存Activity的状态\"><a href=\"#四-保存Activity的状态\" class=\"headerlink\" title=\"四 保存Activity的状态\"></a>四 保存Activity的状态</h3><p>上一节中已简单提到，当一个activity被paused或者stopped时，activity的状态可以被保存。 的确如此，因为 Activity 对象在paused或者stopped时仍然被保留在内存之中——它所有的成员信息和当前状态都仍然存活。 这样用户在activity里所作的改动全都还保存着，所以当activity返回到前台时（当它“resume“），那些改动仍然有效。</p>\n<p>不过，如果系统是为了回收内存而销毁activity，则这个 Activity 对象就会被销毁，这样系统就无法简单地resume一下就能还原完整状态的activity。 如果用户要返回到这个activity的话，系统必须重新创建这个Activity 对象。可是用户并不知道系统是先销毁activity再重新创建了它的，所以，他很可能希望activity完全保持原样。 这种情况下，你可以保证activity状态的相关重要信息都由另一个回调方法保存下来了，此方法让你能保存activity状态的相关信息： onSaveInstanceState()。</p>\n<p>在activity变得很容易被销毁之前，系统会调用 onSaveInstanceState()方法。 调用时系统会传入一个Bundle对象， 你可以利用 putString() 之类的方法，以键值对的方式来把activity状态信息保存到该Bundle对象中。 然后，如果系统杀掉了你的application进程并且用户又返回到你的activity，系统就会重建activity并将这个 Bundle 传入onCreate() 和onRestoreInstanceState() 中，你就可以从 Bundle 中解析出已保存信息并恢复activity状态。如果没有储存状态信息，那么传入的 Bundle 将为null（当activity第一次被创建时就是如此）。<br>下图是Activity状态保存示意图：<br><img src=\"/2017/02/27/android基础之activity/Activity状态保存示意图.png\" alt=\"activity状态保存示意图\" title=\"activity状态保存示意图\">  </p>\n<h3 id=\"五-配置改动后的处理\"><a href=\"#五-配置改动后的处理\" class=\"headerlink\" title=\"五 配置改动后的处理\"></a>五 配置改动后的处理</h3><p>设备的某些配置可能会在运行时发生变化（比如屏幕方向、键盘可用性以及语言）。 当发生这些变化时，Android会重建这个运行中的activity（系统会调用 onDestroy() ，然后再马上调用 onCreate() ）。这种设计有助于应用程序适用新的参数配置，通过把你预置的可替换资源（比如对应各种屏幕方向和尺寸的layout）自动重新装载进入应用程序的方式来实现。</p>\n<p>如果你采取了适当的设计，让activity能够正确地处理这些因为屏幕方向而引起的重启，并能如上所述地恢复activity状态， 那么你的应用程序将对生命周期中其它的意外事件更具适应能力。</p>\n<p>处理这类重启的最佳方式，就是利用 onSaveInstanceState() 和onRestoreInstanceState() （或者 onCreate() ）进行状态的保存和恢复，如上节所述。   </p>\n<h3 id=\"六-Activity的启动方式\"><a href=\"#六-Activity的启动方式\" class=\"headerlink\" title=\"六 Activity的启动方式\"></a>六 Activity的启动方式</h3><p>antivity的启动方式可以通过两种方式定义：     </p>\n<h5 id=\"Androidmanifest文件\"><a href=\"#Androidmanifest文件\" class=\"headerlink\" title=\"Androidmanifest文件\"></a>Androidmanifest文件</h5><p>Androidmanifest文件是android的清单文件，android的四大组件与相应权限皆需在这里设置。在这里你可以利用 <activity> 元素的 launchMode 属性来设定 activity 与 task 的关系。<br>可通过Androidmanifest文件设置的启动模式有：      </activity></p>\n<ul>\n<li>standard</li>\n<li>singleTop</li>\n<li>singleTask</li>\n<li>singleInstance       </li>\n</ul>\n<h5 id=\"Intent标志\"><a href=\"#Intent标志\" class=\"headerlink\" title=\"Intent标志\"></a>Intent标志</h5><p>Intent标志中有以下几种Activity的启动方式:       </p>\n<ul>\n<li>FLAG_ACTIVITY_NEW_TASK</li>\n<li>FLAG_ACTIVITY_SINGLE_TOP</li>\n<li>FLAG_ACTIVITY_CLEAR_TOP<br>通过Intent标志的方式来启动Activity，优先级比manifest的高。    </li>\n</ul>\n<blockquote>\n<p><strong>警告</strong>： 大多数应用不应该改变 activity 和 task 默认的工作方式。 如果你确定有必要修改默认方式，请保持<br>谨慎，并确保 activity 在启动和从其它 activity 用回退键返回时的可用性。 请确保对可能与用户预期的导航方式<br>相冲突的地方进行测试。      </p>\n</blockquote>\n<h3 id=\"七-启动Activity\"><a href=\"#七-启动Activity\" class=\"headerlink\" title=\"七 启动Activity\"></a>七 启动Activity</h3><p>要启动一个activity需要使用Intent，实际上android中组件之前的通信皆由Intent完成（如果你不了解Intent，请看我之后的博客<a href=\"android基础之Intents与Intent-Filters.md\" title=\"android基础之Intents与Intent-Filters\">android基础之Intents与Intent-Filters.md</a>），而使用Intent启动activity有显示和隐式两种方式。   </p>\n<h5 id=\"显示启动\"><a href=\"#显示启动\" class=\"headerlink\" title=\"显示启动\"></a>显示启动</h5><pre><code class=\"java\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, SignInActivity.class);\nstartActivity(intent);<span class=\"comment\">//显示启动一个叫SignInActivity的Activity</span>\n</code></pre>\n<h5 id=\"隐式启动\"><a href=\"#隐式启动\" class=\"headerlink\" title=\"隐式启动\"></a>隐式启动</h5><p>要想隐式启动一个activity，你需要使用intent-filter来暴露你的activity。使用filter有java代码和xml文件两种方式，推荐使用第二种方式，你只需在Androidmanifest.xml文件中的activit元素中加入intent-filter属性，并声明一个action即可。但是如果你想使你的activity更独立，那么就不要为你的activity设置filter。那么什么时候使用这种方式呢？<br>如果，你的程序可能想要展示某些动作，例如发邮件，短信，微博，或者使用你activity中的数据。 这时候，你就不应该使用自己的activity来做这些工作。你应该调用系统中其他程序提供的响应功能。 这是intent真正体现其价值的地方。你可以创建一个描述了响应动作的intent,然后系统来为你挑选完成任务的程序。 如果有多个选择，系统会提示用户进行选择。例如你想让用户发邮件，你可以创建下面的intent：        </p>\n<pre><code class=\"java\">Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_EMAIL, recipientArray);<span class=\"comment\">//recipientArray即你想发送过去的联系人信息</span>\nstartActivity(intent);\n</code></pre>\n<h5 id=\"启动一个带返回结果的Activity\"><a href=\"#启动一个带返回结果的Activity\" class=\"headerlink\" title=\"启动一个带返回结果的Activity\"></a>启动一个带返回结果的Activity</h5><p>有时候，你想要启动一个activity,并从这个activty获得一个结果。 这时，要通过 startActivityForResult() (取代startActivity()) 来启动activity。 然后通过实现onActivityResult()回调方法来获得返回后的结果。 当这个后续的activity被关闭，它将发送一个 Intent 给 onActivityResult() 方法。     </p>\n<p>例如，你可能想要取一个联系人的信息。下面介绍怎么创建intent并处理结果:         </p>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">pickContact</span><span class=\"params\">()</span> </span>{\n    <span class=\"comment\">// Create an intent to \"pick\" a contact, as defined by the content provider URI</span>\n    Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);\n    startActivityForResult(intent, PICK_CONTACT_REQUEST);\n}\n\n<span class=\"meta\">@Override</span>\n<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> resultCode, Intent data)</span> </span>{\n    <span class=\"comment\">// If the request went well (OK) and the request was PICK_CONTACT_REQUEST</span>\n    <span class=\"keyword\">if</span> (resultCode == Activity.RESULT_OK &amp;&amp; requestCode == PICK_CONTACT_REQUEST) {\n        <span class=\"comment\">// Perform a query to the contact's content provider for the contact's name</span>\n        Cursor cursor = getContentResolver().query(data.getData(),\n        <span class=\"keyword\">new</span> String[] {Contacts.DISPLAY_NAME}, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);\n        <span class=\"keyword\">if</span> (cursor.moveToFirst()) { <span class=\"comment\">// True if the cursor is not empty</span>\n            <span class=\"keyword\">int</span> columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);\n            String name = cursor.getString(columnIndex);\n            <span class=\"comment\">// Do something with the selected contact's name...</span>\n        }\n    }\n}\n</code></pre>\n<p>这个例子展示了使用onActivityResult() 来获取结果的基本方法。 第一步要判断请求是否被成功响应，通过判断resultCode 是不是RESULT_OK—， 然后判断这个响应是不是针对相应的请求— ，此时只要判断requestCode 和发送时提供的第二个参数 startActivityForResult() 是否相匹配。 最后，查询 Intent中的data信息。 (data 参数)。</p>\n<p>这个过程中，ContentResolver 开启了一个查询而不是content provider, 它返回一个 Cursor ，这将允许数据被读取。更多content provider相关信息，请阅读我之后的博客<a href=\"android基础之Content-Providers.md\" title=\"android基础之Content-Providers\">android基础之Content-Providers.md</a>。     </p>\n<h5 id=\"关闭activity\"><a href=\"#关闭activity\" class=\"headerlink\" title=\"关闭activity\"></a>关闭activity</h5><p>你可以通过调用finish() 来终止activity。 你也可以调用finishActivity() 来终止你之前启动了的一个独立activity。    </p>\n<blockquote>\n<p><strong>注意</strong>: 多数情况下，你不应该明确地通过这些方式来关闭acitivity。 就像下面要讨论的activity的生命周期。系统会为你管理。所以你不必关闭他们。 调用这些方法将有悖于用户体验。它们仅用于你绝对不想让用户再返回这个activity的实例。   </p>\n</blockquote>\n<h3 id=\"八-Task和back-stack\"><a href=\"#八-Task和back-stack\" class=\"headerlink\" title=\"八 Task和back stack\"></a>八 Task和back stack</h3><p>一个app通常包含多个activity，android使用task来管理这些activity。当你在手机上没点开一个app，android即为这个app创建一个task，task中有一个back stack，你多点开的activity将依次入栈或者出栈，若你的activity调用别的应用的activity，它也会被压入本activity中。（activity与back stack的关系可阅读上文的activity的启动方式，它定义了activity在back stack中的存在方式）。<br>一个app即对应一个task，若你点开一个新的app，则该新app会进入前台，而之前的会被调入后台。当android的内存不足时，后台的task则可能被销毁。    </p>\n<p>其实，activity所处的task可以通过<activity>元素的taskAffinity属性指定，taskAffinity 属性是一个字符串值，必须与<manifest> 元素定义的包名称保证唯一性，因为系统把这个包名称用于标识应用的默认 task affinity值。但是，注意，一般情况下如无必要，不要去修改taskAffinity的值。    </manifest></activity></p>\n<h3 id=\"九-总结\"><a href=\"#九-总结\" class=\"headerlink\" title=\"九 总结\"></a>九 总结</h3><p>到这里，android的activity相关的知识已经介绍的差不多了，但是这其中还有很多细节需要读者自己去发现。我所说的并不全面，有些地方可能还有谬误，万不可全信，这些仅仅是我个人的理解。其实博客的功能也只是让你对一个陌生的事物知道个大概，要想最终精通还需要多写多做。这些东西你只有自己经历了，研究了它才能成为你自己的东西，否则不过是镜花水月。<br>作为一个程序员最重要的是勤劳，最后以一句话与大家共勉：慈不掌兵，义不行贾，懒不撸码。</p>\n","excerpt":"","more":"<h3 id=\"一-Activity简介\"><a href=\"#一-Activity简介\" class=\"headerlink\" title=\"一 Activity简介\"></a>一 Activity简介</h3><p>activity是android四大组件之一，用于android app的界面显示。activity中包含一个window，window中则包含包含相应的view。</p>\n<h3 id=\"二-Activity类的层次结构\"><a href=\"#二-Activity类的层次结构\" class=\"headerlink\" title=\"二 Activity类的层次结构\"></a>二 Activity类的层次结构</h3><p>继承的抽象类： ContextThemeWrapper<br>实现的接口： ComponentCallbacks2 KeyEvent.Callback LayoutInflater.Factory2 View.OnCreateContextMenuListener Window.Callback      </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.lang.Object   </div><div class=\"line\">\tandroid.content.Context</div><div class=\"line\">\t\tandroid.content.ContextWrapper</div><div class=\"line\">\t\t\tandroid.content.ContextThemeWrapper</div><div class=\"line\">\t\t\t\tandroid.app.Activity</div></pre></td></tr></table></figure>\n<p>直接子类： AccountAuthenticatorActivity, ActivityGroup, AliasActivity, ExpandableListActivity, FragmentActivity, ListActivity, NativeActivity 　　　<br>间接子类： ActionBarActivity, LauncherActivity, PreferenceActivity, TabActivity 　　　</p>\n<h3 id=\"三-Activity的生命周期\"><a href=\"#三-Activity的生命周期\" class=\"headerlink\" title=\"三 Activity的生命周期   　\"></a>三 Activity的生命周期   　</h3><p>Activity在它的一生中有以下四种状态：  </p>\n<ul>\n<li>running：此时Activity处于屏幕的前台并且拥有焦点，位于回退栈的顶部（回退栈将在下面介绍）。   </li>\n<li>paused： 此时另一个Activity位于前台并拥有焦点，也就是说另一个Activity覆盖在本Activity的上面，但是这个Activity是透明的或者没有占据全屏，即从屏幕上还可以看到下面的Activity（比如弹出个红包）。一个paused的activity是完全存活的（Activity 对象仍然保留在内存里，它保持着所有的状态和成员信息，并且保持与window manager的联接），但在系统内存严重不足的情况下它能被杀死。    </li>\n<li>stopped： 本Activity被其他Activity完全覆盖了，看不见了。一个stopped的activity也仍然是存活的（Activity 对象仍然保留在内存中，它保持着所有的状态和成员信息，但是不再与window manager联接了）。 但是，对于用户而言它已经不再可见了，并且当其它地方需要内存时它将会被杀死。    </li>\n<li>killed： 当Activity处于paused或者stopped时，若内存不足，它将可能被干掉。当它被再次创建处于前台时，需要调用onCreate方法重新创建并恢复之前的状态<br>下面是activity的生命周期图：      <img src=\"/2017/02/27/android基础之activity/activity生命周期图.png\" alt=\"activity生命周期图\" title=\"activity生命周期图\">       \n由上图可以看出activity有三种不同的生命周期：　　</li>\n<li>完整生命周期： onCreate–onDestroy    </li>\n<li>可见生命周期： onResume到onPause之间循环    </li>\n<li>前台生命周期： onStart-onStop-onRestart三者之间循环<br>Activity中的回调方法    </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        <span class=\"comment\">// The activity is being created.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onStart();</div><div class=\"line\">        <span class=\"comment\">// The activity is about to become visible.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onResume();</div><div class=\"line\">        <span class=\"comment\">// The activity has become visible (it is now \"resumed\").</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onPause();</div><div class=\"line\">        <span class=\"comment\">// Another activity is taking focus (this activity is about to be \"paused\").</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onStop();</div><div class=\"line\">        <span class=\"comment\">// The activity is no longer visible (it is now \"stopped\")</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</div><div class=\"line\">        <span class=\"comment\">// The activity is about to be destroyed.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Activity回调方法汇总：<br><img src=\"/2017/02/27/android基础之activity/activity回调方法汇总.png\" alt=\"activity回调方法汇总\" title=\"activity回调方法汇总\"><br>标为“之后可否被杀死？”的列指明了系统是否可以在这个方法返回之后的任意时刻杀掉这个activity的宿主进程， 而不再执行其它流程上的activity代码。 有三个方法是标为“可以”：（ onPause()、 onStop()、 和onDestroy()）。 因为onPause()是三个方法中的第一个， 一旦activity被创建， onPause() 就是进程可以被杀死之前最后一个能确保被调用的方法 ——如果系统在某种紧急情况下必须回收内存，则 onStop() 和onDestroy() 可能就不会被调用了。因此，你应该使用 onPause() 来把至关重要的需长期保存的数据写入存储器（比如用户所编辑的内容）。 不过，应该对必须通过 onPause() 方法进行保存的信息有所选择，因为该方法中所有的阻塞操作都会让切换到下一个activity的停滞，并使用户感觉到迟缓。</p>\n<p>“之后可否被杀死？”列中标为“否”的方法，在它们被调用时的那一刻起，就会保护本activity的宿主进程不被杀掉。 因此，只有在 onPause() 方法返回时至 onResume() 方法被调用时之间，activity才会被杀掉。直到 onPause() 再次被调用并返回时，activity都不会再次允许被杀死。</p>\n<p>Note:表1中标明的技术上不“可杀”的activity仍然有可能会被系统杀死——但那只有在没有任何资源的极端情况下才会发生。     </p>\n<h3 id=\"四-保存Activity的状态\"><a href=\"#四-保存Activity的状态\" class=\"headerlink\" title=\"四 保存Activity的状态\"></a>四 保存Activity的状态</h3><p>上一节中已简单提到，当一个activity被paused或者stopped时，activity的状态可以被保存。 的确如此，因为 Activity 对象在paused或者stopped时仍然被保留在内存之中——它所有的成员信息和当前状态都仍然存活。 这样用户在activity里所作的改动全都还保存着，所以当activity返回到前台时（当它“resume“），那些改动仍然有效。</p>\n<p>不过，如果系统是为了回收内存而销毁activity，则这个 Activity 对象就会被销毁，这样系统就无法简单地resume一下就能还原完整状态的activity。 如果用户要返回到这个activity的话，系统必须重新创建这个Activity 对象。可是用户并不知道系统是先销毁activity再重新创建了它的，所以，他很可能希望activity完全保持原样。 这种情况下，你可以保证activity状态的相关重要信息都由另一个回调方法保存下来了，此方法让你能保存activity状态的相关信息： onSaveInstanceState()。</p>\n<p>在activity变得很容易被销毁之前，系统会调用 onSaveInstanceState()方法。 调用时系统会传入一个Bundle对象， 你可以利用 putString() 之类的方法，以键值对的方式来把activity状态信息保存到该Bundle对象中。 然后，如果系统杀掉了你的application进程并且用户又返回到你的activity，系统就会重建activity并将这个 Bundle 传入onCreate() 和onRestoreInstanceState() 中，你就可以从 Bundle 中解析出已保存信息并恢复activity状态。如果没有储存状态信息，那么传入的 Bundle 将为null（当activity第一次被创建时就是如此）。<br>下图是Activity状态保存示意图：<br><img src=\"/2017/02/27/android基础之activity/Activity状态保存示意图.png\" alt=\"activity状态保存示意图\" title=\"activity状态保存示意图\">  </p>\n<h3 id=\"五-配置改动后的处理\"><a href=\"#五-配置改动后的处理\" class=\"headerlink\" title=\"五 配置改动后的处理\"></a>五 配置改动后的处理</h3><p>设备的某些配置可能会在运行时发生变化（比如屏幕方向、键盘可用性以及语言）。 当发生这些变化时，Android会重建这个运行中的activity（系统会调用 onDestroy() ，然后再马上调用 onCreate() ）。这种设计有助于应用程序适用新的参数配置，通过把你预置的可替换资源（比如对应各种屏幕方向和尺寸的layout）自动重新装载进入应用程序的方式来实现。</p>\n<p>如果你采取了适当的设计，让activity能够正确地处理这些因为屏幕方向而引起的重启，并能如上所述地恢复activity状态， 那么你的应用程序将对生命周期中其它的意外事件更具适应能力。</p>\n<p>处理这类重启的最佳方式，就是利用 onSaveInstanceState() 和onRestoreInstanceState() （或者 onCreate() ）进行状态的保存和恢复，如上节所述。   </p>\n<h3 id=\"六-Activity的启动方式\"><a href=\"#六-Activity的启动方式\" class=\"headerlink\" title=\"六 Activity的启动方式\"></a>六 Activity的启动方式</h3><p>antivity的启动方式可以通过两种方式定义：     </p>\n<h5 id=\"Androidmanifest文件\"><a href=\"#Androidmanifest文件\" class=\"headerlink\" title=\"Androidmanifest文件\"></a>Androidmanifest文件</h5><p>Androidmanifest文件是android的清单文件，android的四大组件与相应权限皆需在这里设置。在这里你可以利用 <activity> 元素的 launchMode 属性来设定 activity 与 task 的关系。<br>可通过Androidmanifest文件设置的启动模式有：      </p>\n<ul>\n<li>standard</li>\n<li>singleTop</li>\n<li>singleTask</li>\n<li>singleInstance       </li>\n</ul>\n<h5 id=\"Intent标志\"><a href=\"#Intent标志\" class=\"headerlink\" title=\"Intent标志\"></a>Intent标志</h5><p>Intent标志中有以下几种Activity的启动方式:       </p>\n<ul>\n<li>FLAG_ACTIVITY_NEW_TASK</li>\n<li>FLAG_ACTIVITY_SINGLE_TOP</li>\n<li>FLAG_ACTIVITY_CLEAR_TOP<br>通过Intent标志的方式来启动Activity，优先级比manifest的高。    </li>\n</ul>\n<blockquote>\n<p><strong>警告</strong>： 大多数应用不应该改变 activity 和 task 默认的工作方式。 如果你确定有必要修改默认方式，请保持<br>谨慎，并确保 activity 在启动和从其它 activity 用回退键返回时的可用性。 请确保对可能与用户预期的导航方式<br>相冲突的地方进行测试。      </p>\n</blockquote>\n<h3 id=\"七-启动Activity\"><a href=\"#七-启动Activity\" class=\"headerlink\" title=\"七 启动Activity\"></a>七 启动Activity</h3><p>要启动一个activity需要使用Intent，实际上android中组件之前的通信皆由Intent完成（如果你不了解Intent，请看我之后的博客<a href=\"android基础之Intents与Intent-Filters.md\" title=\"android基础之Intents与Intent-Filters\">android基础之Intents与Intent-Filters.md</a>），而使用Intent启动activity有显示和隐式两种方式。   </p>\n<h5 id=\"显示启动\"><a href=\"#显示启动\" class=\"headerlink\" title=\"显示启动\"></a>显示启动</h5><pre><code class=\"java\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, SignInActivity.class);\nstartActivity(intent);<span class=\"comment\">//显示启动一个叫SignInActivity的Activity</span>\n</code></pre>\n<h5 id=\"隐式启动\"><a href=\"#隐式启动\" class=\"headerlink\" title=\"隐式启动\"></a>隐式启动</h5><p>要想隐式启动一个activity，你需要使用intent-filter来暴露你的activity。使用filter有java代码和xml文件两种方式，推荐使用第二种方式，你只需在Androidmanifest.xml文件中的activit元素中加入intent-filter属性，并声明一个action即可。但是如果你想使你的activity更独立，那么就不要为你的activity设置filter。那么什么时候使用这种方式呢？<br>如果，你的程序可能想要展示某些动作，例如发邮件，短信，微博，或者使用你activity中的数据。 这时候，你就不应该使用自己的activity来做这些工作。你应该调用系统中其他程序提供的响应功能。 这是intent真正体现其价值的地方。你可以创建一个描述了响应动作的intent,然后系统来为你挑选完成任务的程序。 如果有多个选择，系统会提示用户进行选择。例如你想让用户发邮件，你可以创建下面的intent：        </p>\n<pre><code class=\"java\">Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_EMAIL, recipientArray);<span class=\"comment\">//recipientArray即你想发送过去的联系人信息</span>\nstartActivity(intent);\n</code></pre>\n<h5 id=\"启动一个带返回结果的Activity\"><a href=\"#启动一个带返回结果的Activity\" class=\"headerlink\" title=\"启动一个带返回结果的Activity\"></a>启动一个带返回结果的Activity</h5><p>有时候，你想要启动一个activity,并从这个activty获得一个结果。 这时，要通过 startActivityForResult() (取代startActivity()) 来启动activity。 然后通过实现onActivityResult()回调方法来获得返回后的结果。 当这个后续的activity被关闭，它将发送一个 Intent 给 onActivityResult() 方法。     </p>\n<p>例如，你可能想要取一个联系人的信息。下面介绍怎么创建intent并处理结果:         </p>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">pickContact</span><span class=\"params\">()</span> </span>{\n    <span class=\"comment\">// Create an intent to \"pick\" a contact, as defined by the content provider URI</span>\n    Intent intent = <span class=\"keyword\">new</span> Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);\n    startActivityForResult(intent, PICK_CONTACT_REQUEST);\n}\n\n<span class=\"meta\">@Override</span>\n<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> resultCode, Intent data)</span> </span>{\n    <span class=\"comment\">// If the request went well (OK) and the request was PICK_CONTACT_REQUEST</span>\n    <span class=\"keyword\">if</span> (resultCode == Activity.RESULT_OK &amp;&amp; requestCode == PICK_CONTACT_REQUEST) {\n        <span class=\"comment\">// Perform a query to the contact's content provider for the contact's name</span>\n        Cursor cursor = getContentResolver().query(data.getData(),\n        <span class=\"keyword\">new</span> String[] {Contacts.DISPLAY_NAME}, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);\n        <span class=\"keyword\">if</span> (cursor.moveToFirst()) { <span class=\"comment\">// True if the cursor is not empty</span>\n            <span class=\"keyword\">int</span> columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);\n            String name = cursor.getString(columnIndex);\n            <span class=\"comment\">// Do something with the selected contact's name...</span>\n        }\n    }\n}\n</code></pre>\n<p>这个例子展示了使用onActivityResult() 来获取结果的基本方法。 第一步要判断请求是否被成功响应，通过判断resultCode 是不是RESULT_OK—， 然后判断这个响应是不是针对相应的请求— ，此时只要判断requestCode 和发送时提供的第二个参数 startActivityForResult() 是否相匹配。 最后，查询 Intent中的data信息。 (data 参数)。</p>\n<p>这个过程中，ContentResolver 开启了一个查询而不是content provider, 它返回一个 Cursor ，这将允许数据被读取。更多content provider相关信息，请阅读我之后的博客<a href=\"android基础之Content-Providers.md\" title=\"android基础之Content-Providers\">android基础之Content-Providers.md</a>。     </p>\n<h5 id=\"关闭activity\"><a href=\"#关闭activity\" class=\"headerlink\" title=\"关闭activity\"></a>关闭activity</h5><p>你可以通过调用finish() 来终止activity。 你也可以调用finishActivity() 来终止你之前启动了的一个独立activity。    </p>\n<blockquote>\n<p><strong>注意</strong>: 多数情况下，你不应该明确地通过这些方式来关闭acitivity。 就像下面要讨论的activity的生命周期。系统会为你管理。所以你不必关闭他们。 调用这些方法将有悖于用户体验。它们仅用于你绝对不想让用户再返回这个activity的实例。   </p>\n</blockquote>\n<h3 id=\"八-Task和back-stack\"><a href=\"#八-Task和back-stack\" class=\"headerlink\" title=\"八 Task和back stack\"></a>八 Task和back stack</h3><p>一个app通常包含多个activity，android使用task来管理这些activity。当你在手机上没点开一个app，android即为这个app创建一个task，task中有一个back stack，你多点开的activity将依次入栈或者出栈，若你的activity调用别的应用的activity，它也会被压入本activity中。（activity与back stack的关系可阅读上文的activity的启动方式，它定义了activity在back stack中的存在方式）。<br>一个app即对应一个task，若你点开一个新的app，则该新app会进入前台，而之前的会被调入后台。当android的内存不足时，后台的task则可能被销毁。    </p>\n<p>其实，activity所处的task可以通过<activity>元素的taskAffinity属性指定，taskAffinity 属性是一个字符串值，必须与<manifest> 元素定义的包名称保证唯一性，因为系统把这个包名称用于标识应用的默认 task affinity值。但是，注意，一般情况下如无必要，不要去修改taskAffinity的值。    </p>\n<h3 id=\"九-总结\"><a href=\"#九-总结\" class=\"headerlink\" title=\"九 总结\"></a>九 总结</h3><p>到这里，android的activity相关的知识已经介绍的差不多了，但是这其中还有很多细节需要读者自己去发现。我所说的并不全面，有些地方可能还有谬误，万不可全信，这些仅仅是我个人的理解。其实博客的功能也只是让你对一个陌生的事物知道个大概，要想最终精通还需要多写多做。这些东西你只有自己经历了，研究了它才能成为你自己的东西，否则不过是镜花水月。<br>作为一个程序员最重要的是勤劳，最后以一句话与大家共勉：慈不掌兵，义不行贾，懒不撸码。</p>\n"},{"title":"android基础之loaders","date":"2017-02-27T06:39:21.000Z","_content":"\n### 一 概述\n\nLoaders从Android3.0开始引进（Loaders被翻译为装载器，它是一个异步加载数据的框架），它能在Activity或Fragment中异步加载数据；装载器具有如下特性：\n\n- 它们对每个Activity和Fragment都有效\n- 它们支持数据的异步加载\n- 它们监视数据源的改变，并在数据源改变时传送新的结果\n- 当由于配置改变而被重新创建后，它们会自动重连到上一个装载器的游标，所以不必重新查询数据\n\n### 二 loader使用相关简介\n\n##### LoaderManager\n\n一个和Activity或Fragment关联抽象类，管理一个或多个装载器的实例，它帮助应用管理那些与Activity或Fragment生命周期相关的长时间运行的操作。最常见的方式是与一个CursorLoader一起使用，你也可以实现自己的装载器以加载其它类型的数据。 每个Activity或Fragment只有一个LoaderManager，但是一个LoaderManager可以拥有多个装载器。\n\n##### Loader\n\n一个执行异步数据加载的抽象类，它是加载器的基类。你可以使用典型的CursorLoader，但是你也可以实现你自己的子类。一旦装载器被激活，它们应该监视它们的数据源并且在数据改变时传送新的结果。\n\n##### AsyncTaskLoader\n\n一个使用AsyncTask来执行异步加载工作的抽象类。继承于Loader\n\n##### CursorLoader\n\n一个AsyncTaskLoader的子类，它查询ContentResolver然后返回一个Cursor。这个装载器类的实现遵循查询游标数据源的标准，它的游标查询是通过AsyncTaskLoader在后台线程中执行，从而不会阻塞UI线程。使用这个装载器是从ContentProvider异步加载数据的最好方式。\n\n##### LoaderManager.LoaderCallbacks\n\n一个用于客户端与LoaderManager交互的回调接口。主要有三个回调方法：onCreateLoader()，onLoadFinished()，onLoaderReset()。\n\n\n### 三 使用Loader\n\n一个使用加载器的典型的应用包含以下几个组件：\n\n- 一个Activity或Fragment；\n-  一个LoaderManager的实例；\n-  一个依靠ContentProvider加载数据的CursorLoader；当然，你也可以继承Loader或AsyncTaskLoader实现你自己的装载器来从其它数据源加载数据；\n- 一个LoaderManager.LoaderCallbacks的实现，这是你创建新的装载器以及管理已有装载器的地方；\n-  一个用于展示装载器的返回数据的方式，例如使用一个SimpleCursorAdapter；\n-  一个数据源，例如ContentProvider（使用CursorLoader加载数据）。\n\n代码示例：\n\n\n\n\n\n### 四 总结\n\n\n\n\n","source":"_posts/android基础之loaders.md","raw":"---\ntitle: android基础之loaders\ndate: 2017-02-27 14:39:21\ncategories: android\ntags:\n- android\n- java\n- loader\n---\n\n### 一 概述\n\nLoaders从Android3.0开始引进（Loaders被翻译为装载器，它是一个异步加载数据的框架），它能在Activity或Fragment中异步加载数据；装载器具有如下特性：\n\n- 它们对每个Activity和Fragment都有效\n- 它们支持数据的异步加载\n- 它们监视数据源的改变，并在数据源改变时传送新的结果\n- 当由于配置改变而被重新创建后，它们会自动重连到上一个装载器的游标，所以不必重新查询数据\n\n### 二 loader使用相关简介\n\n##### LoaderManager\n\n一个和Activity或Fragment关联抽象类，管理一个或多个装载器的实例，它帮助应用管理那些与Activity或Fragment生命周期相关的长时间运行的操作。最常见的方式是与一个CursorLoader一起使用，你也可以实现自己的装载器以加载其它类型的数据。 每个Activity或Fragment只有一个LoaderManager，但是一个LoaderManager可以拥有多个装载器。\n\n##### Loader\n\n一个执行异步数据加载的抽象类，它是加载器的基类。你可以使用典型的CursorLoader，但是你也可以实现你自己的子类。一旦装载器被激活，它们应该监视它们的数据源并且在数据改变时传送新的结果。\n\n##### AsyncTaskLoader\n\n一个使用AsyncTask来执行异步加载工作的抽象类。继承于Loader\n\n##### CursorLoader\n\n一个AsyncTaskLoader的子类，它查询ContentResolver然后返回一个Cursor。这个装载器类的实现遵循查询游标数据源的标准，它的游标查询是通过AsyncTaskLoader在后台线程中执行，从而不会阻塞UI线程。使用这个装载器是从ContentProvider异步加载数据的最好方式。\n\n##### LoaderManager.LoaderCallbacks\n\n一个用于客户端与LoaderManager交互的回调接口。主要有三个回调方法：onCreateLoader()，onLoadFinished()，onLoaderReset()。\n\n\n### 三 使用Loader\n\n一个使用加载器的典型的应用包含以下几个组件：\n\n- 一个Activity或Fragment；\n-  一个LoaderManager的实例；\n-  一个依靠ContentProvider加载数据的CursorLoader；当然，你也可以继承Loader或AsyncTaskLoader实现你自己的装载器来从其它数据源加载数据；\n- 一个LoaderManager.LoaderCallbacks的实现，这是你创建新的装载器以及管理已有装载器的地方；\n-  一个用于展示装载器的返回数据的方式，例如使用一个SimpleCursorAdapter；\n-  一个数据源，例如ContentProvider（使用CursorLoader加载数据）。\n\n代码示例：\n\n\n\n\n\n### 四 总结\n\n\n\n\n","slug":"android基础之loaders","published":1,"updated":"2017-03-08T06:40:48.863Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk21001iaknzfqnjed6r","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Loaders从Android3.0开始引进（Loaders被翻译为装载器，它是一个异步加载数据的框架），它能在Activity或Fragment中异步加载数据；装载器具有如下特性：</p>\n<ul>\n<li>它们对每个Activity和Fragment都有效</li>\n<li>它们支持数据的异步加载</li>\n<li>它们监视数据源的改变，并在数据源改变时传送新的结果</li>\n<li>当由于配置改变而被重新创建后，它们会自动重连到上一个装载器的游标，所以不必重新查询数据</li>\n</ul>\n<h3 id=\"二-loader使用相关简介\"><a href=\"#二-loader使用相关简介\" class=\"headerlink\" title=\"二 loader使用相关简介\"></a>二 loader使用相关简介</h3><h5 id=\"LoaderManager\"><a href=\"#LoaderManager\" class=\"headerlink\" title=\"LoaderManager\"></a>LoaderManager</h5><p>一个和Activity或Fragment关联抽象类，管理一个或多个装载器的实例，它帮助应用管理那些与Activity或Fragment生命周期相关的长时间运行的操作。最常见的方式是与一个CursorLoader一起使用，你也可以实现自己的装载器以加载其它类型的数据。 每个Activity或Fragment只有一个LoaderManager，但是一个LoaderManager可以拥有多个装载器。</p>\n<h5 id=\"Loader\"><a href=\"#Loader\" class=\"headerlink\" title=\"Loader\"></a>Loader</h5><p>一个执行异步数据加载的抽象类，它是加载器的基类。你可以使用典型的CursorLoader，但是你也可以实现你自己的子类。一旦装载器被激活，它们应该监视它们的数据源并且在数据改变时传送新的结果。</p>\n<h5 id=\"AsyncTaskLoader\"><a href=\"#AsyncTaskLoader\" class=\"headerlink\" title=\"AsyncTaskLoader\"></a>AsyncTaskLoader</h5><p>一个使用AsyncTask来执行异步加载工作的抽象类。继承于Loader</p>\n<h5 id=\"CursorLoader\"><a href=\"#CursorLoader\" class=\"headerlink\" title=\"CursorLoader\"></a>CursorLoader</h5><p>一个AsyncTaskLoader的子类，它查询ContentResolver然后返回一个Cursor。这个装载器类的实现遵循查询游标数据源的标准，它的游标查询是通过AsyncTaskLoader在后台线程中执行，从而不会阻塞UI线程。使用这个装载器是从ContentProvider异步加载数据的最好方式。</p>\n<h5 id=\"LoaderManager-LoaderCallbacks\"><a href=\"#LoaderManager-LoaderCallbacks\" class=\"headerlink\" title=\"LoaderManager.LoaderCallbacks\"></a>LoaderManager.LoaderCallbacks</h5><p>一个用于客户端与LoaderManager交互的回调接口。主要有三个回调方法：onCreateLoader()，onLoadFinished()，onLoaderReset()。</p>\n<h3 id=\"三-使用Loader\"><a href=\"#三-使用Loader\" class=\"headerlink\" title=\"三 使用Loader\"></a>三 使用Loader</h3><p>一个使用加载器的典型的应用包含以下几个组件：</p>\n<ul>\n<li>一个Activity或Fragment；</li>\n<li>一个LoaderManager的实例；</li>\n<li>一个依靠ContentProvider加载数据的CursorLoader；当然，你也可以继承Loader或AsyncTaskLoader实现你自己的装载器来从其它数据源加载数据；</li>\n<li>一个LoaderManager.LoaderCallbacks的实现，这是你创建新的装载器以及管理已有装载器的地方；</li>\n<li>一个用于展示装载器的返回数据的方式，例如使用一个SimpleCursorAdapter；</li>\n<li>一个数据源，例如ContentProvider（使用CursorLoader加载数据）。</li>\n</ul>\n<p>代码示例：</p>\n<h3 id=\"四-总结\"><a href=\"#四-总结\" class=\"headerlink\" title=\"四 总结\"></a>四 总结</h3>","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Loaders从Android3.0开始引进（Loaders被翻译为装载器，它是一个异步加载数据的框架），它能在Activity或Fragment中异步加载数据；装载器具有如下特性：</p>\n<ul>\n<li>它们对每个Activity和Fragment都有效</li>\n<li>它们支持数据的异步加载</li>\n<li>它们监视数据源的改变，并在数据源改变时传送新的结果</li>\n<li>当由于配置改变而被重新创建后，它们会自动重连到上一个装载器的游标，所以不必重新查询数据</li>\n</ul>\n<h3 id=\"二-loader使用相关简介\"><a href=\"#二-loader使用相关简介\" class=\"headerlink\" title=\"二 loader使用相关简介\"></a>二 loader使用相关简介</h3><h5 id=\"LoaderManager\"><a href=\"#LoaderManager\" class=\"headerlink\" title=\"LoaderManager\"></a>LoaderManager</h5><p>一个和Activity或Fragment关联抽象类，管理一个或多个装载器的实例，它帮助应用管理那些与Activity或Fragment生命周期相关的长时间运行的操作。最常见的方式是与一个CursorLoader一起使用，你也可以实现自己的装载器以加载其它类型的数据。 每个Activity或Fragment只有一个LoaderManager，但是一个LoaderManager可以拥有多个装载器。</p>\n<h5 id=\"Loader\"><a href=\"#Loader\" class=\"headerlink\" title=\"Loader\"></a>Loader</h5><p>一个执行异步数据加载的抽象类，它是加载器的基类。你可以使用典型的CursorLoader，但是你也可以实现你自己的子类。一旦装载器被激活，它们应该监视它们的数据源并且在数据改变时传送新的结果。</p>\n<h5 id=\"AsyncTaskLoader\"><a href=\"#AsyncTaskLoader\" class=\"headerlink\" title=\"AsyncTaskLoader\"></a>AsyncTaskLoader</h5><p>一个使用AsyncTask来执行异步加载工作的抽象类。继承于Loader</p>\n<h5 id=\"CursorLoader\"><a href=\"#CursorLoader\" class=\"headerlink\" title=\"CursorLoader\"></a>CursorLoader</h5><p>一个AsyncTaskLoader的子类，它查询ContentResolver然后返回一个Cursor。这个装载器类的实现遵循查询游标数据源的标准，它的游标查询是通过AsyncTaskLoader在后台线程中执行，从而不会阻塞UI线程。使用这个装载器是从ContentProvider异步加载数据的最好方式。</p>\n<h5 id=\"LoaderManager-LoaderCallbacks\"><a href=\"#LoaderManager-LoaderCallbacks\" class=\"headerlink\" title=\"LoaderManager.LoaderCallbacks\"></a>LoaderManager.LoaderCallbacks</h5><p>一个用于客户端与LoaderManager交互的回调接口。主要有三个回调方法：onCreateLoader()，onLoadFinished()，onLoaderReset()。</p>\n<h3 id=\"三-使用Loader\"><a href=\"#三-使用Loader\" class=\"headerlink\" title=\"三 使用Loader\"></a>三 使用Loader</h3><p>一个使用加载器的典型的应用包含以下几个组件：</p>\n<ul>\n<li>一个Activity或Fragment；</li>\n<li>一个LoaderManager的实例；</li>\n<li>一个依靠ContentProvider加载数据的CursorLoader；当然，你也可以继承Loader或AsyncTaskLoader实现你自己的装载器来从其它数据源加载数据；</li>\n<li>一个LoaderManager.LoaderCallbacks的实现，这是你创建新的装载器以及管理已有装载器的地方；</li>\n<li>一个用于展示装载器的返回数据的方式，例如使用一个SimpleCursorAdapter；</li>\n<li>一个数据源，例如ContentProvider（使用CursorLoader加载数据）。</li>\n</ul>\n<p>代码示例：</p>\n<h3 id=\"四-总结\"><a href=\"#四-总结\" class=\"headerlink\" title=\"四 总结\"></a>四 总结</h3>"},{"title":"android基础之事件分发机制","date":"2017-02-28T10:25:28.000Z","_content":"\n### 一 概述\n\n在android开发中会经常遇到滑动冲突（比如ScrollView或是SliddingMenu与ListView的嵌套）的问题，需要我们深入的了解android事件响应机制才能解决，事件响应机制已经是android开发者必不可少的知识。\n\n### 二 涉及到事件响应的常用方法构成\n\n用户在手指与屏幕接触过程中通过MotionEvent对象产生一系列事件，它有四种状态： \n\n- MotionEvent.ACTION_DOWN　：手指按下屏幕的瞬间（一切事件的开始）\n- MotionEvent.ACTION_MOVE　：手指在屏幕上移动\n- MotionEvent.ACTION_UP　：手指离开屏幕瞬间\n- MotionEvent.ACTION_CANCEL 　：取消手势，一般由程序产生，不会由用户产生\n\nAndroid中的事件onClick, onLongClick，onScroll, onFling等等，都是由许多个Touch事件构成的（一个ACTION_DOWN， n个ACTION_MOVE，1个ACTION_UP）。\n\nandroid 事件响应机制是先分发（先由外部的View接收，然后依次传递给其内层的最小View）再处理 （从最小View单元（事件源）开始依次向外层传递。）的形式实现的。\n\n复杂性表现在：可以控制每层事件是否继续传递（分发和拦截协同实现），以及事件的具体消费（事件分发也具有事件消费能力）。\n\n### 三 android事件处理涉及到的三个重要函数\n\n##### 1.事件分发：public boolean dispatchTouchEvent(MotionEvent ev)\n\n当有监听到事件时，首先由Activity进行捕获，进入事件分发处理流程。（因为activity没有事件拦截，View和ViewGroup有）会将事件传递给最外层View的dispatchTouchEvent(MotionEvent ev)方法，该方法对事件进行分发。 \n\n- return true ：表示该View内部消化掉了所有事件。\n\n- return false ：事件在本层不再继续进行分发，并交由上层控件的onTouchEvent方法进行消费（如果本层控件已经是Activity，那么事件将被系统消费或处理）。　\n\n- 如果事件分发返回系统默认的 super.dispatchTouchEvent(ev)，事件将分发给本层的事件拦截onInterceptTouchEvent 方法进行处理\n\n##### 2.事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)\n\n- return true ：表示将事件进行拦截，并将拦截到的事件交由本层控件 的 onTouchEvent 进行处理；\n\n- return false ：则表示不对事件进行拦截，事件得以成功分发到子View。并由子View的dispatchTouchEvent进行处理。　\n\n- 如果返回super.onInterceptTouchEvent(ev)，默认表示拦截该事件，并将事件传递给当前View的onTouchEvent方法，和return true一样。\n\n##### 3.事件响应：public boolean onTouchEvent(MotionEvent ev)\n\n在dispatchTouchEvent（事件分发）返回super.dispatchTouchEvent(ev)并且onInterceptTouchEvent（事件拦截返回true或super.onInterceptTouchEvent(ev)的情况下，那么事件会传递到onTouchEvent方法，该方法对事件进行响应。\n\n- 如果return true，表示onTouchEvent处理完事件后消费了此次事件。此时事件终结；\n\n- 如果return fasle，则表示不响应事件，那么该事件将会不断向上层View的onTouchEvent方法传递，直到某个View的onTouchEvent方法返回true，如果到了最顶层View还是返回false，那么认为该事件不消耗，则在同一个事件系列中，当前View无法再次接收到事件，该事件会交由Activity的onTouchEvent进行处理；　　\n\n- 如果return super.dispatchTouchEvent(ev)，则表示不响应事件，结果与return false一样。\n\n从以上过程中可以看出，dispatchTouchEvent无论返回true还是false，事件都不再进行分发，只有当其返回super.dispatchTouchEvent(ev)，才表明其具有向下层分发的愿望，但是是否能够分发成功，则需要经过事件拦截onInterceptTouchEvent的审核。事件是否向上传递处理是由onTouchEvent的返回值决定的。\n\n下面是Touch事件传递机制流程图：\n\n{% asset_img Touch事件分发机制流程图.png Touch事件分发机制流程图 %}\n\n### 四 View源码分析\n\nAndroid中ImageView、textView、Button等继承于View但没有重写的dispatchTouchEvent方法，所以都用的View的该方法进行事件分发。\n\n看View重要函数部分源码：\n\n```java\npublic boolean dispatchTouchEvent(MotionEvent event) {\n//返回true,表示该View内部消化掉了所有事件。返回false，表示View内部只处理了ACTION_DOWN事件，事件继续传递，向上级View(ViewGroup)传递。\n\n    if (mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED &&\n            mOnTouchListener.onTouch(this, event)) {\n  //此处的onTouch方式就是回调的我们注册OnTouchListener时重写的onTouch()方法\n        return true;\n    }\n    return onTouchEvent(event);\n}\n```\n\n首先进行三个条件的判断：\n\n- 查看是否给button设置了OnTouchListener()事件；\n- 控件是否Enable；（控件默认都是enable的）\n- button里面实现的OnTouchListener监听里的onTouch()方法是否返回true；\n\n如果条件都满足，则该事件被消耗掉，不再进入onTouchEvent中处理。否则将事件将交给onTouchEvent方法处理。\n\n```java\n public boolean onTouchEvent(MotionEvent event) {\n    ...\n\n   /＊ 当前onTouch的组件必须是可点击的比如Button，ImageButton等等，此处CLICKABLE为true，才会进入if方法，最后返回true。\n 如果是ImageView、TexitView这些默认为不可点击的View,此处CLICKABLE为false，最后返回false。当然会有特殊情况，如果给这些View设置了onClick监听器，此处CLICKABLE也将为true　　＊／\n\n    if (((viewFlags & CLICKABLE) == CLICKABLE ||  \n            (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_UP:\n                ...\n                            if (!post(mPerformClick)) {\n                                performClick();// 实际就是回调了我们注册的OnClickListener中重新的onClick()方法\n                            }\n                 ...\n                break;\n\n            case MotionEvent.ACTION_DOWN:\n               ...\n                break;\n\n            case MotionEvent.ACTION_CANCEL:\n                ...\n                break;\n\n            case MotionEvent.ACTION_MOVE:\n               ...\n                break;\n        }\n        return true;\n    }\n\n    return false;\n}\n```\n\n```java\npublic boolean performClick() {\n    ...\n ／／\n    if (li != null && li.mOnClickListener != null) {\n        ...\n        li.mOnClickListener.onClick(this);\n        return true;\n    }\n\n    return false;\n}\n\n public void setOnClickListener(OnClickListener l) {\n    if (!isClickable()) {\n        setClickable(true);\n    }\n    getListenerInfo().mOnClickListener = l;\n}\n```\n\n只有我们注册OnTouchListener时重写的 onTouch()方法中:\n\n- 返回false —> 执行onTouchEvent方法 —> 导致onClick()回调方法执行　\n- 返回true —> onTouchEvent方法不执行 —> 导致onClick()回调方法不会执行\n\n### 五 ViewGroup源码分析\n\nAndroid中诸如LinearLayout等的五大布局控件，都是继承自ViewGroup，而ViewGroup本身是继承自View，所以ViewGroup的事件处理机制对这些控件都有效。\n\n```java\npublic boolean dispatchTouchEvent(MotionEvent ev) {  \n       final int action = ev.getAction();  \n       final float xf = ev.getX();  \n       final float yf = ev.getY();  \n       final float scrolledXFloat = xf + mScrollX;  \n       final float scrolledYFloat = yf + mScrollY;  \n       final Rect frame = mTempRect;  \n\n       //这个值默认是false, 然后我们可以通过requestDisallowInterceptTouchEvent(boolean disallowIntercept)方法  \n       //来改变disallowIntercept的值  \n       boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;  \n\n       //这里是ACTION_DOWN的处理逻辑  \n       if (action == MotionEvent.ACTION_DOWN) {  \n        //清除mMotionTarget, 每次ACTION_DOWN都很设置mMotionTarget为null  \n           if (mMotionTarget != null) {  \n               mMotionTarget = null;  \n           }  \n\n           //disallowIntercept默认是false, 就看ViewGroup的onInterceptTouchEvent()方法  \n           if (disallowIntercept || !onInterceptTouchEvent(ev)) {  //第一点\n               ev.setAction(MotionEvent.ACTION_DOWN);  \n               final int scrolledXInt = (int) scrolledXFloat;  \n               final int scrolledYInt = (int) scrolledYFloat;  \n               final View[] children = mChildren;  \n               final int count = mChildrenCount;  \n               //遍历其子View  \n               for (int i = count - 1; i >= 0; i--) {  //第二点\n                   final View child = children[i];  \n\n                   //如果该子View是VISIBLE或者该子View正在执行动画, 表示该View才  \n                   //可以接受到Touch事件  \n                   if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE  \n                           || child.getAnimation() != null) {  \n                    //获取子View的位置范围  \n                       child.getHitRect(frame);  \n\n                       //如Touch到屏幕上的点在该子View上面  \n                       if (frame.contains(scrolledXInt, scrolledYInt)) {  \n                           // offset the event to the view's coordinate system  \n                           final float xc = scrolledXFloat - child.mLeft;  \n                           final float yc = scrolledYFloat - child.mTop;  \n                           ev.setLocation(xc, yc);  \n                           child.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  \n\n                           //调用该子View的dispatchTouchEvent()方法  \n                           if (child.dispatchTouchEvent(ev))  {  \n                               // 如果child.dispatchTouchEvent(ev)返回true表示  \n                            //该事件被消费了，设置mMotionTarget为该子View  \n                               mMotionTarget = child;  \n                               //直接返回true  \n                               return true;  \n                           }  \n                           // The event didn't get handled, try the next view.  \n                           // Don't reset the event's location, it's not  \n                           // necessary here.  \n                       }  \n                   }  \n               }  \n           }  \n       }  \n\n       //判断是否为ACTION_UP或者ACTION_CANCEL  \n       boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  \n               (action == MotionEvent.ACTION_CANCEL);  \n\n       if (isUpOrCancel) {  \n           //如果是ACTION_UP或者ACTION_CANCEL, 将disallowIntercept设置为默认的false  \n        //假如我们调用了requestDisallowInterceptTouchEvent()方法来设置disallowIntercept为true  \n        //当我们抬起手指或者取消Touch事件的时候要将disallowIntercept重置为false  \n        //所以说上面的disallowIntercept默认在我们每次ACTION_DOWN的时候都是false  \n           mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;  \n       }  \n\n       // The event wasn't an ACTION_DOWN, dispatch it to our target if  \n       // we have one.  \n       final View target = mMotionTarget;  \n       //mMotionTarget为null意味着没有找到消费Touch事件的View, 所以我们需要调用ViewGroup父类的  \n       //dispatchTouchEvent()方法，也就是View的dispatchTouchEvent()方法  \n       if (target == null) {  \n           // We don't have a target, this means we're handling the  \n           // event as a regular view.  \n           ev.setLocation(xf, yf);  \n           if ((mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {  \n               ev.setAction(MotionEvent.ACTION_CANCEL);  \n               mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  \n           }  \n           return super.dispatchTouchEvent(ev);  \n       }  \n\n       //这个if里面的代码ACTION_DOWN不会执行，只有ACTION_MOVE  \n       //ACTION_UP才会走到这里, 假如在ACTION_MOVE或者ACTION_UP拦截的  \n       //Touch事件, 将ACTION_CANCEL派发给target，然后直接返回true  \n       //表示消费了此Touch事件  \n       if (!disallowIntercept && onInterceptTouchEvent(ev)) {  \n           final float xc = scrolledXFloat - (float) target.mLeft;  \n           final float yc = scrolledYFloat - (float) target.mTop;  \n           mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  \n           ev.setAction(MotionEvent.ACTION_CANCEL);  \n           ev.setLocation(xc, yc);  \n\n           if (!target.dispatchTouchEvent(ev)) {  \n           }  \n           // clear the target  \n           mMotionTarget = null;  \n           // Don't dispatch this event to our own view, because we already  \n           // saw it when intercepting; we just want to give the following  \n           // event to the normal onTouchEvent().  \n           return true;  \n       }  \n\n       if (isUpOrCancel) {  \n           mMotionTarget = null;  \n       }  \n\n       // finally offset the event to the target's coordinate system and  \n       // dispatch the event.  \n       final float xc = scrolledXFloat - (float) target.mLeft;  \n       final float yc = scrolledYFloat - (float) target.mTop;  \n       ev.setLocation(xc, yc);  \n\n       if ((target.mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {  \n           ev.setAction(MotionEvent.ACTION_CANCEL);  \n           target.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  \n           mMotionTarget = null;  \n       }  \n\n       //如果没有拦截ACTION_MOVE, ACTION_DOWN的话，直接将Touch事件派发给target  \n       return target.dispatchTouchEvent(ev);  \n   }\n```\n\n- dispatchTouchEvent作用：决定事件是否由onInterceptTouchEvent来拦截处理。 返回super.dispatchTouchEvent时，由onInterceptTouchEvent来决定事件的流向 返回false时，会继续分发事件，自己内部只处理了ACTION_DOWN 返回true时，不会继续分发事件，自己内部处理了所有事件（ACTION_DOWN,ACTION_MOVE,ACTION_UP）\n\n- onInterceptTouchEvent作用：拦截事件，用来决定事件是否传向子View 返回true时，拦截后交给自己的onTouchEvent处理 返回false时，拦截后交给子View来处理\n\n- onTouchEvent作用：事件最终到达这个方法 返回true时，内部处理所有的事件，换句话说，后续事件将继续传递给该view的onTouchEvent()处理 返回false时，事件会向上传递，由onToucEvent来接受，如果最上面View中的onTouchEvent也返回false的话，那么事件就会消失\n\n### 六 总结\n\n- 如果ViewGroup找到了能够处理该事件的View，则直接交给子View处理，自己的onTouchEvent不会被触发；　\n\n- 可以通过复写onInterceptTouchEvent(ev)方法，拦截子View的事件（即return true），把事件交给自己处理，则会执行自己对应的onTouchEvent方法。\n\n- 子View可以通过调用getParent().requestDisallowInterceptTouchEvent(true); 阻止ViewGroup对其MOVE或者UP事件进行拦截；　　\n\n- 一个点击事件产生后，它的传递过程如下： Activity->Window->View。顶级View接收到事件之后，就会按相应规则去分发事件。如果一个View的onTouchEvent方法返回false，那么将会交给父容器的onTouchEvent方法进行处理，逐级往上，如果所有的View都不处理该事件，则交由Activity的onTouchEvent进行处理。　\n\n- 如果某一个View开始处理事件，如果他不消耗ACTION_DOWN事件（也就是onTouchEvent返回false），则同一事件序列比如接下来进行ACTION_MOVE，则不会再交给该View处理。\n\n- ViewGroup默认不拦截任何事件。　\n\n- 诸如TextView、ImageView这些不作为容器的View，一旦接受到事件，就调用onTouchEvent方法，它们本身没有onInterceptTouchEvent方法。正常情况下，它们都会消耗事件（返回true），除非它们是不可点击的（clickable和longClickable都为false），那么就会交由父容器的onTouchEvent处理。　\n\n- 点击事件分发过程如下 dispatchTouchEvent—->OnTouchListener的onTouch方法—->onTouchEvent-->OnClickListener的onClick方法。也就是说，我们平时调用的setOnClickListener，优先级是最低的，所以，onTouchEvent或OnTouchListener的onTouch方法如果返回true，则不响应onClick方法...\n\n{% asset_img android事件分发.png 一个据说很牛的图 %}\n\n","source":"_posts/android基础之事件分发机制.md","raw":"---\ntitle: android基础之事件分发机制\ndate: 2017-02-28 18:25:28\ncategories: android\ntags:\n- android\n- java\n- View\n- 事件分发\n---\n\n### 一 概述\n\n在android开发中会经常遇到滑动冲突（比如ScrollView或是SliddingMenu与ListView的嵌套）的问题，需要我们深入的了解android事件响应机制才能解决，事件响应机制已经是android开发者必不可少的知识。\n\n### 二 涉及到事件响应的常用方法构成\n\n用户在手指与屏幕接触过程中通过MotionEvent对象产生一系列事件，它有四种状态： \n\n- MotionEvent.ACTION_DOWN　：手指按下屏幕的瞬间（一切事件的开始）\n- MotionEvent.ACTION_MOVE　：手指在屏幕上移动\n- MotionEvent.ACTION_UP　：手指离开屏幕瞬间\n- MotionEvent.ACTION_CANCEL 　：取消手势，一般由程序产生，不会由用户产生\n\nAndroid中的事件onClick, onLongClick，onScroll, onFling等等，都是由许多个Touch事件构成的（一个ACTION_DOWN， n个ACTION_MOVE，1个ACTION_UP）。\n\nandroid 事件响应机制是先分发（先由外部的View接收，然后依次传递给其内层的最小View）再处理 （从最小View单元（事件源）开始依次向外层传递。）的形式实现的。\n\n复杂性表现在：可以控制每层事件是否继续传递（分发和拦截协同实现），以及事件的具体消费（事件分发也具有事件消费能力）。\n\n### 三 android事件处理涉及到的三个重要函数\n\n##### 1.事件分发：public boolean dispatchTouchEvent(MotionEvent ev)\n\n当有监听到事件时，首先由Activity进行捕获，进入事件分发处理流程。（因为activity没有事件拦截，View和ViewGroup有）会将事件传递给最外层View的dispatchTouchEvent(MotionEvent ev)方法，该方法对事件进行分发。 \n\n- return true ：表示该View内部消化掉了所有事件。\n\n- return false ：事件在本层不再继续进行分发，并交由上层控件的onTouchEvent方法进行消费（如果本层控件已经是Activity，那么事件将被系统消费或处理）。　\n\n- 如果事件分发返回系统默认的 super.dispatchTouchEvent(ev)，事件将分发给本层的事件拦截onInterceptTouchEvent 方法进行处理\n\n##### 2.事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)\n\n- return true ：表示将事件进行拦截，并将拦截到的事件交由本层控件 的 onTouchEvent 进行处理；\n\n- return false ：则表示不对事件进行拦截，事件得以成功分发到子View。并由子View的dispatchTouchEvent进行处理。　\n\n- 如果返回super.onInterceptTouchEvent(ev)，默认表示拦截该事件，并将事件传递给当前View的onTouchEvent方法，和return true一样。\n\n##### 3.事件响应：public boolean onTouchEvent(MotionEvent ev)\n\n在dispatchTouchEvent（事件分发）返回super.dispatchTouchEvent(ev)并且onInterceptTouchEvent（事件拦截返回true或super.onInterceptTouchEvent(ev)的情况下，那么事件会传递到onTouchEvent方法，该方法对事件进行响应。\n\n- 如果return true，表示onTouchEvent处理完事件后消费了此次事件。此时事件终结；\n\n- 如果return fasle，则表示不响应事件，那么该事件将会不断向上层View的onTouchEvent方法传递，直到某个View的onTouchEvent方法返回true，如果到了最顶层View还是返回false，那么认为该事件不消耗，则在同一个事件系列中，当前View无法再次接收到事件，该事件会交由Activity的onTouchEvent进行处理；　　\n\n- 如果return super.dispatchTouchEvent(ev)，则表示不响应事件，结果与return false一样。\n\n从以上过程中可以看出，dispatchTouchEvent无论返回true还是false，事件都不再进行分发，只有当其返回super.dispatchTouchEvent(ev)，才表明其具有向下层分发的愿望，但是是否能够分发成功，则需要经过事件拦截onInterceptTouchEvent的审核。事件是否向上传递处理是由onTouchEvent的返回值决定的。\n\n下面是Touch事件传递机制流程图：\n\n{% asset_img Touch事件分发机制流程图.png Touch事件分发机制流程图 %}\n\n### 四 View源码分析\n\nAndroid中ImageView、textView、Button等继承于View但没有重写的dispatchTouchEvent方法，所以都用的View的该方法进行事件分发。\n\n看View重要函数部分源码：\n\n```java\npublic boolean dispatchTouchEvent(MotionEvent event) {\n//返回true,表示该View内部消化掉了所有事件。返回false，表示View内部只处理了ACTION_DOWN事件，事件继续传递，向上级View(ViewGroup)传递。\n\n    if (mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED &&\n            mOnTouchListener.onTouch(this, event)) {\n  //此处的onTouch方式就是回调的我们注册OnTouchListener时重写的onTouch()方法\n        return true;\n    }\n    return onTouchEvent(event);\n}\n```\n\n首先进行三个条件的判断：\n\n- 查看是否给button设置了OnTouchListener()事件；\n- 控件是否Enable；（控件默认都是enable的）\n- button里面实现的OnTouchListener监听里的onTouch()方法是否返回true；\n\n如果条件都满足，则该事件被消耗掉，不再进入onTouchEvent中处理。否则将事件将交给onTouchEvent方法处理。\n\n```java\n public boolean onTouchEvent(MotionEvent event) {\n    ...\n\n   /＊ 当前onTouch的组件必须是可点击的比如Button，ImageButton等等，此处CLICKABLE为true，才会进入if方法，最后返回true。\n 如果是ImageView、TexitView这些默认为不可点击的View,此处CLICKABLE为false，最后返回false。当然会有特殊情况，如果给这些View设置了onClick监听器，此处CLICKABLE也将为true　　＊／\n\n    if (((viewFlags & CLICKABLE) == CLICKABLE ||  \n            (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_UP:\n                ...\n                            if (!post(mPerformClick)) {\n                                performClick();// 实际就是回调了我们注册的OnClickListener中重新的onClick()方法\n                            }\n                 ...\n                break;\n\n            case MotionEvent.ACTION_DOWN:\n               ...\n                break;\n\n            case MotionEvent.ACTION_CANCEL:\n                ...\n                break;\n\n            case MotionEvent.ACTION_MOVE:\n               ...\n                break;\n        }\n        return true;\n    }\n\n    return false;\n}\n```\n\n```java\npublic boolean performClick() {\n    ...\n ／／\n    if (li != null && li.mOnClickListener != null) {\n        ...\n        li.mOnClickListener.onClick(this);\n        return true;\n    }\n\n    return false;\n}\n\n public void setOnClickListener(OnClickListener l) {\n    if (!isClickable()) {\n        setClickable(true);\n    }\n    getListenerInfo().mOnClickListener = l;\n}\n```\n\n只有我们注册OnTouchListener时重写的 onTouch()方法中:\n\n- 返回false —> 执行onTouchEvent方法 —> 导致onClick()回调方法执行　\n- 返回true —> onTouchEvent方法不执行 —> 导致onClick()回调方法不会执行\n\n### 五 ViewGroup源码分析\n\nAndroid中诸如LinearLayout等的五大布局控件，都是继承自ViewGroup，而ViewGroup本身是继承自View，所以ViewGroup的事件处理机制对这些控件都有效。\n\n```java\npublic boolean dispatchTouchEvent(MotionEvent ev) {  \n       final int action = ev.getAction();  \n       final float xf = ev.getX();  \n       final float yf = ev.getY();  \n       final float scrolledXFloat = xf + mScrollX;  \n       final float scrolledYFloat = yf + mScrollY;  \n       final Rect frame = mTempRect;  \n\n       //这个值默认是false, 然后我们可以通过requestDisallowInterceptTouchEvent(boolean disallowIntercept)方法  \n       //来改变disallowIntercept的值  \n       boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;  \n\n       //这里是ACTION_DOWN的处理逻辑  \n       if (action == MotionEvent.ACTION_DOWN) {  \n        //清除mMotionTarget, 每次ACTION_DOWN都很设置mMotionTarget为null  \n           if (mMotionTarget != null) {  \n               mMotionTarget = null;  \n           }  \n\n           //disallowIntercept默认是false, 就看ViewGroup的onInterceptTouchEvent()方法  \n           if (disallowIntercept || !onInterceptTouchEvent(ev)) {  //第一点\n               ev.setAction(MotionEvent.ACTION_DOWN);  \n               final int scrolledXInt = (int) scrolledXFloat;  \n               final int scrolledYInt = (int) scrolledYFloat;  \n               final View[] children = mChildren;  \n               final int count = mChildrenCount;  \n               //遍历其子View  \n               for (int i = count - 1; i >= 0; i--) {  //第二点\n                   final View child = children[i];  \n\n                   //如果该子View是VISIBLE或者该子View正在执行动画, 表示该View才  \n                   //可以接受到Touch事件  \n                   if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE  \n                           || child.getAnimation() != null) {  \n                    //获取子View的位置范围  \n                       child.getHitRect(frame);  \n\n                       //如Touch到屏幕上的点在该子View上面  \n                       if (frame.contains(scrolledXInt, scrolledYInt)) {  \n                           // offset the event to the view's coordinate system  \n                           final float xc = scrolledXFloat - child.mLeft;  \n                           final float yc = scrolledYFloat - child.mTop;  \n                           ev.setLocation(xc, yc);  \n                           child.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  \n\n                           //调用该子View的dispatchTouchEvent()方法  \n                           if (child.dispatchTouchEvent(ev))  {  \n                               // 如果child.dispatchTouchEvent(ev)返回true表示  \n                            //该事件被消费了，设置mMotionTarget为该子View  \n                               mMotionTarget = child;  \n                               //直接返回true  \n                               return true;  \n                           }  \n                           // The event didn't get handled, try the next view.  \n                           // Don't reset the event's location, it's not  \n                           // necessary here.  \n                       }  \n                   }  \n               }  \n           }  \n       }  \n\n       //判断是否为ACTION_UP或者ACTION_CANCEL  \n       boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  \n               (action == MotionEvent.ACTION_CANCEL);  \n\n       if (isUpOrCancel) {  \n           //如果是ACTION_UP或者ACTION_CANCEL, 将disallowIntercept设置为默认的false  \n        //假如我们调用了requestDisallowInterceptTouchEvent()方法来设置disallowIntercept为true  \n        //当我们抬起手指或者取消Touch事件的时候要将disallowIntercept重置为false  \n        //所以说上面的disallowIntercept默认在我们每次ACTION_DOWN的时候都是false  \n           mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;  \n       }  \n\n       // The event wasn't an ACTION_DOWN, dispatch it to our target if  \n       // we have one.  \n       final View target = mMotionTarget;  \n       //mMotionTarget为null意味着没有找到消费Touch事件的View, 所以我们需要调用ViewGroup父类的  \n       //dispatchTouchEvent()方法，也就是View的dispatchTouchEvent()方法  \n       if (target == null) {  \n           // We don't have a target, this means we're handling the  \n           // event as a regular view.  \n           ev.setLocation(xf, yf);  \n           if ((mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {  \n               ev.setAction(MotionEvent.ACTION_CANCEL);  \n               mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  \n           }  \n           return super.dispatchTouchEvent(ev);  \n       }  \n\n       //这个if里面的代码ACTION_DOWN不会执行，只有ACTION_MOVE  \n       //ACTION_UP才会走到这里, 假如在ACTION_MOVE或者ACTION_UP拦截的  \n       //Touch事件, 将ACTION_CANCEL派发给target，然后直接返回true  \n       //表示消费了此Touch事件  \n       if (!disallowIntercept && onInterceptTouchEvent(ev)) {  \n           final float xc = scrolledXFloat - (float) target.mLeft;  \n           final float yc = scrolledYFloat - (float) target.mTop;  \n           mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  \n           ev.setAction(MotionEvent.ACTION_CANCEL);  \n           ev.setLocation(xc, yc);  \n\n           if (!target.dispatchTouchEvent(ev)) {  \n           }  \n           // clear the target  \n           mMotionTarget = null;  \n           // Don't dispatch this event to our own view, because we already  \n           // saw it when intercepting; we just want to give the following  \n           // event to the normal onTouchEvent().  \n           return true;  \n       }  \n\n       if (isUpOrCancel) {  \n           mMotionTarget = null;  \n       }  \n\n       // finally offset the event to the target's coordinate system and  \n       // dispatch the event.  \n       final float xc = scrolledXFloat - (float) target.mLeft;  \n       final float yc = scrolledYFloat - (float) target.mTop;  \n       ev.setLocation(xc, yc);  \n\n       if ((target.mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {  \n           ev.setAction(MotionEvent.ACTION_CANCEL);  \n           target.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  \n           mMotionTarget = null;  \n       }  \n\n       //如果没有拦截ACTION_MOVE, ACTION_DOWN的话，直接将Touch事件派发给target  \n       return target.dispatchTouchEvent(ev);  \n   }\n```\n\n- dispatchTouchEvent作用：决定事件是否由onInterceptTouchEvent来拦截处理。 返回super.dispatchTouchEvent时，由onInterceptTouchEvent来决定事件的流向 返回false时，会继续分发事件，自己内部只处理了ACTION_DOWN 返回true时，不会继续分发事件，自己内部处理了所有事件（ACTION_DOWN,ACTION_MOVE,ACTION_UP）\n\n- onInterceptTouchEvent作用：拦截事件，用来决定事件是否传向子View 返回true时，拦截后交给自己的onTouchEvent处理 返回false时，拦截后交给子View来处理\n\n- onTouchEvent作用：事件最终到达这个方法 返回true时，内部处理所有的事件，换句话说，后续事件将继续传递给该view的onTouchEvent()处理 返回false时，事件会向上传递，由onToucEvent来接受，如果最上面View中的onTouchEvent也返回false的话，那么事件就会消失\n\n### 六 总结\n\n- 如果ViewGroup找到了能够处理该事件的View，则直接交给子View处理，自己的onTouchEvent不会被触发；　\n\n- 可以通过复写onInterceptTouchEvent(ev)方法，拦截子View的事件（即return true），把事件交给自己处理，则会执行自己对应的onTouchEvent方法。\n\n- 子View可以通过调用getParent().requestDisallowInterceptTouchEvent(true); 阻止ViewGroup对其MOVE或者UP事件进行拦截；　　\n\n- 一个点击事件产生后，它的传递过程如下： Activity->Window->View。顶级View接收到事件之后，就会按相应规则去分发事件。如果一个View的onTouchEvent方法返回false，那么将会交给父容器的onTouchEvent方法进行处理，逐级往上，如果所有的View都不处理该事件，则交由Activity的onTouchEvent进行处理。　\n\n- 如果某一个View开始处理事件，如果他不消耗ACTION_DOWN事件（也就是onTouchEvent返回false），则同一事件序列比如接下来进行ACTION_MOVE，则不会再交给该View处理。\n\n- ViewGroup默认不拦截任何事件。　\n\n- 诸如TextView、ImageView这些不作为容器的View，一旦接受到事件，就调用onTouchEvent方法，它们本身没有onInterceptTouchEvent方法。正常情况下，它们都会消耗事件（返回true），除非它们是不可点击的（clickable和longClickable都为false），那么就会交由父容器的onTouchEvent处理。　\n\n- 点击事件分发过程如下 dispatchTouchEvent—->OnTouchListener的onTouch方法—->onTouchEvent-->OnClickListener的onClick方法。也就是说，我们平时调用的setOnClickListener，优先级是最低的，所以，onTouchEvent或OnTouchListener的onTouch方法如果返回true，则不响应onClick方法...\n\n{% asset_img android事件分发.png 一个据说很牛的图 %}\n\n","slug":"android基础之事件分发机制","published":1,"updated":"2017-03-09T09:07:03.016Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk24001maknz23fm0hun","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>在android开发中会经常遇到滑动冲突（比如ScrollView或是SliddingMenu与ListView的嵌套）的问题，需要我们深入的了解android事件响应机制才能解决，事件响应机制已经是android开发者必不可少的知识。</p>\n<h3 id=\"二-涉及到事件响应的常用方法构成\"><a href=\"#二-涉及到事件响应的常用方法构成\" class=\"headerlink\" title=\"二 涉及到事件响应的常用方法构成\"></a>二 涉及到事件响应的常用方法构成</h3><p>用户在手指与屏幕接触过程中通过MotionEvent对象产生一系列事件，它有四种状态： </p>\n<ul>\n<li>MotionEvent.ACTION_DOWN　：手指按下屏幕的瞬间（一切事件的开始）</li>\n<li>MotionEvent.ACTION_MOVE　：手指在屏幕上移动</li>\n<li>MotionEvent.ACTION_UP　：手指离开屏幕瞬间</li>\n<li>MotionEvent.ACTION_CANCEL 　：取消手势，一般由程序产生，不会由用户产生</li>\n</ul>\n<p>Android中的事件onClick, onLongClick，onScroll, onFling等等，都是由许多个Touch事件构成的（一个ACTION_DOWN， n个ACTION_MOVE，1个ACTION_UP）。</p>\n<p>android 事件响应机制是先分发（先由外部的View接收，然后依次传递给其内层的最小View）再处理 （从最小View单元（事件源）开始依次向外层传递。）的形式实现的。</p>\n<p>复杂性表现在：可以控制每层事件是否继续传递（分发和拦截协同实现），以及事件的具体消费（事件分发也具有事件消费能力）。</p>\n<h3 id=\"三-android事件处理涉及到的三个重要函数\"><a href=\"#三-android事件处理涉及到的三个重要函数\" class=\"headerlink\" title=\"三 android事件处理涉及到的三个重要函数\"></a>三 android事件处理涉及到的三个重要函数</h3><h5 id=\"1-事件分发：public-boolean-dispatchTouchEvent-MotionEvent-ev\"><a href=\"#1-事件分发：public-boolean-dispatchTouchEvent-MotionEvent-ev\" class=\"headerlink\" title=\"1.事件分发：public boolean dispatchTouchEvent(MotionEvent ev)\"></a>1.事件分发：public boolean dispatchTouchEvent(MotionEvent ev)</h5><p>当有监听到事件时，首先由Activity进行捕获，进入事件分发处理流程。（因为activity没有事件拦截，View和ViewGroup有）会将事件传递给最外层View的dispatchTouchEvent(MotionEvent ev)方法，该方法对事件进行分发。 </p>\n<ul>\n<li><p>return true ：表示该View内部消化掉了所有事件。</p>\n</li>\n<li><p>return false ：事件在本层不再继续进行分发，并交由上层控件的onTouchEvent方法进行消费（如果本层控件已经是Activity，那么事件将被系统消费或处理）。　</p>\n</li>\n<li><p>如果事件分发返回系统默认的 super.dispatchTouchEvent(ev)，事件将分发给本层的事件拦截onInterceptTouchEvent 方法进行处理</p>\n</li>\n</ul>\n<h5 id=\"2-事件拦截：public-boolean-onInterceptTouchEvent-MotionEvent-ev\"><a href=\"#2-事件拦截：public-boolean-onInterceptTouchEvent-MotionEvent-ev\" class=\"headerlink\" title=\"2.事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)\"></a>2.事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)</h5><ul>\n<li><p>return true ：表示将事件进行拦截，并将拦截到的事件交由本层控件 的 onTouchEvent 进行处理；</p>\n</li>\n<li><p>return false ：则表示不对事件进行拦截，事件得以成功分发到子View。并由子View的dispatchTouchEvent进行处理。　</p>\n</li>\n<li><p>如果返回super.onInterceptTouchEvent(ev)，默认表示拦截该事件，并将事件传递给当前View的onTouchEvent方法，和return true一样。</p>\n</li>\n</ul>\n<h5 id=\"3-事件响应：public-boolean-onTouchEvent-MotionEvent-ev\"><a href=\"#3-事件响应：public-boolean-onTouchEvent-MotionEvent-ev\" class=\"headerlink\" title=\"3.事件响应：public boolean onTouchEvent(MotionEvent ev)\"></a>3.事件响应：public boolean onTouchEvent(MotionEvent ev)</h5><p>在dispatchTouchEvent（事件分发）返回super.dispatchTouchEvent(ev)并且onInterceptTouchEvent（事件拦截返回true或super.onInterceptTouchEvent(ev)的情况下，那么事件会传递到onTouchEvent方法，该方法对事件进行响应。</p>\n<ul>\n<li><p>如果return true，表示onTouchEvent处理完事件后消费了此次事件。此时事件终结；</p>\n</li>\n<li><p>如果return fasle，则表示不响应事件，那么该事件将会不断向上层View的onTouchEvent方法传递，直到某个View的onTouchEvent方法返回true，如果到了最顶层View还是返回false，那么认为该事件不消耗，则在同一个事件系列中，当前View无法再次接收到事件，该事件会交由Activity的onTouchEvent进行处理；　　</p>\n</li>\n<li><p>如果return super.dispatchTouchEvent(ev)，则表示不响应事件，结果与return false一样。</p>\n</li>\n</ul>\n<p>从以上过程中可以看出，dispatchTouchEvent无论返回true还是false，事件都不再进行分发，只有当其返回super.dispatchTouchEvent(ev)，才表明其具有向下层分发的愿望，但是是否能够分发成功，则需要经过事件拦截onInterceptTouchEvent的审核。事件是否向上传递处理是由onTouchEvent的返回值决定的。</p>\n<p>下面是Touch事件传递机制流程图：</p>\n<img src=\"/2017/02/28/android基础之事件分发机制/Touch事件分发机制流程图.png\" alt=\"Touch事件分发机制流程图\" title=\"Touch事件分发机制流程图\">\n<h3 id=\"四-View源码分析\"><a href=\"#四-View源码分析\" class=\"headerlink\" title=\"四 View源码分析\"></a>四 View源码分析</h3><p>Android中ImageView、textView、Button等继承于View但没有重写的dispatchTouchEvent方法，所以都用的View的该方法进行事件分发。</p>\n<p>看View重要函数部分源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">//返回true,表示该View内部消化掉了所有事件。返回false，表示View内部只处理了ACTION_DOWN事件，事件继续传递，向上级View(ViewGroup)传递。</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (mOnTouchListener != <span class=\"keyword\">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;</div><div class=\"line\">            mOnTouchListener.onTouch(<span class=\"keyword\">this</span>, event)) &#123;</div><div class=\"line\">  <span class=\"comment\">//此处的onTouch方式就是回调的我们注册OnTouchListener时重写的onTouch()方法</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> onTouchEvent(event);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先进行三个条件的判断：</p>\n<ul>\n<li>查看是否给button设置了OnTouchListener()事件；</li>\n<li>控件是否Enable；（控件默认都是enable的）</li>\n<li>button里面实现的OnTouchListener监听里的onTouch()方法是否返回true；</li>\n</ul>\n<p>如果条件都满足，则该事件被消耗掉，不再进入onTouchEvent中处理。否则将事件将交给onTouchEvent方法处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\"></div><div class=\"line\">   /＊ 当前onTouch的组件必须是可点击的比如Button，ImageButton等等，此处CLICKABLE为<span class=\"keyword\">true</span>，才会进入<span class=\"keyword\">if</span>方法，最后返回<span class=\"keyword\">true</span>。</div><div class=\"line\"> 如果是ImageView、TexitView这些默认为不可点击的View,此处CLICKABLE为<span class=\"keyword\">false</span>，最后返回<span class=\"keyword\">false</span>。当然会有特殊情况，如果给这些View设置了onClick监听器，此处CLICKABLE也将为<span class=\"keyword\">true</span>　　＊／</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  </div><div class=\"line\">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (event.getAction()) &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_UP:</div><div class=\"line\">                ...</div><div class=\"line\">                            <span class=\"keyword\">if</span> (!post(mPerformClick)) &#123;</div><div class=\"line\">                                performClick();<span class=\"comment\">// 实际就是回调了我们注册的OnClickListener中重新的onClick()方法</span></div><div class=\"line\">                            &#125;</div><div class=\"line\">                 ...</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</div><div class=\"line\">               ...</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_CANCEL:</div><div class=\"line\">                ...</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE:</div><div class=\"line\">               ...</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">performClick</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\"> ／／</div><div class=\"line\">    <span class=\"keyword\">if</span> (li != <span class=\"keyword\">null</span> &amp;&amp; li.mOnClickListener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        ...</div><div class=\"line\">        li.mOnClickListener.onClick(<span class=\"keyword\">this</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOnClickListener</span><span class=\"params\">(OnClickListener l)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!isClickable()) &#123;</div><div class=\"line\">        setClickable(<span class=\"keyword\">true</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    getListenerInfo().mOnClickListener = l;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>只有我们注册OnTouchListener时重写的 onTouch()方法中:</p>\n<ul>\n<li>返回false —&gt; 执行onTouchEvent方法 —&gt; 导致onClick()回调方法执行　</li>\n<li>返回true —&gt; onTouchEvent方法不执行 —&gt; 导致onClick()回调方法不会执行</li>\n</ul>\n<h3 id=\"五-ViewGroup源码分析\"><a href=\"#五-ViewGroup源码分析\" class=\"headerlink\" title=\"五 ViewGroup源码分析\"></a>五 ViewGroup源码分析</h3><p>Android中诸如LinearLayout等的五大布局控件，都是继承自ViewGroup，而ViewGroup本身是继承自View，所以ViewGroup的事件处理机制对这些控件都有效。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> action = ev.getAction();  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> xf = ev.getX();  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> yf = ev.getY();  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> scrolledXFloat = xf + mScrollX;  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> scrolledYFloat = yf + mScrollY;  </div><div class=\"line\">       <span class=\"keyword\">final</span> Rect frame = mTempRect;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//这个值默认是false, 然后我们可以通过requestDisallowInterceptTouchEvent(boolean disallowIntercept)方法  </span></div><div class=\"line\">       <span class=\"comment\">//来改变disallowIntercept的值  </span></div><div class=\"line\">       <span class=\"keyword\">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class=\"number\">0</span>;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//这里是ACTION_DOWN的处理逻辑  </span></div><div class=\"line\">       <span class=\"keyword\">if</span> (action == MotionEvent.ACTION_DOWN) &#123;  </div><div class=\"line\">        <span class=\"comment\">//清除mMotionTarget, 每次ACTION_DOWN都很设置mMotionTarget为null  </span></div><div class=\"line\">           <span class=\"keyword\">if</span> (mMotionTarget != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">               mMotionTarget = <span class=\"keyword\">null</span>;  </div><div class=\"line\">           &#125;  </div><div class=\"line\"></div><div class=\"line\">           <span class=\"comment\">//disallowIntercept默认是false, 就看ViewGroup的onInterceptTouchEvent()方法  </span></div><div class=\"line\">           <span class=\"keyword\">if</span> (disallowIntercept || !onInterceptTouchEvent(ev)) &#123;  <span class=\"comment\">//第一点</span></div><div class=\"line\">               ev.setAction(MotionEvent.ACTION_DOWN);  </div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> scrolledXInt = (<span class=\"keyword\">int</span>) scrolledXFloat;  </div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> scrolledYInt = (<span class=\"keyword\">int</span>) scrolledYFloat;  </div><div class=\"line\">               <span class=\"keyword\">final</span> View[] children = mChildren;  </div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> count = mChildrenCount;  </div><div class=\"line\">               <span class=\"comment\">//遍历其子View  </span></div><div class=\"line\">               <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = count - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;  <span class=\"comment\">//第二点</span></div><div class=\"line\">                   <span class=\"keyword\">final</span> View child = children[i];  </div><div class=\"line\"></div><div class=\"line\">                   <span class=\"comment\">//如果该子View是VISIBLE或者该子View正在执行动画, 表示该View才  </span></div><div class=\"line\">                   <span class=\"comment\">//可以接受到Touch事件  </span></div><div class=\"line\">                   <span class=\"keyword\">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE  </div><div class=\"line\">                           || child.getAnimation() != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">                    <span class=\"comment\">//获取子View的位置范围  </span></div><div class=\"line\">                       child.getHitRect(frame);  </div><div class=\"line\"></div><div class=\"line\">                       <span class=\"comment\">//如Touch到屏幕上的点在该子View上面  </span></div><div class=\"line\">                       <span class=\"keyword\">if</span> (frame.contains(scrolledXInt, scrolledYInt)) &#123;  </div><div class=\"line\">                           <span class=\"comment\">// offset the event to the view's coordinate system  </span></div><div class=\"line\">                           <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> xc = scrolledXFloat - child.mLeft;  </div><div class=\"line\">                           <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> yc = scrolledYFloat - child.mTop;  </div><div class=\"line\">                           ev.setLocation(xc, yc);  </div><div class=\"line\">                           child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class=\"line\"></div><div class=\"line\">                           <span class=\"comment\">//调用该子View的dispatchTouchEvent()方法  </span></div><div class=\"line\">                           <span class=\"keyword\">if</span> (child.dispatchTouchEvent(ev))  &#123;  </div><div class=\"line\">                               <span class=\"comment\">// 如果child.dispatchTouchEvent(ev)返回true表示  </span></div><div class=\"line\">                            <span class=\"comment\">//该事件被消费了，设置mMotionTarget为该子View  </span></div><div class=\"line\">                               mMotionTarget = child;  </div><div class=\"line\">                               <span class=\"comment\">//直接返回true  </span></div><div class=\"line\">                               <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </div><div class=\"line\">                           &#125;  </div><div class=\"line\">                           <span class=\"comment\">// The event didn't get handled, try the next view.  </span></div><div class=\"line\">                           <span class=\"comment\">// Don't reset the event's location, it's not  </span></div><div class=\"line\">                           <span class=\"comment\">// necessary here.  </span></div><div class=\"line\">                       &#125;  </div><div class=\"line\">                   &#125;  </div><div class=\"line\">               &#125;  </div><div class=\"line\">           &#125;  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//判断是否为ACTION_UP或者ACTION_CANCEL  </span></div><div class=\"line\">       <span class=\"keyword\">boolean</span> isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  </div><div class=\"line\">               (action == MotionEvent.ACTION_CANCEL);  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (isUpOrCancel) &#123;  </div><div class=\"line\">           <span class=\"comment\">//如果是ACTION_UP或者ACTION_CANCEL, 将disallowIntercept设置为默认的false  </span></div><div class=\"line\">        <span class=\"comment\">//假如我们调用了requestDisallowInterceptTouchEvent()方法来设置disallowIntercept为true  </span></div><div class=\"line\">        <span class=\"comment\">//当我们抬起手指或者取消Touch事件的时候要将disallowIntercept重置为false  </span></div><div class=\"line\">        <span class=\"comment\">//所以说上面的disallowIntercept默认在我们每次ACTION_DOWN的时候都是false  </span></div><div class=\"line\">           mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">// The event wasn't an ACTION_DOWN, dispatch it to our target if  </span></div><div class=\"line\">       <span class=\"comment\">// we have one.  </span></div><div class=\"line\">       <span class=\"keyword\">final</span> View target = mMotionTarget;  </div><div class=\"line\">       <span class=\"comment\">//mMotionTarget为null意味着没有找到消费Touch事件的View, 所以我们需要调用ViewGroup父类的  </span></div><div class=\"line\">       <span class=\"comment\">//dispatchTouchEvent()方法，也就是View的dispatchTouchEvent()方法  </span></div><div class=\"line\">       <span class=\"keyword\">if</span> (target == <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">           <span class=\"comment\">// We don't have a target, this means we're handling the  </span></div><div class=\"line\">           <span class=\"comment\">// event as a regular view.  </span></div><div class=\"line\">           ev.setLocation(xf, yf);  </div><div class=\"line\">           <span class=\"keyword\">if</span> ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != <span class=\"number\">0</span>) &#123;  </div><div class=\"line\">               ev.setAction(MotionEvent.ACTION_CANCEL);  </div><div class=\"line\">               mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class=\"line\">           &#125;  </div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.dispatchTouchEvent(ev);  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//这个if里面的代码ACTION_DOWN不会执行，只有ACTION_MOVE  </span></div><div class=\"line\">       <span class=\"comment\">//ACTION_UP才会走到这里, 假如在ACTION_MOVE或者ACTION_UP拦截的  </span></div><div class=\"line\">       <span class=\"comment\">//Touch事件, 将ACTION_CANCEL派发给target，然后直接返回true  </span></div><div class=\"line\">       <span class=\"comment\">//表示消费了此Touch事件  </span></div><div class=\"line\">       <span class=\"keyword\">if</span> (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) &#123;  </div><div class=\"line\">           <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> xc = scrolledXFloat - (<span class=\"keyword\">float</span>) target.mLeft;  </div><div class=\"line\">           <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> yc = scrolledYFloat - (<span class=\"keyword\">float</span>) target.mTop;  </div><div class=\"line\">           mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class=\"line\">           ev.setAction(MotionEvent.ACTION_CANCEL);  </div><div class=\"line\">           ev.setLocation(xc, yc);  </div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">if</span> (!target.dispatchTouchEvent(ev)) &#123;  </div><div class=\"line\">           &#125;  </div><div class=\"line\">           <span class=\"comment\">// clear the target  </span></div><div class=\"line\">           mMotionTarget = <span class=\"keyword\">null</span>;  </div><div class=\"line\">           <span class=\"comment\">// Don't dispatch this event to our own view, because we already  </span></div><div class=\"line\">           <span class=\"comment\">// saw it when intercepting; we just want to give the following  </span></div><div class=\"line\">           <span class=\"comment\">// event to the normal onTouchEvent().  </span></div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (isUpOrCancel) &#123;  </div><div class=\"line\">           mMotionTarget = <span class=\"keyword\">null</span>;  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">// finally offset the event to the target's coordinate system and  </span></div><div class=\"line\">       <span class=\"comment\">// dispatch the event.  </span></div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> xc = scrolledXFloat - (<span class=\"keyword\">float</span>) target.mLeft;  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> yc = scrolledYFloat - (<span class=\"keyword\">float</span>) target.mTop;  </div><div class=\"line\">       ev.setLocation(xc, yc);  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> ((target.mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != <span class=\"number\">0</span>) &#123;  </div><div class=\"line\">           ev.setAction(MotionEvent.ACTION_CANCEL);  </div><div class=\"line\">           target.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class=\"line\">           mMotionTarget = <span class=\"keyword\">null</span>;  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//如果没有拦截ACTION_MOVE, ACTION_DOWN的话，直接将Touch事件派发给target  </span></div><div class=\"line\">       <span class=\"keyword\">return</span> target.dispatchTouchEvent(ev);  </div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>dispatchTouchEvent作用：决定事件是否由onInterceptTouchEvent来拦截处理。 返回super.dispatchTouchEvent时，由onInterceptTouchEvent来决定事件的流向 返回false时，会继续分发事件，自己内部只处理了ACTION_DOWN 返回true时，不会继续分发事件，自己内部处理了所有事件（ACTION_DOWN,ACTION_MOVE,ACTION_UP）</p>\n</li>\n<li><p>onInterceptTouchEvent作用：拦截事件，用来决定事件是否传向子View 返回true时，拦截后交给自己的onTouchEvent处理 返回false时，拦截后交给子View来处理</p>\n</li>\n<li><p>onTouchEvent作用：事件最终到达这个方法 返回true时，内部处理所有的事件，换句话说，后续事件将继续传递给该view的onTouchEvent()处理 返回false时，事件会向上传递，由onToucEvent来接受，如果最上面View中的onTouchEvent也返回false的话，那么事件就会消失</p>\n</li>\n</ul>\n<h3 id=\"六-总结\"><a href=\"#六-总结\" class=\"headerlink\" title=\"六 总结\"></a>六 总结</h3><ul>\n<li><p>如果ViewGroup找到了能够处理该事件的View，则直接交给子View处理，自己的onTouchEvent不会被触发；　</p>\n</li>\n<li><p>可以通过复写onInterceptTouchEvent(ev)方法，拦截子View的事件（即return true），把事件交给自己处理，则会执行自己对应的onTouchEvent方法。</p>\n</li>\n<li><p>子View可以通过调用getParent().requestDisallowInterceptTouchEvent(true); 阻止ViewGroup对其MOVE或者UP事件进行拦截；　　</p>\n</li>\n<li><p>一个点击事件产生后，它的传递过程如下： Activity-&gt;Window-&gt;View。顶级View接收到事件之后，就会按相应规则去分发事件。如果一个View的onTouchEvent方法返回false，那么将会交给父容器的onTouchEvent方法进行处理，逐级往上，如果所有的View都不处理该事件，则交由Activity的onTouchEvent进行处理。　</p>\n</li>\n<li><p>如果某一个View开始处理事件，如果他不消耗ACTION_DOWN事件（也就是onTouchEvent返回false），则同一事件序列比如接下来进行ACTION_MOVE，则不会再交给该View处理。</p>\n</li>\n<li><p>ViewGroup默认不拦截任何事件。　</p>\n</li>\n<li><p>诸如TextView、ImageView这些不作为容器的View，一旦接受到事件，就调用onTouchEvent方法，它们本身没有onInterceptTouchEvent方法。正常情况下，它们都会消耗事件（返回true），除非它们是不可点击的（clickable和longClickable都为false），那么就会交由父容器的onTouchEvent处理。　</p>\n</li>\n<li><p>点击事件分发过程如下 dispatchTouchEvent—-&gt;OnTouchListener的onTouch方法—-&gt;onTouchEvent–&gt;OnClickListener的onClick方法。也就是说，我们平时调用的setOnClickListener，优先级是最低的，所以，onTouchEvent或OnTouchListener的onTouch方法如果返回true，则不响应onClick方法…</p>\n</li>\n</ul>\n<img src=\"/2017/02/28/android基础之事件分发机制/android事件分发.png\" alt=\"一个据说很牛的图\" title=\"一个据说很牛的图\">\n","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>在android开发中会经常遇到滑动冲突（比如ScrollView或是SliddingMenu与ListView的嵌套）的问题，需要我们深入的了解android事件响应机制才能解决，事件响应机制已经是android开发者必不可少的知识。</p>\n<h3 id=\"二-涉及到事件响应的常用方法构成\"><a href=\"#二-涉及到事件响应的常用方法构成\" class=\"headerlink\" title=\"二 涉及到事件响应的常用方法构成\"></a>二 涉及到事件响应的常用方法构成</h3><p>用户在手指与屏幕接触过程中通过MotionEvent对象产生一系列事件，它有四种状态： </p>\n<ul>\n<li>MotionEvent.ACTION_DOWN　：手指按下屏幕的瞬间（一切事件的开始）</li>\n<li>MotionEvent.ACTION_MOVE　：手指在屏幕上移动</li>\n<li>MotionEvent.ACTION_UP　：手指离开屏幕瞬间</li>\n<li>MotionEvent.ACTION_CANCEL 　：取消手势，一般由程序产生，不会由用户产生</li>\n</ul>\n<p>Android中的事件onClick, onLongClick，onScroll, onFling等等，都是由许多个Touch事件构成的（一个ACTION_DOWN， n个ACTION_MOVE，1个ACTION_UP）。</p>\n<p>android 事件响应机制是先分发（先由外部的View接收，然后依次传递给其内层的最小View）再处理 （从最小View单元（事件源）开始依次向外层传递。）的形式实现的。</p>\n<p>复杂性表现在：可以控制每层事件是否继续传递（分发和拦截协同实现），以及事件的具体消费（事件分发也具有事件消费能力）。</p>\n<h3 id=\"三-android事件处理涉及到的三个重要函数\"><a href=\"#三-android事件处理涉及到的三个重要函数\" class=\"headerlink\" title=\"三 android事件处理涉及到的三个重要函数\"></a>三 android事件处理涉及到的三个重要函数</h3><h5 id=\"1-事件分发：public-boolean-dispatchTouchEvent-MotionEvent-ev\"><a href=\"#1-事件分发：public-boolean-dispatchTouchEvent-MotionEvent-ev\" class=\"headerlink\" title=\"1.事件分发：public boolean dispatchTouchEvent(MotionEvent ev)\"></a>1.事件分发：public boolean dispatchTouchEvent(MotionEvent ev)</h5><p>当有监听到事件时，首先由Activity进行捕获，进入事件分发处理流程。（因为activity没有事件拦截，View和ViewGroup有）会将事件传递给最外层View的dispatchTouchEvent(MotionEvent ev)方法，该方法对事件进行分发。 </p>\n<ul>\n<li><p>return true ：表示该View内部消化掉了所有事件。</p>\n</li>\n<li><p>return false ：事件在本层不再继续进行分发，并交由上层控件的onTouchEvent方法进行消费（如果本层控件已经是Activity，那么事件将被系统消费或处理）。　</p>\n</li>\n<li><p>如果事件分发返回系统默认的 super.dispatchTouchEvent(ev)，事件将分发给本层的事件拦截onInterceptTouchEvent 方法进行处理</p>\n</li>\n</ul>\n<h5 id=\"2-事件拦截：public-boolean-onInterceptTouchEvent-MotionEvent-ev\"><a href=\"#2-事件拦截：public-boolean-onInterceptTouchEvent-MotionEvent-ev\" class=\"headerlink\" title=\"2.事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)\"></a>2.事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)</h5><ul>\n<li><p>return true ：表示将事件进行拦截，并将拦截到的事件交由本层控件 的 onTouchEvent 进行处理；</p>\n</li>\n<li><p>return false ：则表示不对事件进行拦截，事件得以成功分发到子View。并由子View的dispatchTouchEvent进行处理。　</p>\n</li>\n<li><p>如果返回super.onInterceptTouchEvent(ev)，默认表示拦截该事件，并将事件传递给当前View的onTouchEvent方法，和return true一样。</p>\n</li>\n</ul>\n<h5 id=\"3-事件响应：public-boolean-onTouchEvent-MotionEvent-ev\"><a href=\"#3-事件响应：public-boolean-onTouchEvent-MotionEvent-ev\" class=\"headerlink\" title=\"3.事件响应：public boolean onTouchEvent(MotionEvent ev)\"></a>3.事件响应：public boolean onTouchEvent(MotionEvent ev)</h5><p>在dispatchTouchEvent（事件分发）返回super.dispatchTouchEvent(ev)并且onInterceptTouchEvent（事件拦截返回true或super.onInterceptTouchEvent(ev)的情况下，那么事件会传递到onTouchEvent方法，该方法对事件进行响应。</p>\n<ul>\n<li><p>如果return true，表示onTouchEvent处理完事件后消费了此次事件。此时事件终结；</p>\n</li>\n<li><p>如果return fasle，则表示不响应事件，那么该事件将会不断向上层View的onTouchEvent方法传递，直到某个View的onTouchEvent方法返回true，如果到了最顶层View还是返回false，那么认为该事件不消耗，则在同一个事件系列中，当前View无法再次接收到事件，该事件会交由Activity的onTouchEvent进行处理；　　</p>\n</li>\n<li><p>如果return super.dispatchTouchEvent(ev)，则表示不响应事件，结果与return false一样。</p>\n</li>\n</ul>\n<p>从以上过程中可以看出，dispatchTouchEvent无论返回true还是false，事件都不再进行分发，只有当其返回super.dispatchTouchEvent(ev)，才表明其具有向下层分发的愿望，但是是否能够分发成功，则需要经过事件拦截onInterceptTouchEvent的审核。事件是否向上传递处理是由onTouchEvent的返回值决定的。</p>\n<p>下面是Touch事件传递机制流程图：</p>\n<img src=\"/2017/02/28/android基础之事件分发机制/Touch事件分发机制流程图.png\" alt=\"Touch事件分发机制流程图\" title=\"Touch事件分发机制流程图\">\n<h3 id=\"四-View源码分析\"><a href=\"#四-View源码分析\" class=\"headerlink\" title=\"四 View源码分析\"></a>四 View源码分析</h3><p>Android中ImageView、textView、Button等继承于View但没有重写的dispatchTouchEvent方法，所以都用的View的该方法进行事件分发。</p>\n<p>看View重要函数部分源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">//返回true,表示该View内部消化掉了所有事件。返回false，表示View内部只处理了ACTION_DOWN事件，事件继续传递，向上级View(ViewGroup)传递。</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (mOnTouchListener != <span class=\"keyword\">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;</div><div class=\"line\">            mOnTouchListener.onTouch(<span class=\"keyword\">this</span>, event)) &#123;</div><div class=\"line\">  <span class=\"comment\">//此处的onTouch方式就是回调的我们注册OnTouchListener时重写的onTouch()方法</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> onTouchEvent(event);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先进行三个条件的判断：</p>\n<ul>\n<li>查看是否给button设置了OnTouchListener()事件；</li>\n<li>控件是否Enable；（控件默认都是enable的）</li>\n<li>button里面实现的OnTouchListener监听里的onTouch()方法是否返回true；</li>\n</ul>\n<p>如果条件都满足，则该事件被消耗掉，不再进入onTouchEvent中处理。否则将事件将交给onTouchEvent方法处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\"></div><div class=\"line\">   /＊ 当前onTouch的组件必须是可点击的比如Button，ImageButton等等，此处CLICKABLE为<span class=\"keyword\">true</span>，才会进入<span class=\"keyword\">if</span>方法，最后返回<span class=\"keyword\">true</span>。</div><div class=\"line\"> 如果是ImageView、TexitView这些默认为不可点击的View,此处CLICKABLE为<span class=\"keyword\">false</span>，最后返回<span class=\"keyword\">false</span>。当然会有特殊情况，如果给这些View设置了onClick监听器，此处CLICKABLE也将为<span class=\"keyword\">true</span>　　＊／</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  </div><div class=\"line\">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (event.getAction()) &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_UP:</div><div class=\"line\">                ...</div><div class=\"line\">                            <span class=\"keyword\">if</span> (!post(mPerformClick)) &#123;</div><div class=\"line\">                                performClick();<span class=\"comment\">// 实际就是回调了我们注册的OnClickListener中重新的onClick()方法</span></div><div class=\"line\">                            &#125;</div><div class=\"line\">                 ...</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</div><div class=\"line\">               ...</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_CANCEL:</div><div class=\"line\">                ...</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE:</div><div class=\"line\">               ...</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">performClick</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\"> ／／</div><div class=\"line\">    <span class=\"keyword\">if</span> (li != <span class=\"keyword\">null</span> &amp;&amp; li.mOnClickListener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        ...</div><div class=\"line\">        li.mOnClickListener.onClick(<span class=\"keyword\">this</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOnClickListener</span><span class=\"params\">(OnClickListener l)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!isClickable()) &#123;</div><div class=\"line\">        setClickable(<span class=\"keyword\">true</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    getListenerInfo().mOnClickListener = l;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>只有我们注册OnTouchListener时重写的 onTouch()方法中:</p>\n<ul>\n<li>返回false —&gt; 执行onTouchEvent方法 —&gt; 导致onClick()回调方法执行　</li>\n<li>返回true —&gt; onTouchEvent方法不执行 —&gt; 导致onClick()回调方法不会执行</li>\n</ul>\n<h3 id=\"五-ViewGroup源码分析\"><a href=\"#五-ViewGroup源码分析\" class=\"headerlink\" title=\"五 ViewGroup源码分析\"></a>五 ViewGroup源码分析</h3><p>Android中诸如LinearLayout等的五大布局控件，都是继承自ViewGroup，而ViewGroup本身是继承自View，所以ViewGroup的事件处理机制对这些控件都有效。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> action = ev.getAction();  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> xf = ev.getX();  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> yf = ev.getY();  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> scrolledXFloat = xf + mScrollX;  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> scrolledYFloat = yf + mScrollY;  </div><div class=\"line\">       <span class=\"keyword\">final</span> Rect frame = mTempRect;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//这个值默认是false, 然后我们可以通过requestDisallowInterceptTouchEvent(boolean disallowIntercept)方法  </span></div><div class=\"line\">       <span class=\"comment\">//来改变disallowIntercept的值  </span></div><div class=\"line\">       <span class=\"keyword\">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class=\"number\">0</span>;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//这里是ACTION_DOWN的处理逻辑  </span></div><div class=\"line\">       <span class=\"keyword\">if</span> (action == MotionEvent.ACTION_DOWN) &#123;  </div><div class=\"line\">        <span class=\"comment\">//清除mMotionTarget, 每次ACTION_DOWN都很设置mMotionTarget为null  </span></div><div class=\"line\">           <span class=\"keyword\">if</span> (mMotionTarget != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">               mMotionTarget = <span class=\"keyword\">null</span>;  </div><div class=\"line\">           &#125;  </div><div class=\"line\"></div><div class=\"line\">           <span class=\"comment\">//disallowIntercept默认是false, 就看ViewGroup的onInterceptTouchEvent()方法  </span></div><div class=\"line\">           <span class=\"keyword\">if</span> (disallowIntercept || !onInterceptTouchEvent(ev)) &#123;  <span class=\"comment\">//第一点</span></div><div class=\"line\">               ev.setAction(MotionEvent.ACTION_DOWN);  </div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> scrolledXInt = (<span class=\"keyword\">int</span>) scrolledXFloat;  </div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> scrolledYInt = (<span class=\"keyword\">int</span>) scrolledYFloat;  </div><div class=\"line\">               <span class=\"keyword\">final</span> View[] children = mChildren;  </div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> count = mChildrenCount;  </div><div class=\"line\">               <span class=\"comment\">//遍历其子View  </span></div><div class=\"line\">               <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = count - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;  <span class=\"comment\">//第二点</span></div><div class=\"line\">                   <span class=\"keyword\">final</span> View child = children[i];  </div><div class=\"line\"></div><div class=\"line\">                   <span class=\"comment\">//如果该子View是VISIBLE或者该子View正在执行动画, 表示该View才  </span></div><div class=\"line\">                   <span class=\"comment\">//可以接受到Touch事件  </span></div><div class=\"line\">                   <span class=\"keyword\">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE  </div><div class=\"line\">                           || child.getAnimation() != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">                    <span class=\"comment\">//获取子View的位置范围  </span></div><div class=\"line\">                       child.getHitRect(frame);  </div><div class=\"line\"></div><div class=\"line\">                       <span class=\"comment\">//如Touch到屏幕上的点在该子View上面  </span></div><div class=\"line\">                       <span class=\"keyword\">if</span> (frame.contains(scrolledXInt, scrolledYInt)) &#123;  </div><div class=\"line\">                           <span class=\"comment\">// offset the event to the view's coordinate system  </span></div><div class=\"line\">                           <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> xc = scrolledXFloat - child.mLeft;  </div><div class=\"line\">                           <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> yc = scrolledYFloat - child.mTop;  </div><div class=\"line\">                           ev.setLocation(xc, yc);  </div><div class=\"line\">                           child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class=\"line\"></div><div class=\"line\">                           <span class=\"comment\">//调用该子View的dispatchTouchEvent()方法  </span></div><div class=\"line\">                           <span class=\"keyword\">if</span> (child.dispatchTouchEvent(ev))  &#123;  </div><div class=\"line\">                               <span class=\"comment\">// 如果child.dispatchTouchEvent(ev)返回true表示  </span></div><div class=\"line\">                            <span class=\"comment\">//该事件被消费了，设置mMotionTarget为该子View  </span></div><div class=\"line\">                               mMotionTarget = child;  </div><div class=\"line\">                               <span class=\"comment\">//直接返回true  </span></div><div class=\"line\">                               <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </div><div class=\"line\">                           &#125;  </div><div class=\"line\">                           <span class=\"comment\">// The event didn't get handled, try the next view.  </span></div><div class=\"line\">                           <span class=\"comment\">// Don't reset the event's location, it's not  </span></div><div class=\"line\">                           <span class=\"comment\">// necessary here.  </span></div><div class=\"line\">                       &#125;  </div><div class=\"line\">                   &#125;  </div><div class=\"line\">               &#125;  </div><div class=\"line\">           &#125;  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//判断是否为ACTION_UP或者ACTION_CANCEL  </span></div><div class=\"line\">       <span class=\"keyword\">boolean</span> isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  </div><div class=\"line\">               (action == MotionEvent.ACTION_CANCEL);  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (isUpOrCancel) &#123;  </div><div class=\"line\">           <span class=\"comment\">//如果是ACTION_UP或者ACTION_CANCEL, 将disallowIntercept设置为默认的false  </span></div><div class=\"line\">        <span class=\"comment\">//假如我们调用了requestDisallowInterceptTouchEvent()方法来设置disallowIntercept为true  </span></div><div class=\"line\">        <span class=\"comment\">//当我们抬起手指或者取消Touch事件的时候要将disallowIntercept重置为false  </span></div><div class=\"line\">        <span class=\"comment\">//所以说上面的disallowIntercept默认在我们每次ACTION_DOWN的时候都是false  </span></div><div class=\"line\">           mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">// The event wasn't an ACTION_DOWN, dispatch it to our target if  </span></div><div class=\"line\">       <span class=\"comment\">// we have one.  </span></div><div class=\"line\">       <span class=\"keyword\">final</span> View target = mMotionTarget;  </div><div class=\"line\">       <span class=\"comment\">//mMotionTarget为null意味着没有找到消费Touch事件的View, 所以我们需要调用ViewGroup父类的  </span></div><div class=\"line\">       <span class=\"comment\">//dispatchTouchEvent()方法，也就是View的dispatchTouchEvent()方法  </span></div><div class=\"line\">       <span class=\"keyword\">if</span> (target == <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">           <span class=\"comment\">// We don't have a target, this means we're handling the  </span></div><div class=\"line\">           <span class=\"comment\">// event as a regular view.  </span></div><div class=\"line\">           ev.setLocation(xf, yf);  </div><div class=\"line\">           <span class=\"keyword\">if</span> ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != <span class=\"number\">0</span>) &#123;  </div><div class=\"line\">               ev.setAction(MotionEvent.ACTION_CANCEL);  </div><div class=\"line\">               mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class=\"line\">           &#125;  </div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.dispatchTouchEvent(ev);  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//这个if里面的代码ACTION_DOWN不会执行，只有ACTION_MOVE  </span></div><div class=\"line\">       <span class=\"comment\">//ACTION_UP才会走到这里, 假如在ACTION_MOVE或者ACTION_UP拦截的  </span></div><div class=\"line\">       <span class=\"comment\">//Touch事件, 将ACTION_CANCEL派发给target，然后直接返回true  </span></div><div class=\"line\">       <span class=\"comment\">//表示消费了此Touch事件  </span></div><div class=\"line\">       <span class=\"keyword\">if</span> (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) &#123;  </div><div class=\"line\">           <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> xc = scrolledXFloat - (<span class=\"keyword\">float</span>) target.mLeft;  </div><div class=\"line\">           <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> yc = scrolledYFloat - (<span class=\"keyword\">float</span>) target.mTop;  </div><div class=\"line\">           mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class=\"line\">           ev.setAction(MotionEvent.ACTION_CANCEL);  </div><div class=\"line\">           ev.setLocation(xc, yc);  </div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">if</span> (!target.dispatchTouchEvent(ev)) &#123;  </div><div class=\"line\">           &#125;  </div><div class=\"line\">           <span class=\"comment\">// clear the target  </span></div><div class=\"line\">           mMotionTarget = <span class=\"keyword\">null</span>;  </div><div class=\"line\">           <span class=\"comment\">// Don't dispatch this event to our own view, because we already  </span></div><div class=\"line\">           <span class=\"comment\">// saw it when intercepting; we just want to give the following  </span></div><div class=\"line\">           <span class=\"comment\">// event to the normal onTouchEvent().  </span></div><div class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (isUpOrCancel) &#123;  </div><div class=\"line\">           mMotionTarget = <span class=\"keyword\">null</span>;  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">// finally offset the event to the target's coordinate system and  </span></div><div class=\"line\">       <span class=\"comment\">// dispatch the event.  </span></div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> xc = scrolledXFloat - (<span class=\"keyword\">float</span>) target.mLeft;  </div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> yc = scrolledYFloat - (<span class=\"keyword\">float</span>) target.mTop;  </div><div class=\"line\">       ev.setLocation(xc, yc);  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> ((target.mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != <span class=\"number\">0</span>) &#123;  </div><div class=\"line\">           ev.setAction(MotionEvent.ACTION_CANCEL);  </div><div class=\"line\">           target.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  </div><div class=\"line\">           mMotionTarget = <span class=\"keyword\">null</span>;  </div><div class=\"line\">       &#125;  </div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">//如果没有拦截ACTION_MOVE, ACTION_DOWN的话，直接将Touch事件派发给target  </span></div><div class=\"line\">       <span class=\"keyword\">return</span> target.dispatchTouchEvent(ev);  </div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>dispatchTouchEvent作用：决定事件是否由onInterceptTouchEvent来拦截处理。 返回super.dispatchTouchEvent时，由onInterceptTouchEvent来决定事件的流向 返回false时，会继续分发事件，自己内部只处理了ACTION_DOWN 返回true时，不会继续分发事件，自己内部处理了所有事件（ACTION_DOWN,ACTION_MOVE,ACTION_UP）</p>\n</li>\n<li><p>onInterceptTouchEvent作用：拦截事件，用来决定事件是否传向子View 返回true时，拦截后交给自己的onTouchEvent处理 返回false时，拦截后交给子View来处理</p>\n</li>\n<li><p>onTouchEvent作用：事件最终到达这个方法 返回true时，内部处理所有的事件，换句话说，后续事件将继续传递给该view的onTouchEvent()处理 返回false时，事件会向上传递，由onToucEvent来接受，如果最上面View中的onTouchEvent也返回false的话，那么事件就会消失</p>\n</li>\n</ul>\n<h3 id=\"六-总结\"><a href=\"#六-总结\" class=\"headerlink\" title=\"六 总结\"></a>六 总结</h3><ul>\n<li><p>如果ViewGroup找到了能够处理该事件的View，则直接交给子View处理，自己的onTouchEvent不会被触发；　</p>\n</li>\n<li><p>可以通过复写onInterceptTouchEvent(ev)方法，拦截子View的事件（即return true），把事件交给自己处理，则会执行自己对应的onTouchEvent方法。</p>\n</li>\n<li><p>子View可以通过调用getParent().requestDisallowInterceptTouchEvent(true); 阻止ViewGroup对其MOVE或者UP事件进行拦截；　　</p>\n</li>\n<li><p>一个点击事件产生后，它的传递过程如下： Activity-&gt;Window-&gt;View。顶级View接收到事件之后，就会按相应规则去分发事件。如果一个View的onTouchEvent方法返回false，那么将会交给父容器的onTouchEvent方法进行处理，逐级往上，如果所有的View都不处理该事件，则交由Activity的onTouchEvent进行处理。　</p>\n</li>\n<li><p>如果某一个View开始处理事件，如果他不消耗ACTION_DOWN事件（也就是onTouchEvent返回false），则同一事件序列比如接下来进行ACTION_MOVE，则不会再交给该View处理。</p>\n</li>\n<li><p>ViewGroup默认不拦截任何事件。　</p>\n</li>\n<li><p>诸如TextView、ImageView这些不作为容器的View，一旦接受到事件，就调用onTouchEvent方法，它们本身没有onInterceptTouchEvent方法。正常情况下，它们都会消耗事件（返回true），除非它们是不可点击的（clickable和longClickable都为false），那么就会交由父容器的onTouchEvent处理。　</p>\n</li>\n<li><p>点击事件分发过程如下 dispatchTouchEvent—-&gt;OnTouchListener的onTouch方法—-&gt;onTouchEvent–&gt;OnClickListener的onClick方法。也就是说，我们平时调用的setOnClickListener，优先级是最低的，所以，onTouchEvent或OnTouchListener的onTouch方法如果返回true，则不响应onClick方法…</p>\n</li>\n</ul>\n<img src=\"/2017/02/28/android基础之事件分发机制/android事件分发.png\" alt=\"一个据说很牛的图\" title=\"一个据说很牛的图\">\n"},{"title":"android基础之缓存","date":"2017-02-28T09:10:22.000Z","_content":"\n### 一 概述\n\n移动开发本质上就是手机和服务器之间进行通信，需要从服务端获取数据。反复通过网络获取数据是比较耗时的，特别是访问比较多的时候，会极大影响了性能，Android中可通过缓存机制来减少频繁的网络操作，减少流量、提升性能。android中缓存分为一级缓存，二级缓存和图片的三级缓存(就是网络)。\n\nAndroid缓存分为内存缓存（一级缓存）和文件缓存（二级缓存）。在早期，各大图片缓存框架流行之前，常用的内存缓存方式是软引用（SoftReference）和弱引用（WeakReference），如大部分的使用方式：HashMap<String url, SoftReference<Drawable>> imageCache;这种形式。从Android 2.3（Level 9）开始，垃圾回收器更倾向于回收SoftReference或WeakReference对象，这使得SoftReference和WeakReference变得不是那么实用有效。同时，到了Android 3.0（Level 11）之后，图片数据Bitmap被放置到了内存的堆区域，而堆区域的内存是由GC管理的，开发者也就不需要进行图片资源的释放工作，但这也使得图片数据的释放无法预知，增加了造成OOM的可能。因此，在Android3.1以后，Android推出了LruCache这个内存缓存类和DiskLruCache这个磁盘缓存类。\n\n当Android端需要获得数据时比如获取网络中的图片，我们首先从内存中查找（按键查找），内存中没有的再从磁盘文件或sqlite中去查找，若磁盘中也没有才通过网络获取（图片的3级缓存策略）；当获得来自网络的数据，就以key-value对的方式先缓存到内存（一级缓存），同时缓存到文件或sqlite中（二级缓存）。注意：内存缓存会造成堆内存泄露，所有一级缓存通常要严格控制缓存的大小，一般控制在系统内存的1/4。\n\n### 二 内存缓存（一级缓存）\n\nandroid中使用LruCache做内存缓存。在介绍这个类之前先了解一下LRU算法。\n\n##### 1.LRU算法\nLRU，全称Least Rencetly Used，即最近最少使用，是一种非常常用的置换算法，也即淘汰最长时间未使用的对象。LRU在操作系统中的页面置换算法中广泛使用，我们的内存或缓存空间是有限的，当新加入一个对象时，造成我们的缓存空间不足了，此时就需要根据某种算法对缓存中原有数据进行淘汰货删除，而LRU选择的是将最长时间未使用的对象进行淘汰。\n\n##### 2.LruCache实现原理\n\n根据LRU算法的思想，要实现LRU最核心的是要有一种数据结构能够基于访问顺序来保存缓存中的对象，这样我们就能够很方便的知道哪个对象是最近访问的，哪个对象是最长时间未访问的。LruCache选择的是LinkedHashMap这个数据结构，LinkedHashMap是一个双向循环链表，在构造LinkedHashMap时，通过一个boolean值来指定LinkedHashMap中保存数据的方式，LinkedHashMap的一个构造方法如下：\n\n```java\n    /* \n         * 初始化LinkedHashMap \n         * 第一个参数：initialCapacity，初始大小 \n         * 第二个参数：loadFactor，负载因子=0.75f \n         * 第三个参数：accessOrder=true，基于访问顺序；accessOrder=false，基于插入顺序 \n         */  \n        public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) {  \n            super(initialCapacity, loadFactor);  \n            init();  \n            this.accessOrder = accessOrder;  \n        }  \n```\n\n显然，在LruCache中选择的是accessOrder = true；此时，当accessOrder 设置为 true时，每当我们更新（即调用put方法）或访问（即调用get方法）map中的结点时，LinkedHashMap内部都会将这个结点移动到链表的尾部，因此，在链表的尾部是最近刚刚使用的结点，在链表的头部是是最近最少使用的结点，当我们的缓存空间不足时，就应该持续把链表头部结点移除掉，直到有剩余空间放置新结点。\n可以看到，LinkedHashMap完成了LruCache中的核心功能，那LruCache中剩下要做的就是定义缓存空间总容量，当前保存数据已使用的容量，对外提供put、get方法。\n\n##### 3.LruCache源码分析\n\n在了解了LruCache的核心原理之后，就可以开始分析LruCache的源码了。\n\n###### 3.1关键字段\n\n根据上面的分析，首先要有总容量、已使用容量、linkedHashMap这几个关键字段，LruCache中提供了下面三个关键字段：\n\n```java\n    //核心数据结构  \n        private final LinkedHashMap<K, V> map;  \n        // 当前缓存数据所占的大小  \n        private int size;  \n        //缓存空间总容量  \n        private int maxSize;  \n```\n\n要注意的是size字段，因为map中可以存放各种类型的数据，这些数据的大小测量方式也是不一样的，比如Bitmap类型的数据和String类型的数据计算他们的大小方式肯定不同，因此，LruCache中在计算放入数据大小的方法sizeOf中，只是简单的返回了1，需要我们重写这个方法，自己去定义数据的测量方式。因此，我们在使用LruCache的时候，经常会看到这种方式： \n\n```java\n    private static final int CACHE_SIZE = 4 * 1024 * 1024;//4Mib  \n        LruCache<String,Bitmap> bitmapCache = new LruCache<String,Bitmap>(CACHE_SIZE){  \n            @Override  \n            protected int sizeOf(String key, Bitmap value) {  \n                return value.getByteCount();//自定义Bitmap数据大小的计算方式  \n            }  \n        };  \n```\n\n###### 3.2 构造方法  \n\n```java\n\tpublic LruCache(int maxSize) {\n\t    if (maxSize <= 0) {\n\t        throw new IllegalArgumentException(\"maxSize <= 0\");\n\t    }\n\t    this.maxSize = maxSize;\n\t    this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n\t}\n```\n\nLruCache只有一个唯一的构造方法，在构造方法中，给定了缓存空间的总大小，初始化了LinkedHashMap核心数据结构，在LinkedHashMap中的第三个参数指定为true，也就设置了accessOrder=true，表示这个LinkedHashMap将是基于数据的访问顺序进行排序。\n\n\n###### 3.3 sizeOf()和safeSizeOf()方法测量数据类型大小\n\n根据上面的解释，由于各种数据类型大小测量的标准不统一，具体测量的方法应该由使用者来实现，如上面给出的一个在实现LruCache时重写sizeOf的一种常用实现方式。通过多态的性质，再具体调用sizeOf时会调用我们重写的方法进行测量，LruCache对sizeOf()的调用进行一层封装，如下： \n\n```java\n\tprivate int safeSizeOf(K key, V value) {\n\t    int result = sizeOf(key, value);\n\t    if (result < 0) {\n\t        throw new IllegalStateException(\"Negative size: \" + key + \"=\" + value);\n\t    }\n\t    return result;\n\t} \n```\n\n里面其实就是调用sizeOf()方法，返回sizeOf计算的大小。\n上面就是LruCache的基本内容，下面就需要提供LruCache的核心功能了。\n\n###### 3.4 put方法缓存数据   \n\n首先看一下它的源码实现：    \n\n```java\n/**\n   * 给对应key缓存value，并且将该value移动到链表的尾部。\n   */\npublic final V put(K key, V value) {\n    if (key == null || value == null) {\n        throw new NullPointerException(\"key == null || value == null\");\n    }\n\n      V previous;\n      synchronized (this) {\n        // 记录 put 的次数\n        putCount++;\n        // 通过键值对，计算出要保存对象value的大小，并更新当前缓存大小\n        size += safeSizeOf(key, value);\n        /*\n         * 如果 之前存在key，用新的value覆盖原来的数据， 并返回 之前key 的value\n         * 记录在 previous\n         */\n        previous = map.put(key, value);\n        // 如果之前存在key，并且之前的value不为null\n        if (previous != null) {\n            // 计算出 之前value的大小，因为前面size已经加上了新的value数据的大小，此时，需要再次更新size，减去原来value的大小\n            size -= safeSizeOf(key, previous);\n        }\n      }\n\n    // 如果之前存在key，并且之前的value不为null\n    if (previous != null) {\n        /*\n         * previous值被剔除了，此次添加的 value 已经作为key的 新值\n         * 告诉 自定义 的 entryRemoved 方法\n         */\n        entryRemoved(false, key, previous, value);\n    }\n    //裁剪缓存容量（在当前缓存数据大小超过了总容量maxSize时，才会真正去执行LRU）\n    trimToSize(maxSize);\n      return previous;\n}\n```\n\n可以看到，put()方法主要有以下几步：   \n1）key和value判空，说明LruCache中不允许key和value为null；   \n2）通过safeSizeOf()获取要加入对象数据的大小，并更新当前缓存数据的大小；   \n3）将新的对象数据放入到缓存中，即调用LinkedHashMap的put方法，如果原来存在该key时，直接替换掉原来的value值，并返回之前的value值，得到之前value的大小，更新当前缓存数据的size大小；如果原来不存在该key，则直接加入缓存即可；   \n4）清理缓存空间\n\n###### 3.5 trimToSize()清理缓存空间    \n当我们加入一个数据时（put），为了保证当前数据的缓存所占大小没有超过我们指定的总大小，通过调用trimToSize()来对缓存空间进行管理控制。\n\n```java\npublic void trimToSize(int maxSize) {\n    /*\n     * 循环进行LRU，直到当前所占容量大小没有超过指定的总容量大小\n     */\n    while (true) {\n        K key;\n        V value;\n        synchronized (this) {\n            // 一些异常情况的处理\n            if (size < 0 || (map.isEmpty() && size != 0)) {\n                throw new IllegalStateException(\n                        getClass().getName() + \".sizeOf() is reporting inconsistent results!\");\n            }\n            // 首先判断当前缓存数据大小是否超过了指定的缓存空间总大小。如果没有超过，即缓存中还可以存入数据，直接跳出循环，清理完毕\n            if (size <= maxSize || map.isEmpty()) {\n                break;\n            }\n            /**\n             * 执行到这，表示当前缓存数据已超过了总容量，需要执行LRU，即将最近最少使用的数据清除掉，直到数据所占缓存空间没有超标;\n             * 根据前面的原理分析，知道，在链表中，链表的头结点是最近最少使用的数据，因此，最先清除掉链表前面的结点\n             */\n            Map.Entry<K, V> toEvict = map.entrySet().iterator().next();\n            key = toEvict.getKey();\n            value = toEvict.getValue();\n            map.remove(key);\n            // 移除掉后，更新当前数据缓存的大小\n            size -= safeSizeOf(key, value);\n            // 更新移除的结点数量\n            evictionCount++;\n        }\n        /*\n         * 通知某个结点被移除，类似于回调\n         */\n        entryRemoved(true, key, value, null);\n    }\n}\n```\n\ntrimToSize()方法的作用就是为了保证当前数据的缓存大小不能超过我们指定的缓存总大小，如果超过了，就会开始移除最近最少使用的数据，直到size符合要求。trimToSize()方法在put()的时候一定会调用，在get()的时候有可能会调用。\n\n\n###### 3.6 get方法获取缓存数据   \n\n```java\n/**\n * 根据key查询缓存，如果该key对应的value存在于缓存，直接返回value；\n* 访问到这个结点时，LinkHashMap会将它移动到双向循环链表的的尾部。\n* 如果如果没有缓存的值，则返回null。（如果开发者重写了create()的话，返回创建的value）\n*/\npublic final V get(K key) {\n    if (key == null) {\n        throw new NullPointerException(\"key == null\");\n    }\n\n    V mapValue;\n    synchronized (this) {\n        // LinkHashMap 如果设置按照访问顺序的话，这里每次get都会重整数据顺序\n        mapValue = map.get(key);\n        // 计算 命中次数\n        if (mapValue != null) {\n            hitCount++;\n            return mapValue;\n        }\n        // 计算 丢失次数\n        missCount++;\n    }\n\n    /*\n     * 官方解释：\n     * 尝试创建一个值，这可能需要很长时间，并且Map可能在create()返回的值时有所不同。如果在create()执行的时\n     * 候，用这个key执行了put方法，那么此时就发生了冲突，我们在Map中删除这个创建的值，释放被创建的值，保留put进去的值。\n     */\n    V createdValue = create(key);\n    if (createdValue == null) {\n        return null;\n    }\n\n    /***************************\n     * 不覆写create方法走不到下面 *\n     ***************************/\n    /*\n     * 正常情况走不到这里\n     * 走到这里的话 说明 实现了自定义的 create(K key) 逻辑\n     * 因为默认的 create(K key) 逻辑为null\n     */\n    synchronized (this) {\n        // 记录 create 的次数\n        createCount++;\n        // 将自定义create创建的值，放入LinkedHashMap中，如果key已经存在，会返回 之前相同key 的值\n        mapValue = map.put(key, createdValue);\n\n        // 如果之前存在相同key的value，即有冲突。\n        if (mapValue != null) {\n            /*\n             * 有冲突\n             * 所以 撤销 刚才的 操作\n             * 将 之前相同key 的值 重新放回去\n             */\n            map.put(key, mapValue);\n        } else {\n            // 拿到键值对，计算出在容量中的相对长度，然后加上\n            size += safeSizeOf(key, createdValue);\n        }\n    }\n\n    // 如果上面 判断出了 将要放入的值发生冲突\n    if (mapValue != null) {\n        /*\n         * 刚才create的值被删除了，原来的 之前相同key 的值被重新添加回去了\n         * 告诉 自定义 的 entryRemoved 方法\n         */\n        entryRemoved(false, key, createdValue, mapValue);\n        return mapValue;\n    } else {\n        // 上面 进行了 size += 操作 所以这里要重整长度\n        trimToSize(maxSize);\n        return createdValue;\n    }\n}\n```\n\nget()方法的思路就是：   \n   1）先尝试从map缓存中获取value，即mapVaule = map.get(key);如果mapVaule != null，说明缓存中存在该对象，直接返回即可；   \n   2）如果mapVaule == null，说明缓存中不存在该对象，大多数情况下会直接返回null；但是如果我们重写了create()方法，在缓存没有该数据的时候自己去创建一个，则会继续往下走，中间可能会出现冲突，看注释；   \n   3）注意：在我们通过LinkedHashMap进行get(key)或put(key,value)时都会对链表进行调整，即将刚刚访问get或加入put的结点放入到链表尾部。\n\n###### 3.7 entryRemoved()     \n\nentryRemoved的源码如下：\n\n```java\n/**\n * 1.当被回收或者删掉时调用。该方法当value被回收释放存储空间时被remove调用\n* 或者替换条目值时put调用，默认实现什么都没做。\n* 2.该方法没用同步调用，如果其他线程访问缓存时，该方法也会执行。\n* 3.evicted=true：如果该条目被删除空间 （表示 进行了trimToSize or remove）  evicted=false：put冲突后 或 get里成功create后\n* 导致\n* 4.newValue!=null，那么则被put()或get()调用。\n*/\nprotected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {\n}\n```\n\nentryRemoved方法是一个空方法，说明这个也是让开发者自己根据需求去重写的。entryRemoved()主要作用就是在结点数据value需要被删除或回收的时候，给开发者的回调。开发者就可以在这个方法里面实现一些自己的逻辑：   \n（1）可以进行资源的回收；     \n（2）可以实现二级内存缓存，可以进一步提高性能，    \n思路如下：重写LruCache的entryRemoved()函数，把删除掉的item，再次存入另外一个LinkedHashMap<String, SoftWeakReference<Bitmap>>中，这个数据结构当做二级缓存，每次获得图片的时候，先判断LruCache中是否缓存，没有的话，再判断这个二级缓存中是否有，如果都没有再从sdcard上获取。sdcard上也没有的话，就从网络服务器上拉取。entryRemoved()在LruCache中有四个地方进行了调用：put()、get()、trimToSize()、remove()中进行了调用。\n\n\n###### 3.8 LruCache的线程安全性 \n\nLruCache是线程安全的，因为在put、get、trimToSize、remove的方法中都加入synchronized进行同步控制。\n\n\n##### 4.LruCache代码示例\n\n使用步骤：\n- 在构造LruCache时提供一个总的缓存大小；\n- 重写sizeOf方法，对存入map的数据大小进行自定义测量；\n- 根据需要，决定是否要重写entryRemoved()方法；\n- 使用LruCache提供的put和get方法进行数据的缓存\n\n```java\nprivate LruCache<String, Bitmap> mMemoryCache;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    ...\n    // 获得虚拟机能提供的最大内存，超过这个大小会抛出OutOfMemory的异常\n    final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);\n\n    // 用１／８的内存大小作为内存缓存\n    final int cacheSize = maxMemory / 8;\n\n    mMemoryCache = new LruCache<String, Bitmap>(cacheSize) {\n        @Override\n        protected int sizeOf(String key, Bitmap bitmap) {\n            // 这里返回的不是item的个数，是cache的size（单位1024个字节）\n            return bitmap.getByteCount() / 1024;\n        }\n    };\n    ...\n}\n\npublic void addBitmapToMemoryCache(String key, Bitmap bitmap) {\n    if (getBitmapFromMemCache(key) == null) {\n        mMemoryCache.put(key, bitmap);\n    }\n}\n\npublic Bitmap getBitmapFromMemCache(String key) {\n    return mMemoryCache.get(key);\n}\n```\n\n当为ImageView加载一张图片时，会先在LruCache 中看看有没有缓存这张图片，如果有的话直接更新到ImageView中，如果没有的话，一个后台线程会被触发来加载这张图片。\n\n```java\npublic void loadBitmap(int resId, ImageView imageView) {\n    final String imageKey = String.valueOf(resId);\n\n    // 查看下内存缓存中是否缓存了这张图片\n    final Bitmap bitmap = getBitmapFromMemCache(imageKey);\n    if (bitmap != null) {\n        mImageView.setImageBitmap(bitmap);\n    } else {\n        mImageView.setImageResource(R.drawable.image_placeholder);\nBitmapWorkerTask task = new BitmapWorkerTask(mImageView);\n        task.execute(resId);\n    }\n}\n```\n\n在图片加载的Task中，需要把加载好的图片加入到内存缓存中。\n\n```java\nclass BitmapWorkerTask extends AsyncTask<Integer, Void, Bitmap> {\n    ...\n    // 在后台完成\n    @Override\n    protected Bitmap doInBackground(Integer... params) {\n        final Bitmap bitmap = decodeSampledBitmapFromResource(\n                getResources(), params[0], 100, 100));\n    addBitmapToMemoryCache(String.valueOf(params[0]), bitmap);\n        return bitmap;\n    }\n    ...\n}\n```\n##### 5.总结\n\n- LruCache 自身并没有释放内存，只是 LinkedHashMap中将数据移除了，如果数据还在别的地方被引用了，还是有泄漏问题，还需要手动释放内存；\n- 覆写 entryRemoved 方法能知道 LruCache 数据移除是是否发生了冲突（冲突是指在map.put()的时候，对应的key中是否存在原来的值），也可以去手动释放资源；\n\n\n### 三 磁盘缓存（二级缓存）\n\nLruCache是一种内存缓存策略，但是当存在大量图片的时候，我们指定的缓存内存空间可能很快就会用完，这个时候，LruCache就会频繁的进行trimToSize()操作，不断的将最近最少使用的数据移除，当再次需要该数据时，又得从网络上重新加载，这样就有可能造成OOM。为此，Google提供了一种磁盘缓存的解决方案——DiskLruCache（DiskLruCache并没有集成到Android源码中，在Android Doc的例子中有讲解）。\n\n##### 1. DiskLruCache实现原理\n\n我们可以先来直观看一下，使用了DiskLruCache缓存策略的APP，缓存目录中是什么样子，如下图：\n\n{% asset_img 文件缓存结果图.png 文件缓存结果图 %}\n\n可以看到，缓存目录中有一堆文件名很长的文件，这些文件就是我们缓存的一张张图片数据，在最后有一个文件名journal的文件，这个journal文件是DiskLruCache的一个日志文件，即保存着每张缓存图片的操作记录，journal文件正是实现DiskLruCache的核心。看到出现了journal文件，基本可以说明这个APP使用了DiskLruCache缓存策略。\n\n根据对LruCache的分析，要实现LRU，最重要的是要有一种数据结构能够基于访问顺序来保存缓存中的对象，LinkedHashMap是一种非常合适的数据结构，为此，DiskLruCache也选择了LinkedHashMap作为维护访问顺序的数据结构，但是，对于DiskLruCache来说，单单LinkedHashMap是不够的，因为我们不能像LruCache一样，直接将数据放置到LinkedHashMap的value中，也就是处于内存当中，在DiskLruCache中，数据是缓存到了本地文件，这里的LinkedHashMap中的value只是保存的是value的一些简要信息Entry，如唯一的文件名称、大小、是否可读等信息，如：\n\n```java\nprivate final class Entry {\n    private final String key;\n    /** Lengths of this entry's files. */\n    private final long[] lengths;\n    /** True if this entry has ever been published */\n    private boolean readable;\n    /** The ongoing edit or null if this entry is not being edited. */\n    private Editor currentEditor;\n    /** The sequence number of the most recently committed edit to this entry. */\n    private long sequenceNumber;\n    private Entry(String key) {\n        this.key = key;\n        this.lengths = new long[valueCount];\n    }\n    public String getLengths() throws IOException {\n        StringBuilder result = new StringBuilder();\n        for (long size : lengths) {\n            result.append(' ').append(size);\n    }\n    return result.toString();\n}\n\n    /**\n     * Set lengths using decimal numbers like \"10123\".\n     */\n    private void setLengths(String[] strings) throws IOException {\n        if (strings.length != valueCount) {\n            throw invalidLengths(strings);\n        }\n\n        try {\n            for (int i = 0; i < strings.length; i++) {\n                lengths[i] = Long.parseLong(strings[i]);\n            }\n        } catch (NumberFormatException e) {\n            throw invalidLengths(strings);\n        }\n    }\n\n    private IOException invalidLengths(String[] strings) throws IOException {\n        throw new IOException(\"unexpected journal line: \" + Arrays.toString(strings));\n    }\n\n    public File getCleanFile(int i) {\n        return new File(directory, key + \".\" + i);\n    }\n\n    public File getDirtyFile(int i) {\n        return new File(directory, key + \".\" + i + \".tmp\");\n    }\n}\n```\n\nDiskLruCache中对于LinkedHashMap定义如下：\n\n```java\nprivate final LinkedHashMap<String, Entry> lruEntries\n\t= new LinkedHashMap<String, Entry>(0, 0.75f, true);\n```\n\n在LruCache中，由于数据是直接缓存中内存中，map中数据的建立是在使用LruCache缓存的过程中逐步建立的，而对于DiskLruCache，由于数据是缓存在本地文件，相当于是持久保存下来的一个文件，即使程序退出文件还在，因此，map中数据的建立，除了在使用DiskLruCache过程中建立外，map还应该包括之前已经存在的缓存文件，因此，在获取DiskLruCache的实例时，DiskLruCache会去读取journal这个日志文件，根据这个日志文件中的信息，建立map的初始数据，同时，会根据journal这个日志文件，维护本地的缓存文件。构造DiskLruCache的方法如下：\n\n```java\npublic static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)\n    throws IOException {\n    if (maxSize <= 0) {\n        throw new IllegalArgumentException(\"maxSize <= 0\");\n    }\n    if (valueCount <= 0) {\n        throw new IllegalArgumentException(\"valueCount <= 0\");\n    }\n\n    // prefer to pick up where we left off\n    DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);\n    if (cache.journalFile.exists()) {\n    try {\n        cache.readJournal();\n        cache.processJournal();\n        cache.journalWriter = new BufferedWriter(new FileWriter(cache.journalFile, true),IO_BUFFER_SIZE);\n                return cache;\n        } catch (IOException journalIsCorrupt) {\n            //                System.logW(\"DiskLruCache \" + directory + \" is corrupt: \"\n            //                        + journalIsCorrupt.getMessage() + \", removing\");\n            cache.delete();\n        }\n   }\n\n    // create a new empty cache\n    directory.mkdirs();\n    cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);\n    cache.rebuildJournal();\n    return cache;\n}\n```\n\n其中，\ncache.readJournal();    \ncache.processJournal();\n正是去读取journal日志文件，建立起map中的初始数据，同时维护缓存文件。\n\n##### 2.journal日志文件\n\njournal日志文件到底保存了什么信息呢，一个标准的journal日志文件信息如下：\n\n```bash\n\nlibcore.io.DiskLruCache    //第一行，固定内容，声明\n1                                        //第二行，cache的版本号，恒为1\n1                                        //第三行，APP的版本号\n2                                        //第四行，一个key，可以存放多少条数据valueCount    \n                                           //第五行，空行分割行\nDIRTY 335c4c6028171cfddfbaae1a9c313c52\nCLEAN 335c4c6028171cfddfbaae1a9c313c52 3934\nREMOVE 335c4c6028171cfddfbaae1a9c313c52\nDIRTY 1ab96a171faeeee38496d8b330771a7a\nCLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234\nREAD 335c4c6028171cfddfbaae1a9c313c52\nREAD 3400330d1dfc7f3f7f4b8d4d803dfcf6\n```\n\n前五行称为journal日志文件的头，下面部分的每一行会以四种前缀之一开始：DIRTY、CLEAN、REMOVE、READ。\n\n以一个DIRTY前缀开始的，后面紧跟着缓存图片的key。以DIRTY这个这个前缀开头，意味着这是一条脏数据。每当我们调用一次DiskLruCache的edit()方法时，都会向journal文件中写入一条DIRTY记录，表示我们正准备写入一条缓存数据，但不知结果如何。然后调用commit()方法表示写入缓存成功，这时会向journal中写入一条CLEAN记录，意味着这条“脏”数据被“洗干净了”，调用abort()方法表示写入缓存失败，这时会向journal中写入一条REMOVE记录。也就是说，每一行DIRTY的key，后面都应该有一行对应的CLEAN或者REMOVE的记录，否则这条数据就是“脏”的，会被自动删除掉。\n\n在CLEAN前缀和key后面还有一个数值，代表的是该条缓存数据的大小。\n\n##### 3.DiskLruCache中的工作流程\n\n**1.**初始化：通过open()方法，获取DiskLruCache的实例，在open方法中通过readJournal(); 方法读取journal日志文件，根据journal日志文件信息建立map中的初始数据；然后再调用processJournal();方法对刚刚建立起的map数据进行分析，分析的工作，一个是计算当前有效缓存文件（即被CLEAN的）的大小，一个是清理无用缓存文件；\n\n**2.**数据缓存与获取缓存：上面的初始化工作完成后，我们就可以在程序中进行数据的缓存功能和获取缓存的功能了；缓存数据的操作是借助DiskLruCache.Editor这个类完成的，这个类也是不能new的，需要调用DiskLruCache的edit()方法来获取实例，如：public Editor edit(String key) throws IOException。在写入完成后，需要进行commit()。\n\n如下一个简单示例：\n\n```java\n    new Thread(new Runnable() {    \n        @Override    \n        public void run() {    \n            try {    \n                String imageUrl = \"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg\";    \n                String key = hashKeyForDisk(imageUrl);  //MD5对url进行加密，这个主要是为了获得统一的16位字符  \n                DiskLruCache.Editor editor = mDiskLruCache.edit(key);  //拿到Editor，往journal日志中写入DIRTY记录  \n                if (editor != null) {    \n                    OutputStream outputStream = editor.newOutputStream(0);    \n                    if (downloadUrlToStream(imageUrl, outputStream)) {  //downloadUrlToStream方法为下载图片的方法，并且将输出流放到outputStream  \n                        editor.commit();  //完成后记得commit()，成功后，再往journal日志中写入CLEAN记录  \n                    } else {    \n                        editor.abort();  //失败后，要remove缓存文件，往journal文件中写入REMOVE记录  \n                    }    \n                }    \n                mDiskLruCache.flush();  //将缓存操作同步到journal日志文件，不一定要在这里就调用  \n            } catch (IOException e) {    \n                e.printStackTrace();    \n            }    \n        }    \n    }).start();   \n```\n\n**注意**每次调用edit()时，会向journal日志文件写入DIRTY为前缀的一条记录；文件保存成功后，调用commit()时，也会向journal日志中写入一条CLEAN为前缀的一条记录，如果失败，需要调用abort()，abort()里面会向journal文件写入一条REMOVE为前缀的记录。\n\n获取缓存数据是通过get()方法实现的，如下一个简单示例：\n\n```java\ntry {    \n    String imageUrl = \"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg\";    \n    String key = hashKeyForDisk(imageUrl);  //MD5对url进行加密，这个主要是为了获得统一的16位字符  \n     //通过get拿到value的Snapshot，里面封装了输入流、key等信息，调用get会向journal文件写入READ为前缀的记录  \n    DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key);   \n    if (snapShot != null) {    \n        InputStream is = snapShot.getInputStream(0);    \n        Bitmap bitmap = BitmapFactory.decodeStream(is);    \n        mImage.setImageBitmap(bitmap);    \n    }    \n} catch (IOException e) {    \n    e.printStackTrace();    \n}\n```\n\n**3.**合适的地方进行flush()\n\n在上面进行数据缓存或获取缓存的时候，调用不同的方法会往journal中写入不同前缀的一行记录，记录写入是通过IO下的Writer写入的，要真正生效，还需要调用writer的flush()方法，而DiskLruCache中的flush()方法中封装了writer.flush()的操作，因此，我们只需要在合适地方调用DiskLruCache中的flush()方法即可。其作用也就是将操作记录同步到journal文件中，这是一个消耗效率的IO操作，我们不用每次一往journal中写数据后就调用flush，这样对效率影响较大，可以在Activity的onPause()中调用一下即可。\n\n##### 4.DiskLruCache总结\n\n- 我们可以在在UI线程中检测内存缓存，即主线程中可以直接使用LruCache；\n- 使用DiskLruCache时，由于缓存或获取都需要对本地文件进行操作，因此需要另开一个线程，在子线程中检测磁盘缓存、保存缓存数据，磁盘操作从来不应该在UI线程中实现；\n- LruCache内存缓存的核心是LinkedHashMap，而DiskLruCache的核心是LinkedHashMap和journal日志文件，相当于把journal看作是一块“内存”，LinkedHashMap的value只保存文件的简要信息，对缓存文件的所有操作都会记录在journal日志文件中。\n\n##### 5.DiskLruCache优化\n\nDiskLruCache是基于日志文件journal的，这就决定了每次对缓存文件的操作都需要进行日志文件的记录，我们可以不用journal文件，在第一次构造DiskLruCache的时候，直接从程序访问缓存目录下的缓存文件，并将每个缓存文件的访问时间作为初始值记录在map的value中，每次访问或保存缓存都更新相应key对应的缓存文件的访问时间，这样就避免了频繁的IO操作，这种情况下就需要使用单例模式对DiskLruCache进行构造了，下面要说的Acache轻量级的数据缓存类就是这种实现方式。\n\n### 四 一个轻量级缓存框架——ACache\n\nACache是一个轻量级的开源cache框架，实际上就是一个叫ACache的java类。已经在商业项目中使用，运行效果不错。\n\nACache类似于SharedPreferences，但是比SharedPreferences功能更加强大，SharedPreferences只能保存一些基本数据类型、Serializable、Bundle等数据。而Acache可以缓存如下数据：普通的字符串、JsonObject、JsonArray、Bitmap、Drawable、序列化的java对象，和 byte数据。\n\n主要特色：\n\n- 轻，轻到只有一个JAVA文件。\n- 可配置，可以配置缓存路径，缓存大小，缓存数量等。\n- 可以设置缓存超时时间，缓存超时自动失效，并被删除。\n- 支持多进程\n\n应用场景：\n\n- 替换SharePreference当做配置文件\n- 可以缓存网络请求数据，比如oschina的android客户端可以缓存http请求的新闻内容，缓存时间假设为1个小时，超时后自动失效，让客户端重新请求新的数据，减少客户端流量，同时减少服务器并发量。\n\n代码示例：\n\n```java\npublic class NewsListActivity extends Activity {\n  private List<News> list;\n  private ListView listView;\n  private LoadImageAdapter adapter;//适配器\n  private ACache acache;//缓存框架\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    // TODO Auto-generated method stub\n    super.onCreate(savedInstanceState);\n    super.setContentView(R.layout.load_img_listview_activity);\n    acache=ACache.get(this);//创建ACache组件\n    initView();//初始化界面，代码不贴了\n}\n\npublic void loadData(){\n   String cacheData=acache.getAsString(\"newsList\");//从缓存中取数据\n   if(cacheData!=null){//如果缓存中有，就不访问网络\n   List<News> newsList=gson.fromJson(cacheData, new TypeToken<List<News>>(){}.getType());//将json转为List\n      list.addAll(newsList);\n      adapter.notifyDataSetChanged();\n      return;\n   }\n   new Thread(new Runnable() {\n     @Override\n     public void run() {\n       // TODO Auto-generated method stub\n       SystemClock.sleep(2000);//模拟网络耗时\n       String json=request();//模拟从网络中获取json数据\n       acache.put(\"newslist\", json, 60*60*1);//将数据存入缓存中，有效时间设置为1小时\n       List<News> newsList=gson.fromJson(json, new TypeToken<List<News>>(){}.getType());\n       list.addAll(newsList);\n       handler.sendEmptyMessage(1);\n    }\n         \n  }).start();\n}\n    /**\n     * 模拟网络请求方法\n     * @return json数据\n     */\nprivate String request(){\n   News news=null;\n   for(int i=0;i<10;i++){\n       news=new News();\n       news.setId(i);\n       news.setImgUrl(\"course/img/face_\"+i+\".png\");\n       news.setTitle(\"新闻标题\"+i);\n       news.setSummary(\"测试\"+i);\n       list.add(news);\n   }\n   Gson gson=new Gson();\n   return gson.toJson(list);    \n}\n\nprivate Handler handler=new Handler()\n   @Override\n   public void handleMessage(Message msg) {\n       // TODO Auto-generated method stub\n       switch(msg.what){\n           case 1:\n             notify_layout.setVisibility(View.GONE);\n             adapter.notifyDataSetChanged();\n           break;\n       }\n   }\n}\n```\n\n\n  \n\n\n","source":"_posts/android基础之缓存.md","raw":"---\ntitle: android基础之缓存\ndate: 2017-02-28 17:10:22\ncategories: android\ntags:\n- android\n- java\n- 缓存\n---\n\n### 一 概述\n\n移动开发本质上就是手机和服务器之间进行通信，需要从服务端获取数据。反复通过网络获取数据是比较耗时的，特别是访问比较多的时候，会极大影响了性能，Android中可通过缓存机制来减少频繁的网络操作，减少流量、提升性能。android中缓存分为一级缓存，二级缓存和图片的三级缓存(就是网络)。\n\nAndroid缓存分为内存缓存（一级缓存）和文件缓存（二级缓存）。在早期，各大图片缓存框架流行之前，常用的内存缓存方式是软引用（SoftReference）和弱引用（WeakReference），如大部分的使用方式：HashMap<String url, SoftReference<Drawable>> imageCache;这种形式。从Android 2.3（Level 9）开始，垃圾回收器更倾向于回收SoftReference或WeakReference对象，这使得SoftReference和WeakReference变得不是那么实用有效。同时，到了Android 3.0（Level 11）之后，图片数据Bitmap被放置到了内存的堆区域，而堆区域的内存是由GC管理的，开发者也就不需要进行图片资源的释放工作，但这也使得图片数据的释放无法预知，增加了造成OOM的可能。因此，在Android3.1以后，Android推出了LruCache这个内存缓存类和DiskLruCache这个磁盘缓存类。\n\n当Android端需要获得数据时比如获取网络中的图片，我们首先从内存中查找（按键查找），内存中没有的再从磁盘文件或sqlite中去查找，若磁盘中也没有才通过网络获取（图片的3级缓存策略）；当获得来自网络的数据，就以key-value对的方式先缓存到内存（一级缓存），同时缓存到文件或sqlite中（二级缓存）。注意：内存缓存会造成堆内存泄露，所有一级缓存通常要严格控制缓存的大小，一般控制在系统内存的1/4。\n\n### 二 内存缓存（一级缓存）\n\nandroid中使用LruCache做内存缓存。在介绍这个类之前先了解一下LRU算法。\n\n##### 1.LRU算法\nLRU，全称Least Rencetly Used，即最近最少使用，是一种非常常用的置换算法，也即淘汰最长时间未使用的对象。LRU在操作系统中的页面置换算法中广泛使用，我们的内存或缓存空间是有限的，当新加入一个对象时，造成我们的缓存空间不足了，此时就需要根据某种算法对缓存中原有数据进行淘汰货删除，而LRU选择的是将最长时间未使用的对象进行淘汰。\n\n##### 2.LruCache实现原理\n\n根据LRU算法的思想，要实现LRU最核心的是要有一种数据结构能够基于访问顺序来保存缓存中的对象，这样我们就能够很方便的知道哪个对象是最近访问的，哪个对象是最长时间未访问的。LruCache选择的是LinkedHashMap这个数据结构，LinkedHashMap是一个双向循环链表，在构造LinkedHashMap时，通过一个boolean值来指定LinkedHashMap中保存数据的方式，LinkedHashMap的一个构造方法如下：\n\n```java\n    /* \n         * 初始化LinkedHashMap \n         * 第一个参数：initialCapacity，初始大小 \n         * 第二个参数：loadFactor，负载因子=0.75f \n         * 第三个参数：accessOrder=true，基于访问顺序；accessOrder=false，基于插入顺序 \n         */  \n        public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) {  \n            super(initialCapacity, loadFactor);  \n            init();  \n            this.accessOrder = accessOrder;  \n        }  \n```\n\n显然，在LruCache中选择的是accessOrder = true；此时，当accessOrder 设置为 true时，每当我们更新（即调用put方法）或访问（即调用get方法）map中的结点时，LinkedHashMap内部都会将这个结点移动到链表的尾部，因此，在链表的尾部是最近刚刚使用的结点，在链表的头部是是最近最少使用的结点，当我们的缓存空间不足时，就应该持续把链表头部结点移除掉，直到有剩余空间放置新结点。\n可以看到，LinkedHashMap完成了LruCache中的核心功能，那LruCache中剩下要做的就是定义缓存空间总容量，当前保存数据已使用的容量，对外提供put、get方法。\n\n##### 3.LruCache源码分析\n\n在了解了LruCache的核心原理之后，就可以开始分析LruCache的源码了。\n\n###### 3.1关键字段\n\n根据上面的分析，首先要有总容量、已使用容量、linkedHashMap这几个关键字段，LruCache中提供了下面三个关键字段：\n\n```java\n    //核心数据结构  \n        private final LinkedHashMap<K, V> map;  \n        // 当前缓存数据所占的大小  \n        private int size;  \n        //缓存空间总容量  \n        private int maxSize;  \n```\n\n要注意的是size字段，因为map中可以存放各种类型的数据，这些数据的大小测量方式也是不一样的，比如Bitmap类型的数据和String类型的数据计算他们的大小方式肯定不同，因此，LruCache中在计算放入数据大小的方法sizeOf中，只是简单的返回了1，需要我们重写这个方法，自己去定义数据的测量方式。因此，我们在使用LruCache的时候，经常会看到这种方式： \n\n```java\n    private static final int CACHE_SIZE = 4 * 1024 * 1024;//4Mib  \n        LruCache<String,Bitmap> bitmapCache = new LruCache<String,Bitmap>(CACHE_SIZE){  \n            @Override  \n            protected int sizeOf(String key, Bitmap value) {  \n                return value.getByteCount();//自定义Bitmap数据大小的计算方式  \n            }  \n        };  \n```\n\n###### 3.2 构造方法  \n\n```java\n\tpublic LruCache(int maxSize) {\n\t    if (maxSize <= 0) {\n\t        throw new IllegalArgumentException(\"maxSize <= 0\");\n\t    }\n\t    this.maxSize = maxSize;\n\t    this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n\t}\n```\n\nLruCache只有一个唯一的构造方法，在构造方法中，给定了缓存空间的总大小，初始化了LinkedHashMap核心数据结构，在LinkedHashMap中的第三个参数指定为true，也就设置了accessOrder=true，表示这个LinkedHashMap将是基于数据的访问顺序进行排序。\n\n\n###### 3.3 sizeOf()和safeSizeOf()方法测量数据类型大小\n\n根据上面的解释，由于各种数据类型大小测量的标准不统一，具体测量的方法应该由使用者来实现，如上面给出的一个在实现LruCache时重写sizeOf的一种常用实现方式。通过多态的性质，再具体调用sizeOf时会调用我们重写的方法进行测量，LruCache对sizeOf()的调用进行一层封装，如下： \n\n```java\n\tprivate int safeSizeOf(K key, V value) {\n\t    int result = sizeOf(key, value);\n\t    if (result < 0) {\n\t        throw new IllegalStateException(\"Negative size: \" + key + \"=\" + value);\n\t    }\n\t    return result;\n\t} \n```\n\n里面其实就是调用sizeOf()方法，返回sizeOf计算的大小。\n上面就是LruCache的基本内容，下面就需要提供LruCache的核心功能了。\n\n###### 3.4 put方法缓存数据   \n\n首先看一下它的源码实现：    \n\n```java\n/**\n   * 给对应key缓存value，并且将该value移动到链表的尾部。\n   */\npublic final V put(K key, V value) {\n    if (key == null || value == null) {\n        throw new NullPointerException(\"key == null || value == null\");\n    }\n\n      V previous;\n      synchronized (this) {\n        // 记录 put 的次数\n        putCount++;\n        // 通过键值对，计算出要保存对象value的大小，并更新当前缓存大小\n        size += safeSizeOf(key, value);\n        /*\n         * 如果 之前存在key，用新的value覆盖原来的数据， 并返回 之前key 的value\n         * 记录在 previous\n         */\n        previous = map.put(key, value);\n        // 如果之前存在key，并且之前的value不为null\n        if (previous != null) {\n            // 计算出 之前value的大小，因为前面size已经加上了新的value数据的大小，此时，需要再次更新size，减去原来value的大小\n            size -= safeSizeOf(key, previous);\n        }\n      }\n\n    // 如果之前存在key，并且之前的value不为null\n    if (previous != null) {\n        /*\n         * previous值被剔除了，此次添加的 value 已经作为key的 新值\n         * 告诉 自定义 的 entryRemoved 方法\n         */\n        entryRemoved(false, key, previous, value);\n    }\n    //裁剪缓存容量（在当前缓存数据大小超过了总容量maxSize时，才会真正去执行LRU）\n    trimToSize(maxSize);\n      return previous;\n}\n```\n\n可以看到，put()方法主要有以下几步：   \n1）key和value判空，说明LruCache中不允许key和value为null；   \n2）通过safeSizeOf()获取要加入对象数据的大小，并更新当前缓存数据的大小；   \n3）将新的对象数据放入到缓存中，即调用LinkedHashMap的put方法，如果原来存在该key时，直接替换掉原来的value值，并返回之前的value值，得到之前value的大小，更新当前缓存数据的size大小；如果原来不存在该key，则直接加入缓存即可；   \n4）清理缓存空间\n\n###### 3.5 trimToSize()清理缓存空间    \n当我们加入一个数据时（put），为了保证当前数据的缓存所占大小没有超过我们指定的总大小，通过调用trimToSize()来对缓存空间进行管理控制。\n\n```java\npublic void trimToSize(int maxSize) {\n    /*\n     * 循环进行LRU，直到当前所占容量大小没有超过指定的总容量大小\n     */\n    while (true) {\n        K key;\n        V value;\n        synchronized (this) {\n            // 一些异常情况的处理\n            if (size < 0 || (map.isEmpty() && size != 0)) {\n                throw new IllegalStateException(\n                        getClass().getName() + \".sizeOf() is reporting inconsistent results!\");\n            }\n            // 首先判断当前缓存数据大小是否超过了指定的缓存空间总大小。如果没有超过，即缓存中还可以存入数据，直接跳出循环，清理完毕\n            if (size <= maxSize || map.isEmpty()) {\n                break;\n            }\n            /**\n             * 执行到这，表示当前缓存数据已超过了总容量，需要执行LRU，即将最近最少使用的数据清除掉，直到数据所占缓存空间没有超标;\n             * 根据前面的原理分析，知道，在链表中，链表的头结点是最近最少使用的数据，因此，最先清除掉链表前面的结点\n             */\n            Map.Entry<K, V> toEvict = map.entrySet().iterator().next();\n            key = toEvict.getKey();\n            value = toEvict.getValue();\n            map.remove(key);\n            // 移除掉后，更新当前数据缓存的大小\n            size -= safeSizeOf(key, value);\n            // 更新移除的结点数量\n            evictionCount++;\n        }\n        /*\n         * 通知某个结点被移除，类似于回调\n         */\n        entryRemoved(true, key, value, null);\n    }\n}\n```\n\ntrimToSize()方法的作用就是为了保证当前数据的缓存大小不能超过我们指定的缓存总大小，如果超过了，就会开始移除最近最少使用的数据，直到size符合要求。trimToSize()方法在put()的时候一定会调用，在get()的时候有可能会调用。\n\n\n###### 3.6 get方法获取缓存数据   \n\n```java\n/**\n * 根据key查询缓存，如果该key对应的value存在于缓存，直接返回value；\n* 访问到这个结点时，LinkHashMap会将它移动到双向循环链表的的尾部。\n* 如果如果没有缓存的值，则返回null。（如果开发者重写了create()的话，返回创建的value）\n*/\npublic final V get(K key) {\n    if (key == null) {\n        throw new NullPointerException(\"key == null\");\n    }\n\n    V mapValue;\n    synchronized (this) {\n        // LinkHashMap 如果设置按照访问顺序的话，这里每次get都会重整数据顺序\n        mapValue = map.get(key);\n        // 计算 命中次数\n        if (mapValue != null) {\n            hitCount++;\n            return mapValue;\n        }\n        // 计算 丢失次数\n        missCount++;\n    }\n\n    /*\n     * 官方解释：\n     * 尝试创建一个值，这可能需要很长时间，并且Map可能在create()返回的值时有所不同。如果在create()执行的时\n     * 候，用这个key执行了put方法，那么此时就发生了冲突，我们在Map中删除这个创建的值，释放被创建的值，保留put进去的值。\n     */\n    V createdValue = create(key);\n    if (createdValue == null) {\n        return null;\n    }\n\n    /***************************\n     * 不覆写create方法走不到下面 *\n     ***************************/\n    /*\n     * 正常情况走不到这里\n     * 走到这里的话 说明 实现了自定义的 create(K key) 逻辑\n     * 因为默认的 create(K key) 逻辑为null\n     */\n    synchronized (this) {\n        // 记录 create 的次数\n        createCount++;\n        // 将自定义create创建的值，放入LinkedHashMap中，如果key已经存在，会返回 之前相同key 的值\n        mapValue = map.put(key, createdValue);\n\n        // 如果之前存在相同key的value，即有冲突。\n        if (mapValue != null) {\n            /*\n             * 有冲突\n             * 所以 撤销 刚才的 操作\n             * 将 之前相同key 的值 重新放回去\n             */\n            map.put(key, mapValue);\n        } else {\n            // 拿到键值对，计算出在容量中的相对长度，然后加上\n            size += safeSizeOf(key, createdValue);\n        }\n    }\n\n    // 如果上面 判断出了 将要放入的值发生冲突\n    if (mapValue != null) {\n        /*\n         * 刚才create的值被删除了，原来的 之前相同key 的值被重新添加回去了\n         * 告诉 自定义 的 entryRemoved 方法\n         */\n        entryRemoved(false, key, createdValue, mapValue);\n        return mapValue;\n    } else {\n        // 上面 进行了 size += 操作 所以这里要重整长度\n        trimToSize(maxSize);\n        return createdValue;\n    }\n}\n```\n\nget()方法的思路就是：   \n   1）先尝试从map缓存中获取value，即mapVaule = map.get(key);如果mapVaule != null，说明缓存中存在该对象，直接返回即可；   \n   2）如果mapVaule == null，说明缓存中不存在该对象，大多数情况下会直接返回null；但是如果我们重写了create()方法，在缓存没有该数据的时候自己去创建一个，则会继续往下走，中间可能会出现冲突，看注释；   \n   3）注意：在我们通过LinkedHashMap进行get(key)或put(key,value)时都会对链表进行调整，即将刚刚访问get或加入put的结点放入到链表尾部。\n\n###### 3.7 entryRemoved()     \n\nentryRemoved的源码如下：\n\n```java\n/**\n * 1.当被回收或者删掉时调用。该方法当value被回收释放存储空间时被remove调用\n* 或者替换条目值时put调用，默认实现什么都没做。\n* 2.该方法没用同步调用，如果其他线程访问缓存时，该方法也会执行。\n* 3.evicted=true：如果该条目被删除空间 （表示 进行了trimToSize or remove）  evicted=false：put冲突后 或 get里成功create后\n* 导致\n* 4.newValue!=null，那么则被put()或get()调用。\n*/\nprotected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {\n}\n```\n\nentryRemoved方法是一个空方法，说明这个也是让开发者自己根据需求去重写的。entryRemoved()主要作用就是在结点数据value需要被删除或回收的时候，给开发者的回调。开发者就可以在这个方法里面实现一些自己的逻辑：   \n（1）可以进行资源的回收；     \n（2）可以实现二级内存缓存，可以进一步提高性能，    \n思路如下：重写LruCache的entryRemoved()函数，把删除掉的item，再次存入另外一个LinkedHashMap<String, SoftWeakReference<Bitmap>>中，这个数据结构当做二级缓存，每次获得图片的时候，先判断LruCache中是否缓存，没有的话，再判断这个二级缓存中是否有，如果都没有再从sdcard上获取。sdcard上也没有的话，就从网络服务器上拉取。entryRemoved()在LruCache中有四个地方进行了调用：put()、get()、trimToSize()、remove()中进行了调用。\n\n\n###### 3.8 LruCache的线程安全性 \n\nLruCache是线程安全的，因为在put、get、trimToSize、remove的方法中都加入synchronized进行同步控制。\n\n\n##### 4.LruCache代码示例\n\n使用步骤：\n- 在构造LruCache时提供一个总的缓存大小；\n- 重写sizeOf方法，对存入map的数据大小进行自定义测量；\n- 根据需要，决定是否要重写entryRemoved()方法；\n- 使用LruCache提供的put和get方法进行数据的缓存\n\n```java\nprivate LruCache<String, Bitmap> mMemoryCache;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    ...\n    // 获得虚拟机能提供的最大内存，超过这个大小会抛出OutOfMemory的异常\n    final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);\n\n    // 用１／８的内存大小作为内存缓存\n    final int cacheSize = maxMemory / 8;\n\n    mMemoryCache = new LruCache<String, Bitmap>(cacheSize) {\n        @Override\n        protected int sizeOf(String key, Bitmap bitmap) {\n            // 这里返回的不是item的个数，是cache的size（单位1024个字节）\n            return bitmap.getByteCount() / 1024;\n        }\n    };\n    ...\n}\n\npublic void addBitmapToMemoryCache(String key, Bitmap bitmap) {\n    if (getBitmapFromMemCache(key) == null) {\n        mMemoryCache.put(key, bitmap);\n    }\n}\n\npublic Bitmap getBitmapFromMemCache(String key) {\n    return mMemoryCache.get(key);\n}\n```\n\n当为ImageView加载一张图片时，会先在LruCache 中看看有没有缓存这张图片，如果有的话直接更新到ImageView中，如果没有的话，一个后台线程会被触发来加载这张图片。\n\n```java\npublic void loadBitmap(int resId, ImageView imageView) {\n    final String imageKey = String.valueOf(resId);\n\n    // 查看下内存缓存中是否缓存了这张图片\n    final Bitmap bitmap = getBitmapFromMemCache(imageKey);\n    if (bitmap != null) {\n        mImageView.setImageBitmap(bitmap);\n    } else {\n        mImageView.setImageResource(R.drawable.image_placeholder);\nBitmapWorkerTask task = new BitmapWorkerTask(mImageView);\n        task.execute(resId);\n    }\n}\n```\n\n在图片加载的Task中，需要把加载好的图片加入到内存缓存中。\n\n```java\nclass BitmapWorkerTask extends AsyncTask<Integer, Void, Bitmap> {\n    ...\n    // 在后台完成\n    @Override\n    protected Bitmap doInBackground(Integer... params) {\n        final Bitmap bitmap = decodeSampledBitmapFromResource(\n                getResources(), params[0], 100, 100));\n    addBitmapToMemoryCache(String.valueOf(params[0]), bitmap);\n        return bitmap;\n    }\n    ...\n}\n```\n##### 5.总结\n\n- LruCache 自身并没有释放内存，只是 LinkedHashMap中将数据移除了，如果数据还在别的地方被引用了，还是有泄漏问题，还需要手动释放内存；\n- 覆写 entryRemoved 方法能知道 LruCache 数据移除是是否发生了冲突（冲突是指在map.put()的时候，对应的key中是否存在原来的值），也可以去手动释放资源；\n\n\n### 三 磁盘缓存（二级缓存）\n\nLruCache是一种内存缓存策略，但是当存在大量图片的时候，我们指定的缓存内存空间可能很快就会用完，这个时候，LruCache就会频繁的进行trimToSize()操作，不断的将最近最少使用的数据移除，当再次需要该数据时，又得从网络上重新加载，这样就有可能造成OOM。为此，Google提供了一种磁盘缓存的解决方案——DiskLruCache（DiskLruCache并没有集成到Android源码中，在Android Doc的例子中有讲解）。\n\n##### 1. DiskLruCache实现原理\n\n我们可以先来直观看一下，使用了DiskLruCache缓存策略的APP，缓存目录中是什么样子，如下图：\n\n{% asset_img 文件缓存结果图.png 文件缓存结果图 %}\n\n可以看到，缓存目录中有一堆文件名很长的文件，这些文件就是我们缓存的一张张图片数据，在最后有一个文件名journal的文件，这个journal文件是DiskLruCache的一个日志文件，即保存着每张缓存图片的操作记录，journal文件正是实现DiskLruCache的核心。看到出现了journal文件，基本可以说明这个APP使用了DiskLruCache缓存策略。\n\n根据对LruCache的分析，要实现LRU，最重要的是要有一种数据结构能够基于访问顺序来保存缓存中的对象，LinkedHashMap是一种非常合适的数据结构，为此，DiskLruCache也选择了LinkedHashMap作为维护访问顺序的数据结构，但是，对于DiskLruCache来说，单单LinkedHashMap是不够的，因为我们不能像LruCache一样，直接将数据放置到LinkedHashMap的value中，也就是处于内存当中，在DiskLruCache中，数据是缓存到了本地文件，这里的LinkedHashMap中的value只是保存的是value的一些简要信息Entry，如唯一的文件名称、大小、是否可读等信息，如：\n\n```java\nprivate final class Entry {\n    private final String key;\n    /** Lengths of this entry's files. */\n    private final long[] lengths;\n    /** True if this entry has ever been published */\n    private boolean readable;\n    /** The ongoing edit or null if this entry is not being edited. */\n    private Editor currentEditor;\n    /** The sequence number of the most recently committed edit to this entry. */\n    private long sequenceNumber;\n    private Entry(String key) {\n        this.key = key;\n        this.lengths = new long[valueCount];\n    }\n    public String getLengths() throws IOException {\n        StringBuilder result = new StringBuilder();\n        for (long size : lengths) {\n            result.append(' ').append(size);\n    }\n    return result.toString();\n}\n\n    /**\n     * Set lengths using decimal numbers like \"10123\".\n     */\n    private void setLengths(String[] strings) throws IOException {\n        if (strings.length != valueCount) {\n            throw invalidLengths(strings);\n        }\n\n        try {\n            for (int i = 0; i < strings.length; i++) {\n                lengths[i] = Long.parseLong(strings[i]);\n            }\n        } catch (NumberFormatException e) {\n            throw invalidLengths(strings);\n        }\n    }\n\n    private IOException invalidLengths(String[] strings) throws IOException {\n        throw new IOException(\"unexpected journal line: \" + Arrays.toString(strings));\n    }\n\n    public File getCleanFile(int i) {\n        return new File(directory, key + \".\" + i);\n    }\n\n    public File getDirtyFile(int i) {\n        return new File(directory, key + \".\" + i + \".tmp\");\n    }\n}\n```\n\nDiskLruCache中对于LinkedHashMap定义如下：\n\n```java\nprivate final LinkedHashMap<String, Entry> lruEntries\n\t= new LinkedHashMap<String, Entry>(0, 0.75f, true);\n```\n\n在LruCache中，由于数据是直接缓存中内存中，map中数据的建立是在使用LruCache缓存的过程中逐步建立的，而对于DiskLruCache，由于数据是缓存在本地文件，相当于是持久保存下来的一个文件，即使程序退出文件还在，因此，map中数据的建立，除了在使用DiskLruCache过程中建立外，map还应该包括之前已经存在的缓存文件，因此，在获取DiskLruCache的实例时，DiskLruCache会去读取journal这个日志文件，根据这个日志文件中的信息，建立map的初始数据，同时，会根据journal这个日志文件，维护本地的缓存文件。构造DiskLruCache的方法如下：\n\n```java\npublic static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)\n    throws IOException {\n    if (maxSize <= 0) {\n        throw new IllegalArgumentException(\"maxSize <= 0\");\n    }\n    if (valueCount <= 0) {\n        throw new IllegalArgumentException(\"valueCount <= 0\");\n    }\n\n    // prefer to pick up where we left off\n    DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);\n    if (cache.journalFile.exists()) {\n    try {\n        cache.readJournal();\n        cache.processJournal();\n        cache.journalWriter = new BufferedWriter(new FileWriter(cache.journalFile, true),IO_BUFFER_SIZE);\n                return cache;\n        } catch (IOException journalIsCorrupt) {\n            //                System.logW(\"DiskLruCache \" + directory + \" is corrupt: \"\n            //                        + journalIsCorrupt.getMessage() + \", removing\");\n            cache.delete();\n        }\n   }\n\n    // create a new empty cache\n    directory.mkdirs();\n    cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);\n    cache.rebuildJournal();\n    return cache;\n}\n```\n\n其中，\ncache.readJournal();    \ncache.processJournal();\n正是去读取journal日志文件，建立起map中的初始数据，同时维护缓存文件。\n\n##### 2.journal日志文件\n\njournal日志文件到底保存了什么信息呢，一个标准的journal日志文件信息如下：\n\n```bash\n\nlibcore.io.DiskLruCache    //第一行，固定内容，声明\n1                                        //第二行，cache的版本号，恒为1\n1                                        //第三行，APP的版本号\n2                                        //第四行，一个key，可以存放多少条数据valueCount    \n                                           //第五行，空行分割行\nDIRTY 335c4c6028171cfddfbaae1a9c313c52\nCLEAN 335c4c6028171cfddfbaae1a9c313c52 3934\nREMOVE 335c4c6028171cfddfbaae1a9c313c52\nDIRTY 1ab96a171faeeee38496d8b330771a7a\nCLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234\nREAD 335c4c6028171cfddfbaae1a9c313c52\nREAD 3400330d1dfc7f3f7f4b8d4d803dfcf6\n```\n\n前五行称为journal日志文件的头，下面部分的每一行会以四种前缀之一开始：DIRTY、CLEAN、REMOVE、READ。\n\n以一个DIRTY前缀开始的，后面紧跟着缓存图片的key。以DIRTY这个这个前缀开头，意味着这是一条脏数据。每当我们调用一次DiskLruCache的edit()方法时，都会向journal文件中写入一条DIRTY记录，表示我们正准备写入一条缓存数据，但不知结果如何。然后调用commit()方法表示写入缓存成功，这时会向journal中写入一条CLEAN记录，意味着这条“脏”数据被“洗干净了”，调用abort()方法表示写入缓存失败，这时会向journal中写入一条REMOVE记录。也就是说，每一行DIRTY的key，后面都应该有一行对应的CLEAN或者REMOVE的记录，否则这条数据就是“脏”的，会被自动删除掉。\n\n在CLEAN前缀和key后面还有一个数值，代表的是该条缓存数据的大小。\n\n##### 3.DiskLruCache中的工作流程\n\n**1.**初始化：通过open()方法，获取DiskLruCache的实例，在open方法中通过readJournal(); 方法读取journal日志文件，根据journal日志文件信息建立map中的初始数据；然后再调用processJournal();方法对刚刚建立起的map数据进行分析，分析的工作，一个是计算当前有效缓存文件（即被CLEAN的）的大小，一个是清理无用缓存文件；\n\n**2.**数据缓存与获取缓存：上面的初始化工作完成后，我们就可以在程序中进行数据的缓存功能和获取缓存的功能了；缓存数据的操作是借助DiskLruCache.Editor这个类完成的，这个类也是不能new的，需要调用DiskLruCache的edit()方法来获取实例，如：public Editor edit(String key) throws IOException。在写入完成后，需要进行commit()。\n\n如下一个简单示例：\n\n```java\n    new Thread(new Runnable() {    \n        @Override    \n        public void run() {    \n            try {    \n                String imageUrl = \"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg\";    \n                String key = hashKeyForDisk(imageUrl);  //MD5对url进行加密，这个主要是为了获得统一的16位字符  \n                DiskLruCache.Editor editor = mDiskLruCache.edit(key);  //拿到Editor，往journal日志中写入DIRTY记录  \n                if (editor != null) {    \n                    OutputStream outputStream = editor.newOutputStream(0);    \n                    if (downloadUrlToStream(imageUrl, outputStream)) {  //downloadUrlToStream方法为下载图片的方法，并且将输出流放到outputStream  \n                        editor.commit();  //完成后记得commit()，成功后，再往journal日志中写入CLEAN记录  \n                    } else {    \n                        editor.abort();  //失败后，要remove缓存文件，往journal文件中写入REMOVE记录  \n                    }    \n                }    \n                mDiskLruCache.flush();  //将缓存操作同步到journal日志文件，不一定要在这里就调用  \n            } catch (IOException e) {    \n                e.printStackTrace();    \n            }    \n        }    \n    }).start();   \n```\n\n**注意**每次调用edit()时，会向journal日志文件写入DIRTY为前缀的一条记录；文件保存成功后，调用commit()时，也会向journal日志中写入一条CLEAN为前缀的一条记录，如果失败，需要调用abort()，abort()里面会向journal文件写入一条REMOVE为前缀的记录。\n\n获取缓存数据是通过get()方法实现的，如下一个简单示例：\n\n```java\ntry {    \n    String imageUrl = \"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg\";    \n    String key = hashKeyForDisk(imageUrl);  //MD5对url进行加密，这个主要是为了获得统一的16位字符  \n     //通过get拿到value的Snapshot，里面封装了输入流、key等信息，调用get会向journal文件写入READ为前缀的记录  \n    DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key);   \n    if (snapShot != null) {    \n        InputStream is = snapShot.getInputStream(0);    \n        Bitmap bitmap = BitmapFactory.decodeStream(is);    \n        mImage.setImageBitmap(bitmap);    \n    }    \n} catch (IOException e) {    \n    e.printStackTrace();    \n}\n```\n\n**3.**合适的地方进行flush()\n\n在上面进行数据缓存或获取缓存的时候，调用不同的方法会往journal中写入不同前缀的一行记录，记录写入是通过IO下的Writer写入的，要真正生效，还需要调用writer的flush()方法，而DiskLruCache中的flush()方法中封装了writer.flush()的操作，因此，我们只需要在合适地方调用DiskLruCache中的flush()方法即可。其作用也就是将操作记录同步到journal文件中，这是一个消耗效率的IO操作，我们不用每次一往journal中写数据后就调用flush，这样对效率影响较大，可以在Activity的onPause()中调用一下即可。\n\n##### 4.DiskLruCache总结\n\n- 我们可以在在UI线程中检测内存缓存，即主线程中可以直接使用LruCache；\n- 使用DiskLruCache时，由于缓存或获取都需要对本地文件进行操作，因此需要另开一个线程，在子线程中检测磁盘缓存、保存缓存数据，磁盘操作从来不应该在UI线程中实现；\n- LruCache内存缓存的核心是LinkedHashMap，而DiskLruCache的核心是LinkedHashMap和journal日志文件，相当于把journal看作是一块“内存”，LinkedHashMap的value只保存文件的简要信息，对缓存文件的所有操作都会记录在journal日志文件中。\n\n##### 5.DiskLruCache优化\n\nDiskLruCache是基于日志文件journal的，这就决定了每次对缓存文件的操作都需要进行日志文件的记录，我们可以不用journal文件，在第一次构造DiskLruCache的时候，直接从程序访问缓存目录下的缓存文件，并将每个缓存文件的访问时间作为初始值记录在map的value中，每次访问或保存缓存都更新相应key对应的缓存文件的访问时间，这样就避免了频繁的IO操作，这种情况下就需要使用单例模式对DiskLruCache进行构造了，下面要说的Acache轻量级的数据缓存类就是这种实现方式。\n\n### 四 一个轻量级缓存框架——ACache\n\nACache是一个轻量级的开源cache框架，实际上就是一个叫ACache的java类。已经在商业项目中使用，运行效果不错。\n\nACache类似于SharedPreferences，但是比SharedPreferences功能更加强大，SharedPreferences只能保存一些基本数据类型、Serializable、Bundle等数据。而Acache可以缓存如下数据：普通的字符串、JsonObject、JsonArray、Bitmap、Drawable、序列化的java对象，和 byte数据。\n\n主要特色：\n\n- 轻，轻到只有一个JAVA文件。\n- 可配置，可以配置缓存路径，缓存大小，缓存数量等。\n- 可以设置缓存超时时间，缓存超时自动失效，并被删除。\n- 支持多进程\n\n应用场景：\n\n- 替换SharePreference当做配置文件\n- 可以缓存网络请求数据，比如oschina的android客户端可以缓存http请求的新闻内容，缓存时间假设为1个小时，超时后自动失效，让客户端重新请求新的数据，减少客户端流量，同时减少服务器并发量。\n\n代码示例：\n\n```java\npublic class NewsListActivity extends Activity {\n  private List<News> list;\n  private ListView listView;\n  private LoadImageAdapter adapter;//适配器\n  private ACache acache;//缓存框架\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    // TODO Auto-generated method stub\n    super.onCreate(savedInstanceState);\n    super.setContentView(R.layout.load_img_listview_activity);\n    acache=ACache.get(this);//创建ACache组件\n    initView();//初始化界面，代码不贴了\n}\n\npublic void loadData(){\n   String cacheData=acache.getAsString(\"newsList\");//从缓存中取数据\n   if(cacheData!=null){//如果缓存中有，就不访问网络\n   List<News> newsList=gson.fromJson(cacheData, new TypeToken<List<News>>(){}.getType());//将json转为List\n      list.addAll(newsList);\n      adapter.notifyDataSetChanged();\n      return;\n   }\n   new Thread(new Runnable() {\n     @Override\n     public void run() {\n       // TODO Auto-generated method stub\n       SystemClock.sleep(2000);//模拟网络耗时\n       String json=request();//模拟从网络中获取json数据\n       acache.put(\"newslist\", json, 60*60*1);//将数据存入缓存中，有效时间设置为1小时\n       List<News> newsList=gson.fromJson(json, new TypeToken<List<News>>(){}.getType());\n       list.addAll(newsList);\n       handler.sendEmptyMessage(1);\n    }\n         \n  }).start();\n}\n    /**\n     * 模拟网络请求方法\n     * @return json数据\n     */\nprivate String request(){\n   News news=null;\n   for(int i=0;i<10;i++){\n       news=new News();\n       news.setId(i);\n       news.setImgUrl(\"course/img/face_\"+i+\".png\");\n       news.setTitle(\"新闻标题\"+i);\n       news.setSummary(\"测试\"+i);\n       list.add(news);\n   }\n   Gson gson=new Gson();\n   return gson.toJson(list);    \n}\n\nprivate Handler handler=new Handler()\n   @Override\n   public void handleMessage(Message msg) {\n       // TODO Auto-generated method stub\n       switch(msg.what){\n           case 1:\n             notify_layout.setVisibility(View.GONE);\n             adapter.notifyDataSetChanged();\n           break;\n       }\n   }\n}\n```\n\n\n  \n\n\n","slug":"android基础之缓存","published":1,"updated":"2017-03-10T01:56:13.064Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk27001paknzo6261zqn","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>移动开发本质上就是手机和服务器之间进行通信，需要从服务端获取数据。反复通过网络获取数据是比较耗时的，特别是访问比较多的时候，会极大影响了性能，Android中可通过缓存机制来减少频繁的网络操作，减少流量、提升性能。android中缓存分为一级缓存，二级缓存和图片的三级缓存(就是网络)。</p>\n<p>Android缓存分为内存缓存（一级缓存）和文件缓存（二级缓存）。在早期，各大图片缓存框架流行之前，常用的内存缓存方式是软引用（SoftReference）和弱引用（WeakReference），如大部分的使用方式：HashMap<string url,=\"\" softreference<drawable=\"\">&gt; imageCache;这种形式。从Android 2.3（Level 9）开始，垃圾回收器更倾向于回收SoftReference或WeakReference对象，这使得SoftReference和WeakReference变得不是那么实用有效。同时，到了Android 3.0（Level 11）之后，图片数据Bitmap被放置到了内存的堆区域，而堆区域的内存是由GC管理的，开发者也就不需要进行图片资源的释放工作，但这也使得图片数据的释放无法预知，增加了造成OOM的可能。因此，在Android3.1以后，Android推出了LruCache这个内存缓存类和DiskLruCache这个磁盘缓存类。</string></p>\n<p>当Android端需要获得数据时比如获取网络中的图片，我们首先从内存中查找（按键查找），内存中没有的再从磁盘文件或sqlite中去查找，若磁盘中也没有才通过网络获取（图片的3级缓存策略）；当获得来自网络的数据，就以key-value对的方式先缓存到内存（一级缓存），同时缓存到文件或sqlite中（二级缓存）。注意：内存缓存会造成堆内存泄露，所有一级缓存通常要严格控制缓存的大小，一般控制在系统内存的1/4。</p>\n<h3 id=\"二-内存缓存（一级缓存）\"><a href=\"#二-内存缓存（一级缓存）\" class=\"headerlink\" title=\"二 内存缓存（一级缓存）\"></a>二 内存缓存（一级缓存）</h3><p>android中使用LruCache做内存缓存。在介绍这个类之前先了解一下LRU算法。</p>\n<h5 id=\"1-LRU算法\"><a href=\"#1-LRU算法\" class=\"headerlink\" title=\"1.LRU算法\"></a>1.LRU算法</h5><p>LRU，全称Least Rencetly Used，即最近最少使用，是一种非常常用的置换算法，也即淘汰最长时间未使用的对象。LRU在操作系统中的页面置换算法中广泛使用，我们的内存或缓存空间是有限的，当新加入一个对象时，造成我们的缓存空间不足了，此时就需要根据某种算法对缓存中原有数据进行淘汰货删除，而LRU选择的是将最长时间未使用的对象进行淘汰。</p>\n<h5 id=\"2-LruCache实现原理\"><a href=\"#2-LruCache实现原理\" class=\"headerlink\" title=\"2.LruCache实现原理\"></a>2.LruCache实现原理</h5><p>根据LRU算法的思想，要实现LRU最核心的是要有一种数据结构能够基于访问顺序来保存缓存中的对象，这样我们就能够很方便的知道哪个对象是最近访问的，哪个对象是最长时间未访问的。LruCache选择的是LinkedHashMap这个数据结构，LinkedHashMap是一个双向循环链表，在构造LinkedHashMap时，通过一个boolean值来指定LinkedHashMap中保存数据的方式，LinkedHashMap的一个构造方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* </span></div><div class=\"line\">     * 初始化LinkedHashMap </div><div class=\"line\">     * 第一个参数：initialCapacity，初始大小 </div><div class=\"line\">     * 第二个参数：loadFactor，负载因子=0.75f </div><div class=\"line\">     * 第三个参数：accessOrder=true，基于访问顺序；accessOrder=false，基于插入顺序 </div><div class=\"line\">     */  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">boolean</span> accessOrder)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">super</span>(initialCapacity, loadFactor);  </div><div class=\"line\">        init();  </div><div class=\"line\">        <span class=\"keyword\">this</span>.accessOrder = accessOrder;  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>显然，在LruCache中选择的是accessOrder = true；此时，当accessOrder 设置为 true时，每当我们更新（即调用put方法）或访问（即调用get方法）map中的结点时，LinkedHashMap内部都会将这个结点移动到链表的尾部，因此，在链表的尾部是最近刚刚使用的结点，在链表的头部是是最近最少使用的结点，当我们的缓存空间不足时，就应该持续把链表头部结点移除掉，直到有剩余空间放置新结点。<br>可以看到，LinkedHashMap完成了LruCache中的核心功能，那LruCache中剩下要做的就是定义缓存空间总容量，当前保存数据已使用的容量，对外提供put、get方法。</p>\n<h5 id=\"3-LruCache源码分析\"><a href=\"#3-LruCache源码分析\" class=\"headerlink\" title=\"3.LruCache源码分析\"></a>3.LruCache源码分析</h5><p>在了解了LruCache的核心原理之后，就可以开始分析LruCache的源码了。</p>\n<h6 id=\"3-1关键字段\"><a href=\"#3-1关键字段\" class=\"headerlink\" title=\"3.1关键字段\"></a>3.1关键字段</h6><p>根据上面的分析，首先要有总容量、已使用容量、linkedHashMap这几个关键字段，LruCache中提供了下面三个关键字段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//核心数据结构  </span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LinkedHashMap&lt;K, V&gt; map;  </div><div class=\"line\">    <span class=\"comment\">// 当前缓存数据所占的大小  </span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;  </div><div class=\"line\">    <span class=\"comment\">//缓存空间总容量  </span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxSize;</div></pre></td></tr></table></figure>\n<p>要注意的是size字段，因为map中可以存放各种类型的数据，这些数据的大小测量方式也是不一样的，比如Bitmap类型的数据和String类型的数据计算他们的大小方式肯定不同，因此，LruCache中在计算放入数据大小的方法sizeOf中，只是简单的返回了1，需要我们重写这个方法，自己去定义数据的测量方式。因此，我们在使用LruCache的时候，经常会看到这种方式： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CACHE_SIZE = <span class=\"number\">4</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;<span class=\"comment\">//4Mib  </span></div><div class=\"line\">    LruCache&lt;String,Bitmap&gt; bitmapCache = <span class=\"keyword\">new</span> LruCache&lt;String,Bitmap&gt;(CACHE_SIZE)&#123;  </div><div class=\"line\">        <span class=\"meta\">@Override</span>  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(String key, Bitmap value)</span> </span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">return</span> value.getByteCount();<span class=\"comment\">//自定义Bitmap数据大小的计算方式  </span></div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<h6 id=\"3-2-构造方法\"><a href=\"#3-2-构造方法\" class=\"headerlink\" title=\"3.2 构造方法\"></a>3.2 构造方法</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LruCache</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (maxSize &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"maxSize &lt;= 0\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.maxSize = maxSize;</div><div class=\"line\">    <span class=\"keyword\">this</span>.map = <span class=\"keyword\">new</span> LinkedHashMap&lt;K, V&gt;(<span class=\"number\">0</span>, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>LruCache只有一个唯一的构造方法，在构造方法中，给定了缓存空间的总大小，初始化了LinkedHashMap核心数据结构，在LinkedHashMap中的第三个参数指定为true，也就设置了accessOrder=true，表示这个LinkedHashMap将是基于数据的访问顺序进行排序。</p>\n<h6 id=\"3-3-sizeOf-和safeSizeOf-方法测量数据类型大小\"><a href=\"#3-3-sizeOf-和safeSizeOf-方法测量数据类型大小\" class=\"headerlink\" title=\"3.3 sizeOf()和safeSizeOf()方法测量数据类型大小\"></a>3.3 sizeOf()和safeSizeOf()方法测量数据类型大小</h6><p>根据上面的解释，由于各种数据类型大小测量的标准不统一，具体测量的方法应该由使用者来实现，如上面给出的一个在实现LruCache时重写sizeOf的一种常用实现方式。通过多态的性质，再具体调用sizeOf时会调用我们重写的方法进行测量，LruCache对sizeOf()的调用进行一层封装，如下： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">safeSizeOf</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> result = sizeOf(key, value);</div><div class=\"line\">    <span class=\"keyword\">if</span> (result &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Negative size: \"</span> + key + <span class=\"string\">\"=\"</span> + value);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>里面其实就是调用sizeOf()方法，返回sizeOf计算的大小。<br>上面就是LruCache的基本内容，下面就需要提供LruCache的核心功能了。</p>\n<h6 id=\"3-4-put方法缓存数据\"><a href=\"#3-4-put方法缓存数据\" class=\"headerlink\" title=\"3.4 put方法缓存数据\"></a>3.4 put方法缓存数据</h6><p>首先看一下它的源码实现：    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">   * 给对应key缓存value，并且将该value移动到链表的尾部。</div><div class=\"line\">   */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null || value == null\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">      V previous;</div><div class=\"line\">      <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// 记录 put 的次数</span></div><div class=\"line\">        putCount++;</div><div class=\"line\">        <span class=\"comment\">// 通过键值对，计算出要保存对象value的大小，并更新当前缓存大小</span></div><div class=\"line\">        size += safeSizeOf(key, value);</div><div class=\"line\">        <span class=\"comment\">/*</span></div><div class=\"line\">         * 如果 之前存在key，用新的value覆盖原来的数据， 并返回 之前key 的value</div><div class=\"line\">         * 记录在 previous</div><div class=\"line\">         */</div><div class=\"line\">        previous = map.put(key, value);</div><div class=\"line\">        <span class=\"comment\">// 如果之前存在key，并且之前的value不为null</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// 计算出 之前value的大小，因为前面size已经加上了新的value数据的大小，此时，需要再次更新size，减去原来value的大小</span></div><div class=\"line\">            size -= safeSizeOf(key, previous);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 如果之前存在key，并且之前的value不为null</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">/*</span></div><div class=\"line\">         * previous值被剔除了，此次添加的 value 已经作为key的 新值</div><div class=\"line\">         * 告诉 自定义 的 entryRemoved 方法</div><div class=\"line\">         */</div><div class=\"line\">        entryRemoved(<span class=\"keyword\">false</span>, key, previous, value);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//裁剪缓存容量（在当前缓存数据大小超过了总容量maxSize时，才会真正去执行LRU）</span></div><div class=\"line\">    trimToSize(maxSize);</div><div class=\"line\">      <span class=\"keyword\">return</span> previous;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，put()方法主要有以下几步：<br>1）key和value判空，说明LruCache中不允许key和value为null；<br>2）通过safeSizeOf()获取要加入对象数据的大小，并更新当前缓存数据的大小；<br>3）将新的对象数据放入到缓存中，即调用LinkedHashMap的put方法，如果原来存在该key时，直接替换掉原来的value值，并返回之前的value值，得到之前value的大小，更新当前缓存数据的size大小；如果原来不存在该key，则直接加入缓存即可；<br>4）清理缓存空间</p>\n<h6 id=\"3-5-trimToSize-清理缓存空间\"><a href=\"#3-5-trimToSize-清理缓存空间\" class=\"headerlink\" title=\"3.5 trimToSize()清理缓存空间\"></a>3.5 trimToSize()清理缓存空间</h6><p>当我们加入一个数据时（put），为了保证当前数据的缓存所占大小没有超过我们指定的总大小，通过调用trimToSize()来对缓存空间进行管理控制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     * 循环进行LRU，直到当前所占容量大小没有超过指定的总容量大小</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">        K key;</div><div class=\"line\">        V value;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// 一些异常情况的处理</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">0</span> || (map.isEmpty() &amp;&amp; size != <span class=\"number\">0</span>)) &#123;</div><div class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</div><div class=\"line\">                        getClass().getName() + <span class=\"string\">\".sizeOf() is reporting inconsistent results!\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">// 首先判断当前缓存数据大小是否超过了指定的缓存空间总大小。如果没有超过，即缓存中还可以存入数据，直接跳出循环，清理完毕</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">/**</span></div><div class=\"line\">             * 执行到这，表示当前缓存数据已超过了总容量，需要执行LRU，即将最近最少使用的数据清除掉，直到数据所占缓存空间没有超标;</div><div class=\"line\">             * 根据前面的原理分析，知道，在链表中，链表的头结点是最近最少使用的数据，因此，最先清除掉链表前面的结点</div><div class=\"line\">             */</div><div class=\"line\">            Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</div><div class=\"line\">            key = toEvict.getKey();</div><div class=\"line\">            value = toEvict.getValue();</div><div class=\"line\">            map.remove(key);</div><div class=\"line\">            <span class=\"comment\">// 移除掉后，更新当前数据缓存的大小</span></div><div class=\"line\">            size -= safeSizeOf(key, value);</div><div class=\"line\">            <span class=\"comment\">// 更新移除的结点数量</span></div><div class=\"line\">            evictionCount++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">/*</span></div><div class=\"line\">         * 通知某个结点被移除，类似于回调</div><div class=\"line\">         */</div><div class=\"line\">        entryRemoved(<span class=\"keyword\">true</span>, key, value, <span class=\"keyword\">null</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>trimToSize()方法的作用就是为了保证当前数据的缓存大小不能超过我们指定的缓存总大小，如果超过了，就会开始移除最近最少使用的数据，直到size符合要求。trimToSize()方法在put()的时候一定会调用，在get()的时候有可能会调用。</p>\n<h6 id=\"3-6-get方法获取缓存数据\"><a href=\"#3-6-get方法获取缓存数据\" class=\"headerlink\" title=\"3.6 get方法获取缓存数据\"></a>3.6 get方法获取缓存数据</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 根据key查询缓存，如果该key对应的value存在于缓存，直接返回value；</div><div class=\"line\">* 访问到这个结点时，LinkHashMap会将它移动到双向循环链表的的尾部。</div><div class=\"line\">* 如果如果没有缓存的值，则返回null。（如果开发者重写了create()的话，返回创建的value）</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">get</span><span class=\"params\">(K key)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    V mapValue;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// LinkHashMap 如果设置按照访问顺序的话，这里每次get都会重整数据顺序</span></div><div class=\"line\">        mapValue = map.get(key);</div><div class=\"line\">        <span class=\"comment\">// 计算 命中次数</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            hitCount++;</div><div class=\"line\">            <span class=\"keyword\">return</span> mapValue;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 计算 丢失次数</span></div><div class=\"line\">        missCount++;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     * 官方解释：</div><div class=\"line\">     * 尝试创建一个值，这可能需要很长时间，并且Map可能在create()返回的值时有所不同。如果在create()执行的时</div><div class=\"line\">     * 候，用这个key执行了put方法，那么此时就发生了冲突，我们在Map中删除这个创建的值，释放被创建的值，保留put进去的值。</div><div class=\"line\">     */</div><div class=\"line\">    V createdValue = create(key);</div><div class=\"line\">    <span class=\"keyword\">if</span> (createdValue == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/***************************</span></div><div class=\"line\">     * 不覆写create方法走不到下面 *</div><div class=\"line\">     ***************************/</div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     * 正常情况走不到这里</div><div class=\"line\">     * 走到这里的话 说明 实现了自定义的 create(K key) 逻辑</div><div class=\"line\">     * 因为默认的 create(K key) 逻辑为null</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// 记录 create 的次数</span></div><div class=\"line\">        createCount++;</div><div class=\"line\">        <span class=\"comment\">// 将自定义create创建的值，放入LinkedHashMap中，如果key已经存在，会返回 之前相同key 的值</span></div><div class=\"line\">        mapValue = map.put(key, createdValue);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 如果之前存在相同key的value，即有冲突。</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">/*</span></div><div class=\"line\">             * 有冲突</div><div class=\"line\">             * 所以 撤销 刚才的 操作</div><div class=\"line\">             * 将 之前相同key 的值 重新放回去</div><div class=\"line\">             */</div><div class=\"line\">            map.put(key, mapValue);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// 拿到键值对，计算出在容量中的相对长度，然后加上</span></div><div class=\"line\">            size += safeSizeOf(key, createdValue);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 如果上面 判断出了 将要放入的值发生冲突</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">/*</span></div><div class=\"line\">         * 刚才create的值被删除了，原来的 之前相同key 的值被重新添加回去了</div><div class=\"line\">         * 告诉 自定义 的 entryRemoved 方法</div><div class=\"line\">         */</div><div class=\"line\">        entryRemoved(<span class=\"keyword\">false</span>, key, createdValue, mapValue);</div><div class=\"line\">        <span class=\"keyword\">return</span> mapValue;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// 上面 进行了 size += 操作 所以这里要重整长度</span></div><div class=\"line\">        trimToSize(maxSize);</div><div class=\"line\">        <span class=\"keyword\">return</span> createdValue;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>get()方法的思路就是：<br>   1）先尝试从map缓存中获取value，即mapVaule = map.get(key);如果mapVaule != null，说明缓存中存在该对象，直接返回即可；<br>   2）如果mapVaule == null，说明缓存中不存在该对象，大多数情况下会直接返回null；但是如果我们重写了create()方法，在缓存没有该数据的时候自己去创建一个，则会继续往下走，中间可能会出现冲突，看注释；<br>   3）注意：在我们通过LinkedHashMap进行get(key)或put(key,value)时都会对链表进行调整，即将刚刚访问get或加入put的结点放入到链表尾部。</p>\n<h6 id=\"3-7-entryRemoved\"><a href=\"#3-7-entryRemoved\" class=\"headerlink\" title=\"3.7 entryRemoved()\"></a>3.7 entryRemoved()</h6><p>entryRemoved的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 1.当被回收或者删掉时调用。该方法当value被回收释放存储空间时被remove调用</div><div class=\"line\">* 或者替换条目值时put调用，默认实现什么都没做。</div><div class=\"line\">* 2.该方法没用同步调用，如果其他线程访问缓存时，该方法也会执行。</div><div class=\"line\">* 3.evicted=true：如果该条目被删除空间 （表示 进行了trimToSize or remove）  evicted=false：put冲突后 或 get里成功create后</div><div class=\"line\">* 导致</div><div class=\"line\">* 4.newValue!=null，那么则被put()或get()调用。</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">entryRemoved</span><span class=\"params\">(<span class=\"keyword\">boolean</span> evicted, K key, V oldValue, V newValue)</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>entryRemoved方法是一个空方法，说明这个也是让开发者自己根据需求去重写的。entryRemoved()主要作用就是在结点数据value需要被删除或回收的时候，给开发者的回调。开发者就可以在这个方法里面实现一些自己的逻辑：<br>（1）可以进行资源的回收；<br>（2）可以实现二级内存缓存，可以进一步提高性能，<br>思路如下：重写LruCache的entryRemoved()函数，把删除掉的item，再次存入另外一个LinkedHashMap<string, softweakreference<bitmap=\"\">&gt;中，这个数据结构当做二级缓存，每次获得图片的时候，先判断LruCache中是否缓存，没有的话，再判断这个二级缓存中是否有，如果都没有再从sdcard上获取。sdcard上也没有的话，就从网络服务器上拉取。entryRemoved()在LruCache中有四个地方进行了调用：put()、get()、trimToSize()、remove()中进行了调用。</string,></p>\n<h6 id=\"3-8-LruCache的线程安全性\"><a href=\"#3-8-LruCache的线程安全性\" class=\"headerlink\" title=\"3.8 LruCache的线程安全性\"></a>3.8 LruCache的线程安全性</h6><p>LruCache是线程安全的，因为在put、get、trimToSize、remove的方法中都加入synchronized进行同步控制。</p>\n<h5 id=\"4-LruCache代码示例\"><a href=\"#4-LruCache代码示例\" class=\"headerlink\" title=\"4.LruCache代码示例\"></a>4.LruCache代码示例</h5><p>使用步骤：</p>\n<ul>\n<li>在构造LruCache时提供一个总的缓存大小；</li>\n<li>重写sizeOf方法，对存入map的数据大小进行自定义测量；</li>\n<li>根据需要，决定是否要重写entryRemoved()方法；</li>\n<li>使用LruCache提供的put和get方法进行数据的缓存</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> LruCache&lt;String, Bitmap&gt; mMemoryCache;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"comment\">// 获得虚拟机能提供的最大内存，超过这个大小会抛出OutOfMemory的异常</span></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxMemory = (<span class=\"keyword\">int</span>) (Runtime.getRuntime().maxMemory() / <span class=\"number\">1024</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 用１／８的内存大小作为内存缓存</span></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> cacheSize = maxMemory / <span class=\"number\">8</span>;</div><div class=\"line\"></div><div class=\"line\">    mMemoryCache = <span class=\"keyword\">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(String key, Bitmap bitmap)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// 这里返回的不是item的个数，是cache的size（单位1024个字节）</span></div><div class=\"line\">            <span class=\"keyword\">return</span> bitmap.getByteCount() / <span class=\"number\">1024</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addBitmapToMemoryCache</span><span class=\"params\">(String key, Bitmap bitmap)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (getBitmapFromMemCache(key) == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        mMemoryCache.put(key, bitmap);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Bitmap <span class=\"title\">getBitmapFromMemCache</span><span class=\"params\">(String key)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> mMemoryCache.get(key);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当为ImageView加载一张图片时，会先在LruCache 中看看有没有缓存这张图片，如果有的话直接更新到ImageView中，如果没有的话，一个后台线程会被触发来加载这张图片。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadBitmap</span><span class=\"params\">(<span class=\"keyword\">int</span> resId, ImageView imageView)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> String imageKey = String.valueOf(resId);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 查看下内存缓存中是否缓存了这张图片</span></div><div class=\"line\">    <span class=\"keyword\">final</span> Bitmap bitmap = getBitmapFromMemCache(imageKey);</div><div class=\"line\">    <span class=\"keyword\">if</span> (bitmap != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        mImageView.setImageBitmap(bitmap);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mImageView.setImageResource(R.drawable.image_placeholder);</div><div class=\"line\">BitmapWorkerTask task = <span class=\"keyword\">new</span> BitmapWorkerTask(mImageView);</div><div class=\"line\">        task.execute(resId);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在图片加载的Task中，需要把加载好的图片加入到内存缓存中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BitmapWorkerTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">AsyncTask</span>&lt;<span class=\"title\">Integer</span>, <span class=\"title\">Void</span>, <span class=\"title\">Bitmap</span>&gt; </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"comment\">// 在后台完成</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Bitmap <span class=\"title\">doInBackground</span><span class=\"params\">(Integer... params)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> Bitmap bitmap = decodeSampledBitmapFromResource(</div><div class=\"line\">                getResources(), params[<span class=\"number\">0</span>], <span class=\"number\">100</span>, <span class=\"number\">100</span>));</div><div class=\"line\">    addBitmapToMemoryCache(String.valueOf(params[<span class=\"number\">0</span>]), bitmap);</div><div class=\"line\">        <span class=\"keyword\">return</span> bitmap;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5.总结\"></a>5.总结</h5><ul>\n<li>LruCache 自身并没有释放内存，只是 LinkedHashMap中将数据移除了，如果数据还在别的地方被引用了，还是有泄漏问题，还需要手动释放内存；</li>\n<li>覆写 entryRemoved 方法能知道 LruCache 数据移除是是否发生了冲突（冲突是指在map.put()的时候，对应的key中是否存在原来的值），也可以去手动释放资源；</li>\n</ul>\n<h3 id=\"三-磁盘缓存（二级缓存）\"><a href=\"#三-磁盘缓存（二级缓存）\" class=\"headerlink\" title=\"三 磁盘缓存（二级缓存）\"></a>三 磁盘缓存（二级缓存）</h3><p>LruCache是一种内存缓存策略，但是当存在大量图片的时候，我们指定的缓存内存空间可能很快就会用完，这个时候，LruCache就会频繁的进行trimToSize()操作，不断的将最近最少使用的数据移除，当再次需要该数据时，又得从网络上重新加载，这样就有可能造成OOM。为此，Google提供了一种磁盘缓存的解决方案——DiskLruCache（DiskLruCache并没有集成到Android源码中，在Android Doc的例子中有讲解）。</p>\n<h5 id=\"1-DiskLruCache实现原理\"><a href=\"#1-DiskLruCache实现原理\" class=\"headerlink\" title=\"1. DiskLruCache实现原理\"></a>1. DiskLruCache实现原理</h5><p>我们可以先来直观看一下，使用了DiskLruCache缓存策略的APP，缓存目录中是什么样子，如下图：</p>\n<img src=\"/2017/02/28/android基础之缓存/文件缓存结果图.png\" alt=\"文件缓存结果图\" title=\"文件缓存结果图\">\n<p>可以看到，缓存目录中有一堆文件名很长的文件，这些文件就是我们缓存的一张张图片数据，在最后有一个文件名journal的文件，这个journal文件是DiskLruCache的一个日志文件，即保存着每张缓存图片的操作记录，journal文件正是实现DiskLruCache的核心。看到出现了journal文件，基本可以说明这个APP使用了DiskLruCache缓存策略。</p>\n<p>根据对LruCache的分析，要实现LRU，最重要的是要有一种数据结构能够基于访问顺序来保存缓存中的对象，LinkedHashMap是一种非常合适的数据结构，为此，DiskLruCache也选择了LinkedHashMap作为维护访问顺序的数据结构，但是，对于DiskLruCache来说，单单LinkedHashMap是不够的，因为我们不能像LruCache一样，直接将数据放置到LinkedHashMap的value中，也就是处于内存当中，在DiskLruCache中，数据是缓存到了本地文件，这里的LinkedHashMap中的value只是保存的是value的一些简要信息Entry，如唯一的文件名称、大小、是否可读等信息，如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String key;</div><div class=\"line\">    <span class=\"comment\">/** Lengths of this entry's files. */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span>[] lengths;</div><div class=\"line\">    <span class=\"comment\">/** True if this entry has ever been published */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> readable;</div><div class=\"line\">    <span class=\"comment\">/** The ongoing edit or null if this entry is not being edited. */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> Editor currentEditor;</div><div class=\"line\">    <span class=\"comment\">/** The sequence number of the most recently committed edit to this entry. */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> sequenceNumber;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Entry</span><span class=\"params\">(String key)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.key = key;</div><div class=\"line\">        <span class=\"keyword\">this</span>.lengths = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[valueCount];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getLengths</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">        StringBuilder result = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">long</span> size : lengths) &#123;</div><div class=\"line\">            result.append(<span class=\"string\">' '</span>).append(size);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result.toString();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Set lengths using decimal numbers like \"10123\".</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setLengths</span><span class=\"params\">(String[] strings)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (strings.length != valueCount) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> invalidLengths(strings);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strings.length; i++) &#123;</div><div class=\"line\">                lengths[i] = Long.parseLong(strings[i]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NumberFormatException e) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> invalidLengths(strings);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> IOException <span class=\"title\">invalidLengths</span><span class=\"params\">(String[] strings)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"unexpected journal line: \"</span> + Arrays.toString(strings));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> File <span class=\"title\">getCleanFile</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> File(directory, key + <span class=\"string\">\".\"</span> + i);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> File <span class=\"title\">getDirtyFile</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> File(directory, key + <span class=\"string\">\".\"</span> + i + <span class=\"string\">\".tmp\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>DiskLruCache中对于LinkedHashMap定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LinkedHashMap&lt;String, Entry&gt; lruEntries</div><div class=\"line\">\t= <span class=\"keyword\">new</span> LinkedHashMap&lt;String, Entry&gt;(<span class=\"number\">0</span>, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</div></pre></td></tr></table></figure>\n<p>在LruCache中，由于数据是直接缓存中内存中，map中数据的建立是在使用LruCache缓存的过程中逐步建立的，而对于DiskLruCache，由于数据是缓存在本地文件，相当于是持久保存下来的一个文件，即使程序退出文件还在，因此，map中数据的建立，除了在使用DiskLruCache过程中建立外，map还应该包括之前已经存在的缓存文件，因此，在获取DiskLruCache的实例时，DiskLruCache会去读取journal这个日志文件，根据这个日志文件中的信息，建立map的初始数据，同时，会根据journal这个日志文件，维护本地的缓存文件。构造DiskLruCache的方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> DiskLruCache <span class=\"title\">open</span><span class=\"params\">(File directory, <span class=\"keyword\">int</span> appVersion, <span class=\"keyword\">int</span> valueCount, <span class=\"keyword\">long</span> maxSize)</span></span></div><div class=\"line\">    <span class=\"keyword\">throws</span> IOException &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (maxSize &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"maxSize &lt;= 0\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (valueCount &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"valueCount &lt;= 0\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// prefer to pick up where we left off</span></div><div class=\"line\">    DiskLruCache cache = <span class=\"keyword\">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</div><div class=\"line\">    <span class=\"keyword\">if</span> (cache.journalFile.exists()) &#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        cache.readJournal();</div><div class=\"line\">        cache.processJournal();</div><div class=\"line\">        cache.journalWriter = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> FileWriter(cache.journalFile, <span class=\"keyword\">true</span>),IO_BUFFER_SIZE);</div><div class=\"line\">                <span class=\"keyword\">return</span> cache;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException journalIsCorrupt) &#123;</div><div class=\"line\">            <span class=\"comment\">//                System.logW(\"DiskLruCache \" + directory + \" is corrupt: \"</span></div><div class=\"line\">            <span class=\"comment\">//                        + journalIsCorrupt.getMessage() + \", removing\");</span></div><div class=\"line\">            cache.delete();</div><div class=\"line\">        &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// create a new empty cache</span></div><div class=\"line\">    directory.mkdirs();</div><div class=\"line\">    cache = <span class=\"keyword\">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</div><div class=\"line\">    cache.rebuildJournal();</div><div class=\"line\">    <span class=\"keyword\">return</span> cache;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，<br>cache.readJournal();<br>cache.processJournal();<br>正是去读取journal日志文件，建立起map中的初始数据，同时维护缓存文件。</p>\n<h5 id=\"2-journal日志文件\"><a href=\"#2-journal日志文件\" class=\"headerlink\" title=\"2.journal日志文件\"></a>2.journal日志文件</h5><p>journal日志文件到底保存了什么信息呢，一个标准的journal日志文件信息如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">libcore.io.DiskLruCache    //第一行，固定内容，声明</div><div class=\"line\">1                                        //第二行，cache的版本号，恒为1</div><div class=\"line\">1                                        //第三行，APP的版本号</div><div class=\"line\">2                                        //第四行，一个key，可以存放多少条数据valueCount    </div><div class=\"line\">                                           //第五行，空行分割行</div><div class=\"line\">DIRTY 335c4c6028171cfddfbaae1a9c313c52</div><div class=\"line\">CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934</div><div class=\"line\">REMOVE 335c4c6028171cfddfbaae1a9c313c52</div><div class=\"line\">DIRTY 1ab96a171faeeee38496d8b330771a7a</div><div class=\"line\">CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234</div><div class=\"line\">READ 335c4c6028171cfddfbaae1a9c313c52</div><div class=\"line\">READ 3400330d1dfc7f3f7f4b8d4d803dfcf6</div></pre></td></tr></table></figure>\n<p>前五行称为journal日志文件的头，下面部分的每一行会以四种前缀之一开始：DIRTY、CLEAN、REMOVE、READ。</p>\n<p>以一个DIRTY前缀开始的，后面紧跟着缓存图片的key。以DIRTY这个这个前缀开头，意味着这是一条脏数据。每当我们调用一次DiskLruCache的edit()方法时，都会向journal文件中写入一条DIRTY记录，表示我们正准备写入一条缓存数据，但不知结果如何。然后调用commit()方法表示写入缓存成功，这时会向journal中写入一条CLEAN记录，意味着这条“脏”数据被“洗干净了”，调用abort()方法表示写入缓存失败，这时会向journal中写入一条REMOVE记录。也就是说，每一行DIRTY的key，后面都应该有一行对应的CLEAN或者REMOVE的记录，否则这条数据就是“脏”的，会被自动删除掉。</p>\n<p>在CLEAN前缀和key后面还有一个数值，代表的是该条缓存数据的大小。</p>\n<h5 id=\"3-DiskLruCache中的工作流程\"><a href=\"#3-DiskLruCache中的工作流程\" class=\"headerlink\" title=\"3.DiskLruCache中的工作流程\"></a>3.DiskLruCache中的工作流程</h5><p><strong>1.</strong>初始化：通过open()方法，获取DiskLruCache的实例，在open方法中通过readJournal(); 方法读取journal日志文件，根据journal日志文件信息建立map中的初始数据；然后再调用processJournal();方法对刚刚建立起的map数据进行分析，分析的工作，一个是计算当前有效缓存文件（即被CLEAN的）的大小，一个是清理无用缓存文件；</p>\n<p><strong>2.</strong>数据缓存与获取缓存：上面的初始化工作完成后，我们就可以在程序中进行数据的缓存功能和获取缓存的功能了；缓存数据的操作是借助DiskLruCache.Editor这个类完成的，这个类也是不能new的，需要调用DiskLruCache的edit()方法来获取实例，如：public Editor edit(String key) throws IOException。在写入完成后，需要进行commit()。</p>\n<p>如下一个简单示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;    </div><div class=\"line\">    <span class=\"meta\">@Override</span>    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;    </div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;    </div><div class=\"line\">            String imageUrl = <span class=\"string\">\"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg\"</span>;    </div><div class=\"line\">            String key = hashKeyForDisk(imageUrl);  <span class=\"comment\">//MD5对url进行加密，这个主要是为了获得统一的16位字符  </span></div><div class=\"line\">            DiskLruCache.Editor editor = mDiskLruCache.edit(key);  <span class=\"comment\">//拿到Editor，往journal日志中写入DIRTY记录  </span></div><div class=\"line\">            <span class=\"keyword\">if</span> (editor != <span class=\"keyword\">null</span>) &#123;    </div><div class=\"line\">                OutputStream outputStream = editor.newOutputStream(<span class=\"number\">0</span>);    </div><div class=\"line\">                <span class=\"keyword\">if</span> (downloadUrlToStream(imageUrl, outputStream)) &#123;  <span class=\"comment\">//downloadUrlToStream方法为下载图片的方法，并且将输出流放到outputStream  </span></div><div class=\"line\">                    editor.commit();  <span class=\"comment\">//完成后记得commit()，成功后，再往journal日志中写入CLEAN记录  </span></div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;    </div><div class=\"line\">                    editor.abort();  <span class=\"comment\">//失败后，要remove缓存文件，往journal文件中写入REMOVE记录  </span></div><div class=\"line\">                &#125;    </div><div class=\"line\">            &#125;    </div><div class=\"line\">            mDiskLruCache.flush();  <span class=\"comment\">//将缓存操作同步到journal日志文件，不一定要在这里就调用  </span></div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;    </div><div class=\"line\">            e.printStackTrace();    </div><div class=\"line\">        &#125;    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;).start();</div></pre></td></tr></table></figure>\n<p><strong>注意</strong>每次调用edit()时，会向journal日志文件写入DIRTY为前缀的一条记录；文件保存成功后，调用commit()时，也会向journal日志中写入一条CLEAN为前缀的一条记录，如果失败，需要调用abort()，abort()里面会向journal文件写入一条REMOVE为前缀的记录。</p>\n<p>获取缓存数据是通过get()方法实现的，如下一个简单示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span> &#123;    </div><div class=\"line\">    String imageUrl = <span class=\"string\">\"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg\"</span>;    </div><div class=\"line\">    String key = hashKeyForDisk(imageUrl);  <span class=\"comment\">//MD5对url进行加密，这个主要是为了获得统一的16位字符  </span></div><div class=\"line\">     <span class=\"comment\">//通过get拿到value的Snapshot，里面封装了输入流、key等信息，调用get会向journal文件写入READ为前缀的记录  </span></div><div class=\"line\">    DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key);   </div><div class=\"line\">    <span class=\"keyword\">if</span> (snapShot != <span class=\"keyword\">null</span>) &#123;    </div><div class=\"line\">        InputStream is = snapShot.getInputStream(<span class=\"number\">0</span>);    </div><div class=\"line\">        Bitmap bitmap = BitmapFactory.decodeStream(is);    </div><div class=\"line\">        mImage.setImageBitmap(bitmap);    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;    </div><div class=\"line\">    e.printStackTrace();    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>3.</strong>合适的地方进行flush()</p>\n<p>在上面进行数据缓存或获取缓存的时候，调用不同的方法会往journal中写入不同前缀的一行记录，记录写入是通过IO下的Writer写入的，要真正生效，还需要调用writer的flush()方法，而DiskLruCache中的flush()方法中封装了writer.flush()的操作，因此，我们只需要在合适地方调用DiskLruCache中的flush()方法即可。其作用也就是将操作记录同步到journal文件中，这是一个消耗效率的IO操作，我们不用每次一往journal中写数据后就调用flush，这样对效率影响较大，可以在Activity的onPause()中调用一下即可。</p>\n<h5 id=\"4-DiskLruCache总结\"><a href=\"#4-DiskLruCache总结\" class=\"headerlink\" title=\"4.DiskLruCache总结\"></a>4.DiskLruCache总结</h5><ul>\n<li>我们可以在在UI线程中检测内存缓存，即主线程中可以直接使用LruCache；</li>\n<li>使用DiskLruCache时，由于缓存或获取都需要对本地文件进行操作，因此需要另开一个线程，在子线程中检测磁盘缓存、保存缓存数据，磁盘操作从来不应该在UI线程中实现；</li>\n<li>LruCache内存缓存的核心是LinkedHashMap，而DiskLruCache的核心是LinkedHashMap和journal日志文件，相当于把journal看作是一块“内存”，LinkedHashMap的value只保存文件的简要信息，对缓存文件的所有操作都会记录在journal日志文件中。</li>\n</ul>\n<h5 id=\"5-DiskLruCache优化\"><a href=\"#5-DiskLruCache优化\" class=\"headerlink\" title=\"5.DiskLruCache优化\"></a>5.DiskLruCache优化</h5><p>DiskLruCache是基于日志文件journal的，这就决定了每次对缓存文件的操作都需要进行日志文件的记录，我们可以不用journal文件，在第一次构造DiskLruCache的时候，直接从程序访问缓存目录下的缓存文件，并将每个缓存文件的访问时间作为初始值记录在map的value中，每次访问或保存缓存都更新相应key对应的缓存文件的访问时间，这样就避免了频繁的IO操作，这种情况下就需要使用单例模式对DiskLruCache进行构造了，下面要说的Acache轻量级的数据缓存类就是这种实现方式。</p>\n<h3 id=\"四-一个轻量级缓存框架——ACache\"><a href=\"#四-一个轻量级缓存框架——ACache\" class=\"headerlink\" title=\"四 一个轻量级缓存框架——ACache\"></a>四 一个轻量级缓存框架——ACache</h3><p>ACache是一个轻量级的开源cache框架，实际上就是一个叫ACache的java类。已经在商业项目中使用，运行效果不错。</p>\n<p>ACache类似于SharedPreferences，但是比SharedPreferences功能更加强大，SharedPreferences只能保存一些基本数据类型、Serializable、Bundle等数据。而Acache可以缓存如下数据：普通的字符串、JsonObject、JsonArray、Bitmap、Drawable、序列化的java对象，和 byte数据。</p>\n<p>主要特色：</p>\n<ul>\n<li>轻，轻到只有一个JAVA文件。</li>\n<li>可配置，可以配置缓存路径，缓存大小，缓存数量等。</li>\n<li>可以设置缓存超时时间，缓存超时自动失效，并被删除。</li>\n<li>支持多进程</li>\n</ul>\n<p>应用场景：</p>\n<ul>\n<li>替换SharePreference当做配置文件</li>\n<li>可以缓存网络请求数据，比如oschina的android客户端可以缓存http请求的新闻内容，缓存时间假设为1个小时，超时后自动失效，让客户端重新请求新的数据，减少客户端流量，同时减少服务器并发量。</li>\n</ul>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewsListActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> List&lt;News&gt; list;</div><div class=\"line\">  <span class=\"keyword\">private</span> ListView listView;</div><div class=\"line\">  <span class=\"keyword\">private</span> LoadImageAdapter adapter;<span class=\"comment\">//适配器</span></div><div class=\"line\">  <span class=\"keyword\">private</span> ACache acache;<span class=\"comment\">//缓存框架</span></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">    <span class=\"keyword\">super</span>.setContentView(R.layout.load_img_listview_activity);</div><div class=\"line\">    acache=ACache.get(<span class=\"keyword\">this</span>);<span class=\"comment\">//创建ACache组件</span></div><div class=\"line\">    initView();<span class=\"comment\">//初始化界面，代码不贴了</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadData</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">   String cacheData=acache.getAsString(<span class=\"string\">\"newsList\"</span>);<span class=\"comment\">//从缓存中取数据</span></div><div class=\"line\">   <span class=\"keyword\">if</span>(cacheData!=<span class=\"keyword\">null</span>)&#123;<span class=\"comment\">//如果缓存中有，就不访问网络</span></div><div class=\"line\">   List&lt;News&gt; newsList=gson.fromJson(cacheData, <span class=\"keyword\">new</span> TypeToken&lt;List&lt;News&gt;&gt;()&#123;&#125;.getType());<span class=\"comment\">//将json转为List</span></div><div class=\"line\">      list.addAll(newsList);</div><div class=\"line\">      adapter.notifyDataSetChanged();</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">       SystemClock.sleep(<span class=\"number\">2000</span>);<span class=\"comment\">//模拟网络耗时</span></div><div class=\"line\">       String json=request();<span class=\"comment\">//模拟从网络中获取json数据</span></div><div class=\"line\">       acache.put(<span class=\"string\">\"newslist\"</span>, json, <span class=\"number\">60</span>*<span class=\"number\">60</span>*<span class=\"number\">1</span>);<span class=\"comment\">//将数据存入缓存中，有效时间设置为1小时</span></div><div class=\"line\">       List&lt;News&gt; newsList=gson.fromJson(json, <span class=\"keyword\">new</span> TypeToken&lt;List&lt;News&gt;&gt;()&#123;&#125;.getType());</div><div class=\"line\">       list.addAll(newsList);</div><div class=\"line\">       handler.sendEmptyMessage(<span class=\"number\">1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">         </div><div class=\"line\">  &#125;).start();</div><div class=\"line\">&#125;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 模拟网络请求方法</div><div class=\"line\">     * <span class=\"doctag\">@return</span> json数据</div><div class=\"line\">     */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">request</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">   News news=<span class=\"keyword\">null</span>;</div><div class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</div><div class=\"line\">       news=<span class=\"keyword\">new</span> News();</div><div class=\"line\">       news.setId(i);</div><div class=\"line\">       news.setImgUrl(<span class=\"string\">\"course/img/face_\"</span>+i+<span class=\"string\">\".png\"</span>);</div><div class=\"line\">       news.setTitle(<span class=\"string\">\"新闻标题\"</span>+i);</div><div class=\"line\">       news.setSummary(<span class=\"string\">\"测试\"</span>+i);</div><div class=\"line\">       list.add(news);</div><div class=\"line\">   &#125;</div><div class=\"line\">   Gson gson=<span class=\"keyword\">new</span> Gson();</div><div class=\"line\">   <span class=\"keyword\">return</span> gson.toJson(list);    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> Handler handler=<span class=\"keyword\">new</span> Handler()</div><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">       <span class=\"keyword\">switch</span>(msg.what)&#123;</div><div class=\"line\">           <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</div><div class=\"line\">             notify_layout.setVisibility(View.GONE);</div><div class=\"line\">             adapter.notifyDataSetChanged();</div><div class=\"line\">           <span class=\"keyword\">break</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>移动开发本质上就是手机和服务器之间进行通信，需要从服务端获取数据。反复通过网络获取数据是比较耗时的，特别是访问比较多的时候，会极大影响了性能，Android中可通过缓存机制来减少频繁的网络操作，减少流量、提升性能。android中缓存分为一级缓存，二级缓存和图片的三级缓存(就是网络)。</p>\n<p>Android缓存分为内存缓存（一级缓存）和文件缓存（二级缓存）。在早期，各大图片缓存框架流行之前，常用的内存缓存方式是软引用（SoftReference）和弱引用（WeakReference），如大部分的使用方式：HashMap<String url, SoftReference<Drawable>&gt; imageCache;这种形式。从Android 2.3（Level 9）开始，垃圾回收器更倾向于回收SoftReference或WeakReference对象，这使得SoftReference和WeakReference变得不是那么实用有效。同时，到了Android 3.0（Level 11）之后，图片数据Bitmap被放置到了内存的堆区域，而堆区域的内存是由GC管理的，开发者也就不需要进行图片资源的释放工作，但这也使得图片数据的释放无法预知，增加了造成OOM的可能。因此，在Android3.1以后，Android推出了LruCache这个内存缓存类和DiskLruCache这个磁盘缓存类。</p>\n<p>当Android端需要获得数据时比如获取网络中的图片，我们首先从内存中查找（按键查找），内存中没有的再从磁盘文件或sqlite中去查找，若磁盘中也没有才通过网络获取（图片的3级缓存策略）；当获得来自网络的数据，就以key-value对的方式先缓存到内存（一级缓存），同时缓存到文件或sqlite中（二级缓存）。注意：内存缓存会造成堆内存泄露，所有一级缓存通常要严格控制缓存的大小，一般控制在系统内存的1/4。</p>\n<h3 id=\"二-内存缓存（一级缓存）\"><a href=\"#二-内存缓存（一级缓存）\" class=\"headerlink\" title=\"二 内存缓存（一级缓存）\"></a>二 内存缓存（一级缓存）</h3><p>android中使用LruCache做内存缓存。在介绍这个类之前先了解一下LRU算法。</p>\n<h5 id=\"1-LRU算法\"><a href=\"#1-LRU算法\" class=\"headerlink\" title=\"1.LRU算法\"></a>1.LRU算法</h5><p>LRU，全称Least Rencetly Used，即最近最少使用，是一种非常常用的置换算法，也即淘汰最长时间未使用的对象。LRU在操作系统中的页面置换算法中广泛使用，我们的内存或缓存空间是有限的，当新加入一个对象时，造成我们的缓存空间不足了，此时就需要根据某种算法对缓存中原有数据进行淘汰货删除，而LRU选择的是将最长时间未使用的对象进行淘汰。</p>\n<h5 id=\"2-LruCache实现原理\"><a href=\"#2-LruCache实现原理\" class=\"headerlink\" title=\"2.LruCache实现原理\"></a>2.LruCache实现原理</h5><p>根据LRU算法的思想，要实现LRU最核心的是要有一种数据结构能够基于访问顺序来保存缓存中的对象，这样我们就能够很方便的知道哪个对象是最近访问的，哪个对象是最长时间未访问的。LruCache选择的是LinkedHashMap这个数据结构，LinkedHashMap是一个双向循环链表，在构造LinkedHashMap时，通过一个boolean值来指定LinkedHashMap中保存数据的方式，LinkedHashMap的一个构造方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* </div><div class=\"line\">     * 初始化LinkedHashMap </div><div class=\"line\">     * 第一个参数：initialCapacity，初始大小 </div><div class=\"line\">     * 第二个参数：loadFactor，负载因子=0.75f </div><div class=\"line\">     * 第三个参数：accessOrder=true，基于访问顺序；accessOrder=false，基于插入顺序 </div><div class=\"line\">     */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">boolean</span> accessOrder)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">super</span>(initialCapacity, loadFactor);  </div><div class=\"line\">        init();  </div><div class=\"line\">        <span class=\"keyword\">this</span>.accessOrder = accessOrder;  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>显然，在LruCache中选择的是accessOrder = true；此时，当accessOrder 设置为 true时，每当我们更新（即调用put方法）或访问（即调用get方法）map中的结点时，LinkedHashMap内部都会将这个结点移动到链表的尾部，因此，在链表的尾部是最近刚刚使用的结点，在链表的头部是是最近最少使用的结点，当我们的缓存空间不足时，就应该持续把链表头部结点移除掉，直到有剩余空间放置新结点。<br>可以看到，LinkedHashMap完成了LruCache中的核心功能，那LruCache中剩下要做的就是定义缓存空间总容量，当前保存数据已使用的容量，对外提供put、get方法。</p>\n<h5 id=\"3-LruCache源码分析\"><a href=\"#3-LruCache源码分析\" class=\"headerlink\" title=\"3.LruCache源码分析\"></a>3.LruCache源码分析</h5><p>在了解了LruCache的核心原理之后，就可以开始分析LruCache的源码了。</p>\n<h6 id=\"3-1关键字段\"><a href=\"#3-1关键字段\" class=\"headerlink\" title=\"3.1关键字段\"></a>3.1关键字段</h6><p>根据上面的分析，首先要有总容量、已使用容量、linkedHashMap这几个关键字段，LruCache中提供了下面三个关键字段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//核心数据结构  </span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LinkedHashMap&lt;K, V&gt; map;  </div><div class=\"line\">    <span class=\"comment\">// 当前缓存数据所占的大小  </span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;  </div><div class=\"line\">    <span class=\"comment\">//缓存空间总容量  </span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxSize;</div></pre></td></tr></table></figure>\n<p>要注意的是size字段，因为map中可以存放各种类型的数据，这些数据的大小测量方式也是不一样的，比如Bitmap类型的数据和String类型的数据计算他们的大小方式肯定不同，因此，LruCache中在计算放入数据大小的方法sizeOf中，只是简单的返回了1，需要我们重写这个方法，自己去定义数据的测量方式。因此，我们在使用LruCache的时候，经常会看到这种方式： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CACHE_SIZE = <span class=\"number\">4</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;<span class=\"comment\">//4Mib  </span></div><div class=\"line\">    LruCache&lt;String,Bitmap&gt; bitmapCache = <span class=\"keyword\">new</span> LruCache&lt;String,Bitmap&gt;(CACHE_SIZE)&#123;  </div><div class=\"line\">        <span class=\"meta\">@Override</span>  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(String key, Bitmap value)</span> </span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">return</span> value.getByteCount();<span class=\"comment\">//自定义Bitmap数据大小的计算方式  </span></div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<h6 id=\"3-2-构造方法\"><a href=\"#3-2-构造方法\" class=\"headerlink\" title=\"3.2 构造方法\"></a>3.2 构造方法</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LruCache</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (maxSize &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"maxSize &lt;= 0\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.maxSize = maxSize;</div><div class=\"line\">    <span class=\"keyword\">this</span>.map = <span class=\"keyword\">new</span> LinkedHashMap&lt;K, V&gt;(<span class=\"number\">0</span>, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>LruCache只有一个唯一的构造方法，在构造方法中，给定了缓存空间的总大小，初始化了LinkedHashMap核心数据结构，在LinkedHashMap中的第三个参数指定为true，也就设置了accessOrder=true，表示这个LinkedHashMap将是基于数据的访问顺序进行排序。</p>\n<h6 id=\"3-3-sizeOf-和safeSizeOf-方法测量数据类型大小\"><a href=\"#3-3-sizeOf-和safeSizeOf-方法测量数据类型大小\" class=\"headerlink\" title=\"3.3 sizeOf()和safeSizeOf()方法测量数据类型大小\"></a>3.3 sizeOf()和safeSizeOf()方法测量数据类型大小</h6><p>根据上面的解释，由于各种数据类型大小测量的标准不统一，具体测量的方法应该由使用者来实现，如上面给出的一个在实现LruCache时重写sizeOf的一种常用实现方式。通过多态的性质，再具体调用sizeOf时会调用我们重写的方法进行测量，LruCache对sizeOf()的调用进行一层封装，如下： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">safeSizeOf</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> result = sizeOf(key, value);</div><div class=\"line\">    <span class=\"keyword\">if</span> (result &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Negative size: \"</span> + key + <span class=\"string\">\"=\"</span> + value);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>里面其实就是调用sizeOf()方法，返回sizeOf计算的大小。<br>上面就是LruCache的基本内容，下面就需要提供LruCache的核心功能了。</p>\n<h6 id=\"3-4-put方法缓存数据\"><a href=\"#3-4-put方法缓存数据\" class=\"headerlink\" title=\"3.4 put方法缓存数据\"></a>3.4 put方法缓存数据</h6><p>首先看一下它的源码实现：    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">   * 给对应key缓存value，并且将该value移动到链表的尾部。</div><div class=\"line\">   */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null || value == null\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">      V previous;</div><div class=\"line\">      <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// 记录 put 的次数</span></div><div class=\"line\">        putCount++;</div><div class=\"line\">        <span class=\"comment\">// 通过键值对，计算出要保存对象value的大小，并更新当前缓存大小</span></div><div class=\"line\">        size += safeSizeOf(key, value);</div><div class=\"line\">        <span class=\"comment\">/*</div><div class=\"line\">         * 如果 之前存在key，用新的value覆盖原来的数据， 并返回 之前key 的value</div><div class=\"line\">         * 记录在 previous</div><div class=\"line\">         */</span></div><div class=\"line\">        previous = map.put(key, value);</div><div class=\"line\">        <span class=\"comment\">// 如果之前存在key，并且之前的value不为null</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// 计算出 之前value的大小，因为前面size已经加上了新的value数据的大小，此时，需要再次更新size，减去原来value的大小</span></div><div class=\"line\">            size -= safeSizeOf(key, previous);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 如果之前存在key，并且之前的value不为null</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">/*</div><div class=\"line\">         * previous值被剔除了，此次添加的 value 已经作为key的 新值</div><div class=\"line\">         * 告诉 自定义 的 entryRemoved 方法</div><div class=\"line\">         */</span></div><div class=\"line\">        entryRemoved(<span class=\"keyword\">false</span>, key, previous, value);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//裁剪缓存容量（在当前缓存数据大小超过了总容量maxSize时，才会真正去执行LRU）</span></div><div class=\"line\">    trimToSize(maxSize);</div><div class=\"line\">      <span class=\"keyword\">return</span> previous;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，put()方法主要有以下几步：<br>1）key和value判空，说明LruCache中不允许key和value为null；<br>2）通过safeSizeOf()获取要加入对象数据的大小，并更新当前缓存数据的大小；<br>3）将新的对象数据放入到缓存中，即调用LinkedHashMap的put方法，如果原来存在该key时，直接替换掉原来的value值，并返回之前的value值，得到之前value的大小，更新当前缓存数据的size大小；如果原来不存在该key，则直接加入缓存即可；<br>4）清理缓存空间</p>\n<h6 id=\"3-5-trimToSize-清理缓存空间\"><a href=\"#3-5-trimToSize-清理缓存空间\" class=\"headerlink\" title=\"3.5 trimToSize()清理缓存空间\"></a>3.5 trimToSize()清理缓存空间</h6><p>当我们加入一个数据时（put），为了保证当前数据的缓存所占大小没有超过我们指定的总大小，通过调用trimToSize()来对缓存空间进行管理控制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/*</div><div class=\"line\">     * 循环进行LRU，直到当前所占容量大小没有超过指定的总容量大小</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">        K key;</div><div class=\"line\">        V value;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// 一些异常情况的处理</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">0</span> || (map.isEmpty() &amp;&amp; size != <span class=\"number\">0</span>)) &#123;</div><div class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</div><div class=\"line\">                        getClass().getName() + <span class=\"string\">\".sizeOf() is reporting inconsistent results!\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">// 首先判断当前缓存数据大小是否超过了指定的缓存空间总大小。如果没有超过，即缓存中还可以存入数据，直接跳出循环，清理完毕</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">/**</div><div class=\"line\">             * 执行到这，表示当前缓存数据已超过了总容量，需要执行LRU，即将最近最少使用的数据清除掉，直到数据所占缓存空间没有超标;</div><div class=\"line\">             * 根据前面的原理分析，知道，在链表中，链表的头结点是最近最少使用的数据，因此，最先清除掉链表前面的结点</div><div class=\"line\">             */</span></div><div class=\"line\">            Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</div><div class=\"line\">            key = toEvict.getKey();</div><div class=\"line\">            value = toEvict.getValue();</div><div class=\"line\">            map.remove(key);</div><div class=\"line\">            <span class=\"comment\">// 移除掉后，更新当前数据缓存的大小</span></div><div class=\"line\">            size -= safeSizeOf(key, value);</div><div class=\"line\">            <span class=\"comment\">// 更新移除的结点数量</span></div><div class=\"line\">            evictionCount++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">/*</div><div class=\"line\">         * 通知某个结点被移除，类似于回调</div><div class=\"line\">         */</span></div><div class=\"line\">        entryRemoved(<span class=\"keyword\">true</span>, key, value, <span class=\"keyword\">null</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>trimToSize()方法的作用就是为了保证当前数据的缓存大小不能超过我们指定的缓存总大小，如果超过了，就会开始移除最近最少使用的数据，直到size符合要求。trimToSize()方法在put()的时候一定会调用，在get()的时候有可能会调用。</p>\n<h6 id=\"3-6-get方法获取缓存数据\"><a href=\"#3-6-get方法获取缓存数据\" class=\"headerlink\" title=\"3.6 get方法获取缓存数据\"></a>3.6 get方法获取缓存数据</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 根据key查询缓存，如果该key对应的value存在于缓存，直接返回value；</div><div class=\"line\">* 访问到这个结点时，LinkHashMap会将它移动到双向循环链表的的尾部。</div><div class=\"line\">* 如果如果没有缓存的值，则返回null。（如果开发者重写了create()的话，返回创建的value）</div><div class=\"line\">*/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">get</span><span class=\"params\">(K key)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    V mapValue;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// LinkHashMap 如果设置按照访问顺序的话，这里每次get都会重整数据顺序</span></div><div class=\"line\">        mapValue = map.get(key);</div><div class=\"line\">        <span class=\"comment\">// 计算 命中次数</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            hitCount++;</div><div class=\"line\">            <span class=\"keyword\">return</span> mapValue;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 计算 丢失次数</span></div><div class=\"line\">        missCount++;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/*</div><div class=\"line\">     * 官方解释：</div><div class=\"line\">     * 尝试创建一个值，这可能需要很长时间，并且Map可能在create()返回的值时有所不同。如果在create()执行的时</div><div class=\"line\">     * 候，用这个key执行了put方法，那么此时就发生了冲突，我们在Map中删除这个创建的值，释放被创建的值，保留put进去的值。</div><div class=\"line\">     */</span></div><div class=\"line\">    V createdValue = create(key);</div><div class=\"line\">    <span class=\"keyword\">if</span> (createdValue == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/***************************</div><div class=\"line\">     * 不覆写create方法走不到下面 *</div><div class=\"line\">     ***************************/</span></div><div class=\"line\">    <span class=\"comment\">/*</div><div class=\"line\">     * 正常情况走不到这里</div><div class=\"line\">     * 走到这里的话 说明 实现了自定义的 create(K key) 逻辑</div><div class=\"line\">     * 因为默认的 create(K key) 逻辑为null</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// 记录 create 的次数</span></div><div class=\"line\">        createCount++;</div><div class=\"line\">        <span class=\"comment\">// 将自定义create创建的值，放入LinkedHashMap中，如果key已经存在，会返回 之前相同key 的值</span></div><div class=\"line\">        mapValue = map.put(key, createdValue);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 如果之前存在相同key的value，即有冲突。</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">/*</div><div class=\"line\">             * 有冲突</div><div class=\"line\">             * 所以 撤销 刚才的 操作</div><div class=\"line\">             * 将 之前相同key 的值 重新放回去</div><div class=\"line\">             */</span></div><div class=\"line\">            map.put(key, mapValue);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// 拿到键值对，计算出在容量中的相对长度，然后加上</span></div><div class=\"line\">            size += safeSizeOf(key, createdValue);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 如果上面 判断出了 将要放入的值发生冲突</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">/*</div><div class=\"line\">         * 刚才create的值被删除了，原来的 之前相同key 的值被重新添加回去了</div><div class=\"line\">         * 告诉 自定义 的 entryRemoved 方法</div><div class=\"line\">         */</span></div><div class=\"line\">        entryRemoved(<span class=\"keyword\">false</span>, key, createdValue, mapValue);</div><div class=\"line\">        <span class=\"keyword\">return</span> mapValue;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// 上面 进行了 size += 操作 所以这里要重整长度</span></div><div class=\"line\">        trimToSize(maxSize);</div><div class=\"line\">        <span class=\"keyword\">return</span> createdValue;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>get()方法的思路就是：<br>   1）先尝试从map缓存中获取value，即mapVaule = map.get(key);如果mapVaule != null，说明缓存中存在该对象，直接返回即可；<br>   2）如果mapVaule == null，说明缓存中不存在该对象，大多数情况下会直接返回null；但是如果我们重写了create()方法，在缓存没有该数据的时候自己去创建一个，则会继续往下走，中间可能会出现冲突，看注释；<br>   3）注意：在我们通过LinkedHashMap进行get(key)或put(key,value)时都会对链表进行调整，即将刚刚访问get或加入put的结点放入到链表尾部。</p>\n<h6 id=\"3-7-entryRemoved\"><a href=\"#3-7-entryRemoved\" class=\"headerlink\" title=\"3.7 entryRemoved()\"></a>3.7 entryRemoved()</h6><p>entryRemoved的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 1.当被回收或者删掉时调用。该方法当value被回收释放存储空间时被remove调用</div><div class=\"line\">* 或者替换条目值时put调用，默认实现什么都没做。</div><div class=\"line\">* 2.该方法没用同步调用，如果其他线程访问缓存时，该方法也会执行。</div><div class=\"line\">* 3.evicted=true：如果该条目被删除空间 （表示 进行了trimToSize or remove）  evicted=false：put冲突后 或 get里成功create后</div><div class=\"line\">* 导致</div><div class=\"line\">* 4.newValue!=null，那么则被put()或get()调用。</div><div class=\"line\">*/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">entryRemoved</span><span class=\"params\">(<span class=\"keyword\">boolean</span> evicted, K key, V oldValue, V newValue)</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>entryRemoved方法是一个空方法，说明这个也是让开发者自己根据需求去重写的。entryRemoved()主要作用就是在结点数据value需要被删除或回收的时候，给开发者的回调。开发者就可以在这个方法里面实现一些自己的逻辑：<br>（1）可以进行资源的回收；<br>（2）可以实现二级内存缓存，可以进一步提高性能，<br>思路如下：重写LruCache的entryRemoved()函数，把删除掉的item，再次存入另外一个LinkedHashMap<String, SoftWeakReference<Bitmap>&gt;中，这个数据结构当做二级缓存，每次获得图片的时候，先判断LruCache中是否缓存，没有的话，再判断这个二级缓存中是否有，如果都没有再从sdcard上获取。sdcard上也没有的话，就从网络服务器上拉取。entryRemoved()在LruCache中有四个地方进行了调用：put()、get()、trimToSize()、remove()中进行了调用。</p>\n<h6 id=\"3-8-LruCache的线程安全性\"><a href=\"#3-8-LruCache的线程安全性\" class=\"headerlink\" title=\"3.8 LruCache的线程安全性\"></a>3.8 LruCache的线程安全性</h6><p>LruCache是线程安全的，因为在put、get、trimToSize、remove的方法中都加入synchronized进行同步控制。</p>\n<h5 id=\"4-LruCache代码示例\"><a href=\"#4-LruCache代码示例\" class=\"headerlink\" title=\"4.LruCache代码示例\"></a>4.LruCache代码示例</h5><p>使用步骤：</p>\n<ul>\n<li>在构造LruCache时提供一个总的缓存大小；</li>\n<li>重写sizeOf方法，对存入map的数据大小进行自定义测量；</li>\n<li>根据需要，决定是否要重写entryRemoved()方法；</li>\n<li>使用LruCache提供的put和get方法进行数据的缓存</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> LruCache&lt;String, Bitmap&gt; mMemoryCache;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"comment\">// 获得虚拟机能提供的最大内存，超过这个大小会抛出OutOfMemory的异常</span></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxMemory = (<span class=\"keyword\">int</span>) (Runtime.getRuntime().maxMemory() / <span class=\"number\">1024</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 用１／８的内存大小作为内存缓存</span></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> cacheSize = maxMemory / <span class=\"number\">8</span>;</div><div class=\"line\"></div><div class=\"line\">    mMemoryCache = <span class=\"keyword\">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(String key, Bitmap bitmap)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// 这里返回的不是item的个数，是cache的size（单位1024个字节）</span></div><div class=\"line\">            <span class=\"keyword\">return</span> bitmap.getByteCount() / <span class=\"number\">1024</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addBitmapToMemoryCache</span><span class=\"params\">(String key, Bitmap bitmap)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (getBitmapFromMemCache(key) == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        mMemoryCache.put(key, bitmap);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Bitmap <span class=\"title\">getBitmapFromMemCache</span><span class=\"params\">(String key)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> mMemoryCache.get(key);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当为ImageView加载一张图片时，会先在LruCache 中看看有没有缓存这张图片，如果有的话直接更新到ImageView中，如果没有的话，一个后台线程会被触发来加载这张图片。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadBitmap</span><span class=\"params\">(<span class=\"keyword\">int</span> resId, ImageView imageView)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> String imageKey = String.valueOf(resId);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 查看下内存缓存中是否缓存了这张图片</span></div><div class=\"line\">    <span class=\"keyword\">final</span> Bitmap bitmap = getBitmapFromMemCache(imageKey);</div><div class=\"line\">    <span class=\"keyword\">if</span> (bitmap != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        mImageView.setImageBitmap(bitmap);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mImageView.setImageResource(R.drawable.image_placeholder);</div><div class=\"line\">BitmapWorkerTask task = <span class=\"keyword\">new</span> BitmapWorkerTask(mImageView);</div><div class=\"line\">        task.execute(resId);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在图片加载的Task中，需要把加载好的图片加入到内存缓存中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BitmapWorkerTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">AsyncTask</span>&lt;<span class=\"title\">Integer</span>, <span class=\"title\">Void</span>, <span class=\"title\">Bitmap</span>&gt; </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"comment\">// 在后台完成</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Bitmap <span class=\"title\">doInBackground</span><span class=\"params\">(Integer... params)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> Bitmap bitmap = decodeSampledBitmapFromResource(</div><div class=\"line\">                getResources(), params[<span class=\"number\">0</span>], <span class=\"number\">100</span>, <span class=\"number\">100</span>));</div><div class=\"line\">    addBitmapToMemoryCache(String.valueOf(params[<span class=\"number\">0</span>]), bitmap);</div><div class=\"line\">        <span class=\"keyword\">return</span> bitmap;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5.总结\"></a>5.总结</h5><ul>\n<li>LruCache 自身并没有释放内存，只是 LinkedHashMap中将数据移除了，如果数据还在别的地方被引用了，还是有泄漏问题，还需要手动释放内存；</li>\n<li>覆写 entryRemoved 方法能知道 LruCache 数据移除是是否发生了冲突（冲突是指在map.put()的时候，对应的key中是否存在原来的值），也可以去手动释放资源；</li>\n</ul>\n<h3 id=\"三-磁盘缓存（二级缓存）\"><a href=\"#三-磁盘缓存（二级缓存）\" class=\"headerlink\" title=\"三 磁盘缓存（二级缓存）\"></a>三 磁盘缓存（二级缓存）</h3><p>LruCache是一种内存缓存策略，但是当存在大量图片的时候，我们指定的缓存内存空间可能很快就会用完，这个时候，LruCache就会频繁的进行trimToSize()操作，不断的将最近最少使用的数据移除，当再次需要该数据时，又得从网络上重新加载，这样就有可能造成OOM。为此，Google提供了一种磁盘缓存的解决方案——DiskLruCache（DiskLruCache并没有集成到Android源码中，在Android Doc的例子中有讲解）。</p>\n<h5 id=\"1-DiskLruCache实现原理\"><a href=\"#1-DiskLruCache实现原理\" class=\"headerlink\" title=\"1. DiskLruCache实现原理\"></a>1. DiskLruCache实现原理</h5><p>我们可以先来直观看一下，使用了DiskLruCache缓存策略的APP，缓存目录中是什么样子，如下图：</p>\n<img src=\"/2017/02/28/android基础之缓存/文件缓存结果图.png\" alt=\"文件缓存结果图\" title=\"文件缓存结果图\">\n<p>可以看到，缓存目录中有一堆文件名很长的文件，这些文件就是我们缓存的一张张图片数据，在最后有一个文件名journal的文件，这个journal文件是DiskLruCache的一个日志文件，即保存着每张缓存图片的操作记录，journal文件正是实现DiskLruCache的核心。看到出现了journal文件，基本可以说明这个APP使用了DiskLruCache缓存策略。</p>\n<p>根据对LruCache的分析，要实现LRU，最重要的是要有一种数据结构能够基于访问顺序来保存缓存中的对象，LinkedHashMap是一种非常合适的数据结构，为此，DiskLruCache也选择了LinkedHashMap作为维护访问顺序的数据结构，但是，对于DiskLruCache来说，单单LinkedHashMap是不够的，因为我们不能像LruCache一样，直接将数据放置到LinkedHashMap的value中，也就是处于内存当中，在DiskLruCache中，数据是缓存到了本地文件，这里的LinkedHashMap中的value只是保存的是value的一些简要信息Entry，如唯一的文件名称、大小、是否可读等信息，如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String key;</div><div class=\"line\">    <span class=\"comment\">/** Lengths of this entry's files. */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span>[] lengths;</div><div class=\"line\">    <span class=\"comment\">/** True if this entry has ever been published */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> readable;</div><div class=\"line\">    <span class=\"comment\">/** The ongoing edit or null if this entry is not being edited. */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> Editor currentEditor;</div><div class=\"line\">    <span class=\"comment\">/** The sequence number of the most recently committed edit to this entry. */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> sequenceNumber;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Entry</span><span class=\"params\">(String key)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.key = key;</div><div class=\"line\">        <span class=\"keyword\">this</span>.lengths = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[valueCount];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getLengths</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">        StringBuilder result = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">long</span> size : lengths) &#123;</div><div class=\"line\">            result.append(<span class=\"string\">' '</span>).append(size);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result.toString();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * Set lengths using decimal numbers like \"10123\".</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setLengths</span><span class=\"params\">(String[] strings)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (strings.length != valueCount) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> invalidLengths(strings);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strings.length; i++) &#123;</div><div class=\"line\">                lengths[i] = Long.parseLong(strings[i]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NumberFormatException e) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> invalidLengths(strings);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> IOException <span class=\"title\">invalidLengths</span><span class=\"params\">(String[] strings)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"unexpected journal line: \"</span> + Arrays.toString(strings));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> File <span class=\"title\">getCleanFile</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> File(directory, key + <span class=\"string\">\".\"</span> + i);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> File <span class=\"title\">getDirtyFile</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> File(directory, key + <span class=\"string\">\".\"</span> + i + <span class=\"string\">\".tmp\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>DiskLruCache中对于LinkedHashMap定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LinkedHashMap&lt;String, Entry&gt; lruEntries</div><div class=\"line\">\t= <span class=\"keyword\">new</span> LinkedHashMap&lt;String, Entry&gt;(<span class=\"number\">0</span>, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</div></pre></td></tr></table></figure>\n<p>在LruCache中，由于数据是直接缓存中内存中，map中数据的建立是在使用LruCache缓存的过程中逐步建立的，而对于DiskLruCache，由于数据是缓存在本地文件，相当于是持久保存下来的一个文件，即使程序退出文件还在，因此，map中数据的建立，除了在使用DiskLruCache过程中建立外，map还应该包括之前已经存在的缓存文件，因此，在获取DiskLruCache的实例时，DiskLruCache会去读取journal这个日志文件，根据这个日志文件中的信息，建立map的初始数据，同时，会根据journal这个日志文件，维护本地的缓存文件。构造DiskLruCache的方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> DiskLruCache <span class=\"title\">open</span><span class=\"params\">(File directory, <span class=\"keyword\">int</span> appVersion, <span class=\"keyword\">int</span> valueCount, <span class=\"keyword\">long</span> maxSize)</span></div><div class=\"line\">    <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (maxSize &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"maxSize &lt;= 0\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (valueCount &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"valueCount &lt;= 0\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// prefer to pick up where we left off</span></div><div class=\"line\">    DiskLruCache cache = <span class=\"keyword\">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</div><div class=\"line\">    <span class=\"keyword\">if</span> (cache.journalFile.exists()) &#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        cache.readJournal();</div><div class=\"line\">        cache.processJournal();</div><div class=\"line\">        cache.journalWriter = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> FileWriter(cache.journalFile, <span class=\"keyword\">true</span>),IO_BUFFER_SIZE);</div><div class=\"line\">                <span class=\"keyword\">return</span> cache;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException journalIsCorrupt) &#123;</div><div class=\"line\">            <span class=\"comment\">//                System.logW(\"DiskLruCache \" + directory + \" is corrupt: \"</span></div><div class=\"line\">            <span class=\"comment\">//                        + journalIsCorrupt.getMessage() + \", removing\");</span></div><div class=\"line\">            cache.delete();</div><div class=\"line\">        &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// create a new empty cache</span></div><div class=\"line\">    directory.mkdirs();</div><div class=\"line\">    cache = <span class=\"keyword\">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</div><div class=\"line\">    cache.rebuildJournal();</div><div class=\"line\">    <span class=\"keyword\">return</span> cache;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，<br>cache.readJournal();<br>cache.processJournal();<br>正是去读取journal日志文件，建立起map中的初始数据，同时维护缓存文件。</p>\n<h5 id=\"2-journal日志文件\"><a href=\"#2-journal日志文件\" class=\"headerlink\" title=\"2.journal日志文件\"></a>2.journal日志文件</h5><p>journal日志文件到底保存了什么信息呢，一个标准的journal日志文件信息如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">libcore.io.DiskLruCache    //第一行，固定内容，声明</div><div class=\"line\">1                                        //第二行，cache的版本号，恒为1</div><div class=\"line\">1                                        //第三行，APP的版本号</div><div class=\"line\">2                                        //第四行，一个key，可以存放多少条数据valueCount    </div><div class=\"line\">                                           //第五行，空行分割行</div><div class=\"line\">DIRTY 335c4c6028171cfddfbaae1a9c313c52</div><div class=\"line\">CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934</div><div class=\"line\">REMOVE 335c4c6028171cfddfbaae1a9c313c52</div><div class=\"line\">DIRTY 1ab96a171faeeee38496d8b330771a7a</div><div class=\"line\">CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234</div><div class=\"line\">READ 335c4c6028171cfddfbaae1a9c313c52</div><div class=\"line\">READ 3400330d1dfc7f3f7f4b8d4d803dfcf6</div></pre></td></tr></table></figure>\n<p>前五行称为journal日志文件的头，下面部分的每一行会以四种前缀之一开始：DIRTY、CLEAN、REMOVE、READ。</p>\n<p>以一个DIRTY前缀开始的，后面紧跟着缓存图片的key。以DIRTY这个这个前缀开头，意味着这是一条脏数据。每当我们调用一次DiskLruCache的edit()方法时，都会向journal文件中写入一条DIRTY记录，表示我们正准备写入一条缓存数据，但不知结果如何。然后调用commit()方法表示写入缓存成功，这时会向journal中写入一条CLEAN记录，意味着这条“脏”数据被“洗干净了”，调用abort()方法表示写入缓存失败，这时会向journal中写入一条REMOVE记录。也就是说，每一行DIRTY的key，后面都应该有一行对应的CLEAN或者REMOVE的记录，否则这条数据就是“脏”的，会被自动删除掉。</p>\n<p>在CLEAN前缀和key后面还有一个数值，代表的是该条缓存数据的大小。</p>\n<h5 id=\"3-DiskLruCache中的工作流程\"><a href=\"#3-DiskLruCache中的工作流程\" class=\"headerlink\" title=\"3.DiskLruCache中的工作流程\"></a>3.DiskLruCache中的工作流程</h5><p><strong>1.</strong>初始化：通过open()方法，获取DiskLruCache的实例，在open方法中通过readJournal(); 方法读取journal日志文件，根据journal日志文件信息建立map中的初始数据；然后再调用processJournal();方法对刚刚建立起的map数据进行分析，分析的工作，一个是计算当前有效缓存文件（即被CLEAN的）的大小，一个是清理无用缓存文件；</p>\n<p><strong>2.</strong>数据缓存与获取缓存：上面的初始化工作完成后，我们就可以在程序中进行数据的缓存功能和获取缓存的功能了；缓存数据的操作是借助DiskLruCache.Editor这个类完成的，这个类也是不能new的，需要调用DiskLruCache的edit()方法来获取实例，如：public Editor edit(String key) throws IOException。在写入完成后，需要进行commit()。</p>\n<p>如下一个简单示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;    </div><div class=\"line\">    <span class=\"meta\">@Override</span>    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;    </div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;    </div><div class=\"line\">            String imageUrl = <span class=\"string\">\"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg\"</span>;    </div><div class=\"line\">            String key = hashKeyForDisk(imageUrl);  <span class=\"comment\">//MD5对url进行加密，这个主要是为了获得统一的16位字符  </span></div><div class=\"line\">            DiskLruCache.Editor editor = mDiskLruCache.edit(key);  <span class=\"comment\">//拿到Editor，往journal日志中写入DIRTY记录  </span></div><div class=\"line\">            <span class=\"keyword\">if</span> (editor != <span class=\"keyword\">null</span>) &#123;    </div><div class=\"line\">                OutputStream outputStream = editor.newOutputStream(<span class=\"number\">0</span>);    </div><div class=\"line\">                <span class=\"keyword\">if</span> (downloadUrlToStream(imageUrl, outputStream)) &#123;  <span class=\"comment\">//downloadUrlToStream方法为下载图片的方法，并且将输出流放到outputStream  </span></div><div class=\"line\">                    editor.commit();  <span class=\"comment\">//完成后记得commit()，成功后，再往journal日志中写入CLEAN记录  </span></div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;    </div><div class=\"line\">                    editor.abort();  <span class=\"comment\">//失败后，要remove缓存文件，往journal文件中写入REMOVE记录  </span></div><div class=\"line\">                &#125;    </div><div class=\"line\">            &#125;    </div><div class=\"line\">            mDiskLruCache.flush();  <span class=\"comment\">//将缓存操作同步到journal日志文件，不一定要在这里就调用  </span></div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;    </div><div class=\"line\">            e.printStackTrace();    </div><div class=\"line\">        &#125;    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;).start();</div></pre></td></tr></table></figure>\n<p><strong>注意</strong>每次调用edit()时，会向journal日志文件写入DIRTY为前缀的一条记录；文件保存成功后，调用commit()时，也会向journal日志中写入一条CLEAN为前缀的一条记录，如果失败，需要调用abort()，abort()里面会向journal文件写入一条REMOVE为前缀的记录。</p>\n<p>获取缓存数据是通过get()方法实现的，如下一个简单示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span> &#123;    </div><div class=\"line\">    String imageUrl = <span class=\"string\">\"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg\"</span>;    </div><div class=\"line\">    String key = hashKeyForDisk(imageUrl);  <span class=\"comment\">//MD5对url进行加密，这个主要是为了获得统一的16位字符  </span></div><div class=\"line\">     <span class=\"comment\">//通过get拿到value的Snapshot，里面封装了输入流、key等信息，调用get会向journal文件写入READ为前缀的记录  </span></div><div class=\"line\">    DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key);   </div><div class=\"line\">    <span class=\"keyword\">if</span> (snapShot != <span class=\"keyword\">null</span>) &#123;    </div><div class=\"line\">        InputStream is = snapShot.getInputStream(<span class=\"number\">0</span>);    </div><div class=\"line\">        Bitmap bitmap = BitmapFactory.decodeStream(is);    </div><div class=\"line\">        mImage.setImageBitmap(bitmap);    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;    </div><div class=\"line\">    e.printStackTrace();    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>3.</strong>合适的地方进行flush()</p>\n<p>在上面进行数据缓存或获取缓存的时候，调用不同的方法会往journal中写入不同前缀的一行记录，记录写入是通过IO下的Writer写入的，要真正生效，还需要调用writer的flush()方法，而DiskLruCache中的flush()方法中封装了writer.flush()的操作，因此，我们只需要在合适地方调用DiskLruCache中的flush()方法即可。其作用也就是将操作记录同步到journal文件中，这是一个消耗效率的IO操作，我们不用每次一往journal中写数据后就调用flush，这样对效率影响较大，可以在Activity的onPause()中调用一下即可。</p>\n<h5 id=\"4-DiskLruCache总结\"><a href=\"#4-DiskLruCache总结\" class=\"headerlink\" title=\"4.DiskLruCache总结\"></a>4.DiskLruCache总结</h5><ul>\n<li>我们可以在在UI线程中检测内存缓存，即主线程中可以直接使用LruCache；</li>\n<li>使用DiskLruCache时，由于缓存或获取都需要对本地文件进行操作，因此需要另开一个线程，在子线程中检测磁盘缓存、保存缓存数据，磁盘操作从来不应该在UI线程中实现；</li>\n<li>LruCache内存缓存的核心是LinkedHashMap，而DiskLruCache的核心是LinkedHashMap和journal日志文件，相当于把journal看作是一块“内存”，LinkedHashMap的value只保存文件的简要信息，对缓存文件的所有操作都会记录在journal日志文件中。</li>\n</ul>\n<h5 id=\"5-DiskLruCache优化\"><a href=\"#5-DiskLruCache优化\" class=\"headerlink\" title=\"5.DiskLruCache优化\"></a>5.DiskLruCache优化</h5><p>DiskLruCache是基于日志文件journal的，这就决定了每次对缓存文件的操作都需要进行日志文件的记录，我们可以不用journal文件，在第一次构造DiskLruCache的时候，直接从程序访问缓存目录下的缓存文件，并将每个缓存文件的访问时间作为初始值记录在map的value中，每次访问或保存缓存都更新相应key对应的缓存文件的访问时间，这样就避免了频繁的IO操作，这种情况下就需要使用单例模式对DiskLruCache进行构造了，下面要说的Acache轻量级的数据缓存类就是这种实现方式。</p>\n<h3 id=\"四-一个轻量级缓存框架——ACache\"><a href=\"#四-一个轻量级缓存框架——ACache\" class=\"headerlink\" title=\"四 一个轻量级缓存框架——ACache\"></a>四 一个轻量级缓存框架——ACache</h3><p>ACache是一个轻量级的开源cache框架，实际上就是一个叫ACache的java类。已经在商业项目中使用，运行效果不错。</p>\n<p>ACache类似于SharedPreferences，但是比SharedPreferences功能更加强大，SharedPreferences只能保存一些基本数据类型、Serializable、Bundle等数据。而Acache可以缓存如下数据：普通的字符串、JsonObject、JsonArray、Bitmap、Drawable、序列化的java对象，和 byte数据。</p>\n<p>主要特色：</p>\n<ul>\n<li>轻，轻到只有一个JAVA文件。</li>\n<li>可配置，可以配置缓存路径，缓存大小，缓存数量等。</li>\n<li>可以设置缓存超时时间，缓存超时自动失效，并被删除。</li>\n<li>支持多进程</li>\n</ul>\n<p>应用场景：</p>\n<ul>\n<li>替换SharePreference当做配置文件</li>\n<li>可以缓存网络请求数据，比如oschina的android客户端可以缓存http请求的新闻内容，缓存时间假设为1个小时，超时后自动失效，让客户端重新请求新的数据，减少客户端流量，同时减少服务器并发量。</li>\n</ul>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewsListActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> List&lt;News&gt; list;</div><div class=\"line\">  <span class=\"keyword\">private</span> ListView listView;</div><div class=\"line\">  <span class=\"keyword\">private</span> LoadImageAdapter adapter;<span class=\"comment\">//适配器</span></div><div class=\"line\">  <span class=\"keyword\">private</span> ACache acache;<span class=\"comment\">//缓存框架</span></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">    <span class=\"keyword\">super</span>.setContentView(R.layout.load_img_listview_activity);</div><div class=\"line\">    acache=ACache.get(<span class=\"keyword\">this</span>);<span class=\"comment\">//创建ACache组件</span></div><div class=\"line\">    initView();<span class=\"comment\">//初始化界面，代码不贴了</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadData</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">   String cacheData=acache.getAsString(<span class=\"string\">\"newsList\"</span>);<span class=\"comment\">//从缓存中取数据</span></div><div class=\"line\">   <span class=\"keyword\">if</span>(cacheData!=<span class=\"keyword\">null</span>)&#123;<span class=\"comment\">//如果缓存中有，就不访问网络</span></div><div class=\"line\">   List&lt;News&gt; newsList=gson.fromJson(cacheData, <span class=\"keyword\">new</span> TypeToken&lt;List&lt;News&gt;&gt;()&#123;&#125;.getType());<span class=\"comment\">//将json转为List</span></div><div class=\"line\">      list.addAll(newsList);</div><div class=\"line\">      adapter.notifyDataSetChanged();</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">       SystemClock.sleep(<span class=\"number\">2000</span>);<span class=\"comment\">//模拟网络耗时</span></div><div class=\"line\">       String json=request();<span class=\"comment\">//模拟从网络中获取json数据</span></div><div class=\"line\">       acache.put(<span class=\"string\">\"newslist\"</span>, json, <span class=\"number\">60</span>*<span class=\"number\">60</span>*<span class=\"number\">1</span>);<span class=\"comment\">//将数据存入缓存中，有效时间设置为1小时</span></div><div class=\"line\">       List&lt;News&gt; newsList=gson.fromJson(json, <span class=\"keyword\">new</span> TypeToken&lt;List&lt;News&gt;&gt;()&#123;&#125;.getType());</div><div class=\"line\">       list.addAll(newsList);</div><div class=\"line\">       handler.sendEmptyMessage(<span class=\"number\">1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">         </div><div class=\"line\">  &#125;).start();</div><div class=\"line\">&#125;</div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 模拟网络请求方法</div><div class=\"line\">     * <span class=\"doctag\">@return</span> json数据</div><div class=\"line\">     */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">request</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">   News news=<span class=\"keyword\">null</span>;</div><div class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</div><div class=\"line\">       news=<span class=\"keyword\">new</span> News();</div><div class=\"line\">       news.setId(i);</div><div class=\"line\">       news.setImgUrl(<span class=\"string\">\"course/img/face_\"</span>+i+<span class=\"string\">\".png\"</span>);</div><div class=\"line\">       news.setTitle(<span class=\"string\">\"新闻标题\"</span>+i);</div><div class=\"line\">       news.setSummary(<span class=\"string\">\"测试\"</span>+i);</div><div class=\"line\">       list.add(news);</div><div class=\"line\">   &#125;</div><div class=\"line\">   Gson gson=<span class=\"keyword\">new</span> Gson();</div><div class=\"line\">   <span class=\"keyword\">return</span> gson.toJson(list);    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> Handler handler=<span class=\"keyword\">new</span> Handler()</div><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">       <span class=\"keyword\">switch</span>(msg.what)&#123;</div><div class=\"line\">           <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</div><div class=\"line\">             notify_layout.setVisibility(View.GONE);</div><div class=\"line\">             adapter.notifyDataSetChanged();</div><div class=\"line\">           <span class=\"keyword\">break</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"android基础之自定义View与ViewGroup","date":"2017-02-28T08:02:37.000Z","_content":"\n### 一 概述\n\n在android应用开发过程中，固定的一些控件和属性可能满足不了开发的需求，所以在一些特殊情况下，我们需要自定义控件与属性。ViewGroup亦继承于View，下面看View的绘制过程：\n\n{% asset_img View绘制过程.png View绘制过程 %}\n\n### 二 自定义View\n\n##### 1. 实现步骤\n\n1. 继承View类或其子类　\n2. 复写view中的一些函数\n3. 为自定义View类增加属性（两种方式）\n4. 绘制控件（导入布局）\n5. 响应用户事件\n6. 定义回调函数（根据自己需求来选择）\n\n##### 2.哪些方法需要被重写\n\n- onDraw()    \nview中onDraw()是个空函数，也就是说具体的视图都要覆写该函数来实现自己的绘制。对于ViewGroup则不需要实现该函数，因为作为容器是“没有内容“的（但必须实现dispatchDraw()函数，告诉子view绘制自己）。\n\n- onLayout()  \n主要是为viewGroup类型布局子视图用的，在View中这个函数为空函数。\n\n- onMeasure()     \n用于计算视图大小（即长和宽）的方式，并通过setMeasuredDimension(width, height)保存计算结果。\n\n- onTouchEvent   \n定义触屏事件来响应用户操作。\n\n还有一些不常用的方法：\n\n- onKeyDown  当按下某个键盘时 　\n- onKeyUp 当松开某个键盘时 　 　　 　　\n- onTrackballEvent 当发生轨迹球事件时 　 　　 　　\n- onSizeChange() 当该组件的大小被改变时 　 　　 　　\n- onFinishInflate() 回调方法，当应用从XML加载该组件并用它构建界面之后调用的方法 　 　　 　　\n- onWindowFocusChanged(boolean) 当该组件得到、失去焦点时 　 　　\n- onAttachedToWindow() 当把该组件放入到某个窗口时 　 　　 　　\n- onDetachedFromWindow() 当把该组件从某个窗口上分离时触发的方法 　 　　 　　\n- onWindowVisibilityChanged(int): 当包含该组件的窗口的可见性发生改变时触发的方法 　\n\n##### 3. 自定义控件的三种方式\n\n- 继承已有的控件     \n当要实现的控件和已有的控件在很多方面比较类似, 通过对已有控件的扩展来满足要求。\n\n- 继承一个布局文件    \n一般用于自定义组合控件，在构造函数中通过inflater和addView()方法加载自定义控件的布局文件形成图形界面（不需要onDraw方法）。\n\n- 继承view     \n通过onDraw方法来绘制出组件界面。\n\n##### 4. 自定义属性的两种方法\n\n- 在布局文件中直接加入属性，在构造函数中去获得。\n\n```java\n\t<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:layout_width=\"match_parent\"\n\t    android:layout_height=\"match_parent\"\n\t    >\n\t     <com.example.demo.myView\n\t         android:layout_width=\"wrap_content\"\n\t         android:layout_height=\"wrap_content\" \n\t         Text=\"@string/hello_world\"\n\t         />\n\t</RelativeLayout>\n```\n\n获取属性值：\n\n```java\n\tpublic myView(Context context, AttributeSet attrs) {\n\t        super(context, attrs);\n\t        // TODO Auto-generated constructor stub\n\tint textId = attrs.getAttributeResourceValue(null, \"Text\", 0);\n\tString text = context.getResources().getText(textId).toString();\n\t    }\n```\n\n- 在res/values/ 下建立一个attrs.xml 来声明自定义view的属性。\n\n可以定义的属性有：\n\n```java\n\t<declare-styleable name = \"名称\"> \n\t//参考某一资源ID (name可以随便命名)\n\t<attr name = \"background\" format = \"reference\" /> \n\t//颜色值 \n\t<attr name = \"textColor\" format = \"color\" /> \n\t//布尔值\n\t<attr name = \"focusable\" format = \"boolean\" /> \n\t//尺寸值 \n\t<attr name = \"layout_width\" format = \"dimension\" /> \n\t//浮点值 \n\t<attr name = \"fromAlpha\" format = \"float\" /> \n\t//整型值 \n\t<attr name = \"frameDuration\" format=\"integer\" /> \n\t//字符串 \n\t<attr name = \"text\" format = \"string\" /> \n\t//百分数 \n\t<attr name = \"pivotX\" format = \"fraction\" /> \n\t\n\t//枚举值 \n\t<attr name=\"orientation\"> \n\t<enum name=\"horizontal\" value=\"0\" /> \n\t<enum name=\"vertical\" value=\"1\" /> \n\t</attr> \n\t\n\t//位或运算 \n\t<attr name=\"windowSoftInputMode\"> \n\t<flag name = \"stateUnspecified\" value = \"0\" /> \n\t<flag name = \"stateUnchanged\" value = \"1\" /> \n\t</attr> \n\t\n\t//多类型\n\t<attr name = \"background\" format = \"reference|color\" /> \n\t</declare-styleable> \n```\n\nattrs.xml进行属性声明\n\n```java\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<resources>\n\t    <declare-styleable name=\"myView\">\n\t        <attr name=\"text\" format=\"string\"/>\n\t        <attr name=\"textColor\" format=\"color\"/>\n\t    </declare-styleable>\n\t</resources>\n```\n\n添加到布局文件\n\n```java\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    xmlns:myview=\"http://schemas.android.com/apk/com.example.demo\"\n    >\n     <com.example.demo.myView\n         android:layout_width=\"wrap_content\"\n         android:layout_height=\"wrap_content\" \n         myview:text = \"test\"\n         myview:textColor =\"#ff0000\"\n         />\n</RelativeLayout>\n```\n\n这里注意命名空间： xmlns:前缀=”http://schemas.android.com/apk/res/包名（或res-auto）”.\n\n在构造函数中获取属性值:\n\n```java\npublic myView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        // TODO Auto-generated constructor stub\n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.myView); \n        String text = a.getString(R.styleable.myView_text); \n        int textColor = a.getColor(R.styleable.myView_textColor, Color.WHITE); \n\n        a.recycle();\n    }\n```\n\n或者：\n\n```java\npublic myView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        // TODO Auto-generated constructor stub\n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.myView); \n        int n = a.getIndexCount();\n        for(int i=0;i<n;i++){\n            int attr = a.getIndex(i);\n            switch (attr) {\n            case R.styleable.myView_text:\n\n                break;\n\n            case R.styleable.myView_textColor:\n\n                break;\n\n            }\n        }\n       a.recycle();\n    }\n```\n\n##### 5.代码示例\n\n实现一个随手指移动的小球。具体步骤：\n\n- 在res/values/ 下建立一个attrs.xml 来声明自定义view的属性\n- 一个继承View并复写部分函数的自定义view的类\n- 一个展示自定义view 的容器界面\n\na .自定义view命名为myView，它有一个属性值，格式为color\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <declare-styleable name=\"myView\">\n        <attr name=\"TextColor\" format=\"color\"/>\n    </declare-styleable>        \n</resources>\n```\n\nb. 在构造函数获取获得view的属性配置和复写onDraw和onTouchEvent函数实现绘制界面和用户事件响应\n\n```java\npublic class myView extends View{\n    //定义画笔和初始位置\n    Paint p = new Paint();\n    public float currentX = 50;\n    public float currentY = 50;\n    public int textColor;\n\n    public myView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        //获取资源文件里面的属性，由于这里只有一个属性值，不用遍历数组，直接通过R文件拿出color值\n        //把属性放在资源文件里，方便设置和复用\n        TypedArray array = context.obtainStyledAttributes(attrs,R.styleable.myView);\n        textColor = array.getColor(R.styleable.myView_TextColor,Color.BLACK);\n        array.recycle();\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        //画一个蓝色的圆形\n        p.setColor(Color.BLUE);\n        canvas.drawCircle(currentX,currentY,30,p);\n        //设置文字和颜色，这里的颜色是资源文件values里面的值\n        p.setColor(textColor);\n        canvas.drawText(\"BY finch\",currentX-30,currentY+50,p);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n\n\n        currentX = event.getX();\n        currentY = event.getY();\n        invalidate();//重新绘制图形\n        return true;\n    }\n}\n```\n\n这里通过不断的更新当前位置坐标和重新绘制图形实现效果，要注意的是使用TypedArray后一定要记得recycle(). 否则会对下次调用产生影响。\n\nc. 把myView加入到activity_main.xml布局里面\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    xmlns:myview=\"http://schemas.android.com/apk/res-auto\"\n    android:paddingBottom=\"@dimen/activity_vertical_margin\"\n    android:paddingLeft=\"@dimen/activity_horizontal_margin\"\n    android:paddingRight=\"@dimen/activity_horizontal_margin\"\n    android:paddingTop=\"@dimen/activity_vertical_margin\"\n    tools:context=\"finch.scu.cn.myview.MainActivity\">\n\n\n    <finch.scu.cn.myview.myView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        myview:TextColor=\"#ff0000\"\n        />\n</RelativeLayout>\n```\n\nd. 最后是MainActivity\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n}\n```\n\n注：具体的view要根据具体的需求来，比如我们要侧滑删除的listview我们可以继承listview，监听侧滑事件，显示删除按钮实现功能。\n\n### 三 自定义ViewGroup\n\n自定义ViewGroup比自定义View要麻烦一些，因为ViewGroup需要去计算子View的大小以此来改变ViewGroup的大小，同时我们还要知道子View的摆放顺序。\n\n##### 1.源码分析\n\n等我看了再说\n\n自定义ViewGroup的时候一般复写：\n\n- onMeasure()方法：   \n计算childView的测量值以及模式，以及设置自己的宽和高　 　　 \n- onLayout()方法    \n对其所有childView的位置进行定位\n\n##### 2.代码示例\n\n- onMeasure方法\n\n```java\n@Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)\n    {\n        // 获得它的父容器为它设置的测量模式和大小\n        int sizeWidth = MeasureSpec.getSize(widthMeasureSpec);\n        int modeWidth = MeasureSpec.getMode(widthMeasureSpec);\n        int sizeHeight = MeasureSpec.getSize(heightMeasureSpec);\n        int modeHeight = MeasureSpec.getMode(heightMeasureSpec);\n\n        // 用于warp_content情况下，来记录父view宽和高\n        int width = 0;\n        int height = 0;\n\n        // 取每一行宽度的最大值\n        int lineWidth = 0;\n        // 每一行的高度累加\n        int lineHeight = 0;\n\n        // 获得子view的个数\n        int cCount = getChildCount();\n\n        for (int i = 0; i < cCount; i++)\n        {\n            View child = getChildAt(i);\n            // 测量子View的宽和高（子view在布局文件中是wrap_content）\n            measureChild(child, widthMeasureSpec, heightMeasureSpec);\n            // 得到LayoutParams\n            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n\n            // 根据测量宽度加上Margin值算出子view的实际宽度（上文中有说明）\n            int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;\n            // 根据测量高度加上Margin值算出子view的实际高度\n            int childHeight = child.getMeasuredHeight() + lp.topMargin+ lp.bottomMargin;\n\n            // 这里的父view是有padding值的，如果再添加一个元素就超出最大宽度就换行\n            if (lineWidth + childWidth > sizeWidth - getPaddingLeft() - getPaddingRight())\n            {\n                // 父view宽度=以前父view宽度、当前行宽的最大值\n                width = Math.max(width, lineWidth);\n                // 换行了，当前行宽=第一个view的宽度\n                lineWidth = childWidth;\n                // 父view的高度=各行高度之和\n                height += lineHeight;\n                //换行了，当前行高=第一个view的高度\n                lineHeight = childHeight;\n            } else{\n                // 叠加行宽\n                lineWidth += childWidth;\n                // 得到当前行最大的高度\n                lineHeight = Math.max(lineHeight, childHeight);\n            }\n            // 最后一个控件\n            if (i == cCount - 1)\n            {\n                width = Math.max(lineWidth, width);\n                height += lineHeight;\n            }\n        }\n        /**\n         * EXACTLY对应match_parent 或具体值\n         * AT_MOST对应wrap_content\n         * 在FlowLayout布局文件中\n         * android:layout_width=\"fill_parent\"\n         * android:layout_height=\"wrap_content\"\n         *\n         * 如果是MeasureSpec.EXACTLY则直接使用父ViewGroup传入的宽和高，否则设置为自己计算的宽和高。\n         */\n        setMeasuredDimension(\n                modeWidth == MeasureSpec.EXACTLY ? sizeWidth : width + getPaddingLeft() + getPaddingRight(),\n                modeHeight == MeasureSpec.EXACTLY ? sizeHeight : height + getPaddingTop()+ getPaddingBottom()\n        );\n\n    }\n```\n\n- onLayout方法\n\n```java\n//存储所有的View\n    private List<List<View>> mAllViews = new ArrayList<List<View>>();\n    //存储每一行的高度\n    private List<Integer> mLineHeight = new ArrayList<Integer>();\n\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b)\n    {\n        mAllViews.clear();\n        mLineHeight.clear();\n\n        // 当前ViewGroup的宽度\n        int width = getWidth();\n\n        int lineWidth = 0;\n        int lineHeight = 0;\n        // 存储每一行所有的childView\n        List<View> lineViews = new ArrayList<View>();\n\n        int cCount = getChildCount();\n\n        for (int i = 0; i < cCount; i++)\n        {\n            View child = getChildAt(i);\n            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n\n            int childWidth = child.getMeasuredWidth();\n            int childHeight = child.getMeasuredHeight();\n\n            lineWidth += childWidth + lp.leftMargin + lp.rightMargin;\n            lineHeight = Math.max(lineHeight, childHeight + lp.topMargin+ lp.bottomMargin);\n            lineViews.add(child);\n\n            // 换行，在onMeasure中childWidth是加上Margin值的\n            if (childWidth + lineWidth + lp.leftMargin + lp.rightMargin > width - getPaddingLeft() - getPaddingRight())\n            {\n                // 记录行高\n                mLineHeight.add(lineHeight);\n                // 记录当前行的Views\n                mAllViews.add(lineViews);\n\n                // 新行的行宽和行高\n                lineWidth = 0;\n                lineHeight = childHeight + lp.topMargin + lp.bottomMargin;\n                // 新行的View集合\n                lineViews = new ArrayList<View>();\n            }\n\n        }\n        // 处理最后一行\n        mLineHeight.add(lineHeight);\n        mAllViews.add(lineViews);\n\n        // 设置子View的位置\n\n        int left = getPaddingLeft();\n        int top = getPaddingTop();\n\n        // 行数\n        int lineNum = mAllViews.size();\n\n        for (int i = 0; i < lineNum; i++)\n        {\n            // 当前行的所有的View\n            lineViews = mAllViews.get(i);\n            lineHeight = mLineHeight.get(i);\n\n            for (int j = 0; j < lineViews.size(); j++)\n            {\n                View child = lineViews.get(j);\n                // 判断child的状态\n                if (child.getVisibility() == View.GONE)\n                {\n                    continue;\n                }\n\n                MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n\n                int lc = left + lp.leftMargin;\n                int tc = top + lp.topMargin;\n                int rc = lc + child.getMeasuredWidth();\n                int bc = tc + child.getMeasuredHeight();\n\n                // 为子View进行布局\n                child.layout(lc, tc, rc, bc);\n\n                left += child.getMeasuredWidth() + lp.leftMargin+ lp.rightMargin;\n            }\n            left = getPaddingLeft() ;\n            top += lineHeight ;\n        }\n\n    }\n\n    /**\n     * 因为我们只需要支持margin，所以直接使用系统的MarginLayoutParams\n     */\n    @Override\n    public LayoutParams generateLayoutParams(AttributeSet attrs)\n    {\n        return new MarginLayoutParams(getContext(), attrs);\n    }\n```\n\n- MainActivity.java\n\n```java\npublic class MainActivity extends Activity {\n\n    LayoutInflater mInflater;\n    @InjectView(R.id.id_flowlayout1)\n    FlowLayout idFlowlayout1;\n    @InjectView(R.id.id_flowlayout2)\n    FlowLayout idFlowlayout2;\n    private String[] mVals = new String[]\n            {\"Do\", \"one thing\", \"at a time\", \"and do well.\", \"Never\", \"forget\",\n                    \"to say\", \"thanks.\", \"Keep on\", \"going \", \"never give up.\"};\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        ButterKnife.inject(this);\n        mInflater = LayoutInflater.from(this);\n        initFlowlayout2();\n    }\n\n    public void initFlowlayout2() {\n        for (int i = 0; i < mVals.length; i++) {\n            final RelativeLayout rl2 = (RelativeLayout) mInflater.inflate(R.layout.flow_layout, idFlowlayout2, false);\n            TextView tv2 = (TextView) rl2.findViewById(R.id.tv);\n            tv2.setText(mVals[i]);\n            rl2.setTag(i);\n            idFlowlayout2.addView(rl2);\n            rl2.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    int i = (int) v.getTag();\n                    addViewToFlowlayout1(i);\n                    rl2.setBackgroundResource(R.drawable.flow_layout_disable_bg);\n                    rl2.setClickable(false);\n                }\n            });\n\n        }\n    }\n    public void addViewToFlowlayout1(int i){\n        RelativeLayout rl1 = (RelativeLayout) mInflater.inflate(R.layout.flow_layout, idFlowlayout1, false);\n        ImageView iv = (ImageView) rl1.findViewById(R.id.iv);\n        iv.setVisibility(View.VISIBLE);\n        TextView tv1 = (TextView) rl1.findViewById(R.id.tv);\n        tv1.setText(mVals[i]);\n        rl1.setTag(i);\n        idFlowlayout1.addView(rl1);\n        rl1.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int i = (int) v.getTag();\n                idFlowlayout1.removeView(v);\n                View view = idFlowlayout2.getChildAt(i);\n                view.setClickable(true);\n                view.setBackgroundResource(R.drawable.flow_layout_bg);\n            }\n        });\n    }\n```\n\n\n### 四 总结\n\n\n\n\n\n","source":"_posts/android基础之自定义View与ViewGroup.md","raw":"---\ntitle: android基础之自定义View与ViewGroup\ndate: 2017-02-28 16:02:37\ncategories: android\ntags:\n- android\n- java\n- view\n- ViewGroup\n---\n\n### 一 概述\n\n在android应用开发过程中，固定的一些控件和属性可能满足不了开发的需求，所以在一些特殊情况下，我们需要自定义控件与属性。ViewGroup亦继承于View，下面看View的绘制过程：\n\n{% asset_img View绘制过程.png View绘制过程 %}\n\n### 二 自定义View\n\n##### 1. 实现步骤\n\n1. 继承View类或其子类　\n2. 复写view中的一些函数\n3. 为自定义View类增加属性（两种方式）\n4. 绘制控件（导入布局）\n5. 响应用户事件\n6. 定义回调函数（根据自己需求来选择）\n\n##### 2.哪些方法需要被重写\n\n- onDraw()    \nview中onDraw()是个空函数，也就是说具体的视图都要覆写该函数来实现自己的绘制。对于ViewGroup则不需要实现该函数，因为作为容器是“没有内容“的（但必须实现dispatchDraw()函数，告诉子view绘制自己）。\n\n- onLayout()  \n主要是为viewGroup类型布局子视图用的，在View中这个函数为空函数。\n\n- onMeasure()     \n用于计算视图大小（即长和宽）的方式，并通过setMeasuredDimension(width, height)保存计算结果。\n\n- onTouchEvent   \n定义触屏事件来响应用户操作。\n\n还有一些不常用的方法：\n\n- onKeyDown  当按下某个键盘时 　\n- onKeyUp 当松开某个键盘时 　 　　 　　\n- onTrackballEvent 当发生轨迹球事件时 　 　　 　　\n- onSizeChange() 当该组件的大小被改变时 　 　　 　　\n- onFinishInflate() 回调方法，当应用从XML加载该组件并用它构建界面之后调用的方法 　 　　 　　\n- onWindowFocusChanged(boolean) 当该组件得到、失去焦点时 　 　　\n- onAttachedToWindow() 当把该组件放入到某个窗口时 　 　　 　　\n- onDetachedFromWindow() 当把该组件从某个窗口上分离时触发的方法 　 　　 　　\n- onWindowVisibilityChanged(int): 当包含该组件的窗口的可见性发生改变时触发的方法 　\n\n##### 3. 自定义控件的三种方式\n\n- 继承已有的控件     \n当要实现的控件和已有的控件在很多方面比较类似, 通过对已有控件的扩展来满足要求。\n\n- 继承一个布局文件    \n一般用于自定义组合控件，在构造函数中通过inflater和addView()方法加载自定义控件的布局文件形成图形界面（不需要onDraw方法）。\n\n- 继承view     \n通过onDraw方法来绘制出组件界面。\n\n##### 4. 自定义属性的两种方法\n\n- 在布局文件中直接加入属性，在构造函数中去获得。\n\n```java\n\t<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:layout_width=\"match_parent\"\n\t    android:layout_height=\"match_parent\"\n\t    >\n\t     <com.example.demo.myView\n\t         android:layout_width=\"wrap_content\"\n\t         android:layout_height=\"wrap_content\" \n\t         Text=\"@string/hello_world\"\n\t         />\n\t</RelativeLayout>\n```\n\n获取属性值：\n\n```java\n\tpublic myView(Context context, AttributeSet attrs) {\n\t        super(context, attrs);\n\t        // TODO Auto-generated constructor stub\n\tint textId = attrs.getAttributeResourceValue(null, \"Text\", 0);\n\tString text = context.getResources().getText(textId).toString();\n\t    }\n```\n\n- 在res/values/ 下建立一个attrs.xml 来声明自定义view的属性。\n\n可以定义的属性有：\n\n```java\n\t<declare-styleable name = \"名称\"> \n\t//参考某一资源ID (name可以随便命名)\n\t<attr name = \"background\" format = \"reference\" /> \n\t//颜色值 \n\t<attr name = \"textColor\" format = \"color\" /> \n\t//布尔值\n\t<attr name = \"focusable\" format = \"boolean\" /> \n\t//尺寸值 \n\t<attr name = \"layout_width\" format = \"dimension\" /> \n\t//浮点值 \n\t<attr name = \"fromAlpha\" format = \"float\" /> \n\t//整型值 \n\t<attr name = \"frameDuration\" format=\"integer\" /> \n\t//字符串 \n\t<attr name = \"text\" format = \"string\" /> \n\t//百分数 \n\t<attr name = \"pivotX\" format = \"fraction\" /> \n\t\n\t//枚举值 \n\t<attr name=\"orientation\"> \n\t<enum name=\"horizontal\" value=\"0\" /> \n\t<enum name=\"vertical\" value=\"1\" /> \n\t</attr> \n\t\n\t//位或运算 \n\t<attr name=\"windowSoftInputMode\"> \n\t<flag name = \"stateUnspecified\" value = \"0\" /> \n\t<flag name = \"stateUnchanged\" value = \"1\" /> \n\t</attr> \n\t\n\t//多类型\n\t<attr name = \"background\" format = \"reference|color\" /> \n\t</declare-styleable> \n```\n\nattrs.xml进行属性声明\n\n```java\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<resources>\n\t    <declare-styleable name=\"myView\">\n\t        <attr name=\"text\" format=\"string\"/>\n\t        <attr name=\"textColor\" format=\"color\"/>\n\t    </declare-styleable>\n\t</resources>\n```\n\n添加到布局文件\n\n```java\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    xmlns:myview=\"http://schemas.android.com/apk/com.example.demo\"\n    >\n     <com.example.demo.myView\n         android:layout_width=\"wrap_content\"\n         android:layout_height=\"wrap_content\" \n         myview:text = \"test\"\n         myview:textColor =\"#ff0000\"\n         />\n</RelativeLayout>\n```\n\n这里注意命名空间： xmlns:前缀=”http://schemas.android.com/apk/res/包名（或res-auto）”.\n\n在构造函数中获取属性值:\n\n```java\npublic myView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        // TODO Auto-generated constructor stub\n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.myView); \n        String text = a.getString(R.styleable.myView_text); \n        int textColor = a.getColor(R.styleable.myView_textColor, Color.WHITE); \n\n        a.recycle();\n    }\n```\n\n或者：\n\n```java\npublic myView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        // TODO Auto-generated constructor stub\n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.myView); \n        int n = a.getIndexCount();\n        for(int i=0;i<n;i++){\n            int attr = a.getIndex(i);\n            switch (attr) {\n            case R.styleable.myView_text:\n\n                break;\n\n            case R.styleable.myView_textColor:\n\n                break;\n\n            }\n        }\n       a.recycle();\n    }\n```\n\n##### 5.代码示例\n\n实现一个随手指移动的小球。具体步骤：\n\n- 在res/values/ 下建立一个attrs.xml 来声明自定义view的属性\n- 一个继承View并复写部分函数的自定义view的类\n- 一个展示自定义view 的容器界面\n\na .自定义view命名为myView，它有一个属性值，格式为color\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <declare-styleable name=\"myView\">\n        <attr name=\"TextColor\" format=\"color\"/>\n    </declare-styleable>        \n</resources>\n```\n\nb. 在构造函数获取获得view的属性配置和复写onDraw和onTouchEvent函数实现绘制界面和用户事件响应\n\n```java\npublic class myView extends View{\n    //定义画笔和初始位置\n    Paint p = new Paint();\n    public float currentX = 50;\n    public float currentY = 50;\n    public int textColor;\n\n    public myView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        //获取资源文件里面的属性，由于这里只有一个属性值，不用遍历数组，直接通过R文件拿出color值\n        //把属性放在资源文件里，方便设置和复用\n        TypedArray array = context.obtainStyledAttributes(attrs,R.styleable.myView);\n        textColor = array.getColor(R.styleable.myView_TextColor,Color.BLACK);\n        array.recycle();\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        //画一个蓝色的圆形\n        p.setColor(Color.BLUE);\n        canvas.drawCircle(currentX,currentY,30,p);\n        //设置文字和颜色，这里的颜色是资源文件values里面的值\n        p.setColor(textColor);\n        canvas.drawText(\"BY finch\",currentX-30,currentY+50,p);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n\n\n        currentX = event.getX();\n        currentY = event.getY();\n        invalidate();//重新绘制图形\n        return true;\n    }\n}\n```\n\n这里通过不断的更新当前位置坐标和重新绘制图形实现效果，要注意的是使用TypedArray后一定要记得recycle(). 否则会对下次调用产生影响。\n\nc. 把myView加入到activity_main.xml布局里面\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    xmlns:myview=\"http://schemas.android.com/apk/res-auto\"\n    android:paddingBottom=\"@dimen/activity_vertical_margin\"\n    android:paddingLeft=\"@dimen/activity_horizontal_margin\"\n    android:paddingRight=\"@dimen/activity_horizontal_margin\"\n    android:paddingTop=\"@dimen/activity_vertical_margin\"\n    tools:context=\"finch.scu.cn.myview.MainActivity\">\n\n\n    <finch.scu.cn.myview.myView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        myview:TextColor=\"#ff0000\"\n        />\n</RelativeLayout>\n```\n\nd. 最后是MainActivity\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n}\n```\n\n注：具体的view要根据具体的需求来，比如我们要侧滑删除的listview我们可以继承listview，监听侧滑事件，显示删除按钮实现功能。\n\n### 三 自定义ViewGroup\n\n自定义ViewGroup比自定义View要麻烦一些，因为ViewGroup需要去计算子View的大小以此来改变ViewGroup的大小，同时我们还要知道子View的摆放顺序。\n\n##### 1.源码分析\n\n等我看了再说\n\n自定义ViewGroup的时候一般复写：\n\n- onMeasure()方法：   \n计算childView的测量值以及模式，以及设置自己的宽和高　 　　 \n- onLayout()方法    \n对其所有childView的位置进行定位\n\n##### 2.代码示例\n\n- onMeasure方法\n\n```java\n@Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)\n    {\n        // 获得它的父容器为它设置的测量模式和大小\n        int sizeWidth = MeasureSpec.getSize(widthMeasureSpec);\n        int modeWidth = MeasureSpec.getMode(widthMeasureSpec);\n        int sizeHeight = MeasureSpec.getSize(heightMeasureSpec);\n        int modeHeight = MeasureSpec.getMode(heightMeasureSpec);\n\n        // 用于warp_content情况下，来记录父view宽和高\n        int width = 0;\n        int height = 0;\n\n        // 取每一行宽度的最大值\n        int lineWidth = 0;\n        // 每一行的高度累加\n        int lineHeight = 0;\n\n        // 获得子view的个数\n        int cCount = getChildCount();\n\n        for (int i = 0; i < cCount; i++)\n        {\n            View child = getChildAt(i);\n            // 测量子View的宽和高（子view在布局文件中是wrap_content）\n            measureChild(child, widthMeasureSpec, heightMeasureSpec);\n            // 得到LayoutParams\n            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n\n            // 根据测量宽度加上Margin值算出子view的实际宽度（上文中有说明）\n            int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;\n            // 根据测量高度加上Margin值算出子view的实际高度\n            int childHeight = child.getMeasuredHeight() + lp.topMargin+ lp.bottomMargin;\n\n            // 这里的父view是有padding值的，如果再添加一个元素就超出最大宽度就换行\n            if (lineWidth + childWidth > sizeWidth - getPaddingLeft() - getPaddingRight())\n            {\n                // 父view宽度=以前父view宽度、当前行宽的最大值\n                width = Math.max(width, lineWidth);\n                // 换行了，当前行宽=第一个view的宽度\n                lineWidth = childWidth;\n                // 父view的高度=各行高度之和\n                height += lineHeight;\n                //换行了，当前行高=第一个view的高度\n                lineHeight = childHeight;\n            } else{\n                // 叠加行宽\n                lineWidth += childWidth;\n                // 得到当前行最大的高度\n                lineHeight = Math.max(lineHeight, childHeight);\n            }\n            // 最后一个控件\n            if (i == cCount - 1)\n            {\n                width = Math.max(lineWidth, width);\n                height += lineHeight;\n            }\n        }\n        /**\n         * EXACTLY对应match_parent 或具体值\n         * AT_MOST对应wrap_content\n         * 在FlowLayout布局文件中\n         * android:layout_width=\"fill_parent\"\n         * android:layout_height=\"wrap_content\"\n         *\n         * 如果是MeasureSpec.EXACTLY则直接使用父ViewGroup传入的宽和高，否则设置为自己计算的宽和高。\n         */\n        setMeasuredDimension(\n                modeWidth == MeasureSpec.EXACTLY ? sizeWidth : width + getPaddingLeft() + getPaddingRight(),\n                modeHeight == MeasureSpec.EXACTLY ? sizeHeight : height + getPaddingTop()+ getPaddingBottom()\n        );\n\n    }\n```\n\n- onLayout方法\n\n```java\n//存储所有的View\n    private List<List<View>> mAllViews = new ArrayList<List<View>>();\n    //存储每一行的高度\n    private List<Integer> mLineHeight = new ArrayList<Integer>();\n\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b)\n    {\n        mAllViews.clear();\n        mLineHeight.clear();\n\n        // 当前ViewGroup的宽度\n        int width = getWidth();\n\n        int lineWidth = 0;\n        int lineHeight = 0;\n        // 存储每一行所有的childView\n        List<View> lineViews = new ArrayList<View>();\n\n        int cCount = getChildCount();\n\n        for (int i = 0; i < cCount; i++)\n        {\n            View child = getChildAt(i);\n            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n\n            int childWidth = child.getMeasuredWidth();\n            int childHeight = child.getMeasuredHeight();\n\n            lineWidth += childWidth + lp.leftMargin + lp.rightMargin;\n            lineHeight = Math.max(lineHeight, childHeight + lp.topMargin+ lp.bottomMargin);\n            lineViews.add(child);\n\n            // 换行，在onMeasure中childWidth是加上Margin值的\n            if (childWidth + lineWidth + lp.leftMargin + lp.rightMargin > width - getPaddingLeft() - getPaddingRight())\n            {\n                // 记录行高\n                mLineHeight.add(lineHeight);\n                // 记录当前行的Views\n                mAllViews.add(lineViews);\n\n                // 新行的行宽和行高\n                lineWidth = 0;\n                lineHeight = childHeight + lp.topMargin + lp.bottomMargin;\n                // 新行的View集合\n                lineViews = new ArrayList<View>();\n            }\n\n        }\n        // 处理最后一行\n        mLineHeight.add(lineHeight);\n        mAllViews.add(lineViews);\n\n        // 设置子View的位置\n\n        int left = getPaddingLeft();\n        int top = getPaddingTop();\n\n        // 行数\n        int lineNum = mAllViews.size();\n\n        for (int i = 0; i < lineNum; i++)\n        {\n            // 当前行的所有的View\n            lineViews = mAllViews.get(i);\n            lineHeight = mLineHeight.get(i);\n\n            for (int j = 0; j < lineViews.size(); j++)\n            {\n                View child = lineViews.get(j);\n                // 判断child的状态\n                if (child.getVisibility() == View.GONE)\n                {\n                    continue;\n                }\n\n                MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n\n                int lc = left + lp.leftMargin;\n                int tc = top + lp.topMargin;\n                int rc = lc + child.getMeasuredWidth();\n                int bc = tc + child.getMeasuredHeight();\n\n                // 为子View进行布局\n                child.layout(lc, tc, rc, bc);\n\n                left += child.getMeasuredWidth() + lp.leftMargin+ lp.rightMargin;\n            }\n            left = getPaddingLeft() ;\n            top += lineHeight ;\n        }\n\n    }\n\n    /**\n     * 因为我们只需要支持margin，所以直接使用系统的MarginLayoutParams\n     */\n    @Override\n    public LayoutParams generateLayoutParams(AttributeSet attrs)\n    {\n        return new MarginLayoutParams(getContext(), attrs);\n    }\n```\n\n- MainActivity.java\n\n```java\npublic class MainActivity extends Activity {\n\n    LayoutInflater mInflater;\n    @InjectView(R.id.id_flowlayout1)\n    FlowLayout idFlowlayout1;\n    @InjectView(R.id.id_flowlayout2)\n    FlowLayout idFlowlayout2;\n    private String[] mVals = new String[]\n            {\"Do\", \"one thing\", \"at a time\", \"and do well.\", \"Never\", \"forget\",\n                    \"to say\", \"thanks.\", \"Keep on\", \"going \", \"never give up.\"};\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        ButterKnife.inject(this);\n        mInflater = LayoutInflater.from(this);\n        initFlowlayout2();\n    }\n\n    public void initFlowlayout2() {\n        for (int i = 0; i < mVals.length; i++) {\n            final RelativeLayout rl2 = (RelativeLayout) mInflater.inflate(R.layout.flow_layout, idFlowlayout2, false);\n            TextView tv2 = (TextView) rl2.findViewById(R.id.tv);\n            tv2.setText(mVals[i]);\n            rl2.setTag(i);\n            idFlowlayout2.addView(rl2);\n            rl2.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    int i = (int) v.getTag();\n                    addViewToFlowlayout1(i);\n                    rl2.setBackgroundResource(R.drawable.flow_layout_disable_bg);\n                    rl2.setClickable(false);\n                }\n            });\n\n        }\n    }\n    public void addViewToFlowlayout1(int i){\n        RelativeLayout rl1 = (RelativeLayout) mInflater.inflate(R.layout.flow_layout, idFlowlayout1, false);\n        ImageView iv = (ImageView) rl1.findViewById(R.id.iv);\n        iv.setVisibility(View.VISIBLE);\n        TextView tv1 = (TextView) rl1.findViewById(R.id.tv);\n        tv1.setText(mVals[i]);\n        rl1.setTag(i);\n        idFlowlayout1.addView(rl1);\n        rl1.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int i = (int) v.getTag();\n                idFlowlayout1.removeView(v);\n                View view = idFlowlayout2.getChildAt(i);\n                view.setClickable(true);\n                view.setBackgroundResource(R.drawable.flow_layout_bg);\n            }\n        });\n    }\n```\n\n\n### 四 总结\n\n\n\n\n\n","slug":"android基础之自定义View与ViewGroup","published":1,"updated":"2017-03-10T06:31:21.932Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk29001saknzu78nxplw","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>在android应用开发过程中，固定的一些控件和属性可能满足不了开发的需求，所以在一些特殊情况下，我们需要自定义控件与属性。ViewGroup亦继承于View，下面看View的绘制过程：</p>\n<img src=\"/2017/02/28/android基础之自定义View与ViewGroup/View绘制过程.png\" alt=\"View绘制过程\" title=\"View绘制过程\">\n<h3 id=\"二-自定义View\"><a href=\"#二-自定义View\" class=\"headerlink\" title=\"二 自定义View\"></a>二 自定义View</h3><h5 id=\"1-实现步骤\"><a href=\"#1-实现步骤\" class=\"headerlink\" title=\"1. 实现步骤\"></a>1. 实现步骤</h5><ol>\n<li>继承View类或其子类　</li>\n<li>复写view中的一些函数</li>\n<li>为自定义View类增加属性（两种方式）</li>\n<li>绘制控件（导入布局）</li>\n<li>响应用户事件</li>\n<li>定义回调函数（根据自己需求来选择）</li>\n</ol>\n<h5 id=\"2-哪些方法需要被重写\"><a href=\"#2-哪些方法需要被重写\" class=\"headerlink\" title=\"2.哪些方法需要被重写\"></a>2.哪些方法需要被重写</h5><ul>\n<li><p>onDraw()<br>view中onDraw()是个空函数，也就是说具体的视图都要覆写该函数来实现自己的绘制。对于ViewGroup则不需要实现该函数，因为作为容器是“没有内容“的（但必须实现dispatchDraw()函数，告诉子view绘制自己）。</p>\n</li>\n<li><p>onLayout()<br>主要是为viewGroup类型布局子视图用的，在View中这个函数为空函数。</p>\n</li>\n<li><p>onMeasure()<br>用于计算视图大小（即长和宽）的方式，并通过setMeasuredDimension(width, height)保存计算结果。</p>\n</li>\n<li><p>onTouchEvent<br>定义触屏事件来响应用户操作。</p>\n</li>\n</ul>\n<p>还有一些不常用的方法：</p>\n<ul>\n<li>onKeyDown  当按下某个键盘时 　</li>\n<li>onKeyUp 当松开某个键盘时 　 　　 　　</li>\n<li>onTrackballEvent 当发生轨迹球事件时 　 　　 　　</li>\n<li>onSizeChange() 当该组件的大小被改变时 　 　　 　　</li>\n<li>onFinishInflate() 回调方法，当应用从XML加载该组件并用它构建界面之后调用的方法 　 　　 　　</li>\n<li>onWindowFocusChanged(boolean) 当该组件得到、失去焦点时 　 　　</li>\n<li>onAttachedToWindow() 当把该组件放入到某个窗口时 　 　　 　　</li>\n<li>onDetachedFromWindow() 当把该组件从某个窗口上分离时触发的方法 　 　　 　　</li>\n<li>onWindowVisibilityChanged(int): 当包含该组件的窗口的可见性发生改变时触发的方法 　</li>\n</ul>\n<h5 id=\"3-自定义控件的三种方式\"><a href=\"#3-自定义控件的三种方式\" class=\"headerlink\" title=\"3. 自定义控件的三种方式\"></a>3. 自定义控件的三种方式</h5><ul>\n<li><p>继承已有的控件<br>当要实现的控件和已有的控件在很多方面比较类似, 通过对已有控件的扩展来满足要求。</p>\n</li>\n<li><p>继承一个布局文件<br>一般用于自定义组合控件，在构造函数中通过inflater和addView()方法加载自定义控件的布局文件形成图形界面（不需要onDraw方法）。</p>\n</li>\n<li><p>继承view<br>通过onDraw方法来绘制出组件界面。</p>\n</li>\n</ul>\n<h5 id=\"4-自定义属性的两种方法\"><a href=\"#4-自定义属性的两种方法\" class=\"headerlink\" title=\"4. 自定义属性的两种方法\"></a>4. 自定义属性的两种方法</h5><ul>\n<li>在布局文件中直接加入属性，在构造函数中去获得。</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"</div><div class=\"line\">    android:layout_width=\"match_parent\"</div><div class=\"line\">    android:layout_height=\"match_parent\"</div><div class=\"line\">    &gt;</div><div class=\"line\">     &lt;com.example.demo.myView</div><div class=\"line\">         android:layout_width=\"wrap_content\"</div><div class=\"line\">         android:layout_height=\"wrap_content\" </div><div class=\"line\">         Text=\"@string/hello_world\"</div><div class=\"line\">         /&gt;</div><div class=\"line\">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>\n<p>获取属性值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">myView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</div><div class=\"line\">        <span class=\"comment\">// TODO Auto-generated constructor stub</span></div><div class=\"line\"><span class=\"keyword\">int</span> textId = attrs.getAttributeResourceValue(<span class=\"keyword\">null</span>, <span class=\"string\">\"Text\"</span>, <span class=\"number\">0</span>);</div><div class=\"line\">String text = context.getResources().getText(textId).toString();</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>在res/values/ 下建立一个attrs.xml 来声明自定义view的属性。</li>\n</ul>\n<p>可以定义的属性有：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;declare-styleable name = \"名称\"&gt; </div><div class=\"line\">//参考某一资源ID (name可以随便命名)</div><div class=\"line\">&lt;attr name = \"background\" format = \"reference\" /&gt; </div><div class=\"line\">//颜色值 </div><div class=\"line\">&lt;attr name = \"textColor\" format = \"color\" /&gt; </div><div class=\"line\">//布尔值</div><div class=\"line\">&lt;attr name = \"focusable\" format = \"boolean\" /&gt; </div><div class=\"line\">//尺寸值 </div><div class=\"line\">&lt;attr name = \"layout_width\" format = \"dimension\" /&gt; </div><div class=\"line\">//浮点值 </div><div class=\"line\">&lt;attr name = \"fromAlpha\" format = \"float\" /&gt; </div><div class=\"line\">//整型值 </div><div class=\"line\">&lt;attr name = \"frameDuration\" format=\"integer\" /&gt; </div><div class=\"line\">//字符串 </div><div class=\"line\">&lt;attr name = \"text\" format = \"string\" /&gt; </div><div class=\"line\">//百分数 </div><div class=\"line\">&lt;attr name = \"pivotX\" format = \"fraction\" /&gt; </div><div class=\"line\"></div><div class=\"line\">//枚举值 </div><div class=\"line\">&lt;attr name=\"orientation\"&gt; </div><div class=\"line\">&lt;enum name=\"horizontal\" value=\"0\" /&gt; </div><div class=\"line\">&lt;enum name=\"vertical\" value=\"1\" /&gt; </div><div class=\"line\">&lt;/attr&gt; </div><div class=\"line\"></div><div class=\"line\">//位或运算 </div><div class=\"line\">&lt;attr name=\"windowSoftInputMode\"&gt; </div><div class=\"line\">&lt;flag name = \"stateUnspecified\" value = \"0\" /&gt; </div><div class=\"line\">&lt;flag name = \"stateUnchanged\" value = \"1\" /&gt; </div><div class=\"line\">&lt;/attr&gt; </div><div class=\"line\"></div><div class=\"line\">//多类型</div><div class=\"line\">&lt;attr name = \"background\" format = \"reference|color\" /&gt; </div><div class=\"line\">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure>\n<p>attrs.xml进行属性声明</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\">&lt;resources&gt;</div><div class=\"line\">    &lt;declare-styleable name=\"myView\"&gt;</div><div class=\"line\">        &lt;attr name=\"text\" format=\"string\"/&gt;</div><div class=\"line\">        &lt;attr name=\"textColor\" format=\"color\"/&gt;</div><div class=\"line\">    &lt;/declare-styleable&gt;</div><div class=\"line\">&lt;/resources&gt;</div></pre></td></tr></table></figure>\n<p>添加到布局文件</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"</div><div class=\"line\">    android:layout_width=\"match_parent\"</div><div class=\"line\">    android:layout_height=\"match_parent\"</div><div class=\"line\">    xmlns:myview=\"http://schemas.android.com/apk/com.example.demo\"</div><div class=\"line\">    &gt;</div><div class=\"line\">     &lt;com.example.demo.myView</div><div class=\"line\">         android:layout_width=\"wrap_content\"</div><div class=\"line\">         android:layout_height=\"wrap_content\" </div><div class=\"line\">         myview:text = \"test\"</div><div class=\"line\">         myview:textColor =\"#ff0000\"</div><div class=\"line\">         /&gt;</div><div class=\"line\">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>\n<p>这里注意命名空间： xmlns:前缀=”<a href=\"http://schemas.android.com/apk/res/包名（或res-auto）”\" target=\"_blank\" rel=\"external\">http://schemas.android.com/apk/res/包名（或res-auto）”</a>.</p>\n<p>在构造函数中获取属性值:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">myView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</div><div class=\"line\">        <span class=\"comment\">// TODO Auto-generated constructor stub</span></div><div class=\"line\">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.myView); </div><div class=\"line\">        String text = a.getString(R.styleable.myView_text); </div><div class=\"line\">        <span class=\"keyword\">int</span> textColor = a.getColor(R.styleable.myView_textColor, Color.WHITE); </div><div class=\"line\"></div><div class=\"line\">        a.recycle();</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>或者：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">myView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</div><div class=\"line\">        <span class=\"comment\">// TODO Auto-generated constructor stub</span></div><div class=\"line\">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.myView); </div><div class=\"line\">        <span class=\"keyword\">int</span> n = a.getIndexCount();</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> attr = a.getIndex(i);</div><div class=\"line\">            <span class=\"keyword\">switch</span> (attr) &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> R.styleable.myView_text:</div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">case</span> R.styleable.myView_textColor:</div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">       a.recycle();</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h5 id=\"5-代码示例\"><a href=\"#5-代码示例\" class=\"headerlink\" title=\"5.代码示例\"></a>5.代码示例</h5><p>实现一个随手指移动的小球。具体步骤：</p>\n<ul>\n<li>在res/values/ 下建立一个attrs.xml 来声明自定义view的属性</li>\n<li>一个继承View并复写部分函数的自定义view的类</li>\n<li>一个展示自定义view 的容器界面</li>\n</ul>\n<p>a .自定义view命名为myView，它有一个属性值，格式为color</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\">&lt;resources&gt;</div><div class=\"line\">    &lt;declare-styleable name=\"myView\"&gt;</div><div class=\"line\">        &lt;attr name=\"TextColor\" format=\"color\"/&gt;</div><div class=\"line\">    &lt;/declare-styleable&gt;        </div><div class=\"line\">&lt;/resources&gt;</div></pre></td></tr></table></figure>\n<p>b. 在构造函数获取获得view的属性配置和复写onDraw和onTouchEvent函数实现绘制界面和用户事件响应</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">myView</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//定义画笔和初始位置</span></div><div class=\"line\">    Paint p = <span class=\"keyword\">new</span> Paint();</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">float</span> currentX = <span class=\"number\">50</span>;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">float</span> currentY = <span class=\"number\">50</span>;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> textColor;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">myView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</div><div class=\"line\">        <span class=\"comment\">//获取资源文件里面的属性，由于这里只有一个属性值，不用遍历数组，直接通过R文件拿出color值</span></div><div class=\"line\">        <span class=\"comment\">//把属性放在资源文件里，方便设置和复用</span></div><div class=\"line\">        TypedArray array = context.obtainStyledAttributes(attrs,R.styleable.myView);</div><div class=\"line\">        textColor = array.getColor(R.styleable.myView_TextColor,Color.BLACK);</div><div class=\"line\">        array.recycle();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onDraw(canvas);</div><div class=\"line\">        <span class=\"comment\">//画一个蓝色的圆形</span></div><div class=\"line\">        p.setColor(Color.BLUE);</div><div class=\"line\">        canvas.drawCircle(currentX,currentY,<span class=\"number\">30</span>,p);</div><div class=\"line\">        <span class=\"comment\">//设置文字和颜色，这里的颜色是资源文件values里面的值</span></div><div class=\"line\">        p.setColor(textColor);</div><div class=\"line\">        canvas.drawText(<span class=\"string\">\"BY finch\"</span>,currentX-<span class=\"number\">30</span>,currentY+<span class=\"number\">50</span>,p);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        currentX = event.getX();</div><div class=\"line\">        currentY = event.getY();</div><div class=\"line\">        invalidate();<span class=\"comment\">//重新绘制图形</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里通过不断的更新当前位置坐标和重新绘制图形实现效果，要注意的是使用TypedArray后一定要记得recycle(). 否则会对下次调用产生影响。</p>\n<p>c. 把myView加入到activity_main.xml布局里面</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\">&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"</div><div class=\"line\">    xmlns:tools=\"http://schemas.android.com/tools\"</div><div class=\"line\">    android:layout_width=\"match_parent\"</div><div class=\"line\">    android:layout_height=\"match_parent\"</div><div class=\"line\">    xmlns:myview=\"http://schemas.android.com/apk/res-auto\"</div><div class=\"line\">    android:paddingBottom=\"@dimen/activity_vertical_margin\"</div><div class=\"line\">    android:paddingLeft=\"@dimen/activity_horizontal_margin\"</div><div class=\"line\">    android:paddingRight=\"@dimen/activity_horizontal_margin\"</div><div class=\"line\">    android:paddingTop=\"@dimen/activity_vertical_margin\"</div><div class=\"line\">    tools:context=\"finch.scu.cn.myview.MainActivity\"&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    &lt;finch.scu.cn.myview.myView</div><div class=\"line\">        android:layout_width=\"match_parent\"</div><div class=\"line\">        android:layout_height=\"match_parent\"</div><div class=\"line\">        myview:TextColor=\"#ff0000\"</div><div class=\"line\">        /&gt;</div><div class=\"line\">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>\n<p>d. 最后是MainActivity</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        setContentView(R.layout.activity_main);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注：具体的view要根据具体的需求来，比如我们要侧滑删除的listview我们可以继承listview，监听侧滑事件，显示删除按钮实现功能。</p>\n<h3 id=\"三-自定义ViewGroup\"><a href=\"#三-自定义ViewGroup\" class=\"headerlink\" title=\"三 自定义ViewGroup\"></a>三 自定义ViewGroup</h3><p>自定义ViewGroup比自定义View要麻烦一些，因为ViewGroup需要去计算子View的大小以此来改变ViewGroup的大小，同时我们还要知道子View的摆放顺序。</p>\n<h5 id=\"1-源码分析\"><a href=\"#1-源码分析\" class=\"headerlink\" title=\"1.源码分析\"></a>1.源码分析</h5><p>等我看了再说</p>\n<p>自定义ViewGroup的时候一般复写：</p>\n<ul>\n<li>onMeasure()方法：<br>计算childView的测量值以及模式，以及设置自己的宽和高　 　　 </li>\n<li>onLayout()方法<br>对其所有childView的位置进行定位</li>\n</ul>\n<h5 id=\"2-代码示例\"><a href=\"#2-代码示例\" class=\"headerlink\" title=\"2.代码示例\"></a>2.代码示例</h5><ul>\n<li>onMeasure方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">// 获得它的父容器为它设置的测量模式和大小</span></div><div class=\"line\">        <span class=\"keyword\">int</span> sizeWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class=\"line\">        <span class=\"keyword\">int</span> modeWidth = MeasureSpec.getMode(widthMeasureSpec);</div><div class=\"line\">        <span class=\"keyword\">int</span> sizeHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class=\"line\">        <span class=\"keyword\">int</span> modeHeight = MeasureSpec.getMode(heightMeasureSpec);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 用于warp_content情况下，来记录父view宽和高</span></div><div class=\"line\">        <span class=\"keyword\">int</span> width = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> height = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 取每一行宽度的最大值</span></div><div class=\"line\">        <span class=\"keyword\">int</span> lineWidth = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"comment\">// 每一行的高度累加</span></div><div class=\"line\">        <span class=\"keyword\">int</span> lineHeight = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 获得子view的个数</span></div><div class=\"line\">        <span class=\"keyword\">int</span> cCount = getChildCount();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cCount; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            View child = getChildAt(i);</div><div class=\"line\">            <span class=\"comment\">// 测量子View的宽和高（子view在布局文件中是wrap_content）</span></div><div class=\"line\">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class=\"line\">            <span class=\"comment\">// 得到LayoutParams</span></div><div class=\"line\">            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 根据测量宽度加上Margin值算出子view的实际宽度（上文中有说明）</span></div><div class=\"line\">            <span class=\"keyword\">int</span> childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</div><div class=\"line\">            <span class=\"comment\">// 根据测量高度加上Margin值算出子view的实际高度</span></div><div class=\"line\">            <span class=\"keyword\">int</span> childHeight = child.getMeasuredHeight() + lp.topMargin+ lp.bottomMargin;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 这里的父view是有padding值的，如果再添加一个元素就超出最大宽度就换行</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (lineWidth + childWidth &gt; sizeWidth - getPaddingLeft() - getPaddingRight())</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"comment\">// 父view宽度=以前父view宽度、当前行宽的最大值</span></div><div class=\"line\">                width = Math.max(width, lineWidth);</div><div class=\"line\">                <span class=\"comment\">// 换行了，当前行宽=第一个view的宽度</span></div><div class=\"line\">                lineWidth = childWidth;</div><div class=\"line\">                <span class=\"comment\">// 父view的高度=各行高度之和</span></div><div class=\"line\">                height += lineHeight;</div><div class=\"line\">                <span class=\"comment\">//换行了，当前行高=第一个view的高度</span></div><div class=\"line\">                lineHeight = childHeight;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">                <span class=\"comment\">// 叠加行宽</span></div><div class=\"line\">                lineWidth += childWidth;</div><div class=\"line\">                <span class=\"comment\">// 得到当前行最大的高度</span></div><div class=\"line\">                lineHeight = Math.max(lineHeight, childHeight);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">// 最后一个控件</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (i == cCount - <span class=\"number\">1</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                width = Math.max(lineWidth, width);</div><div class=\"line\">                height += lineHeight;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">/**</span></div><div class=\"line\">         * EXACTLY对应match_parent 或具体值</div><div class=\"line\">         * AT_MOST对应wrap_content</div><div class=\"line\">         * 在FlowLayout布局文件中</div><div class=\"line\">         * android:layout_width=\"fill_parent\"</div><div class=\"line\">         * android:layout_height=\"wrap_content\"</div><div class=\"line\">         *</div><div class=\"line\">         * 如果是MeasureSpec.EXACTLY则直接使用父ViewGroup传入的宽和高，否则设置为自己计算的宽和高。</div><div class=\"line\">         */</div><div class=\"line\">        setMeasuredDimension(</div><div class=\"line\">                modeWidth == MeasureSpec.EXACTLY ? sizeWidth : width + getPaddingLeft() + getPaddingRight(),</div><div class=\"line\">                modeHeight == MeasureSpec.EXACTLY ? sizeHeight : height + getPaddingTop()+ getPaddingBottom()</div><div class=\"line\">        );</div><div class=\"line\"></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>onLayout方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//存储所有的View</span></div><div class=\"line\">    <span class=\"keyword\">private</span> List&lt;List&lt;View&gt;&gt; mAllViews = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;View&gt;&gt;();</div><div class=\"line\">    <span class=\"comment\">//存储每一行的高度</span></div><div class=\"line\">    <span class=\"keyword\">private</span> List&lt;Integer&gt; mLineHeight = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        mAllViews.clear();</div><div class=\"line\">        mLineHeight.clear();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 当前ViewGroup的宽度</span></div><div class=\"line\">        <span class=\"keyword\">int</span> width = getWidth();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> lineWidth = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> lineHeight = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"comment\">// 存储每一行所有的childView</span></div><div class=\"line\">        List&lt;View&gt; lineViews = <span class=\"keyword\">new</span> ArrayList&lt;View&gt;();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> cCount = getChildCount();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cCount; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            View child = getChildAt(i);</div><div class=\"line\">            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">int</span> childWidth = child.getMeasuredWidth();</div><div class=\"line\">            <span class=\"keyword\">int</span> childHeight = child.getMeasuredHeight();</div><div class=\"line\"></div><div class=\"line\">            lineWidth += childWidth + lp.leftMargin + lp.rightMargin;</div><div class=\"line\">            lineHeight = Math.max(lineHeight, childHeight + lp.topMargin+ lp.bottomMargin);</div><div class=\"line\">            lineViews.add(child);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 换行，在onMeasure中childWidth是加上Margin值的</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (childWidth + lineWidth + lp.leftMargin + lp.rightMargin &gt; width - getPaddingLeft() - getPaddingRight())</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"comment\">// 记录行高</span></div><div class=\"line\">                mLineHeight.add(lineHeight);</div><div class=\"line\">                <span class=\"comment\">// 记录当前行的Views</span></div><div class=\"line\">                mAllViews.add(lineViews);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// 新行的行宽和行高</span></div><div class=\"line\">                lineWidth = <span class=\"number\">0</span>;</div><div class=\"line\">                lineHeight = childHeight + lp.topMargin + lp.bottomMargin;</div><div class=\"line\">                <span class=\"comment\">// 新行的View集合</span></div><div class=\"line\">                lineViews = <span class=\"keyword\">new</span> ArrayList&lt;View&gt;();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 处理最后一行</span></div><div class=\"line\">        mLineHeight.add(lineHeight);</div><div class=\"line\">        mAllViews.add(lineViews);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 设置子View的位置</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> left = getPaddingLeft();</div><div class=\"line\">        <span class=\"keyword\">int</span> top = getPaddingTop();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 行数</span></div><div class=\"line\">        <span class=\"keyword\">int</span> lineNum = mAllViews.size();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; lineNum; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"comment\">// 当前行的所有的View</span></div><div class=\"line\">            lineViews = mAllViews.get(i);</div><div class=\"line\">            lineHeight = mLineHeight.get(i);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; lineViews.size(); j++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                View child = lineViews.get(j);</div><div class=\"line\">                <span class=\"comment\">// 判断child的状态</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (child.getVisibility() == View.GONE)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">int</span> lc = left + lp.leftMargin;</div><div class=\"line\">                <span class=\"keyword\">int</span> tc = top + lp.topMargin;</div><div class=\"line\">                <span class=\"keyword\">int</span> rc = lc + child.getMeasuredWidth();</div><div class=\"line\">                <span class=\"keyword\">int</span> bc = tc + child.getMeasuredHeight();</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// 为子View进行布局</span></div><div class=\"line\">                child.layout(lc, tc, rc, bc);</div><div class=\"line\"></div><div class=\"line\">                left += child.getMeasuredWidth() + lp.leftMargin+ lp.rightMargin;</div><div class=\"line\">            &#125;</div><div class=\"line\">            left = getPaddingLeft() ;</div><div class=\"line\">            top += lineHeight ;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 因为我们只需要支持margin，所以直接使用系统的MarginLayoutParams</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LayoutParams <span class=\"title\">generateLayoutParams</span><span class=\"params\">(AttributeSet attrs)</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MarginLayoutParams(getContext(), attrs);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>MainActivity.java</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    LayoutInflater mInflater;</div><div class=\"line\">    <span class=\"meta\">@InjectView</span>(R.id.id_flowlayout1)</div><div class=\"line\">    FlowLayout idFlowlayout1;</div><div class=\"line\">    <span class=\"meta\">@InjectView</span>(R.id.id_flowlayout2)</div><div class=\"line\">    FlowLayout idFlowlayout2;</div><div class=\"line\">    <span class=\"keyword\">private</span> String[] mVals = <span class=\"keyword\">new</span> String[]</div><div class=\"line\">            &#123;<span class=\"string\">\"Do\"</span>, <span class=\"string\">\"one thing\"</span>, <span class=\"string\">\"at a time\"</span>, <span class=\"string\">\"and do well.\"</span>, <span class=\"string\">\"Never\"</span>, <span class=\"string\">\"forget\"</span>,</div><div class=\"line\">                    <span class=\"string\">\"to say\"</span>, <span class=\"string\">\"thanks.\"</span>, <span class=\"string\">\"Keep on\"</span>, <span class=\"string\">\"going \"</span>, <span class=\"string\">\"never give up.\"</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        setContentView(R.layout.activity_main);</div><div class=\"line\">        ButterKnife.inject(<span class=\"keyword\">this</span>);</div><div class=\"line\">        mInflater = LayoutInflater.from(<span class=\"keyword\">this</span>);</div><div class=\"line\">        initFlowlayout2();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initFlowlayout2</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mVals.length; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> RelativeLayout rl2 = (RelativeLayout) mInflater.inflate(R.layout.flow_layout, idFlowlayout2, <span class=\"keyword\">false</span>);</div><div class=\"line\">            TextView tv2 = (TextView) rl2.findViewById(R.id.tv);</div><div class=\"line\">            tv2.setText(mVals[i]);</div><div class=\"line\">            rl2.setTag(i);</div><div class=\"line\">            idFlowlayout2.addView(rl2);</div><div class=\"line\">            rl2.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">                    <span class=\"keyword\">int</span> i = (<span class=\"keyword\">int</span>) v.getTag();</div><div class=\"line\">                    addViewToFlowlayout1(i);</div><div class=\"line\">                    rl2.setBackgroundResource(R.drawable.flow_layout_disable_bg);</div><div class=\"line\">                    rl2.setClickable(<span class=\"keyword\">false</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addViewToFlowlayout1</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</div><div class=\"line\">        RelativeLayout rl1 = (RelativeLayout) mInflater.inflate(R.layout.flow_layout, idFlowlayout1, <span class=\"keyword\">false</span>);</div><div class=\"line\">        ImageView iv = (ImageView) rl1.findViewById(R.id.iv);</div><div class=\"line\">        iv.setVisibility(View.VISIBLE);</div><div class=\"line\">        TextView tv1 = (TextView) rl1.findViewById(R.id.tv);</div><div class=\"line\">        tv1.setText(mVals[i]);</div><div class=\"line\">        rl1.setTag(i);</div><div class=\"line\">        idFlowlayout1.addView(rl1);</div><div class=\"line\">        rl1.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> i = (<span class=\"keyword\">int</span>) v.getTag();</div><div class=\"line\">                idFlowlayout1.removeView(v);</div><div class=\"line\">                View view = idFlowlayout2.getChildAt(i);</div><div class=\"line\">                view.setClickable(<span class=\"keyword\">true</span>);</div><div class=\"line\">                view.setBackgroundResource(R.drawable.flow_layout_bg);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"四-总结\"><a href=\"#四-总结\" class=\"headerlink\" title=\"四 总结\"></a>四 总结</h3>","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>在android应用开发过程中，固定的一些控件和属性可能满足不了开发的需求，所以在一些特殊情况下，我们需要自定义控件与属性。ViewGroup亦继承于View，下面看View的绘制过程：</p>\n<img src=\"/2017/02/28/android基础之自定义View与ViewGroup/View绘制过程.png\" alt=\"View绘制过程\" title=\"View绘制过程\">\n<h3 id=\"二-自定义View\"><a href=\"#二-自定义View\" class=\"headerlink\" title=\"二 自定义View\"></a>二 自定义View</h3><h5 id=\"1-实现步骤\"><a href=\"#1-实现步骤\" class=\"headerlink\" title=\"1. 实现步骤\"></a>1. 实现步骤</h5><ol>\n<li>继承View类或其子类　</li>\n<li>复写view中的一些函数</li>\n<li>为自定义View类增加属性（两种方式）</li>\n<li>绘制控件（导入布局）</li>\n<li>响应用户事件</li>\n<li>定义回调函数（根据自己需求来选择）</li>\n</ol>\n<h5 id=\"2-哪些方法需要被重写\"><a href=\"#2-哪些方法需要被重写\" class=\"headerlink\" title=\"2.哪些方法需要被重写\"></a>2.哪些方法需要被重写</h5><ul>\n<li><p>onDraw()<br>view中onDraw()是个空函数，也就是说具体的视图都要覆写该函数来实现自己的绘制。对于ViewGroup则不需要实现该函数，因为作为容器是“没有内容“的（但必须实现dispatchDraw()函数，告诉子view绘制自己）。</p>\n</li>\n<li><p>onLayout()<br>主要是为viewGroup类型布局子视图用的，在View中这个函数为空函数。</p>\n</li>\n<li><p>onMeasure()<br>用于计算视图大小（即长和宽）的方式，并通过setMeasuredDimension(width, height)保存计算结果。</p>\n</li>\n<li><p>onTouchEvent<br>定义触屏事件来响应用户操作。</p>\n</li>\n</ul>\n<p>还有一些不常用的方法：</p>\n<ul>\n<li>onKeyDown  当按下某个键盘时 　</li>\n<li>onKeyUp 当松开某个键盘时 　 　　 　　</li>\n<li>onTrackballEvent 当发生轨迹球事件时 　 　　 　　</li>\n<li>onSizeChange() 当该组件的大小被改变时 　 　　 　　</li>\n<li>onFinishInflate() 回调方法，当应用从XML加载该组件并用它构建界面之后调用的方法 　 　　 　　</li>\n<li>onWindowFocusChanged(boolean) 当该组件得到、失去焦点时 　 　　</li>\n<li>onAttachedToWindow() 当把该组件放入到某个窗口时 　 　　 　　</li>\n<li>onDetachedFromWindow() 当把该组件从某个窗口上分离时触发的方法 　 　　 　　</li>\n<li>onWindowVisibilityChanged(int): 当包含该组件的窗口的可见性发生改变时触发的方法 　</li>\n</ul>\n<h5 id=\"3-自定义控件的三种方式\"><a href=\"#3-自定义控件的三种方式\" class=\"headerlink\" title=\"3. 自定义控件的三种方式\"></a>3. 自定义控件的三种方式</h5><ul>\n<li><p>继承已有的控件<br>当要实现的控件和已有的控件在很多方面比较类似, 通过对已有控件的扩展来满足要求。</p>\n</li>\n<li><p>继承一个布局文件<br>一般用于自定义组合控件，在构造函数中通过inflater和addView()方法加载自定义控件的布局文件形成图形界面（不需要onDraw方法）。</p>\n</li>\n<li><p>继承view<br>通过onDraw方法来绘制出组件界面。</p>\n</li>\n</ul>\n<h5 id=\"4-自定义属性的两种方法\"><a href=\"#4-自定义属性的两种方法\" class=\"headerlink\" title=\"4. 自定义属性的两种方法\"></a>4. 自定义属性的两种方法</h5><ul>\n<li>在布局文件中直接加入属性，在构造函数中去获得。</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"</div><div class=\"line\">    android:layout_width=\"match_parent\"</div><div class=\"line\">    android:layout_height=\"match_parent\"</div><div class=\"line\">    &gt;</div><div class=\"line\">     &lt;com.example.demo.myView</div><div class=\"line\">         android:layout_width=\"wrap_content\"</div><div class=\"line\">         android:layout_height=\"wrap_content\" </div><div class=\"line\">         Text=\"@string/hello_world\"</div><div class=\"line\">         /&gt;</div><div class=\"line\">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>\n<p>获取属性值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">myView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</div><div class=\"line\">        <span class=\"comment\">// TODO Auto-generated constructor stub</span></div><div class=\"line\"><span class=\"keyword\">int</span> textId = attrs.getAttributeResourceValue(<span class=\"keyword\">null</span>, <span class=\"string\">\"Text\"</span>, <span class=\"number\">0</span>);</div><div class=\"line\">String text = context.getResources().getText(textId).toString();</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>在res/values/ 下建立一个attrs.xml 来声明自定义view的属性。</li>\n</ul>\n<p>可以定义的属性有：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;declare-styleable name = \"名称\"&gt; </div><div class=\"line\">//参考某一资源ID (name可以随便命名)</div><div class=\"line\">&lt;attr name = \"background\" format = \"reference\" /&gt; </div><div class=\"line\">//颜色值 </div><div class=\"line\">&lt;attr name = \"textColor\" format = \"color\" /&gt; </div><div class=\"line\">//布尔值</div><div class=\"line\">&lt;attr name = \"focusable\" format = \"boolean\" /&gt; </div><div class=\"line\">//尺寸值 </div><div class=\"line\">&lt;attr name = \"layout_width\" format = \"dimension\" /&gt; </div><div class=\"line\">//浮点值 </div><div class=\"line\">&lt;attr name = \"fromAlpha\" format = \"float\" /&gt; </div><div class=\"line\">//整型值 </div><div class=\"line\">&lt;attr name = \"frameDuration\" format=\"integer\" /&gt; </div><div class=\"line\">//字符串 </div><div class=\"line\">&lt;attr name = \"text\" format = \"string\" /&gt; </div><div class=\"line\">//百分数 </div><div class=\"line\">&lt;attr name = \"pivotX\" format = \"fraction\" /&gt; </div><div class=\"line\"></div><div class=\"line\">//枚举值 </div><div class=\"line\">&lt;attr name=\"orientation\"&gt; </div><div class=\"line\">&lt;enum name=\"horizontal\" value=\"0\" /&gt; </div><div class=\"line\">&lt;enum name=\"vertical\" value=\"1\" /&gt; </div><div class=\"line\">&lt;/attr&gt; </div><div class=\"line\"></div><div class=\"line\">//位或运算 </div><div class=\"line\">&lt;attr name=\"windowSoftInputMode\"&gt; </div><div class=\"line\">&lt;flag name = \"stateUnspecified\" value = \"0\" /&gt; </div><div class=\"line\">&lt;flag name = \"stateUnchanged\" value = \"1\" /&gt; </div><div class=\"line\">&lt;/attr&gt; </div><div class=\"line\"></div><div class=\"line\">//多类型</div><div class=\"line\">&lt;attr name = \"background\" format = \"reference|color\" /&gt; </div><div class=\"line\">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure>\n<p>attrs.xml进行属性声明</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\">&lt;resources&gt;</div><div class=\"line\">    &lt;declare-styleable name=\"myView\"&gt;</div><div class=\"line\">        &lt;attr name=\"text\" format=\"string\"/&gt;</div><div class=\"line\">        &lt;attr name=\"textColor\" format=\"color\"/&gt;</div><div class=\"line\">    &lt;/declare-styleable&gt;</div><div class=\"line\">&lt;/resources&gt;</div></pre></td></tr></table></figure>\n<p>添加到布局文件</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"</div><div class=\"line\">    android:layout_width=\"match_parent\"</div><div class=\"line\">    android:layout_height=\"match_parent\"</div><div class=\"line\">    xmlns:myview=\"http://schemas.android.com/apk/com.example.demo\"</div><div class=\"line\">    &gt;</div><div class=\"line\">     &lt;com.example.demo.myView</div><div class=\"line\">         android:layout_width=\"wrap_content\"</div><div class=\"line\">         android:layout_height=\"wrap_content\" </div><div class=\"line\">         myview:text = \"test\"</div><div class=\"line\">         myview:textColor =\"#ff0000\"</div><div class=\"line\">         /&gt;</div><div class=\"line\">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>\n<p>这里注意命名空间： xmlns:前缀=”<a href=\"http://schemas.android.com/apk/res/包名（或res-auto）”\">http://schemas.android.com/apk/res/包名（或res-auto）”</a>.</p>\n<p>在构造函数中获取属性值:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">myView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</div><div class=\"line\">        <span class=\"comment\">// TODO Auto-generated constructor stub</span></div><div class=\"line\">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.myView); </div><div class=\"line\">        String text = a.getString(R.styleable.myView_text); </div><div class=\"line\">        <span class=\"keyword\">int</span> textColor = a.getColor(R.styleable.myView_textColor, Color.WHITE); </div><div class=\"line\"></div><div class=\"line\">        a.recycle();</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>或者：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">myView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</div><div class=\"line\">        <span class=\"comment\">// TODO Auto-generated constructor stub</span></div><div class=\"line\">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.myView); </div><div class=\"line\">        <span class=\"keyword\">int</span> n = a.getIndexCount();</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> attr = a.getIndex(i);</div><div class=\"line\">            <span class=\"keyword\">switch</span> (attr) &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> R.styleable.myView_text:</div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">case</span> R.styleable.myView_textColor:</div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">       a.recycle();</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h5 id=\"5-代码示例\"><a href=\"#5-代码示例\" class=\"headerlink\" title=\"5.代码示例\"></a>5.代码示例</h5><p>实现一个随手指移动的小球。具体步骤：</p>\n<ul>\n<li>在res/values/ 下建立一个attrs.xml 来声明自定义view的属性</li>\n<li>一个继承View并复写部分函数的自定义view的类</li>\n<li>一个展示自定义view 的容器界面</li>\n</ul>\n<p>a .自定义view命名为myView，它有一个属性值，格式为color</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\">&lt;resources&gt;</div><div class=\"line\">    &lt;declare-styleable name=\"myView\"&gt;</div><div class=\"line\">        &lt;attr name=\"TextColor\" format=\"color\"/&gt;</div><div class=\"line\">    &lt;/declare-styleable&gt;        </div><div class=\"line\">&lt;/resources&gt;</div></pre></td></tr></table></figure>\n<p>b. 在构造函数获取获得view的属性配置和复写onDraw和onTouchEvent函数实现绘制界面和用户事件响应</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">myView</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//定义画笔和初始位置</span></div><div class=\"line\">    Paint p = <span class=\"keyword\">new</span> Paint();</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">float</span> currentX = <span class=\"number\">50</span>;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">float</span> currentY = <span class=\"number\">50</span>;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> textColor;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">myView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</div><div class=\"line\">        <span class=\"comment\">//获取资源文件里面的属性，由于这里只有一个属性值，不用遍历数组，直接通过R文件拿出color值</span></div><div class=\"line\">        <span class=\"comment\">//把属性放在资源文件里，方便设置和复用</span></div><div class=\"line\">        TypedArray array = context.obtainStyledAttributes(attrs,R.styleable.myView);</div><div class=\"line\">        textColor = array.getColor(R.styleable.myView_TextColor,Color.BLACK);</div><div class=\"line\">        array.recycle();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onDraw(canvas);</div><div class=\"line\">        <span class=\"comment\">//画一个蓝色的圆形</span></div><div class=\"line\">        p.setColor(Color.BLUE);</div><div class=\"line\">        canvas.drawCircle(currentX,currentY,<span class=\"number\">30</span>,p);</div><div class=\"line\">        <span class=\"comment\">//设置文字和颜色，这里的颜色是资源文件values里面的值</span></div><div class=\"line\">        p.setColor(textColor);</div><div class=\"line\">        canvas.drawText(<span class=\"string\">\"BY finch\"</span>,currentX-<span class=\"number\">30</span>,currentY+<span class=\"number\">50</span>,p);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        currentX = event.getX();</div><div class=\"line\">        currentY = event.getY();</div><div class=\"line\">        invalidate();<span class=\"comment\">//重新绘制图形</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里通过不断的更新当前位置坐标和重新绘制图形实现效果，要注意的是使用TypedArray后一定要记得recycle(). 否则会对下次调用产生影响。</p>\n<p>c. 把myView加入到activity_main.xml布局里面</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\">&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"</div><div class=\"line\">    xmlns:tools=\"http://schemas.android.com/tools\"</div><div class=\"line\">    android:layout_width=\"match_parent\"</div><div class=\"line\">    android:layout_height=\"match_parent\"</div><div class=\"line\">    xmlns:myview=\"http://schemas.android.com/apk/res-auto\"</div><div class=\"line\">    android:paddingBottom=\"@dimen/activity_vertical_margin\"</div><div class=\"line\">    android:paddingLeft=\"@dimen/activity_horizontal_margin\"</div><div class=\"line\">    android:paddingRight=\"@dimen/activity_horizontal_margin\"</div><div class=\"line\">    android:paddingTop=\"@dimen/activity_vertical_margin\"</div><div class=\"line\">    tools:context=\"finch.scu.cn.myview.MainActivity\"&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    &lt;finch.scu.cn.myview.myView</div><div class=\"line\">        android:layout_width=\"match_parent\"</div><div class=\"line\">        android:layout_height=\"match_parent\"</div><div class=\"line\">        myview:TextColor=\"#ff0000\"</div><div class=\"line\">        /&gt;</div><div class=\"line\">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>\n<p>d. 最后是MainActivity</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        setContentView(R.layout.activity_main);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注：具体的view要根据具体的需求来，比如我们要侧滑删除的listview我们可以继承listview，监听侧滑事件，显示删除按钮实现功能。</p>\n<h3 id=\"三-自定义ViewGroup\"><a href=\"#三-自定义ViewGroup\" class=\"headerlink\" title=\"三 自定义ViewGroup\"></a>三 自定义ViewGroup</h3><p>自定义ViewGroup比自定义View要麻烦一些，因为ViewGroup需要去计算子View的大小以此来改变ViewGroup的大小，同时我们还要知道子View的摆放顺序。</p>\n<h5 id=\"1-源码分析\"><a href=\"#1-源码分析\" class=\"headerlink\" title=\"1.源码分析\"></a>1.源码分析</h5><p>等我看了再说</p>\n<p>自定义ViewGroup的时候一般复写：</p>\n<ul>\n<li>onMeasure()方法：<br>计算childView的测量值以及模式，以及设置自己的宽和高　 　　 </li>\n<li>onLayout()方法<br>对其所有childView的位置进行定位</li>\n</ul>\n<h5 id=\"2-代码示例\"><a href=\"#2-代码示例\" class=\"headerlink\" title=\"2.代码示例\"></a>2.代码示例</h5><ul>\n<li>onMeasure方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 获得它的父容器为它设置的测量模式和大小</span></div><div class=\"line\">        <span class=\"keyword\">int</span> sizeWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class=\"line\">        <span class=\"keyword\">int</span> modeWidth = MeasureSpec.getMode(widthMeasureSpec);</div><div class=\"line\">        <span class=\"keyword\">int</span> sizeHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class=\"line\">        <span class=\"keyword\">int</span> modeHeight = MeasureSpec.getMode(heightMeasureSpec);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 用于warp_content情况下，来记录父view宽和高</span></div><div class=\"line\">        <span class=\"keyword\">int</span> width = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> height = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 取每一行宽度的最大值</span></div><div class=\"line\">        <span class=\"keyword\">int</span> lineWidth = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"comment\">// 每一行的高度累加</span></div><div class=\"line\">        <span class=\"keyword\">int</span> lineHeight = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 获得子view的个数</span></div><div class=\"line\">        <span class=\"keyword\">int</span> cCount = getChildCount();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cCount; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            View child = getChildAt(i);</div><div class=\"line\">            <span class=\"comment\">// 测量子View的宽和高（子view在布局文件中是wrap_content）</span></div><div class=\"line\">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class=\"line\">            <span class=\"comment\">// 得到LayoutParams</span></div><div class=\"line\">            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 根据测量宽度加上Margin值算出子view的实际宽度（上文中有说明）</span></div><div class=\"line\">            <span class=\"keyword\">int</span> childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</div><div class=\"line\">            <span class=\"comment\">// 根据测量高度加上Margin值算出子view的实际高度</span></div><div class=\"line\">            <span class=\"keyword\">int</span> childHeight = child.getMeasuredHeight() + lp.topMargin+ lp.bottomMargin;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 这里的父view是有padding值的，如果再添加一个元素就超出最大宽度就换行</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (lineWidth + childWidth &gt; sizeWidth - getPaddingLeft() - getPaddingRight())</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"comment\">// 父view宽度=以前父view宽度、当前行宽的最大值</span></div><div class=\"line\">                width = Math.max(width, lineWidth);</div><div class=\"line\">                <span class=\"comment\">// 换行了，当前行宽=第一个view的宽度</span></div><div class=\"line\">                lineWidth = childWidth;</div><div class=\"line\">                <span class=\"comment\">// 父view的高度=各行高度之和</span></div><div class=\"line\">                height += lineHeight;</div><div class=\"line\">                <span class=\"comment\">//换行了，当前行高=第一个view的高度</span></div><div class=\"line\">                lineHeight = childHeight;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">                <span class=\"comment\">// 叠加行宽</span></div><div class=\"line\">                lineWidth += childWidth;</div><div class=\"line\">                <span class=\"comment\">// 得到当前行最大的高度</span></div><div class=\"line\">                lineHeight = Math.max(lineHeight, childHeight);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">// 最后一个控件</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (i == cCount - <span class=\"number\">1</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                width = Math.max(lineWidth, width);</div><div class=\"line\">                height += lineHeight;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">/**</div><div class=\"line\">         * EXACTLY对应match_parent 或具体值</div><div class=\"line\">         * AT_MOST对应wrap_content</div><div class=\"line\">         * 在FlowLayout布局文件中</div><div class=\"line\">         * android:layout_width=\"fill_parent\"</div><div class=\"line\">         * android:layout_height=\"wrap_content\"</div><div class=\"line\">         *</div><div class=\"line\">         * 如果是MeasureSpec.EXACTLY则直接使用父ViewGroup传入的宽和高，否则设置为自己计算的宽和高。</div><div class=\"line\">         */</span></div><div class=\"line\">        setMeasuredDimension(</div><div class=\"line\">                modeWidth == MeasureSpec.EXACTLY ? sizeWidth : width + getPaddingLeft() + getPaddingRight(),</div><div class=\"line\">                modeHeight == MeasureSpec.EXACTLY ? sizeHeight : height + getPaddingTop()+ getPaddingBottom()</div><div class=\"line\">        );</div><div class=\"line\"></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>onLayout方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//存储所有的View</span></div><div class=\"line\">    <span class=\"keyword\">private</span> List&lt;List&lt;View&gt;&gt; mAllViews = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;View&gt;&gt;();</div><div class=\"line\">    <span class=\"comment\">//存储每一行的高度</span></div><div class=\"line\">    <span class=\"keyword\">private</span> List&lt;Integer&gt; mLineHeight = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        mAllViews.clear();</div><div class=\"line\">        mLineHeight.clear();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 当前ViewGroup的宽度</span></div><div class=\"line\">        <span class=\"keyword\">int</span> width = getWidth();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> lineWidth = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> lineHeight = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"comment\">// 存储每一行所有的childView</span></div><div class=\"line\">        List&lt;View&gt; lineViews = <span class=\"keyword\">new</span> ArrayList&lt;View&gt;();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> cCount = getChildCount();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cCount; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            View child = getChildAt(i);</div><div class=\"line\">            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">int</span> childWidth = child.getMeasuredWidth();</div><div class=\"line\">            <span class=\"keyword\">int</span> childHeight = child.getMeasuredHeight();</div><div class=\"line\"></div><div class=\"line\">            lineWidth += childWidth + lp.leftMargin + lp.rightMargin;</div><div class=\"line\">            lineHeight = Math.max(lineHeight, childHeight + lp.topMargin+ lp.bottomMargin);</div><div class=\"line\">            lineViews.add(child);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 换行，在onMeasure中childWidth是加上Margin值的</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (childWidth + lineWidth + lp.leftMargin + lp.rightMargin &gt; width - getPaddingLeft() - getPaddingRight())</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"comment\">// 记录行高</span></div><div class=\"line\">                mLineHeight.add(lineHeight);</div><div class=\"line\">                <span class=\"comment\">// 记录当前行的Views</span></div><div class=\"line\">                mAllViews.add(lineViews);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// 新行的行宽和行高</span></div><div class=\"line\">                lineWidth = <span class=\"number\">0</span>;</div><div class=\"line\">                lineHeight = childHeight + lp.topMargin + lp.bottomMargin;</div><div class=\"line\">                <span class=\"comment\">// 新行的View集合</span></div><div class=\"line\">                lineViews = <span class=\"keyword\">new</span> ArrayList&lt;View&gt;();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 处理最后一行</span></div><div class=\"line\">        mLineHeight.add(lineHeight);</div><div class=\"line\">        mAllViews.add(lineViews);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 设置子View的位置</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">int</span> left = getPaddingLeft();</div><div class=\"line\">        <span class=\"keyword\">int</span> top = getPaddingTop();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 行数</span></div><div class=\"line\">        <span class=\"keyword\">int</span> lineNum = mAllViews.size();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; lineNum; i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"comment\">// 当前行的所有的View</span></div><div class=\"line\">            lineViews = mAllViews.get(i);</div><div class=\"line\">            lineHeight = mLineHeight.get(i);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; lineViews.size(); j++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                View child = lineViews.get(j);</div><div class=\"line\">                <span class=\"comment\">// 判断child的状态</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (child.getVisibility() == View.GONE)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">int</span> lc = left + lp.leftMargin;</div><div class=\"line\">                <span class=\"keyword\">int</span> tc = top + lp.topMargin;</div><div class=\"line\">                <span class=\"keyword\">int</span> rc = lc + child.getMeasuredWidth();</div><div class=\"line\">                <span class=\"keyword\">int</span> bc = tc + child.getMeasuredHeight();</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// 为子View进行布局</span></div><div class=\"line\">                child.layout(lc, tc, rc, bc);</div><div class=\"line\"></div><div class=\"line\">                left += child.getMeasuredWidth() + lp.leftMargin+ lp.rightMargin;</div><div class=\"line\">            &#125;</div><div class=\"line\">            left = getPaddingLeft() ;</div><div class=\"line\">            top += lineHeight ;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 因为我们只需要支持margin，所以直接使用系统的MarginLayoutParams</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LayoutParams <span class=\"title\">generateLayoutParams</span><span class=\"params\">(AttributeSet attrs)</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MarginLayoutParams(getContext(), attrs);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>MainActivity.java</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    LayoutInflater mInflater;</div><div class=\"line\">    <span class=\"meta\">@InjectView</span>(R.id.id_flowlayout1)</div><div class=\"line\">    FlowLayout idFlowlayout1;</div><div class=\"line\">    <span class=\"meta\">@InjectView</span>(R.id.id_flowlayout2)</div><div class=\"line\">    FlowLayout idFlowlayout2;</div><div class=\"line\">    <span class=\"keyword\">private</span> String[] mVals = <span class=\"keyword\">new</span> String[]</div><div class=\"line\">            &#123;<span class=\"string\">\"Do\"</span>, <span class=\"string\">\"one thing\"</span>, <span class=\"string\">\"at a time\"</span>, <span class=\"string\">\"and do well.\"</span>, <span class=\"string\">\"Never\"</span>, <span class=\"string\">\"forget\"</span>,</div><div class=\"line\">                    <span class=\"string\">\"to say\"</span>, <span class=\"string\">\"thanks.\"</span>, <span class=\"string\">\"Keep on\"</span>, <span class=\"string\">\"going \"</span>, <span class=\"string\">\"never give up.\"</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        setContentView(R.layout.activity_main);</div><div class=\"line\">        ButterKnife.inject(<span class=\"keyword\">this</span>);</div><div class=\"line\">        mInflater = LayoutInflater.from(<span class=\"keyword\">this</span>);</div><div class=\"line\">        initFlowlayout2();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initFlowlayout2</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mVals.length; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> RelativeLayout rl2 = (RelativeLayout) mInflater.inflate(R.layout.flow_layout, idFlowlayout2, <span class=\"keyword\">false</span>);</div><div class=\"line\">            TextView tv2 = (TextView) rl2.findViewById(R.id.tv);</div><div class=\"line\">            tv2.setText(mVals[i]);</div><div class=\"line\">            rl2.setTag(i);</div><div class=\"line\">            idFlowlayout2.addView(rl2);</div><div class=\"line\">            rl2.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">                    <span class=\"keyword\">int</span> i = (<span class=\"keyword\">int</span>) v.getTag();</div><div class=\"line\">                    addViewToFlowlayout1(i);</div><div class=\"line\">                    rl2.setBackgroundResource(R.drawable.flow_layout_disable_bg);</div><div class=\"line\">                    rl2.setClickable(<span class=\"keyword\">false</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addViewToFlowlayout1</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</div><div class=\"line\">        RelativeLayout rl1 = (RelativeLayout) mInflater.inflate(R.layout.flow_layout, idFlowlayout1, <span class=\"keyword\">false</span>);</div><div class=\"line\">        ImageView iv = (ImageView) rl1.findViewById(R.id.iv);</div><div class=\"line\">        iv.setVisibility(View.VISIBLE);</div><div class=\"line\">        TextView tv1 = (TextView) rl1.findViewById(R.id.tv);</div><div class=\"line\">        tv1.setText(mVals[i]);</div><div class=\"line\">        rl1.setTag(i);</div><div class=\"line\">        idFlowlayout1.addView(rl1);</div><div class=\"line\">        rl1.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> i = (<span class=\"keyword\">int</span>) v.getTag();</div><div class=\"line\">                idFlowlayout1.removeView(v);</div><div class=\"line\">                View view = idFlowlayout2.getChildAt(i);</div><div class=\"line\">                view.setClickable(<span class=\"keyword\">true</span>);</div><div class=\"line\">                view.setBackgroundResource(R.drawable.flow_layout_bg);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"四-总结\"><a href=\"#四-总结\" class=\"headerlink\" title=\"四 总结\"></a>四 总结</h3>"},{"title":"android基础之进程间通信","date":"2017-02-28T10:00:00.000Z","_content":"","source":"_posts/android基础之进程间通信.md","raw":"---\ntitle: android基础之进程间通信\ndate: 2017-02-28 18:00:00\ncategories:\ntags:\n---\n","slug":"android基础之进程间通信","published":1,"updated":"2017-02-28T10:00:00.191Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk2a001vaknzfdgtqtp0","content":"","excerpt":"","more":""},{"title":"hexo搭建博客指南（一）--建站","date":"2017-02-16T07:08:29.000Z","_content":"### 一 hexo简介   \n\n> hexo是一款快速，高效，简洁的博客框架。\n\n### 二 搭建博客   \n\n#### 2.1 安装环境\n\n&emsp;&emsp;hexo是基于node.js的，因此要想使用hexo，必须安装node环境，同时还需要git，用于将hexo部署到github上。所需软件：  \nnode.js &emsp;&emsp;下载链接：[http://nodejs.cn/download/](http://nodejs.cn/download/)  \ngit &emsp;&emsp;&emsp;&emsp;下载链接：[https://git-for-windows.github.io/](https://git-for-windows.github.io/)  \n\n\n下载后直接安装，完成后打开windows的cmd，输入以下命令：  \n\n``` bash\nnode -v    \nnpm -v \n```        \n\n当出现以下信息时，则说明安装成功。    \n   \n``` bash\nzhengrui-ds@ZHENGRUI-DS MINGW64 ~\n$ node -v\nv6.9.4\n\nzhengrui-ds@ZHENGRUI-DS MINGW64 ~\n$ npm -v\n3.10.10\n```\n\n\n#### 2.2 安装hexo    \n\n安装客户端   \n\n```bash\nnpm install -g hexo-cli    \n```   \n\n安装服务端  \n\n```bash\nnpm install hexo --save   \n```   \n\n新建一个用于装在hexo的文件夹，如hexo  \n切换到该文件夹，执行以下命令：   \n\n```bash\n hexo init  //初始化该文件夹  \n npm install  //安装相应的依赖包\n```    \n\n此时hexo搭建博客已基本完成。可执行以下命令来查看博客的初始效果：  \n\n```bash\n\thexo clean   //清空public文件夹下面的内容，该文件夹用于存放生成的网页文件。  \n\thexo g       //该命令用于产生相应的网页文件，在public文件夹下  \n\thexo s      //启动一个本地服务器，一般是http://localhost:4000，可查看生成的网页情况。\n```    \n\n**注意**：有时会存在4000端口被占用的情况，此时可以使用hexo s -p 端口号&emsp;来指定端口号。其实如果你有使用linux的经验，应该知道这些命令一般都可以在命令的后面加上-h或者--help来查看它的用法。hexo中的命令可以连写，如hexo g与hexo s可合写成hexo s -g  \n\n#### 2.3 将博客部署到github上  \n&emsp;&emsp;要想将博客部署到github上，你需要先有一个github账号，并且将你本地的git（计算机）与github关联起来。本文已认为你已经有了自己的github账号并已关联本地，如果没有请移步我的另一篇博客TODO  \n其次你需要了解一下hexo的配置文件_config.yml：  \n站点配置\n``` bash\n# Site\ntitle: ZHENGRUI'BLOG\nsubtitle: 今日之果，皆因曾经之因\ndescription:\nauthor: zhengrui\nlanguage: zh-CN\ntimezone:\n``` \n将博客部署到github上  \n``` bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: git@github.com:zhezaoyizhuding/zhezaoyizhuding.github.io.git\n  branch: master\n```  \n你需要执行以下命令，安装hexo的git插件  \n\n```bash\nnpm install hexo-deployer-git --save\n```    \n\n后面要加--save否则无法将依赖写入hexo的package.json中，执行以下命令即可将网站部署到github上。  \n\n```bash\nhexo d\n```  \n\n至此你一讲将博客部署到github上了，在浏览器输入https://你的github用户名.github.io即可访问。","source":"_posts/hexo搭建博客指南（一）-建站.md","raw":"---\ntitle: hexo搭建博客指南（一）--建站\ndate: 2017-02-16 15:08:29\ncategories: hexo\ntags:\n- hexo\n---\n### 一 hexo简介   \n\n> hexo是一款快速，高效，简洁的博客框架。\n\n### 二 搭建博客   \n\n#### 2.1 安装环境\n\n&emsp;&emsp;hexo是基于node.js的，因此要想使用hexo，必须安装node环境，同时还需要git，用于将hexo部署到github上。所需软件：  \nnode.js &emsp;&emsp;下载链接：[http://nodejs.cn/download/](http://nodejs.cn/download/)  \ngit &emsp;&emsp;&emsp;&emsp;下载链接：[https://git-for-windows.github.io/](https://git-for-windows.github.io/)  \n\n\n下载后直接安装，完成后打开windows的cmd，输入以下命令：  \n\n``` bash\nnode -v    \nnpm -v \n```        \n\n当出现以下信息时，则说明安装成功。    \n   \n``` bash\nzhengrui-ds@ZHENGRUI-DS MINGW64 ~\n$ node -v\nv6.9.4\n\nzhengrui-ds@ZHENGRUI-DS MINGW64 ~\n$ npm -v\n3.10.10\n```\n\n\n#### 2.2 安装hexo    \n\n安装客户端   \n\n```bash\nnpm install -g hexo-cli    \n```   \n\n安装服务端  \n\n```bash\nnpm install hexo --save   \n```   \n\n新建一个用于装在hexo的文件夹，如hexo  \n切换到该文件夹，执行以下命令：   \n\n```bash\n hexo init  //初始化该文件夹  \n npm install  //安装相应的依赖包\n```    \n\n此时hexo搭建博客已基本完成。可执行以下命令来查看博客的初始效果：  \n\n```bash\n\thexo clean   //清空public文件夹下面的内容，该文件夹用于存放生成的网页文件。  \n\thexo g       //该命令用于产生相应的网页文件，在public文件夹下  \n\thexo s      //启动一个本地服务器，一般是http://localhost:4000，可查看生成的网页情况。\n```    \n\n**注意**：有时会存在4000端口被占用的情况，此时可以使用hexo s -p 端口号&emsp;来指定端口号。其实如果你有使用linux的经验，应该知道这些命令一般都可以在命令的后面加上-h或者--help来查看它的用法。hexo中的命令可以连写，如hexo g与hexo s可合写成hexo s -g  \n\n#### 2.3 将博客部署到github上  \n&emsp;&emsp;要想将博客部署到github上，你需要先有一个github账号，并且将你本地的git（计算机）与github关联起来。本文已认为你已经有了自己的github账号并已关联本地，如果没有请移步我的另一篇博客TODO  \n其次你需要了解一下hexo的配置文件_config.yml：  \n站点配置\n``` bash\n# Site\ntitle: ZHENGRUI'BLOG\nsubtitle: 今日之果，皆因曾经之因\ndescription:\nauthor: zhengrui\nlanguage: zh-CN\ntimezone:\n``` \n将博客部署到github上  \n``` bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: git@github.com:zhezaoyizhuding/zhezaoyizhuding.github.io.git\n  branch: master\n```  \n你需要执行以下命令，安装hexo的git插件  \n\n```bash\nnpm install hexo-deployer-git --save\n```    \n\n后面要加--save否则无法将依赖写入hexo的package.json中，执行以下命令即可将网站部署到github上。  \n\n```bash\nhexo d\n```  \n\n至此你一讲将博客部署到github上了，在浏览器输入https://你的github用户名.github.io即可访问。","slug":"hexo搭建博客指南（一）-建站","published":1,"updated":"2017-02-23T08:34:12.388Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk2c001zaknzlrfu9opv","content":"<h3 id=\"一-hexo简介\"><a href=\"#一-hexo简介\" class=\"headerlink\" title=\"一 hexo简介\"></a>一 hexo简介</h3><blockquote>\n<p>hexo是一款快速，高效，简洁的博客框架。</p>\n</blockquote>\n<h3 id=\"二-搭建博客\"><a href=\"#二-搭建博客\" class=\"headerlink\" title=\"二 搭建博客\"></a>二 搭建博客</h3><h4 id=\"2-1-安装环境\"><a href=\"#2-1-安装环境\" class=\"headerlink\" title=\"2.1 安装环境\"></a>2.1 安装环境</h4><p>&emsp;&emsp;hexo是基于node.js的，因此要想使用hexo，必须安装node环境，同时还需要git，用于将hexo部署到github上。所需软件：<br>node.js &emsp;&emsp;下载链接：<a href=\"http://nodejs.cn/download/\" target=\"_blank\" rel=\"external\">http://nodejs.cn/download/</a><br>git &emsp;&emsp;&emsp;&emsp;下载链接：<a href=\"https://git-for-windows.github.io/\" target=\"_blank\" rel=\"external\">https://git-for-windows.github.io/</a>  </p>\n<p>下载后直接安装，完成后打开windows的cmd，输入以下命令：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">node -v    </div><div class=\"line\">npm -v </div><div class=\"line\">```        </div><div class=\"line\"></div><div class=\"line\">当出现以下信息时，则说明安装成功。    </div><div class=\"line\">   </div><div class=\"line\">``` bash</div><div class=\"line\">zhengrui-ds@ZHENGRUI-DS MINGW64 ~</div><div class=\"line\">$ node -v</div><div class=\"line\">v6.9.4</div><div class=\"line\"></div><div class=\"line\">zhengrui-ds@ZHENGRUI-DS MINGW64 ~</div><div class=\"line\">$ npm -v</div><div class=\"line\">3.10.10</div></pre></td></tr></table></figure>\n<h4 id=\"2-2-安装hexo\"><a href=\"#2-2-安装hexo\" class=\"headerlink\" title=\"2.2 安装hexo\"></a>2.2 安装hexo</h4><p>安装客户端   </p>\n<pre><code class=\"bash\">npm install -g hexo-cli\n</code></pre>\n<p>安装服务端  </p>\n<pre><code class=\"bash\">npm install hexo --save\n</code></pre>\n<p>新建一个用于装在hexo的文件夹，如hexo<br>切换到该文件夹，执行以下命令：   </p>\n<pre><code class=\"bash\">hexo init  //初始化该文件夹  \nnpm install  //安装相应的依赖包\n</code></pre>\n<p>此时hexo搭建博客已基本完成。可执行以下命令来查看博客的初始效果：  </p>\n<pre><code class=\"bash\">hexo clean   //清空public文件夹下面的内容，该文件夹用于存放生成的网页文件。  \nhexo g       //该命令用于产生相应的网页文件，在public文件夹下  \nhexo s      //启动一个本地服务器，一般是http://localhost:4000，可查看生成的网页情况。\n</code></pre>\n<p><strong>注意</strong>：有时会存在4000端口被占用的情况，此时可以使用hexo s -p 端口号&emsp;来指定端口号。其实如果你有使用linux的经验，应该知道这些命令一般都可以在命令的后面加上-h或者–help来查看它的用法。hexo中的命令可以连写，如hexo g与hexo s可合写成hexo s -g  </p>\n<h4 id=\"2-3-将博客部署到github上\"><a href=\"#2-3-将博客部署到github上\" class=\"headerlink\" title=\"2.3 将博客部署到github上\"></a>2.3 将博客部署到github上</h4><p>&emsp;&emsp;要想将博客部署到github上，你需要先有一个github账号，并且将你本地的git（计算机）与github关联起来。本文已认为你已经有了自己的github账号并已关联本地，如果没有请移步我的另一篇博客TODO<br>其次你需要了解一下hexo的配置文件_config.yml：<br>站点配置</p>\n<pre><code class=\"bash\"><span class=\"comment\"># Site</span>\ntitle: ZHENGRUI<span class=\"string\">'BLOG\nsubtitle: 今日之果，皆因曾经之因\ndescription:\nauthor: zhengrui\nlanguage: zh-CN\ntimezone:</span>\n</code></pre>\n<p>将博客部署到github上  </p>\n<pre><code class=\"bash\"><span class=\"comment\"># Deployment</span>\n<span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span>\ndeploy:\n  <span class=\"built_in\">type</span>: git\n  repo: git@github.com:zhezaoyizhuding/zhezaoyizhuding.github.io.git\n  branch: master\n</code></pre>\n<p>你需要执行以下命令，安装hexo的git插件  </p>\n<pre><code class=\"bash\">npm install hexo-deployer-git --save\n</code></pre>\n<p>后面要加–save否则无法将依赖写入hexo的package.json中，执行以下命令即可将网站部署到github上。  </p>\n<pre><code class=\"bash\">hexo d\n</code></pre>\n<p>至此你一讲将博客部署到github上了，在浏览器输入<a href=\"https://你的github用户名.github.io即可访问。\" target=\"_blank\" rel=\"external\">https://你的github用户名.github.io即可访问。</a></p>\n","excerpt":"","more":"<h3 id=\"一-hexo简介\"><a href=\"#一-hexo简介\" class=\"headerlink\" title=\"一 hexo简介\"></a>一 hexo简介</h3><blockquote>\n<p>hexo是一款快速，高效，简洁的博客框架。</p>\n</blockquote>\n<h3 id=\"二-搭建博客\"><a href=\"#二-搭建博客\" class=\"headerlink\" title=\"二 搭建博客\"></a>二 搭建博客</h3><h4 id=\"2-1-安装环境\"><a href=\"#2-1-安装环境\" class=\"headerlink\" title=\"2.1 安装环境\"></a>2.1 安装环境</h4><p>&emsp;&emsp;hexo是基于node.js的，因此要想使用hexo，必须安装node环境，同时还需要git，用于将hexo部署到github上。所需软件：<br>node.js &emsp;&emsp;下载链接：<a href=\"http://nodejs.cn/download/\">http://nodejs.cn/download/</a><br>git &emsp;&emsp;&emsp;&emsp;下载链接：<a href=\"https://git-for-windows.github.io/\">https://git-for-windows.github.io/</a>  </p>\n<p>下载后直接安装，完成后打开windows的cmd，输入以下命令：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">node -v    </div><div class=\"line\">npm -v </div><div class=\"line\">```        </div><div class=\"line\"></div><div class=\"line\">当出现以下信息时，则说明安装成功。    </div><div class=\"line\">   </div><div class=\"line\">``` bash</div><div class=\"line\">zhengrui-ds@ZHENGRUI-DS MINGW64 ~</div><div class=\"line\">$ node -v</div><div class=\"line\">v6.9.4</div><div class=\"line\"></div><div class=\"line\">zhengrui-ds@ZHENGRUI-DS MINGW64 ~</div><div class=\"line\">$ npm -v</div><div class=\"line\">3.10.10</div></pre></td></tr></table></figure>\n<h4 id=\"2-2-安装hexo\"><a href=\"#2-2-安装hexo\" class=\"headerlink\" title=\"2.2 安装hexo\"></a>2.2 安装hexo</h4><p>安装客户端   </p>\n<pre><code class=\"bash\">npm install -g hexo-cli\n</code></pre>\n<p>安装服务端  </p>\n<pre><code class=\"bash\">npm install hexo --save\n</code></pre>\n<p>新建一个用于装在hexo的文件夹，如hexo<br>切换到该文件夹，执行以下命令：   </p>\n<pre><code class=\"bash\">hexo init  //初始化该文件夹  \nnpm install  //安装相应的依赖包\n</code></pre>\n<p>此时hexo搭建博客已基本完成。可执行以下命令来查看博客的初始效果：  </p>\n<pre><code class=\"bash\">hexo clean   //清空public文件夹下面的内容，该文件夹用于存放生成的网页文件。  \nhexo g       //该命令用于产生相应的网页文件，在public文件夹下  \nhexo s      //启动一个本地服务器，一般是http://localhost:4000，可查看生成的网页情况。\n</code></pre>\n<p><strong>注意</strong>：有时会存在4000端口被占用的情况，此时可以使用hexo s -p 端口号&emsp;来指定端口号。其实如果你有使用linux的经验，应该知道这些命令一般都可以在命令的后面加上-h或者–help来查看它的用法。hexo中的命令可以连写，如hexo g与hexo s可合写成hexo s -g  </p>\n<h4 id=\"2-3-将博客部署到github上\"><a href=\"#2-3-将博客部署到github上\" class=\"headerlink\" title=\"2.3 将博客部署到github上\"></a>2.3 将博客部署到github上</h4><p>&emsp;&emsp;要想将博客部署到github上，你需要先有一个github账号，并且将你本地的git（计算机）与github关联起来。本文已认为你已经有了自己的github账号并已关联本地，如果没有请移步我的另一篇博客TODO<br>其次你需要了解一下hexo的配置文件_config.yml：<br>站点配置</p>\n<pre><code class=\"bash\"><span class=\"comment\"># Site</span>\ntitle: ZHENGRUI<span class=\"string\">'BLOG\nsubtitle: 今日之果，皆因曾经之因\ndescription:\nauthor: zhengrui\nlanguage: zh-CN\ntimezone:</span>\n</code></pre>\n<p>将博客部署到github上  </p>\n<pre><code class=\"bash\"><span class=\"comment\"># Deployment</span>\n<span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span>\ndeploy:\n  <span class=\"built_in\">type</span>: git\n  repo: git@github.com:zhezaoyizhuding/zhezaoyizhuding.github.io.git\n  branch: master\n</code></pre>\n<p>你需要执行以下命令，安装hexo的git插件  </p>\n<pre><code class=\"bash\">npm install hexo-deployer-git --save\n</code></pre>\n<p>后面要加–save否则无法将依赖写入hexo的package.json中，执行以下命令即可将网站部署到github上。  </p>\n<pre><code class=\"bash\">hexo d\n</code></pre>\n<p>至此你一讲将博客部署到github上了，在浏览器输入<a href=\"https://你的github用户名.github.io即可访问。\">https://你的github用户名.github.io即可访问。</a></p>\n"},{"title":"android基础之消息推送","date":"2017-03-01T06:28:10.000Z","_content":"\n### 一 概述\n\n消息推送现在是需要与服务器进行通信的app的基本需求，因此我们有必要了解一下android消息推送的机制。\n\n### 二 几种常见的消息推送的方案\n\n- 轮询(Pull)方式：   \n应用程序应当阶段性的与服务器进行连接并查询是否有新的消息到达，你必须自己实现与服务器之间的通信，例如消息排队等。而且你还要考虑轮询的频率，如果太慢可能导致某些消息的延迟，如果太快，则会大量消耗网络带宽和电池。\n\n- SMS(Push)方式：    \n在Android平台上，你可以通过拦截SMS消息并且解析消息内容来了解服务器的意图，并获取其显示内容进行处理。但是这种方法需要向移动公司缴纳相应的费用。我们目前很难找到免费的短消息发送网关来实现这种方案。\n\n- 长连接(Push)方式：    \n这个方案是现在使用较多的方案。下面主要介绍pull和这种消息推送的方案。\n\n### 三 轮询（pull）原理介绍\n\n##### 1. 原理（即是一个http请求）\n\n其原理在于在android端的程序中，让一个SERVICE一直跑在后台，在规定时间之内调用服务器接口进行数据获取。这里的原理很简单，当然实现起来也不难；然后，这个类之中肯定要做网络数据请求，所以我们在Service中建立一个线程（因为在android系统中网络请求属于长时间操作，不能放主线程，不然会导致异常），在线程中和服务器进行通信。\n\n最后，这个逻辑写完后，我们需要考虑一个问题，如何进行在规定时间内调用该服务器，当然可以用Thread+Handler(这个不是那么稳定),也可以使用AlamManager+Thread（比较稳定），因为我们需要其在后台一直运行，所以可以依靠系统的Alammanager这个类来实现，Alammanager是属于系统的一个闹钟提醒类，通过它我们能实现在规定间隔时间调用，并且也比较稳定，这个service被杀后会自己自动启动服务。\n\n##### 2. 代码示例\n\n\n\n### 四 android长连接（push）消息推送\n\n##### 1. 心跳包机制\n\n所谓的心跳包就是客户端定时放送简单的信息给服务器端，告诉它我还在而已。代码就是每隔几分钟发送一个固定信息给服务器端，服务器端回复一个固定信息。如果服务器端几分钟后没有收到客户端信息则视客户端断开。比如有些通信软件长时间不适用，要想知道它的状态是在线还是离线，就需要心跳包，定时发包收包。　 　\n\n心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活在。事实上这是为了保活长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。 \n\n在TCP机制里面，本身是存在有心跳包机制的，也就是TCP选项:SO_KEEPALIVE. 系统默认是设置的2小时的心跳频率。\n\n##### 2.android系统的推送和iOS的推送的区别\n\nIOS长连接是由系统来维护的，也就是说苹果的IOS系统在系统级别维护了一个客户端和苹果服务器的长链接，IOS上的所有应用上的推送都是先将消息推送到苹果的服务器然后将苹果服务器通过这个系统级别的长链接推送到手机终端上，这样的的几个好处为：\n\n- 在手机终端始终只要维护一个长连接即可，而且由于这个长链接是系统级别的不会出现被杀死而无法推送的情况　\n- 省电，不会出现每个应用都各自维护一个自己的长连接。\n- 安全，只有在苹果注册的开发者才能够进行推送，等等。　\n\nandroid的长连接是由每个应用各自维护的，但是google也推出了和苹果技术架构相似的推送框架，C2DM,云端推送功能，但是由于google的服务器不在中国境内，其他的原因你懂的。所以导致这个推送无法使用，android的开发者不得不自己去维护一个长链接，于是每个应用如果都24小时在线，那么都得各自维护一个长连接，这种电量和流量的消耗是可想而知的。虽然国内也出现了各种推送平台，但是都无法达到只维护一个长连接这种消耗的级别。　\n\n##### 3.几种基于长连接的消息推送方案\n\n- C2DM云端推送功能。\n- MQTT协议实现Android推送功能。\n- RSMB实现推送功能。\n- XMPP协议实现Android推送功能\n- 使用第三方平台。如极光推送\n- 自己搭\n ","source":"_posts/android基础之消息推送.md","raw":"---\ntitle: android基础之消息推送\ndate: 2017-03-01 14:28:10\ncategories: android\ntags:\n- android\n- java\n- 长连接\n- 推送\n- push\n- pull\n---\n\n### 一 概述\n\n消息推送现在是需要与服务器进行通信的app的基本需求，因此我们有必要了解一下android消息推送的机制。\n\n### 二 几种常见的消息推送的方案\n\n- 轮询(Pull)方式：   \n应用程序应当阶段性的与服务器进行连接并查询是否有新的消息到达，你必须自己实现与服务器之间的通信，例如消息排队等。而且你还要考虑轮询的频率，如果太慢可能导致某些消息的延迟，如果太快，则会大量消耗网络带宽和电池。\n\n- SMS(Push)方式：    \n在Android平台上，你可以通过拦截SMS消息并且解析消息内容来了解服务器的意图，并获取其显示内容进行处理。但是这种方法需要向移动公司缴纳相应的费用。我们目前很难找到免费的短消息发送网关来实现这种方案。\n\n- 长连接(Push)方式：    \n这个方案是现在使用较多的方案。下面主要介绍pull和这种消息推送的方案。\n\n### 三 轮询（pull）原理介绍\n\n##### 1. 原理（即是一个http请求）\n\n其原理在于在android端的程序中，让一个SERVICE一直跑在后台，在规定时间之内调用服务器接口进行数据获取。这里的原理很简单，当然实现起来也不难；然后，这个类之中肯定要做网络数据请求，所以我们在Service中建立一个线程（因为在android系统中网络请求属于长时间操作，不能放主线程，不然会导致异常），在线程中和服务器进行通信。\n\n最后，这个逻辑写完后，我们需要考虑一个问题，如何进行在规定时间内调用该服务器，当然可以用Thread+Handler(这个不是那么稳定),也可以使用AlamManager+Thread（比较稳定），因为我们需要其在后台一直运行，所以可以依靠系统的Alammanager这个类来实现，Alammanager是属于系统的一个闹钟提醒类，通过它我们能实现在规定间隔时间调用，并且也比较稳定，这个service被杀后会自己自动启动服务。\n\n##### 2. 代码示例\n\n\n\n### 四 android长连接（push）消息推送\n\n##### 1. 心跳包机制\n\n所谓的心跳包就是客户端定时放送简单的信息给服务器端，告诉它我还在而已。代码就是每隔几分钟发送一个固定信息给服务器端，服务器端回复一个固定信息。如果服务器端几分钟后没有收到客户端信息则视客户端断开。比如有些通信软件长时间不适用，要想知道它的状态是在线还是离线，就需要心跳包，定时发包收包。　 　\n\n心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活在。事实上这是为了保活长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。 \n\n在TCP机制里面，本身是存在有心跳包机制的，也就是TCP选项:SO_KEEPALIVE. 系统默认是设置的2小时的心跳频率。\n\n##### 2.android系统的推送和iOS的推送的区别\n\nIOS长连接是由系统来维护的，也就是说苹果的IOS系统在系统级别维护了一个客户端和苹果服务器的长链接，IOS上的所有应用上的推送都是先将消息推送到苹果的服务器然后将苹果服务器通过这个系统级别的长链接推送到手机终端上，这样的的几个好处为：\n\n- 在手机终端始终只要维护一个长连接即可，而且由于这个长链接是系统级别的不会出现被杀死而无法推送的情况　\n- 省电，不会出现每个应用都各自维护一个自己的长连接。\n- 安全，只有在苹果注册的开发者才能够进行推送，等等。　\n\nandroid的长连接是由每个应用各自维护的，但是google也推出了和苹果技术架构相似的推送框架，C2DM,云端推送功能，但是由于google的服务器不在中国境内，其他的原因你懂的。所以导致这个推送无法使用，android的开发者不得不自己去维护一个长链接，于是每个应用如果都24小时在线，那么都得各自维护一个长连接，这种电量和流量的消耗是可想而知的。虽然国内也出现了各种推送平台，但是都无法达到只维护一个长连接这种消耗的级别。　\n\n##### 3.几种基于长连接的消息推送方案\n\n- C2DM云端推送功能。\n- MQTT协议实现Android推送功能。\n- RSMB实现推送功能。\n- XMPP协议实现Android推送功能\n- 使用第三方平台。如极光推送\n- 自己搭\n ","slug":"android基础之消息推送","published":1,"updated":"2017-03-10T08:04:49.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk2d0021aknzwe6d7x1o","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>消息推送现在是需要与服务器进行通信的app的基本需求，因此我们有必要了解一下android消息推送的机制。</p>\n<h3 id=\"二-几种常见的消息推送的方案\"><a href=\"#二-几种常见的消息推送的方案\" class=\"headerlink\" title=\"二 几种常见的消息推送的方案\"></a>二 几种常见的消息推送的方案</h3><ul>\n<li><p>轮询(Pull)方式：<br>应用程序应当阶段性的与服务器进行连接并查询是否有新的消息到达，你必须自己实现与服务器之间的通信，例如消息排队等。而且你还要考虑轮询的频率，如果太慢可能导致某些消息的延迟，如果太快，则会大量消耗网络带宽和电池。</p>\n</li>\n<li><p>SMS(Push)方式：<br>在Android平台上，你可以通过拦截SMS消息并且解析消息内容来了解服务器的意图，并获取其显示内容进行处理。但是这种方法需要向移动公司缴纳相应的费用。我们目前很难找到免费的短消息发送网关来实现这种方案。</p>\n</li>\n<li><p>长连接(Push)方式：<br>这个方案是现在使用较多的方案。下面主要介绍pull和这种消息推送的方案。</p>\n</li>\n</ul>\n<h3 id=\"三-轮询（pull）原理介绍\"><a href=\"#三-轮询（pull）原理介绍\" class=\"headerlink\" title=\"三 轮询（pull）原理介绍\"></a>三 轮询（pull）原理介绍</h3><h5 id=\"1-原理（即是一个http请求）\"><a href=\"#1-原理（即是一个http请求）\" class=\"headerlink\" title=\"1. 原理（即是一个http请求）\"></a>1. 原理（即是一个http请求）</h5><p>其原理在于在android端的程序中，让一个SERVICE一直跑在后台，在规定时间之内调用服务器接口进行数据获取。这里的原理很简单，当然实现起来也不难；然后，这个类之中肯定要做网络数据请求，所以我们在Service中建立一个线程（因为在android系统中网络请求属于长时间操作，不能放主线程，不然会导致异常），在线程中和服务器进行通信。</p>\n<p>最后，这个逻辑写完后，我们需要考虑一个问题，如何进行在规定时间内调用该服务器，当然可以用Thread+Handler(这个不是那么稳定),也可以使用AlamManager+Thread（比较稳定），因为我们需要其在后台一直运行，所以可以依靠系统的Alammanager这个类来实现，Alammanager是属于系统的一个闹钟提醒类，通过它我们能实现在规定间隔时间调用，并且也比较稳定，这个service被杀后会自己自动启动服务。</p>\n<h5 id=\"2-代码示例\"><a href=\"#2-代码示例\" class=\"headerlink\" title=\"2. 代码示例\"></a>2. 代码示例</h5><h3 id=\"四-android长连接（push）消息推送\"><a href=\"#四-android长连接（push）消息推送\" class=\"headerlink\" title=\"四 android长连接（push）消息推送\"></a>四 android长连接（push）消息推送</h3><h5 id=\"1-心跳包机制\"><a href=\"#1-心跳包机制\" class=\"headerlink\" title=\"1. 心跳包机制\"></a>1. 心跳包机制</h5><p>所谓的心跳包就是客户端定时放送简单的信息给服务器端，告诉它我还在而已。代码就是每隔几分钟发送一个固定信息给服务器端，服务器端回复一个固定信息。如果服务器端几分钟后没有收到客户端信息则视客户端断开。比如有些通信软件长时间不适用，要想知道它的状态是在线还是离线，就需要心跳包，定时发包收包。　 　</p>\n<p>心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活在。事实上这是为了保活长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。 </p>\n<p>在TCP机制里面，本身是存在有心跳包机制的，也就是TCP选项:SO_KEEPALIVE. 系统默认是设置的2小时的心跳频率。</p>\n<h5 id=\"2-android系统的推送和iOS的推送的区别\"><a href=\"#2-android系统的推送和iOS的推送的区别\" class=\"headerlink\" title=\"2.android系统的推送和iOS的推送的区别\"></a>2.android系统的推送和iOS的推送的区别</h5><p>IOS长连接是由系统来维护的，也就是说苹果的IOS系统在系统级别维护了一个客户端和苹果服务器的长链接，IOS上的所有应用上的推送都是先将消息推送到苹果的服务器然后将苹果服务器通过这个系统级别的长链接推送到手机终端上，这样的的几个好处为：</p>\n<ul>\n<li>在手机终端始终只要维护一个长连接即可，而且由于这个长链接是系统级别的不会出现被杀死而无法推送的情况　</li>\n<li>省电，不会出现每个应用都各自维护一个自己的长连接。</li>\n<li>安全，只有在苹果注册的开发者才能够进行推送，等等。　</li>\n</ul>\n<p>android的长连接是由每个应用各自维护的，但是google也推出了和苹果技术架构相似的推送框架，C2DM,云端推送功能，但是由于google的服务器不在中国境内，其他的原因你懂的。所以导致这个推送无法使用，android的开发者不得不自己去维护一个长链接，于是每个应用如果都24小时在线，那么都得各自维护一个长连接，这种电量和流量的消耗是可想而知的。虽然国内也出现了各种推送平台，但是都无法达到只维护一个长连接这种消耗的级别。　</p>\n<h5 id=\"3-几种基于长连接的消息推送方案\"><a href=\"#3-几种基于长连接的消息推送方案\" class=\"headerlink\" title=\"3.几种基于长连接的消息推送方案\"></a>3.几种基于长连接的消息推送方案</h5><ul>\n<li>C2DM云端推送功能。</li>\n<li>MQTT协议实现Android推送功能。</li>\n<li>RSMB实现推送功能。</li>\n<li>XMPP协议实现Android推送功能</li>\n<li>使用第三方平台。如极光推送</li>\n<li>自己搭</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>消息推送现在是需要与服务器进行通信的app的基本需求，因此我们有必要了解一下android消息推送的机制。</p>\n<h3 id=\"二-几种常见的消息推送的方案\"><a href=\"#二-几种常见的消息推送的方案\" class=\"headerlink\" title=\"二 几种常见的消息推送的方案\"></a>二 几种常见的消息推送的方案</h3><ul>\n<li><p>轮询(Pull)方式：<br>应用程序应当阶段性的与服务器进行连接并查询是否有新的消息到达，你必须自己实现与服务器之间的通信，例如消息排队等。而且你还要考虑轮询的频率，如果太慢可能导致某些消息的延迟，如果太快，则会大量消耗网络带宽和电池。</p>\n</li>\n<li><p>SMS(Push)方式：<br>在Android平台上，你可以通过拦截SMS消息并且解析消息内容来了解服务器的意图，并获取其显示内容进行处理。但是这种方法需要向移动公司缴纳相应的费用。我们目前很难找到免费的短消息发送网关来实现这种方案。</p>\n</li>\n<li><p>长连接(Push)方式：<br>这个方案是现在使用较多的方案。下面主要介绍pull和这种消息推送的方案。</p>\n</li>\n</ul>\n<h3 id=\"三-轮询（pull）原理介绍\"><a href=\"#三-轮询（pull）原理介绍\" class=\"headerlink\" title=\"三 轮询（pull）原理介绍\"></a>三 轮询（pull）原理介绍</h3><h5 id=\"1-原理（即是一个http请求）\"><a href=\"#1-原理（即是一个http请求）\" class=\"headerlink\" title=\"1. 原理（即是一个http请求）\"></a>1. 原理（即是一个http请求）</h5><p>其原理在于在android端的程序中，让一个SERVICE一直跑在后台，在规定时间之内调用服务器接口进行数据获取。这里的原理很简单，当然实现起来也不难；然后，这个类之中肯定要做网络数据请求，所以我们在Service中建立一个线程（因为在android系统中网络请求属于长时间操作，不能放主线程，不然会导致异常），在线程中和服务器进行通信。</p>\n<p>最后，这个逻辑写完后，我们需要考虑一个问题，如何进行在规定时间内调用该服务器，当然可以用Thread+Handler(这个不是那么稳定),也可以使用AlamManager+Thread（比较稳定），因为我们需要其在后台一直运行，所以可以依靠系统的Alammanager这个类来实现，Alammanager是属于系统的一个闹钟提醒类，通过它我们能实现在规定间隔时间调用，并且也比较稳定，这个service被杀后会自己自动启动服务。</p>\n<h5 id=\"2-代码示例\"><a href=\"#2-代码示例\" class=\"headerlink\" title=\"2. 代码示例\"></a>2. 代码示例</h5><h3 id=\"四-android长连接（push）消息推送\"><a href=\"#四-android长连接（push）消息推送\" class=\"headerlink\" title=\"四 android长连接（push）消息推送\"></a>四 android长连接（push）消息推送</h3><h5 id=\"1-心跳包机制\"><a href=\"#1-心跳包机制\" class=\"headerlink\" title=\"1. 心跳包机制\"></a>1. 心跳包机制</h5><p>所谓的心跳包就是客户端定时放送简单的信息给服务器端，告诉它我还在而已。代码就是每隔几分钟发送一个固定信息给服务器端，服务器端回复一个固定信息。如果服务器端几分钟后没有收到客户端信息则视客户端断开。比如有些通信软件长时间不适用，要想知道它的状态是在线还是离线，就需要心跳包，定时发包收包。　 　</p>\n<p>心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活在。事实上这是为了保活长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。 </p>\n<p>在TCP机制里面，本身是存在有心跳包机制的，也就是TCP选项:SO_KEEPALIVE. 系统默认是设置的2小时的心跳频率。</p>\n<h5 id=\"2-android系统的推送和iOS的推送的区别\"><a href=\"#2-android系统的推送和iOS的推送的区别\" class=\"headerlink\" title=\"2.android系统的推送和iOS的推送的区别\"></a>2.android系统的推送和iOS的推送的区别</h5><p>IOS长连接是由系统来维护的，也就是说苹果的IOS系统在系统级别维护了一个客户端和苹果服务器的长链接，IOS上的所有应用上的推送都是先将消息推送到苹果的服务器然后将苹果服务器通过这个系统级别的长链接推送到手机终端上，这样的的几个好处为：</p>\n<ul>\n<li>在手机终端始终只要维护一个长连接即可，而且由于这个长链接是系统级别的不会出现被杀死而无法推送的情况　</li>\n<li>省电，不会出现每个应用都各自维护一个自己的长连接。</li>\n<li>安全，只有在苹果注册的开发者才能够进行推送，等等。　</li>\n</ul>\n<p>android的长连接是由每个应用各自维护的，但是google也推出了和苹果技术架构相似的推送框架，C2DM,云端推送功能，但是由于google的服务器不在中国境内，其他的原因你懂的。所以导致这个推送无法使用，android的开发者不得不自己去维护一个长链接，于是每个应用如果都24小时在线，那么都得各自维护一个长连接，这种电量和流量的消耗是可想而知的。虽然国内也出现了各种推送平台，但是都无法达到只维护一个长连接这种消耗的级别。　</p>\n<h5 id=\"3-几种基于长连接的消息推送方案\"><a href=\"#3-几种基于长连接的消息推送方案\" class=\"headerlink\" title=\"3.几种基于长连接的消息推送方案\"></a>3.几种基于长连接的消息推送方案</h5><ul>\n<li>C2DM云端推送功能。</li>\n<li>MQTT协议实现Android推送功能。</li>\n<li>RSMB实现推送功能。</li>\n<li>XMPP协议实现Android推送功能</li>\n<li>使用第三方平台。如极光推送</li>\n<li>自己搭</li>\n</ul>\n"},{"title":"http协议与https","date":"2017-04-01T02:44:16.000Z","_content":"\n### 一 HTTP协议\n\nHTTP（HyperText Transfer Protocol，超文本传输协议）是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\n##### HTTP协议的特点\n\n- 支持客户端/服务器（B/S）模式\n\n- 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。\n\n- 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。\n\n- 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n\n- 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n\n##### 客户端通过HTTP想服务器请求资源的过程\n\n- 浏览器分析连接指向的URL，\n- 浏览器请求DNS服务器解析域名的IP地址。\n- 根据IP地址浏览器与服务器建立TCP连接，\n- 浏览器发出请求（GET）\n- 服务器响应，发送资源。\n- 释放TCP连接。\n\n##### HTTP请求\n\n客户端通过一个HTTP请求从服务器请求消息。HTTP请求分为请求行，请求头，空行，请求数据。\n\n1.**请求行**：请求行由三个标记组成--请求方法，请求URI和HTTP版本，它们由空格分隔。\n\n例如：\n\n```bash\nGET /index.html HTTP/1.1\n```\n\nHTTP规范定义了八种可能的请求方法：\n\n- GET：检索URI中标识资源的一个简单请求\n- HEAD：与GET方法相同，服务器只返回状态行和头标，并不返回请求文档\n- POST：服务器接受被写入客户端输出流中的数据的请求\n- PUT：服务器保存请求数据作为指定URI新内容的请求\n- DELETE：服务器删除URI中命名的资源的请求\n- OPTIONS：关于服务器支持的请求方法信息的请求\n- TRACE：Web服务器反馈Http请求和其头标的请求\n- CONNECT：已文档化但当前未实现的一个方法，预留做隧道处理\n\n2.**请求头标**：由关键字/值对组成，每行一对，关键字和值用冒号（:）分隔。\n请求头标通知服务器有关于客户端的功能和标识（cookie就是放在请求头中），典型的请求头标有：\nUser-Agent        客户端厂家和版本\nAccept            客户端可识别的内容类型列表\nContent-Length    附加到请求的数据字节数\n\n3.**空行**：最后一个请求头标之后是一个空行，发送回车符和退行，通知服务器以下不再有头标。\n\n4.**请求数据**：使用POST传送数据，最常使用的是Content-Type和Content-Length头标。\n\n##### HTTP响应\n\nWeb服务器解析请求，定位指定资源。服务器将资源副本写至套接字（即端口），在此处由客户端读取。\n一个响应由四个部分组成；状态行、响应头标、空行、响应数据\n\n1.**状态行**：状态行由三个标记组成：HTTP版本、响应代码和响应描述。\nHTTP版本：向客户端指明其可理解的最高版本。\n响应代码：3位的数字代码，指出请求的成功或失败，如果失败则指出原因。\n响应描述：为响应代码的可读性解释。\n例如：HTTP/1.1 200 OK\n\nHTTP响应码：\n\n- 1xx：信息，请求收到，继续处理\n- 2xx：成功，行为被成功地接受、理解和采纳\n- 3xx：重定向，为了完成请求，必须进一步执行的动作\n- 4xx：客户端错误，请求包含语法错误或者请求无法实现\n- 5xx：服务器错误，服务器不能实现一种明显无效的请求\n\n下表显示每个响应码及其含义：\n\n```bash\n100     继续。客户端应继续其请求\n101     切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议\n200     OK，请求成功。一般用于GET与POST请求\n201     已创建。成功请求并创建了新的资源\n202     已接受。已经接受请求，但未处理完成\n203     非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本\n204     无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档\n205     重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域\n206     部分内容。服务器成功处理了部分GET请求\n300     多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如浏览器）选择\n301     永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替\n302     临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI\n303     查看其它地址。与301类似。使用GET和POST请求查看\n304     未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源\n305     使用代理。所请求的资源必须通过代理访问\n307     临时重定向。与302类似。使用GET请求重定向\n400     客户端请求的语法错误，服务器无法理解\n401     请求要求用户的身份认证\n402     保留，将来使用\n403     服务器理解请求客户端的请求，但是拒绝执行此请求\n404     服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面\n405     客户端请求中的方法被禁止\n406     服务器无法根据客户端请求的内容特性完成请求\n407     请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权\n408     服务器等待客户端发送的请求时间过长，超时\n409     服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突\n410     客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置\n411     服务器无法处理客户端发送的不带Content-Length的请求信息\n412     客户端请求信息的先决条件错误\n413     由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息\n414     请求的URI过长（URI通常为网址），服务器无法处理\n415     服务器无法处理请求附带的媒体格式\n416     客户端请求的范围无效\n417     服务器无法满足Expect的请求头信息\n500     服务器内部错误，无法完成请求\n501     服务器不支持请求的功能，无法完成请求\n502     充当网关或代理的服务器，从远端服务器接收到了一个无效的请求\n503     由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中\n504     充当网关或代理的服务器，未及时从远端服务器获取请求\n505     服务器不支持请求的HTTP协议的版本，无法完成处理\n```\n\n2.**响应头标**：像请求头标一样，它们指出服务器的功能，标识出响应数据的细节。\n\n3.**空行**：最后一个响应头标之后是一个空行，发送回车符和退行，表明服务器以下不再有头标。\n\n4.**响应数据**：HTML文档和图像等，也就是HTML本身。\n\n浏览器解析HTTp响应显示数据的过程：\n\n- 浏览器首先解析状态行，查看表明请求是否成功的状态代码。\n- 然后解析每一个响应头标，头标告知以下为若干字节的HTML。\n- 读取响应数据HTML，根据HTML的语法和语义对其进行格式化，并在浏览器窗口中显示它。\n- 一个HTML文档可能包含其它需要被载入的资源引用，浏览器识别这些引用，对其它的资源再进行额外的请求，此过程循环多次。\n\n##### HTTP1.0与HTTP1.1的区别\n\n一个WEB站点每天可能要接收到上百万的用户请求，为了提高系统的效率，**HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求**。但是，这也造成了一些性能上的缺陷，例如，一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的URL地址，当WEB浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析WEB服务器返回的该网页文档中的HTML内容时，发现其中的<img>图像标签后，浏览器将根据<img>标签中的src属性所指定的URL地址再次向服务器发出下载图像数据的请求，如下图所示。\n\n{% asset_img 474814076.png %}\n\n显 然，访问一个包含有许多图像的网页文件的整个过程包含了多次请求和响应，每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个文档和图像，上一次和下一次请求完全分离。即使图像文件都很小，但是客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程，并且会严重影响客户机和服务器的性 能。当一个网页文件中包含Applet，JavaScript文件，CSS文件等内容时，也会出现类似上述的情况。\n\n为了克服HTTP 1.0的这个缺陷，**HTTP 1.1支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。**一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。**HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。**基于HTTP 1.1协议的客户机与服务器的信息交换过程，如下图所示。\n\n{% asset_img 1146631942.png %}\n\n可见，HTTP 1.1在继承了HTTP 1.0优点的基础上，也克服了HTTP 1.0的性能问题。不仅如此，HTTP 1.1还通过增加更多的请求头和响应头来改进和扩充HTTP 1.0的功能。例如，**由于HTTP 1.0不支持Host请求头字段**，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个IP地址和端口号上配置多个虚拟WEB站点。在HTTP 1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。**HTTP 1.1的持续连接（长连接），也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。**HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。（具体的可以看HTTP的RFC规范）\n\n##### HTTP1.1与HTTP2.0的区别\n\nHTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0），是HTTP协议的的第二个主要版本，使用于万维网。HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议。\n\n与HTTP/1相比，主要区别包括：\n\n- HTTP/2采用二进制格式而非文本格式\n- HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行\n- 使用报头压缩，HTTP/2降低了开销\n- HTTP/2让服务器可以将响应主动“推送”到客户端缓存中\n\nHTTP/2为什么是二进制？\n\n比起像HTTP/1.x这样的文本协议，二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少\n\n为什么 HTTP/2 需要多路传输?\n\nHTTP/1.x 有个问题叫线端阻塞(head-of-line blocking), 它是指一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢。HTTP/1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求). 此外, 由于网络媒介(intermediary )和服务器不能很好的支持流水线, 导致部署起来困难重重。而多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。所以客户端只需要一个连接就能加载一个页面。\n\n消息头为什么需要压缩?\n\n假定一个页面有80个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1400字节的消息头（着同样也并不少见，因为Cookie和引用等东西的存在）, 至少要7到8个来回去“在线”获得这些消息头。这还不包括响应时间——那只是从客户端那里获取到它们所花的时间而已。这全都由于TCP的慢启动机制，它会基于对已知有多少个包，来确定还要来回去获取哪些包 – 这很明显的限制了最初的几个来回可以发送的数据包的数量。相比之下，即使是头部轻微的压缩也可以是让那些请求只需一个来回就能搞定——有时候甚至一个包就可以了。这种开销是可以被节省下来的，特别是当你考虑移动客户端应用的时候，即使是良好条件下，一般也会看到几百毫秒的来回延迟。\n\n服务器推送的好处是什么？\n\n当浏览器请求一个网页时，服务器将会发回HTML，在服务器开始发送JavaScript、图片和CSS前，服务器需要等待浏览器解析HTML和发送所有内嵌资源的请求。服务器推送服务通过“推送”那些它认为客户端将会需要的内容到客户端的缓存中，以此来避免往返的延迟。\n\n### 二 HTTPS简介\n\n由于HTTP通信是明文通信的，这样发送中的数据将受到威胁。如：\n\n- 窃听风险（eavesdropping）：第三方可以获知通信内容。\n- 篡改风险（tampering）：第三方可以修改通信内容。\n- 冒充风险（pretending）：第三方可以冒充他人身份参与通信。\n\n因此出现了HTTPS，希望达到：\n\n- 所有信息都是加密传播，第三方无法窃听。\n- 具有校验机制，一旦被篡改，通信双方会立刻发现。\n- 配备身份证书，防止身份被冒充。\n\n##### 概述\n\nHTTPS 可以认为是 HTTP + TLS/SSL,它的发展历史如下：\n\n- 1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。\n- 1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。\n- 1996年，SSL 3.0版问世，得到大规模应用。\n- 1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。\n- 2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。\n\n目前常用的 HTTP 协议是 HTTP1.1，常用的 TLS 协议版本有如下几个：TLS1.2, TLS1.1, TLS1.0 和 SSL3.0。其中 SSL3.0 由于 POODLE 攻击已经被证明不安全，但统计发现依然有不到 1% 的浏览器使用 SSL3.0。TLS1.0 也存在部分安全漏洞，比如 RC4 和 BEAST 攻击。TLS1.2 和 TLS1.1 暂时没有已知的安全漏洞，比较安全，同时有大量扩展提升速度和性能，推荐大家使用。需要关注一点的就是 TLS1.3 将会是 TLS 协议一个非常重大的改革。不管是安全性还是用户访问速度都会有质的提升。不过目前没有明确的发布时间。同时 HTTP2 也已经正式定稿，这个由 SPDY 协议演化而来的协议相比 HTTP1.1 又是一个非常重大的变动，能够明显提升应用层数据的传输效率。\n\n##### HTTPS原理\n\nHTTPS内容加密的过程可以简述成：用对称加密来加密数据，用公钥加密来加密对称加密的秘钥（这句话其实并不准确，因为通信是传输的并不是秘钥本身，而是用于生成秘钥的随机数）。要实现这个客户端和服务器要通过四次握手。如下图：\n\n{% asset_img HTTPS握手图.jpg HTTPS四次握手图 %}\n\n1.客户端发出请求（ClientHello）\n\n首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。在这一步，客户端主要向服务器提供以下信息：\n\n- 支持的协议版本，比如TLS 1.0版。\n- 一个客户端生成的随机数，稍后用于生成\"对话密钥\"。（这是关键）\n- 支持的加密方法，比如RSA公钥加密。\n- 支持的压缩方法。\n\n2.服务器回应（SeverHello）\n\n服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容：\n\n- 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。\n- 一个服务器生成的随机数，稍后用于生成\"对话密钥\"。\n- 确认使用的加密方法，比如RSA公钥加密。\n- 服务器证书。（含公钥加密的公钥，用于加密premaster_secrect）\n\n除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供\"客户端证书\"。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。\n\n3.客户端回应\n\n客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息：\n\n- 一个随机数。该随机数用服务器公钥加密，防止被窃听。（这个随机数就是premaster_secrect）\n- 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。\n- 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。\n\n此时客户端和服务器同时都有了三个随机数，它们将通多相同的秘钥生成器（秘钥生成算法）来获得相同的“会话秘钥”。\n\n至于为什么使用三个随机数而不是直接随机生成秘钥，大神们回答如下：\n\n> \"不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre_master     secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。\"\n\n此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。\n\n4.服务器的最后回应\n\n- 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。\n- 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。\n\n至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用\"会话密钥\"加密内容。\n\n\n\n\n\n\n","source":"_posts/http协议与https.md","raw":"---\ntitle: http协议与https\ndate: 2017-04-01 10:44:16\ncategories: 网络协议\ntags:\n- HTTP\n- HTTPS\n---\n\n### 一 HTTP协议\n\nHTTP（HyperText Transfer Protocol，超文本传输协议）是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\n##### HTTP协议的特点\n\n- 支持客户端/服务器（B/S）模式\n\n- 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。\n\n- 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。\n\n- 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n\n- 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n\n##### 客户端通过HTTP想服务器请求资源的过程\n\n- 浏览器分析连接指向的URL，\n- 浏览器请求DNS服务器解析域名的IP地址。\n- 根据IP地址浏览器与服务器建立TCP连接，\n- 浏览器发出请求（GET）\n- 服务器响应，发送资源。\n- 释放TCP连接。\n\n##### HTTP请求\n\n客户端通过一个HTTP请求从服务器请求消息。HTTP请求分为请求行，请求头，空行，请求数据。\n\n1.**请求行**：请求行由三个标记组成--请求方法，请求URI和HTTP版本，它们由空格分隔。\n\n例如：\n\n```bash\nGET /index.html HTTP/1.1\n```\n\nHTTP规范定义了八种可能的请求方法：\n\n- GET：检索URI中标识资源的一个简单请求\n- HEAD：与GET方法相同，服务器只返回状态行和头标，并不返回请求文档\n- POST：服务器接受被写入客户端输出流中的数据的请求\n- PUT：服务器保存请求数据作为指定URI新内容的请求\n- DELETE：服务器删除URI中命名的资源的请求\n- OPTIONS：关于服务器支持的请求方法信息的请求\n- TRACE：Web服务器反馈Http请求和其头标的请求\n- CONNECT：已文档化但当前未实现的一个方法，预留做隧道处理\n\n2.**请求头标**：由关键字/值对组成，每行一对，关键字和值用冒号（:）分隔。\n请求头标通知服务器有关于客户端的功能和标识（cookie就是放在请求头中），典型的请求头标有：\nUser-Agent        客户端厂家和版本\nAccept            客户端可识别的内容类型列表\nContent-Length    附加到请求的数据字节数\n\n3.**空行**：最后一个请求头标之后是一个空行，发送回车符和退行，通知服务器以下不再有头标。\n\n4.**请求数据**：使用POST传送数据，最常使用的是Content-Type和Content-Length头标。\n\n##### HTTP响应\n\nWeb服务器解析请求，定位指定资源。服务器将资源副本写至套接字（即端口），在此处由客户端读取。\n一个响应由四个部分组成；状态行、响应头标、空行、响应数据\n\n1.**状态行**：状态行由三个标记组成：HTTP版本、响应代码和响应描述。\nHTTP版本：向客户端指明其可理解的最高版本。\n响应代码：3位的数字代码，指出请求的成功或失败，如果失败则指出原因。\n响应描述：为响应代码的可读性解释。\n例如：HTTP/1.1 200 OK\n\nHTTP响应码：\n\n- 1xx：信息，请求收到，继续处理\n- 2xx：成功，行为被成功地接受、理解和采纳\n- 3xx：重定向，为了完成请求，必须进一步执行的动作\n- 4xx：客户端错误，请求包含语法错误或者请求无法实现\n- 5xx：服务器错误，服务器不能实现一种明显无效的请求\n\n下表显示每个响应码及其含义：\n\n```bash\n100     继续。客户端应继续其请求\n101     切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议\n200     OK，请求成功。一般用于GET与POST请求\n201     已创建。成功请求并创建了新的资源\n202     已接受。已经接受请求，但未处理完成\n203     非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本\n204     无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档\n205     重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域\n206     部分内容。服务器成功处理了部分GET请求\n300     多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如浏览器）选择\n301     永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替\n302     临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI\n303     查看其它地址。与301类似。使用GET和POST请求查看\n304     未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源\n305     使用代理。所请求的资源必须通过代理访问\n307     临时重定向。与302类似。使用GET请求重定向\n400     客户端请求的语法错误，服务器无法理解\n401     请求要求用户的身份认证\n402     保留，将来使用\n403     服务器理解请求客户端的请求，但是拒绝执行此请求\n404     服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面\n405     客户端请求中的方法被禁止\n406     服务器无法根据客户端请求的内容特性完成请求\n407     请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权\n408     服务器等待客户端发送的请求时间过长，超时\n409     服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突\n410     客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置\n411     服务器无法处理客户端发送的不带Content-Length的请求信息\n412     客户端请求信息的先决条件错误\n413     由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息\n414     请求的URI过长（URI通常为网址），服务器无法处理\n415     服务器无法处理请求附带的媒体格式\n416     客户端请求的范围无效\n417     服务器无法满足Expect的请求头信息\n500     服务器内部错误，无法完成请求\n501     服务器不支持请求的功能，无法完成请求\n502     充当网关或代理的服务器，从远端服务器接收到了一个无效的请求\n503     由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中\n504     充当网关或代理的服务器，未及时从远端服务器获取请求\n505     服务器不支持请求的HTTP协议的版本，无法完成处理\n```\n\n2.**响应头标**：像请求头标一样，它们指出服务器的功能，标识出响应数据的细节。\n\n3.**空行**：最后一个响应头标之后是一个空行，发送回车符和退行，表明服务器以下不再有头标。\n\n4.**响应数据**：HTML文档和图像等，也就是HTML本身。\n\n浏览器解析HTTp响应显示数据的过程：\n\n- 浏览器首先解析状态行，查看表明请求是否成功的状态代码。\n- 然后解析每一个响应头标，头标告知以下为若干字节的HTML。\n- 读取响应数据HTML，根据HTML的语法和语义对其进行格式化，并在浏览器窗口中显示它。\n- 一个HTML文档可能包含其它需要被载入的资源引用，浏览器识别这些引用，对其它的资源再进行额外的请求，此过程循环多次。\n\n##### HTTP1.0与HTTP1.1的区别\n\n一个WEB站点每天可能要接收到上百万的用户请求，为了提高系统的效率，**HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求**。但是，这也造成了一些性能上的缺陷，例如，一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的URL地址，当WEB浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析WEB服务器返回的该网页文档中的HTML内容时，发现其中的<img>图像标签后，浏览器将根据<img>标签中的src属性所指定的URL地址再次向服务器发出下载图像数据的请求，如下图所示。\n\n{% asset_img 474814076.png %}\n\n显 然，访问一个包含有许多图像的网页文件的整个过程包含了多次请求和响应，每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个文档和图像，上一次和下一次请求完全分离。即使图像文件都很小，但是客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程，并且会严重影响客户机和服务器的性 能。当一个网页文件中包含Applet，JavaScript文件，CSS文件等内容时，也会出现类似上述的情况。\n\n为了克服HTTP 1.0的这个缺陷，**HTTP 1.1支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。**一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。**HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。**基于HTTP 1.1协议的客户机与服务器的信息交换过程，如下图所示。\n\n{% asset_img 1146631942.png %}\n\n可见，HTTP 1.1在继承了HTTP 1.0优点的基础上，也克服了HTTP 1.0的性能问题。不仅如此，HTTP 1.1还通过增加更多的请求头和响应头来改进和扩充HTTP 1.0的功能。例如，**由于HTTP 1.0不支持Host请求头字段**，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个IP地址和端口号上配置多个虚拟WEB站点。在HTTP 1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。**HTTP 1.1的持续连接（长连接），也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。**HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。（具体的可以看HTTP的RFC规范）\n\n##### HTTP1.1与HTTP2.0的区别\n\nHTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0），是HTTP协议的的第二个主要版本，使用于万维网。HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议。\n\n与HTTP/1相比，主要区别包括：\n\n- HTTP/2采用二进制格式而非文本格式\n- HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行\n- 使用报头压缩，HTTP/2降低了开销\n- HTTP/2让服务器可以将响应主动“推送”到客户端缓存中\n\nHTTP/2为什么是二进制？\n\n比起像HTTP/1.x这样的文本协议，二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少\n\n为什么 HTTP/2 需要多路传输?\n\nHTTP/1.x 有个问题叫线端阻塞(head-of-line blocking), 它是指一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢。HTTP/1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求). 此外, 由于网络媒介(intermediary )和服务器不能很好的支持流水线, 导致部署起来困难重重。而多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。所以客户端只需要一个连接就能加载一个页面。\n\n消息头为什么需要压缩?\n\n假定一个页面有80个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1400字节的消息头（着同样也并不少见，因为Cookie和引用等东西的存在）, 至少要7到8个来回去“在线”获得这些消息头。这还不包括响应时间——那只是从客户端那里获取到它们所花的时间而已。这全都由于TCP的慢启动机制，它会基于对已知有多少个包，来确定还要来回去获取哪些包 – 这很明显的限制了最初的几个来回可以发送的数据包的数量。相比之下，即使是头部轻微的压缩也可以是让那些请求只需一个来回就能搞定——有时候甚至一个包就可以了。这种开销是可以被节省下来的，特别是当你考虑移动客户端应用的时候，即使是良好条件下，一般也会看到几百毫秒的来回延迟。\n\n服务器推送的好处是什么？\n\n当浏览器请求一个网页时，服务器将会发回HTML，在服务器开始发送JavaScript、图片和CSS前，服务器需要等待浏览器解析HTML和发送所有内嵌资源的请求。服务器推送服务通过“推送”那些它认为客户端将会需要的内容到客户端的缓存中，以此来避免往返的延迟。\n\n### 二 HTTPS简介\n\n由于HTTP通信是明文通信的，这样发送中的数据将受到威胁。如：\n\n- 窃听风险（eavesdropping）：第三方可以获知通信内容。\n- 篡改风险（tampering）：第三方可以修改通信内容。\n- 冒充风险（pretending）：第三方可以冒充他人身份参与通信。\n\n因此出现了HTTPS，希望达到：\n\n- 所有信息都是加密传播，第三方无法窃听。\n- 具有校验机制，一旦被篡改，通信双方会立刻发现。\n- 配备身份证书，防止身份被冒充。\n\n##### 概述\n\nHTTPS 可以认为是 HTTP + TLS/SSL,它的发展历史如下：\n\n- 1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。\n- 1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。\n- 1996年，SSL 3.0版问世，得到大规模应用。\n- 1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。\n- 2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。\n\n目前常用的 HTTP 协议是 HTTP1.1，常用的 TLS 协议版本有如下几个：TLS1.2, TLS1.1, TLS1.0 和 SSL3.0。其中 SSL3.0 由于 POODLE 攻击已经被证明不安全，但统计发现依然有不到 1% 的浏览器使用 SSL3.0。TLS1.0 也存在部分安全漏洞，比如 RC4 和 BEAST 攻击。TLS1.2 和 TLS1.1 暂时没有已知的安全漏洞，比较安全，同时有大量扩展提升速度和性能，推荐大家使用。需要关注一点的就是 TLS1.3 将会是 TLS 协议一个非常重大的改革。不管是安全性还是用户访问速度都会有质的提升。不过目前没有明确的发布时间。同时 HTTP2 也已经正式定稿，这个由 SPDY 协议演化而来的协议相比 HTTP1.1 又是一个非常重大的变动，能够明显提升应用层数据的传输效率。\n\n##### HTTPS原理\n\nHTTPS内容加密的过程可以简述成：用对称加密来加密数据，用公钥加密来加密对称加密的秘钥（这句话其实并不准确，因为通信是传输的并不是秘钥本身，而是用于生成秘钥的随机数）。要实现这个客户端和服务器要通过四次握手。如下图：\n\n{% asset_img HTTPS握手图.jpg HTTPS四次握手图 %}\n\n1.客户端发出请求（ClientHello）\n\n首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。在这一步，客户端主要向服务器提供以下信息：\n\n- 支持的协议版本，比如TLS 1.0版。\n- 一个客户端生成的随机数，稍后用于生成\"对话密钥\"。（这是关键）\n- 支持的加密方法，比如RSA公钥加密。\n- 支持的压缩方法。\n\n2.服务器回应（SeverHello）\n\n服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容：\n\n- 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。\n- 一个服务器生成的随机数，稍后用于生成\"对话密钥\"。\n- 确认使用的加密方法，比如RSA公钥加密。\n- 服务器证书。（含公钥加密的公钥，用于加密premaster_secrect）\n\n除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供\"客户端证书\"。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。\n\n3.客户端回应\n\n客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息：\n\n- 一个随机数。该随机数用服务器公钥加密，防止被窃听。（这个随机数就是premaster_secrect）\n- 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。\n- 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。\n\n此时客户端和服务器同时都有了三个随机数，它们将通多相同的秘钥生成器（秘钥生成算法）来获得相同的“会话秘钥”。\n\n至于为什么使用三个随机数而不是直接随机生成秘钥，大神们回答如下：\n\n> \"不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre_master     secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。\"\n\n此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。\n\n4.服务器的最后回应\n\n- 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。\n- 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。\n\n至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用\"会话密钥\"加密内容。\n\n\n\n\n\n\n","slug":"http协议与https","published":1,"updated":"2017-04-01T09:04:26.857Z","_id":"cj0z0sk2e0025aknz14bpg36w","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"一-HTTP协议\"><a href=\"#一-HTTP协议\" class=\"headerlink\" title=\"一 HTTP协议\"></a>一 HTTP协议</h3><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>\n<h5 id=\"HTTP协议的特点\"><a href=\"#HTTP协议的特点\" class=\"headerlink\" title=\"HTTP协议的特点\"></a>HTTP协议的特点</h5><ul>\n<li><p>支持客户端/服务器（B/S）模式</p>\n</li>\n<li><p>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>\n</li>\n<li><p>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>\n</li>\n<li><p>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>\n</li>\n<li><p>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>\n</li>\n</ul>\n<h5 id=\"客户端通过HTTP想服务器请求资源的过程\"><a href=\"#客户端通过HTTP想服务器请求资源的过程\" class=\"headerlink\" title=\"客户端通过HTTP想服务器请求资源的过程\"></a>客户端通过HTTP想服务器请求资源的过程</h5><ul>\n<li>浏览器分析连接指向的URL，</li>\n<li>浏览器请求DNS服务器解析域名的IP地址。</li>\n<li>根据IP地址浏览器与服务器建立TCP连接，</li>\n<li>浏览器发出请求（GET）</li>\n<li>服务器响应，发送资源。</li>\n<li>释放TCP连接。</li>\n</ul>\n<h5 id=\"HTTP请求\"><a href=\"#HTTP请求\" class=\"headerlink\" title=\"HTTP请求\"></a>HTTP请求</h5><p>客户端通过一个HTTP请求从服务器请求消息。HTTP请求分为请求行，请求头，空行，请求数据。</p>\n<p>1.<strong>请求行</strong>：请求行由三个标记组成–请求方法，请求URI和HTTP版本，它们由空格分隔。</p>\n<p>例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET /index.html HTTP/1.1</div></pre></td></tr></table></figure>\n<p>HTTP规范定义了八种可能的请求方法：</p>\n<ul>\n<li>GET：检索URI中标识资源的一个简单请求</li>\n<li>HEAD：与GET方法相同，服务器只返回状态行和头标，并不返回请求文档</li>\n<li>POST：服务器接受被写入客户端输出流中的数据的请求</li>\n<li>PUT：服务器保存请求数据作为指定URI新内容的请求</li>\n<li>DELETE：服务器删除URI中命名的资源的请求</li>\n<li>OPTIONS：关于服务器支持的请求方法信息的请求</li>\n<li>TRACE：Web服务器反馈Http请求和其头标的请求</li>\n<li>CONNECT：已文档化但当前未实现的一个方法，预留做隧道处理</li>\n</ul>\n<p>2.<strong>请求头标</strong>：由关键字/值对组成，每行一对，关键字和值用冒号（:）分隔。<br>请求头标通知服务器有关于客户端的功能和标识（cookie就是放在请求头中），典型的请求头标有：<br>User-Agent        客户端厂家和版本<br>Accept            客户端可识别的内容类型列表<br>Content-Length    附加到请求的数据字节数</p>\n<p>3.<strong>空行</strong>：最后一个请求头标之后是一个空行，发送回车符和退行，通知服务器以下不再有头标。</p>\n<p>4.<strong>请求数据</strong>：使用POST传送数据，最常使用的是Content-Type和Content-Length头标。</p>\n<h5 id=\"HTTP响应\"><a href=\"#HTTP响应\" class=\"headerlink\" title=\"HTTP响应\"></a>HTTP响应</h5><p>Web服务器解析请求，定位指定资源。服务器将资源副本写至套接字（即端口），在此处由客户端读取。<br>一个响应由四个部分组成；状态行、响应头标、空行、响应数据</p>\n<p>1.<strong>状态行</strong>：状态行由三个标记组成：HTTP版本、响应代码和响应描述。<br>HTTP版本：向客户端指明其可理解的最高版本。<br>响应代码：3位的数字代码，指出请求的成功或失败，如果失败则指出原因。<br>响应描述：为响应代码的可读性解释。<br>例如：HTTP/1.1 200 OK</p>\n<p>HTTP响应码：</p>\n<ul>\n<li>1xx：信息，请求收到，继续处理</li>\n<li>2xx：成功，行为被成功地接受、理解和采纳</li>\n<li>3xx：重定向，为了完成请求，必须进一步执行的动作</li>\n<li>4xx：客户端错误，请求包含语法错误或者请求无法实现</li>\n<li>5xx：服务器错误，服务器不能实现一种明显无效的请求</li>\n</ul>\n<p>下表显示每个响应码及其含义：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">100     继续。客户端应继续其请求</div><div class=\"line\">101     切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</div><div class=\"line\">200     OK，请求成功。一般用于GET与POST请求</div><div class=\"line\">201     已创建。成功请求并创建了新的资源</div><div class=\"line\">202     已接受。已经接受请求，但未处理完成</div><div class=\"line\">203     非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</div><div class=\"line\">204     无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</div><div class=\"line\">205     重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</div><div class=\"line\">206     部分内容。服务器成功处理了部分GET请求</div><div class=\"line\">300     多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如浏览器）选择</div><div class=\"line\">301     永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</div><div class=\"line\">302     临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</div><div class=\"line\">303     查看其它地址。与301类似。使用GET和POST请求查看</div><div class=\"line\">304     未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</div><div class=\"line\">305     使用代理。所请求的资源必须通过代理访问</div><div class=\"line\">307     临时重定向。与302类似。使用GET请求重定向</div><div class=\"line\">400     客户端请求的语法错误，服务器无法理解</div><div class=\"line\">401     请求要求用户的身份认证</div><div class=\"line\">402     保留，将来使用</div><div class=\"line\">403     服务器理解请求客户端的请求，但是拒绝执行此请求</div><div class=\"line\">404     服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置<span class=\"string\">\"您所请求的资源无法找到\"</span>的个性页面</div><div class=\"line\">405     客户端请求中的方法被禁止</div><div class=\"line\">406     服务器无法根据客户端请求的内容特性完成请求</div><div class=\"line\">407     请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</div><div class=\"line\">408     服务器等待客户端发送的请求时间过长，超时</div><div class=\"line\">409     服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</div><div class=\"line\">410     客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</div><div class=\"line\">411     服务器无法处理客户端发送的不带Content-Length的请求信息</div><div class=\"line\">412     客户端请求信息的先决条件错误</div><div class=\"line\">413     由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</div><div class=\"line\">414     请求的URI过长（URI通常为网址），服务器无法处理</div><div class=\"line\">415     服务器无法处理请求附带的媒体格式</div><div class=\"line\">416     客户端请求的范围无效</div><div class=\"line\">417     服务器无法满足Expect的请求头信息</div><div class=\"line\">500     服务器内部错误，无法完成请求</div><div class=\"line\">501     服务器不支持请求的功能，无法完成请求</div><div class=\"line\">502     充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</div><div class=\"line\">503     由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</div><div class=\"line\">504     充当网关或代理的服务器，未及时从远端服务器获取请求</div><div class=\"line\">505     服务器不支持请求的HTTP协议的版本，无法完成处理</div></pre></td></tr></table></figure>\n<p>2.<strong>响应头标</strong>：像请求头标一样，它们指出服务器的功能，标识出响应数据的细节。</p>\n<p>3.<strong>空行</strong>：最后一个响应头标之后是一个空行，发送回车符和退行，表明服务器以下不再有头标。</p>\n<p>4.<strong>响应数据</strong>：HTML文档和图像等，也就是HTML本身。</p>\n<p>浏览器解析HTTp响应显示数据的过程：</p>\n<ul>\n<li>浏览器首先解析状态行，查看表明请求是否成功的状态代码。</li>\n<li>然后解析每一个响应头标，头标告知以下为若干字节的HTML。</li>\n<li>读取响应数据HTML，根据HTML的语法和语义对其进行格式化，并在浏览器窗口中显示它。</li>\n<li>一个HTML文档可能包含其它需要被载入的资源引用，浏览器识别这些引用，对其它的资源再进行额外的请求，此过程循环多次。</li>\n</ul>\n<h5 id=\"HTTP1-0与HTTP1-1的区别\"><a href=\"#HTTP1-0与HTTP1-1的区别\" class=\"headerlink\" title=\"HTTP1.0与HTTP1.1的区别\"></a>HTTP1.0与HTTP1.1的区别</h5><p>一个WEB站点每天可能要接收到上百万的用户请求，为了提高系统的效率，<strong>HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求</strong>。但是，这也造成了一些性能上的缺陷，例如，一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的URL地址，当WEB浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析WEB服务器返回的该网页文档中的HTML内容时，发现其中的<img>图像标签后，浏览器将根据<img>标签中的src属性所指定的URL地址再次向服务器发出下载图像数据的请求，如下图所示。</p>\n<img src=\"/2017/04/01/http协议与https/474814076.png\" alt=\"474814076.png\" title=\"\">\n<p>显 然，访问一个包含有许多图像的网页文件的整个过程包含了多次请求和响应，每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个文档和图像，上一次和下一次请求完全分离。即使图像文件都很小，但是客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程，并且会严重影响客户机和服务器的性 能。当一个网页文件中包含Applet，JavaScript文件，CSS文件等内容时，也会出现类似上述的情况。</p>\n<p>为了克服HTTP 1.0的这个缺陷，<strong>HTTP 1.1支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。</strong>一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。<strong>HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</strong>基于HTTP 1.1协议的客户机与服务器的信息交换过程，如下图所示。</p>\n<img src=\"/2017/04/01/http协议与https/1146631942.png\" alt=\"1146631942.png\" title=\"\">\n<p>可见，HTTP 1.1在继承了HTTP 1.0优点的基础上，也克服了HTTP 1.0的性能问题。不仅如此，HTTP 1.1还通过增加更多的请求头和响应头来改进和扩充HTTP 1.0的功能。例如，<strong>由于HTTP 1.0不支持Host请求头字段</strong>，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个IP地址和端口号上配置多个虚拟WEB站点。在HTTP 1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。<strong>HTTP 1.1的持续连接（长连接），也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。</strong>HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。（具体的可以看HTTP的RFC规范）</p>\n<h5 id=\"HTTP1-1与HTTP2-0的区别\"><a href=\"#HTTP1-1与HTTP2-0的区别\" class=\"headerlink\" title=\"HTTP1.1与HTTP2.0的区别\"></a>HTTP1.1与HTTP2.0的区别</h5><p>HTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0），是HTTP协议的的第二个主要版本，使用于万维网。HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议。</p>\n<p>与HTTP/1相比，主要区别包括：</p>\n<ul>\n<li>HTTP/2采用二进制格式而非文本格式</li>\n<li>HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行</li>\n<li>使用报头压缩，HTTP/2降低了开销</li>\n<li>HTTP/2让服务器可以将响应主动“推送”到客户端缓存中</li>\n</ul>\n<p>HTTP/2为什么是二进制？</p>\n<p>比起像HTTP/1.x这样的文本协议，二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少</p>\n<p>为什么 HTTP/2 需要多路传输?</p>\n<p>HTTP/1.x 有个问题叫线端阻塞(head-of-line blocking), 它是指一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢。HTTP/1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求). 此外, 由于网络媒介(intermediary )和服务器不能很好的支持流水线, 导致部署起来困难重重。而多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。所以客户端只需要一个连接就能加载一个页面。</p>\n<p>消息头为什么需要压缩?</p>\n<p>假定一个页面有80个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1400字节的消息头（着同样也并不少见，因为Cookie和引用等东西的存在）, 至少要7到8个来回去“在线”获得这些消息头。这还不包括响应时间——那只是从客户端那里获取到它们所花的时间而已。这全都由于TCP的慢启动机制，它会基于对已知有多少个包，来确定还要来回去获取哪些包 – 这很明显的限制了最初的几个来回可以发送的数据包的数量。相比之下，即使是头部轻微的压缩也可以是让那些请求只需一个来回就能搞定——有时候甚至一个包就可以了。这种开销是可以被节省下来的，特别是当你考虑移动客户端应用的时候，即使是良好条件下，一般也会看到几百毫秒的来回延迟。</p>\n<p>服务器推送的好处是什么？</p>\n<p>当浏览器请求一个网页时，服务器将会发回HTML，在服务器开始发送JavaScript、图片和CSS前，服务器需要等待浏览器解析HTML和发送所有内嵌资源的请求。服务器推送服务通过“推送”那些它认为客户端将会需要的内容到客户端的缓存中，以此来避免往返的延迟。</p>\n<h3 id=\"二-HTTPS简介\"><a href=\"#二-HTTPS简介\" class=\"headerlink\" title=\"二 HTTPS简介\"></a>二 HTTPS简介</h3><p>由于HTTP通信是明文通信的，这样发送中的数据将受到威胁。如：</p>\n<ul>\n<li>窃听风险（eavesdropping）：第三方可以获知通信内容。</li>\n<li>篡改风险（tampering）：第三方可以修改通信内容。</li>\n<li>冒充风险（pretending）：第三方可以冒充他人身份参与通信。</li>\n</ul>\n<p>因此出现了HTTPS，希望达到：</p>\n<ul>\n<li>所有信息都是加密传播，第三方无法窃听。</li>\n<li>具有校验机制，一旦被篡改，通信双方会立刻发现。</li>\n<li>配备身份证书，防止身份被冒充。</li>\n</ul>\n<h5 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h5><p>HTTPS 可以认为是 HTTP + TLS/SSL,它的发展历史如下：</p>\n<ul>\n<li>1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。</li>\n<li>1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。</li>\n<li>1996年，SSL 3.0版问世，得到大规模应用。</li>\n<li>1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。</li>\n<li>2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。</li>\n</ul>\n<p>目前常用的 HTTP 协议是 HTTP1.1，常用的 TLS 协议版本有如下几个：TLS1.2, TLS1.1, TLS1.0 和 SSL3.0。其中 SSL3.0 由于 POODLE 攻击已经被证明不安全，但统计发现依然有不到 1% 的浏览器使用 SSL3.0。TLS1.0 也存在部分安全漏洞，比如 RC4 和 BEAST 攻击。TLS1.2 和 TLS1.1 暂时没有已知的安全漏洞，比较安全，同时有大量扩展提升速度和性能，推荐大家使用。需要关注一点的就是 TLS1.3 将会是 TLS 协议一个非常重大的改革。不管是安全性还是用户访问速度都会有质的提升。不过目前没有明确的发布时间。同时 HTTP2 也已经正式定稿，这个由 SPDY 协议演化而来的协议相比 HTTP1.1 又是一个非常重大的变动，能够明显提升应用层数据的传输效率。</p>\n<h5 id=\"HTTPS原理\"><a href=\"#HTTPS原理\" class=\"headerlink\" title=\"HTTPS原理\"></a>HTTPS原理</h5><p>HTTPS内容加密的过程可以简述成：用对称加密来加密数据，用公钥加密来加密对称加密的秘钥（这句话其实并不准确，因为通信是传输的并不是秘钥本身，而是用于生成秘钥的随机数）。要实现这个客户端和服务器要通过四次握手。如下图：</p>\n<img src=\"/2017/04/01/http协议与https/HTTPS握手图.jpg\" alt=\"HTTPS四次握手图\" title=\"HTTPS四次握手图\">\n<p>1.客户端发出请求（ClientHello）</p>\n<p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。在这一步，客户端主要向服务器提供以下信息：</p>\n<ul>\n<li>支持的协议版本，比如TLS 1.0版。</li>\n<li>一个客户端生成的随机数，稍后用于生成”对话密钥”。（这是关键）</li>\n<li>支持的加密方法，比如RSA公钥加密。</li>\n<li>支持的压缩方法。</li>\n</ul>\n<p>2.服务器回应（SeverHello）</p>\n<p>服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容：</p>\n<ul>\n<li>确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</li>\n<li>一个服务器生成的随机数，稍后用于生成”对话密钥”。</li>\n<li>确认使用的加密方法，比如RSA公钥加密。</li>\n<li>服务器证书。（含公钥加密的公钥，用于加密premaster_secrect）</li>\n</ul>\n<p>除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p>\n<p>3.客户端回应</p>\n<p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息：</p>\n<ul>\n<li>一个随机数。该随机数用服务器公钥加密，防止被窃听。（这个随机数就是premaster_secrect）</li>\n<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>\n<li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</li>\n</ul>\n<p>此时客户端和服务器同时都有了三个随机数，它们将通多相同的秘钥生成器（秘钥生成算法）来获得相同的“会话秘钥”。</p>\n<p>至于为什么使用三个随机数而不是直接随机生成秘钥，大神们回答如下：</p>\n<blockquote>\n<p>“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre_master     secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”</p>\n</blockquote>\n<p>此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p>\n<p>4.服务器的最后回应</p>\n<ul>\n<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>\n<li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</li>\n</ul>\n<p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p>\n","excerpt":"","more":"<h3 id=\"一-HTTP协议\"><a href=\"#一-HTTP协议\" class=\"headerlink\" title=\"一 HTTP协议\"></a>一 HTTP协议</h3><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>\n<h5 id=\"HTTP协议的特点\"><a href=\"#HTTP协议的特点\" class=\"headerlink\" title=\"HTTP协议的特点\"></a>HTTP协议的特点</h5><ul>\n<li><p>支持客户端/服务器（B/S）模式</p>\n</li>\n<li><p>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>\n</li>\n<li><p>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>\n</li>\n<li><p>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>\n</li>\n<li><p>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>\n</li>\n</ul>\n<h5 id=\"客户端通过HTTP想服务器请求资源的过程\"><a href=\"#客户端通过HTTP想服务器请求资源的过程\" class=\"headerlink\" title=\"客户端通过HTTP想服务器请求资源的过程\"></a>客户端通过HTTP想服务器请求资源的过程</h5><ul>\n<li>浏览器分析连接指向的URL，</li>\n<li>浏览器请求DNS服务器解析域名的IP地址。</li>\n<li>根据IP地址浏览器与服务器建立TCP连接，</li>\n<li>浏览器发出请求（GET）</li>\n<li>服务器响应，发送资源。</li>\n<li>释放TCP连接。</li>\n</ul>\n<h5 id=\"HTTP请求\"><a href=\"#HTTP请求\" class=\"headerlink\" title=\"HTTP请求\"></a>HTTP请求</h5><p>客户端通过一个HTTP请求从服务器请求消息。HTTP请求分为请求行，请求头，空行，请求数据。</p>\n<p>1.<strong>请求行</strong>：请求行由三个标记组成–请求方法，请求URI和HTTP版本，它们由空格分隔。</p>\n<p>例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET /index.html HTTP/1.1</div></pre></td></tr></table></figure>\n<p>HTTP规范定义了八种可能的请求方法：</p>\n<ul>\n<li>GET：检索URI中标识资源的一个简单请求</li>\n<li>HEAD：与GET方法相同，服务器只返回状态行和头标，并不返回请求文档</li>\n<li>POST：服务器接受被写入客户端输出流中的数据的请求</li>\n<li>PUT：服务器保存请求数据作为指定URI新内容的请求</li>\n<li>DELETE：服务器删除URI中命名的资源的请求</li>\n<li>OPTIONS：关于服务器支持的请求方法信息的请求</li>\n<li>TRACE：Web服务器反馈Http请求和其头标的请求</li>\n<li>CONNECT：已文档化但当前未实现的一个方法，预留做隧道处理</li>\n</ul>\n<p>2.<strong>请求头标</strong>：由关键字/值对组成，每行一对，关键字和值用冒号（:）分隔。<br>请求头标通知服务器有关于客户端的功能和标识（cookie就是放在请求头中），典型的请求头标有：<br>User-Agent        客户端厂家和版本<br>Accept            客户端可识别的内容类型列表<br>Content-Length    附加到请求的数据字节数</p>\n<p>3.<strong>空行</strong>：最后一个请求头标之后是一个空行，发送回车符和退行，通知服务器以下不再有头标。</p>\n<p>4.<strong>请求数据</strong>：使用POST传送数据，最常使用的是Content-Type和Content-Length头标。</p>\n<h5 id=\"HTTP响应\"><a href=\"#HTTP响应\" class=\"headerlink\" title=\"HTTP响应\"></a>HTTP响应</h5><p>Web服务器解析请求，定位指定资源。服务器将资源副本写至套接字（即端口），在此处由客户端读取。<br>一个响应由四个部分组成；状态行、响应头标、空行、响应数据</p>\n<p>1.<strong>状态行</strong>：状态行由三个标记组成：HTTP版本、响应代码和响应描述。<br>HTTP版本：向客户端指明其可理解的最高版本。<br>响应代码：3位的数字代码，指出请求的成功或失败，如果失败则指出原因。<br>响应描述：为响应代码的可读性解释。<br>例如：HTTP/1.1 200 OK</p>\n<p>HTTP响应码：</p>\n<ul>\n<li>1xx：信息，请求收到，继续处理</li>\n<li>2xx：成功，行为被成功地接受、理解和采纳</li>\n<li>3xx：重定向，为了完成请求，必须进一步执行的动作</li>\n<li>4xx：客户端错误，请求包含语法错误或者请求无法实现</li>\n<li>5xx：服务器错误，服务器不能实现一种明显无效的请求</li>\n</ul>\n<p>下表显示每个响应码及其含义：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">100     继续。客户端应继续其请求</div><div class=\"line\">101     切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</div><div class=\"line\">200     OK，请求成功。一般用于GET与POST请求</div><div class=\"line\">201     已创建。成功请求并创建了新的资源</div><div class=\"line\">202     已接受。已经接受请求，但未处理完成</div><div class=\"line\">203     非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</div><div class=\"line\">204     无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</div><div class=\"line\">205     重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</div><div class=\"line\">206     部分内容。服务器成功处理了部分GET请求</div><div class=\"line\">300     多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如浏览器）选择</div><div class=\"line\">301     永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</div><div class=\"line\">302     临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</div><div class=\"line\">303     查看其它地址。与301类似。使用GET和POST请求查看</div><div class=\"line\">304     未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</div><div class=\"line\">305     使用代理。所请求的资源必须通过代理访问</div><div class=\"line\">307     临时重定向。与302类似。使用GET请求重定向</div><div class=\"line\">400     客户端请求的语法错误，服务器无法理解</div><div class=\"line\">401     请求要求用户的身份认证</div><div class=\"line\">402     保留，将来使用</div><div class=\"line\">403     服务器理解请求客户端的请求，但是拒绝执行此请求</div><div class=\"line\">404     服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置<span class=\"string\">\"您所请求的资源无法找到\"</span>的个性页面</div><div class=\"line\">405     客户端请求中的方法被禁止</div><div class=\"line\">406     服务器无法根据客户端请求的内容特性完成请求</div><div class=\"line\">407     请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</div><div class=\"line\">408     服务器等待客户端发送的请求时间过长，超时</div><div class=\"line\">409     服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</div><div class=\"line\">410     客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</div><div class=\"line\">411     服务器无法处理客户端发送的不带Content-Length的请求信息</div><div class=\"line\">412     客户端请求信息的先决条件错误</div><div class=\"line\">413     由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</div><div class=\"line\">414     请求的URI过长（URI通常为网址），服务器无法处理</div><div class=\"line\">415     服务器无法处理请求附带的媒体格式</div><div class=\"line\">416     客户端请求的范围无效</div><div class=\"line\">417     服务器无法满足Expect的请求头信息</div><div class=\"line\">500     服务器内部错误，无法完成请求</div><div class=\"line\">501     服务器不支持请求的功能，无法完成请求</div><div class=\"line\">502     充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</div><div class=\"line\">503     由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</div><div class=\"line\">504     充当网关或代理的服务器，未及时从远端服务器获取请求</div><div class=\"line\">505     服务器不支持请求的HTTP协议的版本，无法完成处理</div></pre></td></tr></table></figure>\n<p>2.<strong>响应头标</strong>：像请求头标一样，它们指出服务器的功能，标识出响应数据的细节。</p>\n<p>3.<strong>空行</strong>：最后一个响应头标之后是一个空行，发送回车符和退行，表明服务器以下不再有头标。</p>\n<p>4.<strong>响应数据</strong>：HTML文档和图像等，也就是HTML本身。</p>\n<p>浏览器解析HTTp响应显示数据的过程：</p>\n<ul>\n<li>浏览器首先解析状态行，查看表明请求是否成功的状态代码。</li>\n<li>然后解析每一个响应头标，头标告知以下为若干字节的HTML。</li>\n<li>读取响应数据HTML，根据HTML的语法和语义对其进行格式化，并在浏览器窗口中显示它。</li>\n<li>一个HTML文档可能包含其它需要被载入的资源引用，浏览器识别这些引用，对其它的资源再进行额外的请求，此过程循环多次。</li>\n</ul>\n<h5 id=\"HTTP1-0与HTTP1-1的区别\"><a href=\"#HTTP1-0与HTTP1-1的区别\" class=\"headerlink\" title=\"HTTP1.0与HTTP1.1的区别\"></a>HTTP1.0与HTTP1.1的区别</h5><p>一个WEB站点每天可能要接收到上百万的用户请求，为了提高系统的效率，<strong>HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求</strong>。但是，这也造成了一些性能上的缺陷，例如，一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的URL地址，当WEB浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析WEB服务器返回的该网页文档中的HTML内容时，发现其中的<img>图像标签后，浏览器将根据<img>标签中的src属性所指定的URL地址再次向服务器发出下载图像数据的请求，如下图所示。</p>\n<img src=\"/2017/04/01/http协议与https/474814076.png\" alt=\"474814076.png\" title=\"\">\n<p>显 然，访问一个包含有许多图像的网页文件的整个过程包含了多次请求和响应，每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个文档和图像，上一次和下一次请求完全分离。即使图像文件都很小，但是客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程，并且会严重影响客户机和服务器的性 能。当一个网页文件中包含Applet，JavaScript文件，CSS文件等内容时，也会出现类似上述的情况。</p>\n<p>为了克服HTTP 1.0的这个缺陷，<strong>HTTP 1.1支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。</strong>一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。<strong>HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</strong>基于HTTP 1.1协议的客户机与服务器的信息交换过程，如下图所示。</p>\n<img src=\"/2017/04/01/http协议与https/1146631942.png\" alt=\"1146631942.png\" title=\"\">\n<p>可见，HTTP 1.1在继承了HTTP 1.0优点的基础上，也克服了HTTP 1.0的性能问题。不仅如此，HTTP 1.1还通过增加更多的请求头和响应头来改进和扩充HTTP 1.0的功能。例如，<strong>由于HTTP 1.0不支持Host请求头字段</strong>，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个IP地址和端口号上配置多个虚拟WEB站点。在HTTP 1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。<strong>HTTP 1.1的持续连接（长连接），也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。</strong>HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。（具体的可以看HTTP的RFC规范）</p>\n<h5 id=\"HTTP1-1与HTTP2-0的区别\"><a href=\"#HTTP1-1与HTTP2-0的区别\" class=\"headerlink\" title=\"HTTP1.1与HTTP2.0的区别\"></a>HTTP1.1与HTTP2.0的区别</h5><p>HTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0），是HTTP协议的的第二个主要版本，使用于万维网。HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议。</p>\n<p>与HTTP/1相比，主要区别包括：</p>\n<ul>\n<li>HTTP/2采用二进制格式而非文本格式</li>\n<li>HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行</li>\n<li>使用报头压缩，HTTP/2降低了开销</li>\n<li>HTTP/2让服务器可以将响应主动“推送”到客户端缓存中</li>\n</ul>\n<p>HTTP/2为什么是二进制？</p>\n<p>比起像HTTP/1.x这样的文本协议，二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少</p>\n<p>为什么 HTTP/2 需要多路传输?</p>\n<p>HTTP/1.x 有个问题叫线端阻塞(head-of-line blocking), 它是指一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢。HTTP/1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求). 此外, 由于网络媒介(intermediary )和服务器不能很好的支持流水线, 导致部署起来困难重重。而多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。所以客户端只需要一个连接就能加载一个页面。</p>\n<p>消息头为什么需要压缩?</p>\n<p>假定一个页面有80个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1400字节的消息头（着同样也并不少见，因为Cookie和引用等东西的存在）, 至少要7到8个来回去“在线”获得这些消息头。这还不包括响应时间——那只是从客户端那里获取到它们所花的时间而已。这全都由于TCP的慢启动机制，它会基于对已知有多少个包，来确定还要来回去获取哪些包 – 这很明显的限制了最初的几个来回可以发送的数据包的数量。相比之下，即使是头部轻微的压缩也可以是让那些请求只需一个来回就能搞定——有时候甚至一个包就可以了。这种开销是可以被节省下来的，特别是当你考虑移动客户端应用的时候，即使是良好条件下，一般也会看到几百毫秒的来回延迟。</p>\n<p>服务器推送的好处是什么？</p>\n<p>当浏览器请求一个网页时，服务器将会发回HTML，在服务器开始发送JavaScript、图片和CSS前，服务器需要等待浏览器解析HTML和发送所有内嵌资源的请求。服务器推送服务通过“推送”那些它认为客户端将会需要的内容到客户端的缓存中，以此来避免往返的延迟。</p>\n<h3 id=\"二-HTTPS简介\"><a href=\"#二-HTTPS简介\" class=\"headerlink\" title=\"二 HTTPS简介\"></a>二 HTTPS简介</h3><p>由于HTTP通信是明文通信的，这样发送中的数据将受到威胁。如：</p>\n<ul>\n<li>窃听风险（eavesdropping）：第三方可以获知通信内容。</li>\n<li>篡改风险（tampering）：第三方可以修改通信内容。</li>\n<li>冒充风险（pretending）：第三方可以冒充他人身份参与通信。</li>\n</ul>\n<p>因此出现了HTTPS，希望达到：</p>\n<ul>\n<li>所有信息都是加密传播，第三方无法窃听。</li>\n<li>具有校验机制，一旦被篡改，通信双方会立刻发现。</li>\n<li>配备身份证书，防止身份被冒充。</li>\n</ul>\n<h5 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h5><p>HTTPS 可以认为是 HTTP + TLS/SSL,它的发展历史如下：</p>\n<ul>\n<li>1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。</li>\n<li>1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。</li>\n<li>1996年，SSL 3.0版问世，得到大规模应用。</li>\n<li>1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。</li>\n<li>2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。</li>\n</ul>\n<p>目前常用的 HTTP 协议是 HTTP1.1，常用的 TLS 协议版本有如下几个：TLS1.2, TLS1.1, TLS1.0 和 SSL3.0。其中 SSL3.0 由于 POODLE 攻击已经被证明不安全，但统计发现依然有不到 1% 的浏览器使用 SSL3.0。TLS1.0 也存在部分安全漏洞，比如 RC4 和 BEAST 攻击。TLS1.2 和 TLS1.1 暂时没有已知的安全漏洞，比较安全，同时有大量扩展提升速度和性能，推荐大家使用。需要关注一点的就是 TLS1.3 将会是 TLS 协议一个非常重大的改革。不管是安全性还是用户访问速度都会有质的提升。不过目前没有明确的发布时间。同时 HTTP2 也已经正式定稿，这个由 SPDY 协议演化而来的协议相比 HTTP1.1 又是一个非常重大的变动，能够明显提升应用层数据的传输效率。</p>\n<h5 id=\"HTTPS原理\"><a href=\"#HTTPS原理\" class=\"headerlink\" title=\"HTTPS原理\"></a>HTTPS原理</h5><p>HTTPS内容加密的过程可以简述成：用对称加密来加密数据，用公钥加密来加密对称加密的秘钥（这句话其实并不准确，因为通信是传输的并不是秘钥本身，而是用于生成秘钥的随机数）。要实现这个客户端和服务器要通过四次握手。如下图：</p>\n<img src=\"/2017/04/01/http协议与https/HTTPS握手图.jpg\" alt=\"HTTPS四次握手图\" title=\"HTTPS四次握手图\">\n<p>1.客户端发出请求（ClientHello）</p>\n<p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。在这一步，客户端主要向服务器提供以下信息：</p>\n<ul>\n<li>支持的协议版本，比如TLS 1.0版。</li>\n<li>一个客户端生成的随机数，稍后用于生成”对话密钥”。（这是关键）</li>\n<li>支持的加密方法，比如RSA公钥加密。</li>\n<li>支持的压缩方法。</li>\n</ul>\n<p>2.服务器回应（SeverHello）</p>\n<p>服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容：</p>\n<ul>\n<li>确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</li>\n<li>一个服务器生成的随机数，稍后用于生成”对话密钥”。</li>\n<li>确认使用的加密方法，比如RSA公钥加密。</li>\n<li>服务器证书。（含公钥加密的公钥，用于加密premaster_secrect）</li>\n</ul>\n<p>除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p>\n<p>3.客户端回应</p>\n<p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息：</p>\n<ul>\n<li>一个随机数。该随机数用服务器公钥加密，防止被窃听。（这个随机数就是premaster_secrect）</li>\n<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>\n<li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</li>\n</ul>\n<p>此时客户端和服务器同时都有了三个随机数，它们将通多相同的秘钥生成器（秘钥生成算法）来获得相同的“会话秘钥”。</p>\n<p>至于为什么使用三个随机数而不是直接随机生成秘钥，大神们回答如下：</p>\n<blockquote>\n<p>“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre_master     secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”</p>\n</blockquote>\n<p>此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p>\n<p>4.服务器的最后回应</p>\n<ul>\n<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>\n<li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</li>\n</ul>\n<p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p>\n"},{"title":"设计模式之单例模式","date":"2017-03-28T02:09:18.000Z","_content":"\n### 一 概述\n\n单例模式（Singleton Pattern）是最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。如果一个全局的类需要频繁的创建和销毁，为了节省资源，通常将它设计成单例。实现该模式要满足一下几点：\n\n- 单例类只能有一个实例。\n- 单例类必须自己创建自己的唯一实例。\n- 单例类必须给所有其他对象提供这一实例。\n\n### 二 单例模式的几种写法\n\n正如茴香豆的几种写法，单例模式也有它的多种写法，我们应当根据具体情况选用。\n\n##### 1.懒汉式（线程不安全）\n\n这种方式是懒加载，只用调用它时才会被实例化；线程不安全，只能在单线程模式下使用。\n\n```java\npublic class Singleton {  \n    private static Singleton instance;  \n    private Singleton (){}  \n  \n    public static Singleton getInstance() {  \n    if (instance == null) {  \n        instance = new Singleton();  \n    }  \n    return instance;  \n    }  \n}\n```\n\n##### 2.懒汉式（线程安全）\n\n这种方式是懒加载，只用调用它时才会被实例化；线程安全，可在多线程模式下使用，但性能会受到影响。\n\n```java\npublic class Singleton {  \n    private static Singleton instance;  \n    private Singleton (){}  \n    public static synchronized Singleton getInstance() {  \n    if (instance == null) {  \n        instance = new Singleton();  \n    }  \n    return instance;  \n    }  \n} \n```\n\n##### 3.饿汉式（线程安全）\n\n这种方式在创建类时就被实例化，线程安全。这种方式比较常用。\n\n```java\npublic class Singleton {  \n    private static Singleton instance = new Singleton();  \n    private Singleton (){}  \n    public static Singleton getInstance() {  \n    return instance;  \n    }  \n} \n```\n\n##### 4.双重校验锁\n\n这种方式采用双锁机制，安全且在多线程情况下能保持高性能。\n\n```java\npublic class Singleton {  \n    private volatile static Singleton singleton;  \n    private Singleton (){}  \n    public static Singleton getSingleton() {  \n    if (singleton == null) {  \n        synchronized (Singleton.class) {  \n        if (singleton == null) {  \n            singleton = new Singleton();  \n        }  \n        }  \n    }  \n    return singleton;  \n    }  \n} \n```\n\n##### 5.静态内部类\n\n这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。\n\n```java\npublic class Singleton {  \n    private static class SingletonHolder {  \n    private static final Singleton INSTANCE = new Singleton();  \n    }  \n    private Singleton (){}  \n    public static final Singleton getInstance() {  \n    return SingletonHolder.INSTANCE;  \n    }  \n}  \n```\n\n##### 6.枚举\n\n这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。\n\n```java\npublic enum Singleton {  \n    INSTANCE;  \n    public void whateverMethod() {  \n    }  \n} \n```\n\n### 三 总结\n\n一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现懒加载效果时，才会使用第 5 种静态内部类方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。","source":"_posts/设计模式之单例模式.md","raw":"---\ntitle: 设计模式之单例模式\ndate: 2017-03-28 10:09:18\ncategories: 设计模式\ntags:\n- 单例模式\n- 创建型模式\n---\n\n### 一 概述\n\n单例模式（Singleton Pattern）是最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。如果一个全局的类需要频繁的创建和销毁，为了节省资源，通常将它设计成单例。实现该模式要满足一下几点：\n\n- 单例类只能有一个实例。\n- 单例类必须自己创建自己的唯一实例。\n- 单例类必须给所有其他对象提供这一实例。\n\n### 二 单例模式的几种写法\n\n正如茴香豆的几种写法，单例模式也有它的多种写法，我们应当根据具体情况选用。\n\n##### 1.懒汉式（线程不安全）\n\n这种方式是懒加载，只用调用它时才会被实例化；线程不安全，只能在单线程模式下使用。\n\n```java\npublic class Singleton {  \n    private static Singleton instance;  \n    private Singleton (){}  \n  \n    public static Singleton getInstance() {  \n    if (instance == null) {  \n        instance = new Singleton();  \n    }  \n    return instance;  \n    }  \n}\n```\n\n##### 2.懒汉式（线程安全）\n\n这种方式是懒加载，只用调用它时才会被实例化；线程安全，可在多线程模式下使用，但性能会受到影响。\n\n```java\npublic class Singleton {  \n    private static Singleton instance;  \n    private Singleton (){}  \n    public static synchronized Singleton getInstance() {  \n    if (instance == null) {  \n        instance = new Singleton();  \n    }  \n    return instance;  \n    }  \n} \n```\n\n##### 3.饿汉式（线程安全）\n\n这种方式在创建类时就被实例化，线程安全。这种方式比较常用。\n\n```java\npublic class Singleton {  \n    private static Singleton instance = new Singleton();  \n    private Singleton (){}  \n    public static Singleton getInstance() {  \n    return instance;  \n    }  \n} \n```\n\n##### 4.双重校验锁\n\n这种方式采用双锁机制，安全且在多线程情况下能保持高性能。\n\n```java\npublic class Singleton {  \n    private volatile static Singleton singleton;  \n    private Singleton (){}  \n    public static Singleton getSingleton() {  \n    if (singleton == null) {  \n        synchronized (Singleton.class) {  \n        if (singleton == null) {  \n            singleton = new Singleton();  \n        }  \n        }  \n    }  \n    return singleton;  \n    }  \n} \n```\n\n##### 5.静态内部类\n\n这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。\n\n```java\npublic class Singleton {  \n    private static class SingletonHolder {  \n    private static final Singleton INSTANCE = new Singleton();  \n    }  \n    private Singleton (){}  \n    public static final Singleton getInstance() {  \n    return SingletonHolder.INSTANCE;  \n    }  \n}  \n```\n\n##### 6.枚举\n\n这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。\n\n```java\npublic enum Singleton {  \n    INSTANCE;  \n    public void whateverMethod() {  \n    }  \n} \n```\n\n### 三 总结\n\n一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现懒加载效果时，才会使用第 5 种静态内部类方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。","slug":"设计模式之单例模式","published":1,"updated":"2017-03-28T03:58:08.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk2g0028aknz8rlnu6be","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>单例模式（Singleton Pattern）是最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。如果一个全局的类需要频繁的创建和销毁，为了节省资源，通常将它设计成单例。实现该模式要满足一下几点：</p>\n<ul>\n<li>单例类只能有一个实例。</li>\n<li>单例类必须自己创建自己的唯一实例。</li>\n<li>单例类必须给所有其他对象提供这一实例。</li>\n</ul>\n<h3 id=\"二-单例模式的几种写法\"><a href=\"#二-单例模式的几种写法\" class=\"headerlink\" title=\"二 单例模式的几种写法\"></a>二 单例模式的几种写法</h3><p>正如茴香豆的几种写法，单例模式也有它的多种写法，我们应当根据具体情况选用。</p>\n<h5 id=\"1-懒汉式（线程不安全）\"><a href=\"#1-懒汉式（线程不安全）\" class=\"headerlink\" title=\"1.懒汉式（线程不安全）\"></a>1.懒汉式（线程不安全）</h5><p>这种方式是懒加载，只用调用它时才会被实例化；线程不安全，只能在单线程模式下使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">        instance = <span class=\"keyword\">new</span> Singleton();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> instance;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"2-懒汉式（线程安全）\"><a href=\"#2-懒汉式（线程安全）\" class=\"headerlink\" title=\"2.懒汉式（线程安全）\"></a>2.懒汉式（线程安全）</h5><p>这种方式是懒加载，只用调用它时才会被实例化；线程安全，可在多线程模式下使用，但性能会受到影响。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">        instance = <span class=\"keyword\">new</span> Singleton();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> instance;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"3-饿汉式（线程安全）\"><a href=\"#3-饿汉式（线程安全）\" class=\"headerlink\" title=\"3.饿汉式（线程安全）\"></a>3.饿汉式（线程安全）</h5><p>这种方式在创建类时就被实例化，线程安全。这种方式比较常用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span> instance;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"4-双重校验锁\"><a href=\"#4-双重校验锁\" class=\"headerlink\" title=\"4.双重校验锁\"></a>4.双重校验锁</h5><p>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">            singleton = <span class=\"keyword\">new</span> Singleton();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> singleton;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"5-静态内部类\"><a href=\"#5-静态内部类\" class=\"headerlink\" title=\"5.静态内部类\"></a>5.静态内部类</h5><p>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"6-枚举\"><a href=\"#6-枚举\" class=\"headerlink\" title=\"6.枚举\"></a>6.枚举</h5><p>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Singleton &#123;  </div><div class=\"line\">    INSTANCE;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">whateverMethod</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"三-总结\"><a href=\"#三-总结\" class=\"headerlink\" title=\"三 总结\"></a>三 总结</h3><p>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现懒加载效果时，才会使用第 5 种静态内部类方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p>\n","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>单例模式（Singleton Pattern）是最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。如果一个全局的类需要频繁的创建和销毁，为了节省资源，通常将它设计成单例。实现该模式要满足一下几点：</p>\n<ul>\n<li>单例类只能有一个实例。</li>\n<li>单例类必须自己创建自己的唯一实例。</li>\n<li>单例类必须给所有其他对象提供这一实例。</li>\n</ul>\n<h3 id=\"二-单例模式的几种写法\"><a href=\"#二-单例模式的几种写法\" class=\"headerlink\" title=\"二 单例模式的几种写法\"></a>二 单例模式的几种写法</h3><p>正如茴香豆的几种写法，单例模式也有它的多种写法，我们应当根据具体情况选用。</p>\n<h5 id=\"1-懒汉式（线程不安全）\"><a href=\"#1-懒汉式（线程不安全）\" class=\"headerlink\" title=\"1.懒汉式（线程不安全）\"></a>1.懒汉式（线程不安全）</h5><p>这种方式是懒加载，只用调用它时才会被实例化；线程不安全，只能在单线程模式下使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">        instance = <span class=\"keyword\">new</span> Singleton();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> instance;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"2-懒汉式（线程安全）\"><a href=\"#2-懒汉式（线程安全）\" class=\"headerlink\" title=\"2.懒汉式（线程安全）\"></a>2.懒汉式（线程安全）</h5><p>这种方式是懒加载，只用调用它时才会被实例化；线程安全，可在多线程模式下使用，但性能会受到影响。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">        instance = <span class=\"keyword\">new</span> Singleton();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> instance;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"3-饿汉式（线程安全）\"><a href=\"#3-饿汉式（线程安全）\" class=\"headerlink\" title=\"3.饿汉式（线程安全）\"></a>3.饿汉式（线程安全）</h5><p>这种方式在创建类时就被实例化，线程安全。这种方式比较常用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span> instance;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"4-双重校验锁\"><a href=\"#4-双重校验锁\" class=\"headerlink\" title=\"4.双重校验锁\"></a>4.双重校验锁</h5><p>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">            singleton = <span class=\"keyword\">new</span> Singleton();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> singleton;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"5-静态内部类\"><a href=\"#5-静态内部类\" class=\"headerlink\" title=\"5.静态内部类\"></a>5.静态内部类</h5><p>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"6-枚举\"><a href=\"#6-枚举\" class=\"headerlink\" title=\"6.枚举\"></a>6.枚举</h5><p>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Singleton &#123;  </div><div class=\"line\">    INSTANCE;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">whateverMethod</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"三-总结\"><a href=\"#三-总结\" class=\"headerlink\" title=\"三 总结\"></a>三 总结</h3><p>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现懒加载效果时，才会使用第 5 种静态内部类方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p>\n"},{"title":"设计模式之工厂模式","date":"2017-03-28T03:58:26.000Z","_content":"\n### 一 概述\n\n工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一，这种类型的设计模式属于创建型模式。工厂模式分为简单工厂模式，工厂方法模式，抽象工厂模式。\n\n### 二 简单工厂模式\n\n简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类\n\n##### 结构\n\n简单工厂模式包含如下角色：\n\n- Factory：工厂角色    \n 工厂角色负责实现创建所有实例的内部逻辑\n\n- Product：抽象产品角色    \n抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口\n\n- ConcreteProduct：具体产品角色     \n具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。\n\n下面的是结构图：\n\n{% asset_img 简单工厂模式类图.jpg 简单工厂模式类图 %}\n\n##### 代码示例\n\n抽象产品类\n\n```java\npublic abstract class Shape {   \n    //各个产品的相同属性与逻辑\n\t....\n\n\t//需要被重写的方法，展现各个产品的不同\n\tpublic abstract void draw();\n}\n```\n\n具体产品类A\n\n```java\npublic class Circle extends Shape{\n    @Override\n    public void draw() {\n        System.out.println(\"圆形工厂：圆形\");        \n    }\n}\n```\n\n具体工厂类B\n\n```java\npublic class Square extends Shape{\n    @Override\n    public void draw() {\n        System.out.println(\"方形工廠：正方形\");\n    }\n}\n```\n\n工厂类\n\n```java\npublic class SimpleFactory {\n    public static Shape createProduct(String product) {\n        if(product.equals(\"circle\")){\n            return new Circle();\n        }else if(product.equals(\"square\")){\n            return new Square();\n        }else {\n            System.out.println(\"無此產品\");\n            return null;\n        }\n    }\n}\n```\n\n主程序\n\n```java\npublic class Main {\n    public static void main(String args[]) {\n        SimpleFactory.createProduct(\"circle\").draw();\n        SimpleFactory.createProduct(\"square\").draw();\n    }\n}\n```\n\n### 三 工厂方法模式\n\n工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类\n\n##### 结构\n\n工厂方法模式包含如下角色：\n\n- Product：抽象产品\n- ConcreteProduct：具体产品\n- Factory：抽象工厂\n- ConcreteFactory：具体工厂\n\n{% asset_img 工厂方法模式类图.jpg 工厂方法模式类图 %}\n\n##### 代码示例\n\n抽象产品接口\n\n```java\npublic interface Pizza {\n    public String getName();\n    public void prepaid();\n    public void baking();\n}\n```\n\n具体产品A\n\n```java\npublic class NYBeefPizza implements Pizza{\n    @Override\n    public String getName() {\n        return \"牛肉Pizza\";\n    }\n\n    @Override\n    public void prepaid() {\n        System.out.println(getName()+\" 準備中...\");\n        System.out.println(getName()+\" 加入紐約特製醬料...\");        \n    }\n\n    @Override\n    public void baking() {\n        System.out.println(getName()+\" 烘烤中...\");    \n    }\n}\n```\n\n具体产品B\n\n```java\npublic class TPSeafoodPizza implements Pizza{\n    @Override\n    public String getName() {\n        return \"海鮮Pizza\";\n    }\n\n    @Override\n    public void prepaid() {\n        System.out.println(getName()+\" 準備中...\");\n        System.out.println(getName()+\" 加入臺北特製醬料...\");        \n    }\n\n    @Override\n    public void baking() {\n        System.out.println(getName()+\" 烘烤中...\");    \n    }\n}\n```\n\n抽象工厂类\n\n```java\npublic abstract class PizzaFactory {\n\n    public Pizza orderPizza(PIZZATYPE pizzaType){\n        System.out.println(getClass()+\" 開始準備Pizza\");\n        Pizza pizza = createPizza(pizzaType);\n        pizza.prepaid();\n        pizza.baking();\n        return pizza;\n    }\n\n    protected abstract Pizza createPizza(PIZZATYPE pizzaType);\n}\n```\n\n具体工厂类A\n\n```java\npublic class NYBeefPizzaFactory extends PizzaFactory {\n\n    @Override\n    protected Pizza createPizza(PIZZATYPE pizzaType) {\n        Pizza pizza = new NYBeefPizza();\n        return pizza;\n    }\n}\n```\n\n具体工厂类B\n\n```java\npublic class TPSeafoodPizzaFactory extends PizzaFactory {\n\n    @Override\n    protected Pizza createPizza(PIZZATYPE pizzaType) {\n        Pizza pizza = new TPSeafoodPizza();\n        return pizza;\n    }\n}\n```\n\n### 四 抽象工厂模式\n\n抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。\n\n##### 结构\n\n抽象工厂模式包含如下角色：\n\n- AbstractFactory：抽象工厂\n- ConcreteFactory：具体工厂\n- AbstractProduct：抽象产品\n- Product：具体产品\n\n{% asset_img 抽象工厂模式类图.jpg 抽象工厂模式类图 %}\n\n##### 代码示例\n\n产品类\n\n```java\n//发动机以及型号    \npublic interface Engine {    \n  \n}    \npublic class EngineA extends Engine{    \n    public EngineA(){    \n        System.out.println(\"制造-->EngineA\");    \n    }    \n}    \npublic class EngineB extends Engine{    \n    public EngineB(){    \n        System.out.println(\"制造-->EngineB\");    \n    }    \n}    \n  \n//空调以及型号    \npublic interface Aircondition {    \n  \n}    \npublic class AirconditionA extends Aircondition{    \n    public AirconditionA(){    \n        System.out.println(\"制造-->AirconditionA\");    \n    }    \n}    \npublic class AirconditionB extends Aircondition{    \n    public AirconditionB(){    \n        System.out.println(\"制造-->AirconditionB\");    \n    }    \n}  \n```\n\n工厂类\n\n```java\n//创建工厂的接口    \npublic interface AbstractFactory {    \n    //制造发动机  \n    public Engine createEngine();  \n    //制造空调   \n    public Aircondition createAircondition();   \n}    \n  \n  \n//为宝马320系列生产配件    \npublic class FactoryBMW320 implements AbstractFactory{    \n        \n    @Override    \n    public Engine createEngine() {      \n        return new EngineA();    \n    }    \n    @Override    \n    public Aircondition createAircondition() {    \n        return new AirconditionA();    \n    }    \n}    \n//宝马523系列  \npublic class FactoryBMW523 implements AbstractFactory {    \n    \n     @Override    \n    public Engine createEngine() {      \n        return new EngineB();    \n    }    \n    @Override    \n    public Aircondition createAircondition() {    \n        return new AirconditionB();    \n    }    \n  \n  \n}  \n```\n\n主程序\n\n```java\n    public class Customer {    \n        public static void main(String[] args){    \n            //生产宝马320系列配件  \n            FactoryBMW320 factoryBMW320 = new FactoryBMW320();    \n            factoryBMW320.createEngine();  \n            factoryBMW320.createAircondition();  \n                \n            //生产宝马523系列配件    \n            FactoryBMW523 factoryBMW523 = new FactoryBMW523();    \n            factoryBMW320.createEngine();  \n            factoryBMW320.createAircondition();  \n        }    \n    }  \n```\n\n### 五 总结\n\n\n","source":"_posts/设计模式之工厂模式.md","raw":"---\ntitle: 设计模式之工厂模式\ndate: 2017-03-28 11:58:26\ncategories: 设计模式\ntags:\n- 创建型模式\n- 简单工厂模式\n- 抽象工厂模式\n- 工厂方法模式\n---\n\n### 一 概述\n\n工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一，这种类型的设计模式属于创建型模式。工厂模式分为简单工厂模式，工厂方法模式，抽象工厂模式。\n\n### 二 简单工厂模式\n\n简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类\n\n##### 结构\n\n简单工厂模式包含如下角色：\n\n- Factory：工厂角色    \n 工厂角色负责实现创建所有实例的内部逻辑\n\n- Product：抽象产品角色    \n抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口\n\n- ConcreteProduct：具体产品角色     \n具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。\n\n下面的是结构图：\n\n{% asset_img 简单工厂模式类图.jpg 简单工厂模式类图 %}\n\n##### 代码示例\n\n抽象产品类\n\n```java\npublic abstract class Shape {   \n    //各个产品的相同属性与逻辑\n\t....\n\n\t//需要被重写的方法，展现各个产品的不同\n\tpublic abstract void draw();\n}\n```\n\n具体产品类A\n\n```java\npublic class Circle extends Shape{\n    @Override\n    public void draw() {\n        System.out.println(\"圆形工厂：圆形\");        \n    }\n}\n```\n\n具体工厂类B\n\n```java\npublic class Square extends Shape{\n    @Override\n    public void draw() {\n        System.out.println(\"方形工廠：正方形\");\n    }\n}\n```\n\n工厂类\n\n```java\npublic class SimpleFactory {\n    public static Shape createProduct(String product) {\n        if(product.equals(\"circle\")){\n            return new Circle();\n        }else if(product.equals(\"square\")){\n            return new Square();\n        }else {\n            System.out.println(\"無此產品\");\n            return null;\n        }\n    }\n}\n```\n\n主程序\n\n```java\npublic class Main {\n    public static void main(String args[]) {\n        SimpleFactory.createProduct(\"circle\").draw();\n        SimpleFactory.createProduct(\"square\").draw();\n    }\n}\n```\n\n### 三 工厂方法模式\n\n工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类\n\n##### 结构\n\n工厂方法模式包含如下角色：\n\n- Product：抽象产品\n- ConcreteProduct：具体产品\n- Factory：抽象工厂\n- ConcreteFactory：具体工厂\n\n{% asset_img 工厂方法模式类图.jpg 工厂方法模式类图 %}\n\n##### 代码示例\n\n抽象产品接口\n\n```java\npublic interface Pizza {\n    public String getName();\n    public void prepaid();\n    public void baking();\n}\n```\n\n具体产品A\n\n```java\npublic class NYBeefPizza implements Pizza{\n    @Override\n    public String getName() {\n        return \"牛肉Pizza\";\n    }\n\n    @Override\n    public void prepaid() {\n        System.out.println(getName()+\" 準備中...\");\n        System.out.println(getName()+\" 加入紐約特製醬料...\");        \n    }\n\n    @Override\n    public void baking() {\n        System.out.println(getName()+\" 烘烤中...\");    \n    }\n}\n```\n\n具体产品B\n\n```java\npublic class TPSeafoodPizza implements Pizza{\n    @Override\n    public String getName() {\n        return \"海鮮Pizza\";\n    }\n\n    @Override\n    public void prepaid() {\n        System.out.println(getName()+\" 準備中...\");\n        System.out.println(getName()+\" 加入臺北特製醬料...\");        \n    }\n\n    @Override\n    public void baking() {\n        System.out.println(getName()+\" 烘烤中...\");    \n    }\n}\n```\n\n抽象工厂类\n\n```java\npublic abstract class PizzaFactory {\n\n    public Pizza orderPizza(PIZZATYPE pizzaType){\n        System.out.println(getClass()+\" 開始準備Pizza\");\n        Pizza pizza = createPizza(pizzaType);\n        pizza.prepaid();\n        pizza.baking();\n        return pizza;\n    }\n\n    protected abstract Pizza createPizza(PIZZATYPE pizzaType);\n}\n```\n\n具体工厂类A\n\n```java\npublic class NYBeefPizzaFactory extends PizzaFactory {\n\n    @Override\n    protected Pizza createPizza(PIZZATYPE pizzaType) {\n        Pizza pizza = new NYBeefPizza();\n        return pizza;\n    }\n}\n```\n\n具体工厂类B\n\n```java\npublic class TPSeafoodPizzaFactory extends PizzaFactory {\n\n    @Override\n    protected Pizza createPizza(PIZZATYPE pizzaType) {\n        Pizza pizza = new TPSeafoodPizza();\n        return pizza;\n    }\n}\n```\n\n### 四 抽象工厂模式\n\n抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。\n\n##### 结构\n\n抽象工厂模式包含如下角色：\n\n- AbstractFactory：抽象工厂\n- ConcreteFactory：具体工厂\n- AbstractProduct：抽象产品\n- Product：具体产品\n\n{% asset_img 抽象工厂模式类图.jpg 抽象工厂模式类图 %}\n\n##### 代码示例\n\n产品类\n\n```java\n//发动机以及型号    \npublic interface Engine {    \n  \n}    \npublic class EngineA extends Engine{    \n    public EngineA(){    \n        System.out.println(\"制造-->EngineA\");    \n    }    \n}    \npublic class EngineB extends Engine{    \n    public EngineB(){    \n        System.out.println(\"制造-->EngineB\");    \n    }    \n}    \n  \n//空调以及型号    \npublic interface Aircondition {    \n  \n}    \npublic class AirconditionA extends Aircondition{    \n    public AirconditionA(){    \n        System.out.println(\"制造-->AirconditionA\");    \n    }    \n}    \npublic class AirconditionB extends Aircondition{    \n    public AirconditionB(){    \n        System.out.println(\"制造-->AirconditionB\");    \n    }    \n}  \n```\n\n工厂类\n\n```java\n//创建工厂的接口    \npublic interface AbstractFactory {    \n    //制造发动机  \n    public Engine createEngine();  \n    //制造空调   \n    public Aircondition createAircondition();   \n}    \n  \n  \n//为宝马320系列生产配件    \npublic class FactoryBMW320 implements AbstractFactory{    \n        \n    @Override    \n    public Engine createEngine() {      \n        return new EngineA();    \n    }    \n    @Override    \n    public Aircondition createAircondition() {    \n        return new AirconditionA();    \n    }    \n}    \n//宝马523系列  \npublic class FactoryBMW523 implements AbstractFactory {    \n    \n     @Override    \n    public Engine createEngine() {      \n        return new EngineB();    \n    }    \n    @Override    \n    public Aircondition createAircondition() {    \n        return new AirconditionB();    \n    }    \n  \n  \n}  \n```\n\n主程序\n\n```java\n    public class Customer {    \n        public static void main(String[] args){    \n            //生产宝马320系列配件  \n            FactoryBMW320 factoryBMW320 = new FactoryBMW320();    \n            factoryBMW320.createEngine();  \n            factoryBMW320.createAircondition();  \n                \n            //生产宝马523系列配件    \n            FactoryBMW523 factoryBMW523 = new FactoryBMW523();    \n            factoryBMW320.createEngine();  \n            factoryBMW320.createAircondition();  \n        }    \n    }  \n```\n\n### 五 总结\n\n\n","slug":"设计模式之工厂模式","published":1,"updated":"2017-03-28T07:50:23.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk2h002caknzr2iyfk6t","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一，这种类型的设计模式属于创建型模式。工厂模式分为简单工厂模式，工厂方法模式，抽象工厂模式。</p>\n<h3 id=\"二-简单工厂模式\"><a href=\"#二-简单工厂模式\" class=\"headerlink\" title=\"二 简单工厂模式\"></a>二 简单工厂模式</h3><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类</p>\n<h5 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h5><p>简单工厂模式包含如下角色：</p>\n<ul>\n<li><p>Factory：工厂角色<br>工厂角色负责实现创建所有实例的内部逻辑</p>\n</li>\n<li><p>Product：抽象产品角色<br>抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</p>\n</li>\n<li><p>ConcreteProduct：具体产品角色<br>具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</p>\n</li>\n</ul>\n<p>下面的是结构图：</p>\n<img src=\"/2017/03/28/设计模式之工厂模式/简单工厂模式类图.jpg\" alt=\"简单工厂模式类图\" title=\"简单工厂模式类图\">\n<h5 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h5><p>抽象产品类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> </span>&#123;   </div><div class=\"line\">    <span class=\"comment\">//各个产品的相同属性与逻辑</span></div><div class=\"line\">\t....</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//需要被重写的方法，展现各个产品的不同</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体产品类A</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span></span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"圆形工厂：圆形\"</span>);        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体工厂类B</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span></span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"方形工廠：正方形\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>工厂类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleFactory</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Shape <span class=\"title\">createProduct</span><span class=\"params\">(String product)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(product.equals(<span class=\"string\">\"circle\"</span>))&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Circle();</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(product.equals(<span class=\"string\">\"square\"</span>))&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Square();</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            System.out.println(<span class=\"string\">\"無此產品\"</span>);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主程序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</div><div class=\"line\">        SimpleFactory.createProduct(<span class=\"string\">\"circle\"</span>).draw();</div><div class=\"line\">        SimpleFactory.createProduct(<span class=\"string\">\"square\"</span>).draw();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"三-工厂方法模式\"><a href=\"#三-工厂方法模式\" class=\"headerlink\" title=\"三 工厂方法模式\"></a>三 工厂方法模式</h3><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类</p>\n<h5 id=\"结构-1\"><a href=\"#结构-1\" class=\"headerlink\" title=\"结构\"></a>结构</h5><p>工厂方法模式包含如下角色：</p>\n<ul>\n<li>Product：抽象产品</li>\n<li>ConcreteProduct：具体产品</li>\n<li>Factory：抽象工厂</li>\n<li>ConcreteFactory：具体工厂</li>\n</ul>\n<img src=\"/2017/03/28/设计模式之工厂模式/工厂方法模式类图.jpg\" alt=\"工厂方法模式类图\" title=\"工厂方法模式类图\">\n<h5 id=\"代码示例-1\"><a href=\"#代码示例-1\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h5><p>抽象产品接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Pizza</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">prepaid</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">baking</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体产品A</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NYBeefPizza</span> <span class=\"keyword\">implements</span> <span class=\"title\">Pizza</span></span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"牛肉Pizza\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">prepaid</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(getName()+<span class=\"string\">\" 準備中...\"</span>);</div><div class=\"line\">        System.out.println(getName()+<span class=\"string\">\" 加入紐約特製醬料...\"</span>);        </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">baking</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(getName()+<span class=\"string\">\" 烘烤中...\"</span>);    </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体产品B</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TPSeafoodPizza</span> <span class=\"keyword\">implements</span> <span class=\"title\">Pizza</span></span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"海鮮Pizza\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">prepaid</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(getName()+<span class=\"string\">\" 準備中...\"</span>);</div><div class=\"line\">        System.out.println(getName()+<span class=\"string\">\" 加入臺北特製醬料...\"</span>);        </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">baking</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(getName()+<span class=\"string\">\" 烘烤中...\"</span>);    </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>抽象工厂类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PizzaFactory</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Pizza <span class=\"title\">orderPizza</span><span class=\"params\">(PIZZATYPE pizzaType)</span></span>&#123;</div><div class=\"line\">        System.out.println(getClass()+<span class=\"string\">\" 開始準備Pizza\"</span>);</div><div class=\"line\">        Pizza pizza = createPizza(pizzaType);</div><div class=\"line\">        pizza.prepaid();</div><div class=\"line\">        pizza.baking();</div><div class=\"line\">        <span class=\"keyword\">return</span> pizza;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> Pizza <span class=\"title\">createPizza</span><span class=\"params\">(PIZZATYPE pizzaType)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体工厂类A</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NYBeefPizzaFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">PizzaFactory</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Pizza <span class=\"title\">createPizza</span><span class=\"params\">(PIZZATYPE pizzaType)</span> </span>&#123;</div><div class=\"line\">        Pizza pizza = <span class=\"keyword\">new</span> NYBeefPizza();</div><div class=\"line\">        <span class=\"keyword\">return</span> pizza;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体工厂类B</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TPSeafoodPizzaFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">PizzaFactory</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Pizza <span class=\"title\">createPizza</span><span class=\"params\">(PIZZATYPE pizzaType)</span> </span>&#123;</div><div class=\"line\">        Pizza pizza = <span class=\"keyword\">new</span> TPSeafoodPizza();</div><div class=\"line\">        <span class=\"keyword\">return</span> pizza;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"四-抽象工厂模式\"><a href=\"#四-抽象工厂模式\" class=\"headerlink\" title=\"四 抽象工厂模式\"></a>四 抽象工厂模式</h3><p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p>\n<h5 id=\"结构-2\"><a href=\"#结构-2\" class=\"headerlink\" title=\"结构\"></a>结构</h5><p>抽象工厂模式包含如下角色：</p>\n<ul>\n<li>AbstractFactory：抽象工厂</li>\n<li>ConcreteFactory：具体工厂</li>\n<li>AbstractProduct：抽象产品</li>\n<li>Product：具体产品</li>\n</ul>\n<img src=\"/2017/03/28/设计模式之工厂模式/抽象工厂模式类图.jpg\" alt=\"抽象工厂模式类图\" title=\"抽象工厂模式类图\">\n<h5 id=\"代码示例-2\"><a href=\"#代码示例-2\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h5><p>产品类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//发动机以及型号    </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Engine</span> </span>&#123;    </div><div class=\"line\">  </div><div class=\"line\">&#125;    </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EngineA</span> <span class=\"keyword\">extends</span> <span class=\"title\">Engine</span></span>&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EngineA</span><span class=\"params\">()</span></span>&#123;    </div><div class=\"line\">        System.out.println(<span class=\"string\">\"制造--&gt;EngineA\"</span>);    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;    </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EngineB</span> <span class=\"keyword\">extends</span> <span class=\"title\">Engine</span></span>&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EngineB</span><span class=\"params\">()</span></span>&#123;    </div><div class=\"line\">        System.out.println(<span class=\"string\">\"制造--&gt;EngineB\"</span>);    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;    </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">//空调以及型号    </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Aircondition</span> </span>&#123;    </div><div class=\"line\">  </div><div class=\"line\">&#125;    </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AirconditionA</span> <span class=\"keyword\">extends</span> <span class=\"title\">Aircondition</span></span>&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AirconditionA</span><span class=\"params\">()</span></span>&#123;    </div><div class=\"line\">        System.out.println(<span class=\"string\">\"制造--&gt;AirconditionA\"</span>);    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;    </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AirconditionB</span> <span class=\"keyword\">extends</span> <span class=\"title\">Aircondition</span></span>&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AirconditionB</span><span class=\"params\">()</span></span>&#123;    </div><div class=\"line\">        System.out.println(<span class=\"string\">\"制造--&gt;AirconditionB\"</span>);    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>工厂类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建工厂的接口    </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AbstractFactory</span> </span>&#123;    </div><div class=\"line\">    <span class=\"comment\">//制造发动机  </span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Engine <span class=\"title\">createEngine</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    <span class=\"comment\">//制造空调   </span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Aircondition <span class=\"title\">createAircondition</span><span class=\"params\">()</span></span>;   </div><div class=\"line\">&#125;    </div><div class=\"line\">  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">//为宝马320系列生产配件    </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FactoryBMW320</span> <span class=\"keyword\">implements</span> <span class=\"title\">AbstractFactory</span></span>&#123;    </div><div class=\"line\">        </div><div class=\"line\">    <span class=\"meta\">@Override</span>    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Engine <span class=\"title\">createEngine</span><span class=\"params\">()</span> </span>&#123;      </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EngineA();    </div><div class=\"line\">    &#125;    </div><div class=\"line\">    <span class=\"meta\">@Override</span>    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Aircondition <span class=\"title\">createAircondition</span><span class=\"params\">()</span> </span>&#123;    </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AirconditionA();    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;    </div><div class=\"line\"><span class=\"comment\">//宝马523系列  </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FactoryBMW523</span> <span class=\"keyword\">implements</span> <span class=\"title\">AbstractFactory</span> </span>&#123;    </div><div class=\"line\">    </div><div class=\"line\">     <span class=\"meta\">@Override</span>    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Engine <span class=\"title\">createEngine</span><span class=\"params\">()</span> </span>&#123;      </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EngineB();    </div><div class=\"line\">    &#125;    </div><div class=\"line\">    <span class=\"meta\">@Override</span>    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Aircondition <span class=\"title\">createAircondition</span><span class=\"params\">()</span> </span>&#123;    </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AirconditionB();    </div><div class=\"line\">    &#125;    </div><div class=\"line\">  </div><div class=\"line\">  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主程序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;    </div><div class=\"line\">        <span class=\"comment\">//生产宝马320系列配件  </span></div><div class=\"line\">        FactoryBMW320 factoryBMW320 = <span class=\"keyword\">new</span> FactoryBMW320();    </div><div class=\"line\">        factoryBMW320.createEngine();  </div><div class=\"line\">        factoryBMW320.createAircondition();  </div><div class=\"line\">            </div><div class=\"line\">        <span class=\"comment\">//生产宝马523系列配件    </span></div><div class=\"line\">        FactoryBMW523 factoryBMW523 = <span class=\"keyword\">new</span> FactoryBMW523();    </div><div class=\"line\">        factoryBMW320.createEngine();  </div><div class=\"line\">        factoryBMW320.createAircondition();  </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"五-总结\"><a href=\"#五-总结\" class=\"headerlink\" title=\"五 总结\"></a>五 总结</h3>","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一，这种类型的设计模式属于创建型模式。工厂模式分为简单工厂模式，工厂方法模式，抽象工厂模式。</p>\n<h3 id=\"二-简单工厂模式\"><a href=\"#二-简单工厂模式\" class=\"headerlink\" title=\"二 简单工厂模式\"></a>二 简单工厂模式</h3><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类</p>\n<h5 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h5><p>简单工厂模式包含如下角色：</p>\n<ul>\n<li><p>Factory：工厂角色<br>工厂角色负责实现创建所有实例的内部逻辑</p>\n</li>\n<li><p>Product：抽象产品角色<br>抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</p>\n</li>\n<li><p>ConcreteProduct：具体产品角色<br>具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</p>\n</li>\n</ul>\n<p>下面的是结构图：</p>\n<img src=\"/2017/03/28/设计模式之工厂模式/简单工厂模式类图.jpg\" alt=\"简单工厂模式类图\" title=\"简单工厂模式类图\">\n<h5 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h5><p>抽象产品类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> </span>&#123;   </div><div class=\"line\">    <span class=\"comment\">//各个产品的相同属性与逻辑</span></div><div class=\"line\">\t....</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//需要被重写的方法，展现各个产品的不同</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体产品类A</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span></span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"圆形工厂：圆形\"</span>);        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体工厂类B</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span></span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"方形工廠：正方形\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>工厂类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleFactory</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Shape <span class=\"title\">createProduct</span><span class=\"params\">(String product)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(product.equals(<span class=\"string\">\"circle\"</span>))&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Circle();</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(product.equals(<span class=\"string\">\"square\"</span>))&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Square();</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            System.out.println(<span class=\"string\">\"無此產品\"</span>);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主程序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</div><div class=\"line\">        SimpleFactory.createProduct(<span class=\"string\">\"circle\"</span>).draw();</div><div class=\"line\">        SimpleFactory.createProduct(<span class=\"string\">\"square\"</span>).draw();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"三-工厂方法模式\"><a href=\"#三-工厂方法模式\" class=\"headerlink\" title=\"三 工厂方法模式\"></a>三 工厂方法模式</h3><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类</p>\n<h5 id=\"结构-1\"><a href=\"#结构-1\" class=\"headerlink\" title=\"结构\"></a>结构</h5><p>工厂方法模式包含如下角色：</p>\n<ul>\n<li>Product：抽象产品</li>\n<li>ConcreteProduct：具体产品</li>\n<li>Factory：抽象工厂</li>\n<li>ConcreteFactory：具体工厂</li>\n</ul>\n<img src=\"/2017/03/28/设计模式之工厂模式/工厂方法模式类图.jpg\" alt=\"工厂方法模式类图\" title=\"工厂方法模式类图\">\n<h5 id=\"代码示例-1\"><a href=\"#代码示例-1\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h5><p>抽象产品接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Pizza</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">prepaid</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">baking</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体产品A</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NYBeefPizza</span> <span class=\"keyword\">implements</span> <span class=\"title\">Pizza</span></span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"牛肉Pizza\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">prepaid</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(getName()+<span class=\"string\">\" 準備中...\"</span>);</div><div class=\"line\">        System.out.println(getName()+<span class=\"string\">\" 加入紐約特製醬料...\"</span>);        </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">baking</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(getName()+<span class=\"string\">\" 烘烤中...\"</span>);    </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体产品B</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TPSeafoodPizza</span> <span class=\"keyword\">implements</span> <span class=\"title\">Pizza</span></span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"海鮮Pizza\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">prepaid</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(getName()+<span class=\"string\">\" 準備中...\"</span>);</div><div class=\"line\">        System.out.println(getName()+<span class=\"string\">\" 加入臺北特製醬料...\"</span>);        </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">baking</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(getName()+<span class=\"string\">\" 烘烤中...\"</span>);    </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>抽象工厂类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PizzaFactory</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Pizza <span class=\"title\">orderPizza</span><span class=\"params\">(PIZZATYPE pizzaType)</span></span>&#123;</div><div class=\"line\">        System.out.println(getClass()+<span class=\"string\">\" 開始準備Pizza\"</span>);</div><div class=\"line\">        Pizza pizza = createPizza(pizzaType);</div><div class=\"line\">        pizza.prepaid();</div><div class=\"line\">        pizza.baking();</div><div class=\"line\">        <span class=\"keyword\">return</span> pizza;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> Pizza <span class=\"title\">createPizza</span><span class=\"params\">(PIZZATYPE pizzaType)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体工厂类A</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NYBeefPizzaFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">PizzaFactory</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Pizza <span class=\"title\">createPizza</span><span class=\"params\">(PIZZATYPE pizzaType)</span> </span>&#123;</div><div class=\"line\">        Pizza pizza = <span class=\"keyword\">new</span> NYBeefPizza();</div><div class=\"line\">        <span class=\"keyword\">return</span> pizza;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体工厂类B</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TPSeafoodPizzaFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">PizzaFactory</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Pizza <span class=\"title\">createPizza</span><span class=\"params\">(PIZZATYPE pizzaType)</span> </span>&#123;</div><div class=\"line\">        Pizza pizza = <span class=\"keyword\">new</span> TPSeafoodPizza();</div><div class=\"line\">        <span class=\"keyword\">return</span> pizza;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"四-抽象工厂模式\"><a href=\"#四-抽象工厂模式\" class=\"headerlink\" title=\"四 抽象工厂模式\"></a>四 抽象工厂模式</h3><p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p>\n<h5 id=\"结构-2\"><a href=\"#结构-2\" class=\"headerlink\" title=\"结构\"></a>结构</h5><p>抽象工厂模式包含如下角色：</p>\n<ul>\n<li>AbstractFactory：抽象工厂</li>\n<li>ConcreteFactory：具体工厂</li>\n<li>AbstractProduct：抽象产品</li>\n<li>Product：具体产品</li>\n</ul>\n<img src=\"/2017/03/28/设计模式之工厂模式/抽象工厂模式类图.jpg\" alt=\"抽象工厂模式类图\" title=\"抽象工厂模式类图\">\n<h5 id=\"代码示例-2\"><a href=\"#代码示例-2\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h5><p>产品类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//发动机以及型号    </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Engine</span> </span>&#123;    </div><div class=\"line\">  </div><div class=\"line\">&#125;    </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EngineA</span> <span class=\"keyword\">extends</span> <span class=\"title\">Engine</span></span>&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EngineA</span><span class=\"params\">()</span></span>&#123;    </div><div class=\"line\">        System.out.println(<span class=\"string\">\"制造--&gt;EngineA\"</span>);    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;    </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EngineB</span> <span class=\"keyword\">extends</span> <span class=\"title\">Engine</span></span>&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EngineB</span><span class=\"params\">()</span></span>&#123;    </div><div class=\"line\">        System.out.println(<span class=\"string\">\"制造--&gt;EngineB\"</span>);    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;    </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">//空调以及型号    </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Aircondition</span> </span>&#123;    </div><div class=\"line\">  </div><div class=\"line\">&#125;    </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AirconditionA</span> <span class=\"keyword\">extends</span> <span class=\"title\">Aircondition</span></span>&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AirconditionA</span><span class=\"params\">()</span></span>&#123;    </div><div class=\"line\">        System.out.println(<span class=\"string\">\"制造--&gt;AirconditionA\"</span>);    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;    </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AirconditionB</span> <span class=\"keyword\">extends</span> <span class=\"title\">Aircondition</span></span>&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AirconditionB</span><span class=\"params\">()</span></span>&#123;    </div><div class=\"line\">        System.out.println(<span class=\"string\">\"制造--&gt;AirconditionB\"</span>);    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>工厂类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建工厂的接口    </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AbstractFactory</span> </span>&#123;    </div><div class=\"line\">    <span class=\"comment\">//制造发动机  </span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Engine <span class=\"title\">createEngine</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    <span class=\"comment\">//制造空调   </span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Aircondition <span class=\"title\">createAircondition</span><span class=\"params\">()</span></span>;   </div><div class=\"line\">&#125;    </div><div class=\"line\">  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">//为宝马320系列生产配件    </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FactoryBMW320</span> <span class=\"keyword\">implements</span> <span class=\"title\">AbstractFactory</span></span>&#123;    </div><div class=\"line\">        </div><div class=\"line\">    <span class=\"meta\">@Override</span>    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Engine <span class=\"title\">createEngine</span><span class=\"params\">()</span> </span>&#123;      </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EngineA();    </div><div class=\"line\">    &#125;    </div><div class=\"line\">    <span class=\"meta\">@Override</span>    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Aircondition <span class=\"title\">createAircondition</span><span class=\"params\">()</span> </span>&#123;    </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AirconditionA();    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;    </div><div class=\"line\"><span class=\"comment\">//宝马523系列  </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FactoryBMW523</span> <span class=\"keyword\">implements</span> <span class=\"title\">AbstractFactory</span> </span>&#123;    </div><div class=\"line\">    </div><div class=\"line\">     <span class=\"meta\">@Override</span>    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Engine <span class=\"title\">createEngine</span><span class=\"params\">()</span> </span>&#123;      </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EngineB();    </div><div class=\"line\">    &#125;    </div><div class=\"line\">    <span class=\"meta\">@Override</span>    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Aircondition <span class=\"title\">createAircondition</span><span class=\"params\">()</span> </span>&#123;    </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AirconditionB();    </div><div class=\"line\">    &#125;    </div><div class=\"line\">  </div><div class=\"line\">  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主程序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;    </div><div class=\"line\">        <span class=\"comment\">//生产宝马320系列配件  </span></div><div class=\"line\">        FactoryBMW320 factoryBMW320 = <span class=\"keyword\">new</span> FactoryBMW320();    </div><div class=\"line\">        factoryBMW320.createEngine();  </div><div class=\"line\">        factoryBMW320.createAircondition();  </div><div class=\"line\">            </div><div class=\"line\">        <span class=\"comment\">//生产宝马523系列配件    </span></div><div class=\"line\">        FactoryBMW523 factoryBMW523 = <span class=\"keyword\">new</span> FactoryBMW523();    </div><div class=\"line\">        factoryBMW320.createEngine();  </div><div class=\"line\">        factoryBMW320.createAircondition();  </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"五-总结\"><a href=\"#五-总结\" class=\"headerlink\" title=\"五 总结\"></a>五 总结</h3>"},{"title":"设计模式之观察者模式","date":"2017-03-28T02:54:21.000Z","_content":"\n### 一 概述\n\n观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。\n\n### 二 结构\n\n观察者模式包含如下角色：\n\n- Subject: 目标\n- ConcreteSubject: 具体目标\n- Observer: 观察者\n- ConcreteObserver: 具体观察者\n\n它的类图如下：\n\n{% asset_img 观察者模式类图.jpg 观察者模式类图 %}\n\n\n### 三 代码示例\n\n被观察者抽象父类\n\n```java\npublic abstract class Subject {\n    /**\n     * 用来保存注册的观察者对象\n     */\n    private    List<Observer> list = new ArrayList<Observer>();\n    /**\n     * 注册观察者对象\n     * @param observer    观察者对象\n     */\n    public void attach(Observer observer){\n        \n        list.add(observer);\n        System.out.println(\"Attached an observer\");\n    }\n    /**\n     * 删除观察者对象\n     * @param observer    观察者对象\n     */\n    public void detach(Observer observer){\n        \n        list.remove(observer);\n    }\n    /**\n     * 通知所有注册的观察者对象\n     */\n    public void notify(String newState){\n        \n        for(Observer observer : list){\n            observer.update(newState);\n        }\n    }\n}\n```\n\n被观察者具体类\n\n```java\npublic class ConcreteSubject extends Subject{\n    \n    private String state;\n    \n    public String getState() {\n        return state;\n    }\n\n    public void setState(String newState){\n        state = newState;\n        System.out.println(\"主题状态为：\" + state);\n        //状态发生改变，通知各个观察者\n        this.nodify(state);\n    }\n}\n```\n\n观察者接口\n\n```java\npublic interface Observer {\n    /**\n     * 更新接口\n     * @param state    更新的状态\n     */\n    public void update(String state);\n}\n```\n\n观察者具体实现类\n\n```java\npublic class ConcreteObserver implements Observer {\n    //观察者的状态\n    private String observerState;\n    \n    @Override\n    public void update(String state) {\n        /**\n         * 更新观察者的状态，使其与目标的状态保持一致\n         */\n        observerState = state;\n        System.out.println(\"状态为：\"+observerState);\n    }\n\n}\n```\n\n主程序调用\n\n```java\npublic class Client {\n\n    public static void main(String[] args) {\n        //创建主题对象\n        ConcreteSubject subject = new ConcreteSubject();\n        //创建观察者对象\n        Observer observer = new ConcreteObserver();\n        //将观察者对象登记到主题对象上\n        subject.attach(observer);\n        //改变主题对象的状态\n        subject.setState(\"new state\");\n    }\n\n} \t\n```\n\n### 四 总结\n\n观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。观察者模式适用情况包括：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。\n\n在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了Java语言对观察者模式的支持。","source":"_posts/设计模式之观察者模式.md","raw":"---\ntitle: 设计模式之观察者模式\ndate: 2017-03-28 10:54:21\ncategories: 设计模式\ntags:\n- 观察者模式\n- 行为模式\n---\n\n### 一 概述\n\n观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。\n\n### 二 结构\n\n观察者模式包含如下角色：\n\n- Subject: 目标\n- ConcreteSubject: 具体目标\n- Observer: 观察者\n- ConcreteObserver: 具体观察者\n\n它的类图如下：\n\n{% asset_img 观察者模式类图.jpg 观察者模式类图 %}\n\n\n### 三 代码示例\n\n被观察者抽象父类\n\n```java\npublic abstract class Subject {\n    /**\n     * 用来保存注册的观察者对象\n     */\n    private    List<Observer> list = new ArrayList<Observer>();\n    /**\n     * 注册观察者对象\n     * @param observer    观察者对象\n     */\n    public void attach(Observer observer){\n        \n        list.add(observer);\n        System.out.println(\"Attached an observer\");\n    }\n    /**\n     * 删除观察者对象\n     * @param observer    观察者对象\n     */\n    public void detach(Observer observer){\n        \n        list.remove(observer);\n    }\n    /**\n     * 通知所有注册的观察者对象\n     */\n    public void notify(String newState){\n        \n        for(Observer observer : list){\n            observer.update(newState);\n        }\n    }\n}\n```\n\n被观察者具体类\n\n```java\npublic class ConcreteSubject extends Subject{\n    \n    private String state;\n    \n    public String getState() {\n        return state;\n    }\n\n    public void setState(String newState){\n        state = newState;\n        System.out.println(\"主题状态为：\" + state);\n        //状态发生改变，通知各个观察者\n        this.nodify(state);\n    }\n}\n```\n\n观察者接口\n\n```java\npublic interface Observer {\n    /**\n     * 更新接口\n     * @param state    更新的状态\n     */\n    public void update(String state);\n}\n```\n\n观察者具体实现类\n\n```java\npublic class ConcreteObserver implements Observer {\n    //观察者的状态\n    private String observerState;\n    \n    @Override\n    public void update(String state) {\n        /**\n         * 更新观察者的状态，使其与目标的状态保持一致\n         */\n        observerState = state;\n        System.out.println(\"状态为：\"+observerState);\n    }\n\n}\n```\n\n主程序调用\n\n```java\npublic class Client {\n\n    public static void main(String[] args) {\n        //创建主题对象\n        ConcreteSubject subject = new ConcreteSubject();\n        //创建观察者对象\n        Observer observer = new ConcreteObserver();\n        //将观察者对象登记到主题对象上\n        subject.attach(observer);\n        //改变主题对象的状态\n        subject.setState(\"new state\");\n    }\n\n} \t\n```\n\n### 四 总结\n\n观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。观察者模式适用情况包括：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。\n\n在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了Java语言对观察者模式的支持。","slug":"设计模式之观察者模式","published":1,"updated":"2017-03-28T03:57:40.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk2k002faknz5mbbm2y6","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p>\n<h3 id=\"二-结构\"><a href=\"#二-结构\" class=\"headerlink\" title=\"二 结构\"></a>二 结构</h3><p>观察者模式包含如下角色：</p>\n<ul>\n<li>Subject: 目标</li>\n<li>ConcreteSubject: 具体目标</li>\n<li>Observer: 观察者</li>\n<li>ConcreteObserver: 具体观察者</li>\n</ul>\n<p>它的类图如下：</p>\n<img src=\"/2017/03/28/设计模式之观察者模式/观察者模式类图.jpg\" alt=\"观察者模式类图\" title=\"观察者模式类图\">\n<h3 id=\"三-代码示例\"><a href=\"#三-代码示例\" class=\"headerlink\" title=\"三 代码示例\"></a>三 代码示例</h3><p>被观察者抽象父类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Subject</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 用来保存注册的观察者对象</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">private</span>    List&lt;Observer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;Observer&gt;();</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 注册观察者对象</div><div class=\"line\">     * <span class=\"doctag\">@param</span> observer    观察者对象</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(Observer observer)</span></span>&#123;</div><div class=\"line\">        </div><div class=\"line\">        list.add(observer);</div><div class=\"line\">        System.out.println(<span class=\"string\">\"Attached an observer\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 删除观察者对象</div><div class=\"line\">     * <span class=\"doctag\">@param</span> observer    观察者对象</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">detach</span><span class=\"params\">(Observer observer)</span></span>&#123;</div><div class=\"line\">        </div><div class=\"line\">        list.remove(observer);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 通知所有注册的观察者对象</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notify</span><span class=\"params\">(String newState)</span></span>&#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">for</span>(Observer observer : list)&#123;</div><div class=\"line\">            observer.update(newState);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>被观察者具体类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteSubject</span> <span class=\"keyword\">extends</span> <span class=\"title\">Subject</span></span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">private</span> String state;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getState</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> state;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setState</span><span class=\"params\">(String newState)</span></span>&#123;</div><div class=\"line\">        state = newState;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"主题状态为：\"</span> + state);</div><div class=\"line\">        <span class=\"comment\">//状态发生改变，通知各个观察者</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.nodify(state);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>观察者接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Observer</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 更新接口</div><div class=\"line\">     * <span class=\"doctag\">@param</span> state    更新的状态</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(String state)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>观察者具体实现类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteObserver</span> <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//观察者的状态</span></div><div class=\"line\">    <span class=\"keyword\">private</span> String observerState;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(String state)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">/**</span></div><div class=\"line\">         * 更新观察者的状态，使其与目标的状态保持一致</div><div class=\"line\">         */</div><div class=\"line\">        observerState = state;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"状态为：\"</span>+observerState);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主程序调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//创建主题对象</span></div><div class=\"line\">        ConcreteSubject subject = <span class=\"keyword\">new</span> ConcreteSubject();</div><div class=\"line\">        <span class=\"comment\">//创建观察者对象</span></div><div class=\"line\">        Observer observer = <span class=\"keyword\">new</span> ConcreteObserver();</div><div class=\"line\">        <span class=\"comment\">//将观察者对象登记到主题对象上</span></div><div class=\"line\">        subject.attach(observer);</div><div class=\"line\">        <span class=\"comment\">//改变主题对象的状态</span></div><div class=\"line\">        subject.setState(<span class=\"string\">\"new state\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"四-总结\"><a href=\"#四-总结\" class=\"headerlink\" title=\"四 总结\"></a>四 总结</h3><p>观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。观察者模式适用情况包括：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。</p>\n<p>在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了Java语言对观察者模式的支持。</p>\n","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p>\n<h3 id=\"二-结构\"><a href=\"#二-结构\" class=\"headerlink\" title=\"二 结构\"></a>二 结构</h3><p>观察者模式包含如下角色：</p>\n<ul>\n<li>Subject: 目标</li>\n<li>ConcreteSubject: 具体目标</li>\n<li>Observer: 观察者</li>\n<li>ConcreteObserver: 具体观察者</li>\n</ul>\n<p>它的类图如下：</p>\n<img src=\"/2017/03/28/设计模式之观察者模式/观察者模式类图.jpg\" alt=\"观察者模式类图\" title=\"观察者模式类图\">\n<h3 id=\"三-代码示例\"><a href=\"#三-代码示例\" class=\"headerlink\" title=\"三 代码示例\"></a>三 代码示例</h3><p>被观察者抽象父类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Subject</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 用来保存注册的观察者对象</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">private</span>    List&lt;Observer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;Observer&gt;();</div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 注册观察者对象</div><div class=\"line\">     * <span class=\"doctag\">@param</span> observer    观察者对象</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(Observer observer)</span></span>&#123;</div><div class=\"line\">        </div><div class=\"line\">        list.add(observer);</div><div class=\"line\">        System.out.println(<span class=\"string\">\"Attached an observer\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 删除观察者对象</div><div class=\"line\">     * <span class=\"doctag\">@param</span> observer    观察者对象</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">detach</span><span class=\"params\">(Observer observer)</span></span>&#123;</div><div class=\"line\">        </div><div class=\"line\">        list.remove(observer);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 通知所有注册的观察者对象</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notify</span><span class=\"params\">(String newState)</span></span>&#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">for</span>(Observer observer : list)&#123;</div><div class=\"line\">            observer.update(newState);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>被观察者具体类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteSubject</span> <span class=\"keyword\">extends</span> <span class=\"title\">Subject</span></span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">private</span> String state;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getState</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> state;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setState</span><span class=\"params\">(String newState)</span></span>&#123;</div><div class=\"line\">        state = newState;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"主题状态为：\"</span> + state);</div><div class=\"line\">        <span class=\"comment\">//状态发生改变，通知各个观察者</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.nodify(state);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>观察者接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Observer</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 更新接口</div><div class=\"line\">     * <span class=\"doctag\">@param</span> state    更新的状态</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(String state)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>观察者具体实现类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteObserver</span> <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//观察者的状态</span></div><div class=\"line\">    <span class=\"keyword\">private</span> String observerState;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(String state)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">/**</div><div class=\"line\">         * 更新观察者的状态，使其与目标的状态保持一致</div><div class=\"line\">         */</span></div><div class=\"line\">        observerState = state;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"状态为：\"</span>+observerState);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主程序调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//创建主题对象</span></div><div class=\"line\">        ConcreteSubject subject = <span class=\"keyword\">new</span> ConcreteSubject();</div><div class=\"line\">        <span class=\"comment\">//创建观察者对象</span></div><div class=\"line\">        Observer observer = <span class=\"keyword\">new</span> ConcreteObserver();</div><div class=\"line\">        <span class=\"comment\">//将观察者对象登记到主题对象上</span></div><div class=\"line\">        subject.attach(observer);</div><div class=\"line\">        <span class=\"comment\">//改变主题对象的状态</span></div><div class=\"line\">        subject.setState(<span class=\"string\">\"new state\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"四-总结\"><a href=\"#四-总结\" class=\"headerlink\" title=\"四 总结\"></a>四 总结</h3><p>观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。观察者模式适用情况包括：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。</p>\n<p>在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了Java语言对观察者模式的支持。</p>\n"},{"title":"android基础之数据存储","date":"2017-02-28T09:42:52.000Z","_content":"\n### 一 概述\n\nAndroid提供了5种方式来让用户保存持久化应用程序数据。根据自己的需求来做选择，比如数据是否是应用程序私有的，是否能被其他程序访问，需要多少数据存储空间等。这五种数据存储方式分别是：\n\n- 使用SharedPreferences存储数据　\n- 文件存储数据\n- SQLite数据库存储数据\n- 使用ContentProvider存储数据\n- 网络存储数据\n\n### 二 五种存储方式介绍\n\n##### 1. SharePreferences\n\nSharedPreference类提供了一个总体框架，使您可以保存和检索任何基本数据类型（ boolean, float, int, long, string）的持久键-值对（基于XML文件存储的“key-value”键值对数据）。将其以XML文件的形式保存起来。通常其存储在“data/data/程序包名/shared_prefs目录下。\n\n###### 获取SharedPreferences对象（通过Context）\n\n- getSharedPreferences (String name, int mode)   \n当我们有多个SharedPreferences的时候，根据第一个参数name获得相应的SharedPreferences对象。    \n\n- getPreferences (int mode)   \n如果你的Activity中只需要一个SharedPreferences的时候使用。\n\n这里的mode有四个选项：\n\n- Context.MODE_PRIVAT   \n该SharedPreferences数据只能被本应用程序读、写。\n\n- Context.MODE_WORLD_READABLE   \n该SharedPreferences数据能被其他应用程序读，但不能写。\n\n- Context.MODE_WORLD_WRITEABLE   \n该SharedPreferences数据能被其他应用程序读和写。\n\n- Context.MODE_MULTI_PROCESS    \nsdk2.3后添加的选项，当多个进程同时读写同一个SharedPreferences时它会检查文件是否修改。\n\n###### 向Shared Preferences中写入值\n\n主要步骤：\n\n- 首先要通过 SharedPreferences.Editor获取到Editor对象；\n- 然后通过Editor的putBoolean() 或 putString()等方法存入值；\n- 最后调用Editor的commit()方法提交；\n\n```java\n\t//Use 0 or MODE_PRIVATE for the default operation \n\tSharedPreferences settings = getSharedPreferences(\"fanrunqi\", 0);\n\tSharedPreferences.Editor editor = settings.edit();\n\teditor.putBoolean(\"isAmazing\", true); \n\t\n\t// 提交本次编辑\n\teditor.commit();\n```\n\n同时Edit还有两个常用的方法：\n\n```java\n    editor.remove(String key) ：下一次commit的时候会移除key对应的键值对\n\n    editor.clear()：移除所有键值对\n```\n\n###### 从Shared Preferences中读取值\n\n读取值使用 SharedPreference对象的getBoolean()或getString()等方法就行了,如：\n\n```java\n\tSharedPreferences settings = getSharedPreferences(\"fanrunqi\", 0);\n\tboolean isAmazing= settings.getBoolean(\"isAmazing\",true);\n```\n\n###### Shared Preferences的优缺点\n\n可以看出来Preferences是很轻量级的应用，使用起来也很方便，简洁。但存储数据类型比较单一（只有基本数据类型），无法进行条件查询，只能在不复杂的存储需求下使用，比如保存配置信息等。\n\n##### 2.文件存储\n\n###### 文件的内部存储（存储在手机中）\n\n当文件被保存在内部存储中时，默认情况下，文件是应用程序私有的，其他应用不能访问。当用户卸载应用程序时这些文件也跟着被删除。文件默认存储位置：/data/data/包名/files/文件名。\n\n**a. 创建和写入一个内部存储的私有文件** \n\n- 调用Context的openFileOutput()函数，填入文件名和操作模式，它会返回一个FileOutputStream对象。\n- 通过FileOutputStream对象的write()函数写入数据。\n- FileOutputStream对象的close ()函数关闭流\n\n例如：\n\n```java\n        String FILENAME = \"a.txt\";\n        String string = \"fanrunqi\";\n\n        try {\n            FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);\n            fos.write(string.getBytes());\n            fos.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n```\n\n在 openFileOutput(String name, int mode)方法中:\n\nname参数:　用于指定文件名称，不能包含路径分隔符“/” ，如果文件不存在，Android 会自动创建它。  \nmode参数：用于指定操作模式，分为四种：\n\n- Context.MODE_PRIVATE = 0    \n为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容。\n\n- Context.MODE_APPEND = 32768     \n该模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。　\n\n- Context.MODE_WORLD_READABLE = 1    \n表示当前文件可以被其他应用读取。\n\n- MODE_WORLD_WRITEABLE     \n表示当前文件可以被其他应用写入。\n\n**b. 读取一个内部存储的私有文件**\n\n步骤：\n\n- 调用openFileInput( )，参数中填入文件名，会返回一个FileInputStream对象。\n- 使用流对象的 read()方法读取字节\n- 调用流的close()方法关闭流\n\n例如：\n\n```java\nString FILENAME = \"a.txt\";\n        try {\n            FileInputStream inStream = openFileInput(FILENAME);\n            int len = 0;\n            byte[] buf = new byte[1024];\n            StringBuilder sb = new StringBuilder();\n            while ((len = inStream.read(buf)) != -1) {\n                sb.append(new String(buf, 0, len));\n            }\n            inStream.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } \n```\n\n其他一些经常用到的方法：\n\n- getFilesDir()：　得到内存储文件的绝对路径\n- getDir()：　在内存储空间中创建或打开一个已经存在的目录\n- deleteFile()：　删除保存在内部存储的文件。　 \n- fileList()：　返回当前由应用程序保存的文件的数组（内存储目录下的全部文件）。\n\n**c.获取编译时的静态文件**\n\n如果你想在应用编译时保存静态文件，应该把文件保存在项目的　res/raw/　目录下，你可以通过 openRawResource()方法去打开它（传入参数R.raw.filename），这个方法返回一个 InputStream流对象你可以读取文件但是不能修改原始文件。\n\n```java\nInputStream is = this.getResources().openRawResource(R.raw.filename);\n```\n\n**d. 获取内存缓存文件**\n\n有时候我们只想缓存一些数据而不是持久化保存，可以使用getCacheDir（）去打开一个文件，文件的存储目录（ /data/data/包名/cache ）是一个应用专门来保存临时缓存文件的内存目录。当设备的内部存储空间比较低的时候，Android可能会删除这些缓存文件来恢复空间，但是你不应该依赖系统来回收，要自己维护这些缓存文件把它们的大小限制在一个合理的范围内，比如1ＭＢ．当你卸载应用的时候这些缓存文件也会被移除。\n\n###### 文件的外部存储（sdcard）\n\n因为内部存储容量限制，有时候需要存储数据比较大的时候需要用到外部存储，使用外部存储分为以下几个步骤：\n\n**a. 添加外部存储访问限权**\n\n首先，要在AndroidManifest.xml中加入访问SDCard的权限，如下:\n\n```java\n\t<!-- 在SDCard中创建与删除文件权限 --> \n    <uses-permission android:name=\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\"/> \n\n    <!-- 往SDCard写入数据权限 --> \n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n\n**b. 检测外部存储的可用性**\n\n在使用外部存储时我们需要检测其状态，它可能被连接到计算机、丢失或者只读等。下面代码将说明如何检查状态：\n\n```java\n\t//获取外存储的状态\n\tString state = Environment.getExternalStorageState();\n\tif (Environment.MEDIA_MOUNTED.equals(state)) {\n\t    // 可读可写\n\t    mExternalStorageAvailable = mExternalStorageWriteable = true;\n\t} else if (Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {\n\t    // 可读\n\t} else {\n\t    // 可能有很多其他的状态，但是我们只需要知道，不能读也不能写  \n\t}\n```\n\n**c. 访问外部存储器中的文件**\n\n1) 如果 API 版本大于或等于８，使用\n\n```java\ngetExternalFilesDir (String type)\n```\n\n该方法打开一个外存储目录，此方法需要一个类型，指定你想要的子目录，如类型参数DIRECTORY_MUSIC和 DIRECTORY_RINGTONES（传null就是你应用程序的文件目录的根目录）。通过指定目录的类型，确保Android的媒体扫描仪将扫描分类系统中的文件（例如，铃声被确定为铃声）。如果用户卸载应用程序，这个目录及其所有内容将被删除。\n\n例如：\n\n```java\nFile file = new File(getExternalFilesDir(null), \"fanrunqi.jpg\");\n```\n\n2) 如果API 版本小于 8 （7或者更低）,使用\n\n```java\ngetExternalStorageDirectory ()\n```\n\n通过该方法打开外存储的根目录，你应该在以下目录下写入你的应用数据，这样当卸载应用程序时该目录及其所有内容也将被删除。目录：/Android/data/<package_name>/files/\n\n代码示例：\n\n```java\nif(Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)){  \n            File sdCardDir = Environment.getExternalStorageDirectory();//获取SDCard目录  \"/sdcard\"        \n\n               File saveFile = new File(sdCardDir,\"a.txt\"); \n\n               //写数据\n                try {\n                    FileOutputStream fos= new FileOutputStream(saveFile); \n                    fos.write(\"fanrunqi\".getBytes()); \n                    fos.close();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                } \n\n                //读数据\n                 try {\n                    FileInputStream fis= new FileInputStream(saveFile); \n                    int len =0;\n                    byte[] buf = new byte[1024];\n                    StringBuffer sb = new StringBuffer();\n                    while((len=fis.read(buf))!=-1){\n                        sb.append(new String(buf, 0, len));\n                    }\n                    fis.close();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }  \n        }\n```\n\n我们也可以在　/Android/data/package_name/cache/目录下做外部缓存。\n\n##### 3. 网路存储\n\n网路存储即是通过HttpUrlConnection或者HttpClint或者okhttp等http框架从服务器中获取数据。\n\n##### 4.SQLite存储\n\n请看我的另一篇博客《android基础之SQLite》\n\n##### 5.ContentProvider存储\n\n看我的另一篇博客《android基础之Content Provider》\n\n### 三 总结\n\n\n\n\n\n","source":"_posts/android基础之数据存储.md","raw":"---\ntitle: android基础之数据存储\ndate: 2017-02-28 17:42:52\ncategories: android\ntags:\n- android\n- java\n- 数据存储\n---\n\n### 一 概述\n\nAndroid提供了5种方式来让用户保存持久化应用程序数据。根据自己的需求来做选择，比如数据是否是应用程序私有的，是否能被其他程序访问，需要多少数据存储空间等。这五种数据存储方式分别是：\n\n- 使用SharedPreferences存储数据　\n- 文件存储数据\n- SQLite数据库存储数据\n- 使用ContentProvider存储数据\n- 网络存储数据\n\n### 二 五种存储方式介绍\n\n##### 1. SharePreferences\n\nSharedPreference类提供了一个总体框架，使您可以保存和检索任何基本数据类型（ boolean, float, int, long, string）的持久键-值对（基于XML文件存储的“key-value”键值对数据）。将其以XML文件的形式保存起来。通常其存储在“data/data/程序包名/shared_prefs目录下。\n\n###### 获取SharedPreferences对象（通过Context）\n\n- getSharedPreferences (String name, int mode)   \n当我们有多个SharedPreferences的时候，根据第一个参数name获得相应的SharedPreferences对象。    \n\n- getPreferences (int mode)   \n如果你的Activity中只需要一个SharedPreferences的时候使用。\n\n这里的mode有四个选项：\n\n- Context.MODE_PRIVAT   \n该SharedPreferences数据只能被本应用程序读、写。\n\n- Context.MODE_WORLD_READABLE   \n该SharedPreferences数据能被其他应用程序读，但不能写。\n\n- Context.MODE_WORLD_WRITEABLE   \n该SharedPreferences数据能被其他应用程序读和写。\n\n- Context.MODE_MULTI_PROCESS    \nsdk2.3后添加的选项，当多个进程同时读写同一个SharedPreferences时它会检查文件是否修改。\n\n###### 向Shared Preferences中写入值\n\n主要步骤：\n\n- 首先要通过 SharedPreferences.Editor获取到Editor对象；\n- 然后通过Editor的putBoolean() 或 putString()等方法存入值；\n- 最后调用Editor的commit()方法提交；\n\n```java\n\t//Use 0 or MODE_PRIVATE for the default operation \n\tSharedPreferences settings = getSharedPreferences(\"fanrunqi\", 0);\n\tSharedPreferences.Editor editor = settings.edit();\n\teditor.putBoolean(\"isAmazing\", true); \n\t\n\t// 提交本次编辑\n\teditor.commit();\n```\n\n同时Edit还有两个常用的方法：\n\n```java\n    editor.remove(String key) ：下一次commit的时候会移除key对应的键值对\n\n    editor.clear()：移除所有键值对\n```\n\n###### 从Shared Preferences中读取值\n\n读取值使用 SharedPreference对象的getBoolean()或getString()等方法就行了,如：\n\n```java\n\tSharedPreferences settings = getSharedPreferences(\"fanrunqi\", 0);\n\tboolean isAmazing= settings.getBoolean(\"isAmazing\",true);\n```\n\n###### Shared Preferences的优缺点\n\n可以看出来Preferences是很轻量级的应用，使用起来也很方便，简洁。但存储数据类型比较单一（只有基本数据类型），无法进行条件查询，只能在不复杂的存储需求下使用，比如保存配置信息等。\n\n##### 2.文件存储\n\n###### 文件的内部存储（存储在手机中）\n\n当文件被保存在内部存储中时，默认情况下，文件是应用程序私有的，其他应用不能访问。当用户卸载应用程序时这些文件也跟着被删除。文件默认存储位置：/data/data/包名/files/文件名。\n\n**a. 创建和写入一个内部存储的私有文件** \n\n- 调用Context的openFileOutput()函数，填入文件名和操作模式，它会返回一个FileOutputStream对象。\n- 通过FileOutputStream对象的write()函数写入数据。\n- FileOutputStream对象的close ()函数关闭流\n\n例如：\n\n```java\n        String FILENAME = \"a.txt\";\n        String string = \"fanrunqi\";\n\n        try {\n            FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);\n            fos.write(string.getBytes());\n            fos.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n```\n\n在 openFileOutput(String name, int mode)方法中:\n\nname参数:　用于指定文件名称，不能包含路径分隔符“/” ，如果文件不存在，Android 会自动创建它。  \nmode参数：用于指定操作模式，分为四种：\n\n- Context.MODE_PRIVATE = 0    \n为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容。\n\n- Context.MODE_APPEND = 32768     \n该模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。　\n\n- Context.MODE_WORLD_READABLE = 1    \n表示当前文件可以被其他应用读取。\n\n- MODE_WORLD_WRITEABLE     \n表示当前文件可以被其他应用写入。\n\n**b. 读取一个内部存储的私有文件**\n\n步骤：\n\n- 调用openFileInput( )，参数中填入文件名，会返回一个FileInputStream对象。\n- 使用流对象的 read()方法读取字节\n- 调用流的close()方法关闭流\n\n例如：\n\n```java\nString FILENAME = \"a.txt\";\n        try {\n            FileInputStream inStream = openFileInput(FILENAME);\n            int len = 0;\n            byte[] buf = new byte[1024];\n            StringBuilder sb = new StringBuilder();\n            while ((len = inStream.read(buf)) != -1) {\n                sb.append(new String(buf, 0, len));\n            }\n            inStream.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } \n```\n\n其他一些经常用到的方法：\n\n- getFilesDir()：　得到内存储文件的绝对路径\n- getDir()：　在内存储空间中创建或打开一个已经存在的目录\n- deleteFile()：　删除保存在内部存储的文件。　 \n- fileList()：　返回当前由应用程序保存的文件的数组（内存储目录下的全部文件）。\n\n**c.获取编译时的静态文件**\n\n如果你想在应用编译时保存静态文件，应该把文件保存在项目的　res/raw/　目录下，你可以通过 openRawResource()方法去打开它（传入参数R.raw.filename），这个方法返回一个 InputStream流对象你可以读取文件但是不能修改原始文件。\n\n```java\nInputStream is = this.getResources().openRawResource(R.raw.filename);\n```\n\n**d. 获取内存缓存文件**\n\n有时候我们只想缓存一些数据而不是持久化保存，可以使用getCacheDir（）去打开一个文件，文件的存储目录（ /data/data/包名/cache ）是一个应用专门来保存临时缓存文件的内存目录。当设备的内部存储空间比较低的时候，Android可能会删除这些缓存文件来恢复空间，但是你不应该依赖系统来回收，要自己维护这些缓存文件把它们的大小限制在一个合理的范围内，比如1ＭＢ．当你卸载应用的时候这些缓存文件也会被移除。\n\n###### 文件的外部存储（sdcard）\n\n因为内部存储容量限制，有时候需要存储数据比较大的时候需要用到外部存储，使用外部存储分为以下几个步骤：\n\n**a. 添加外部存储访问限权**\n\n首先，要在AndroidManifest.xml中加入访问SDCard的权限，如下:\n\n```java\n\t<!-- 在SDCard中创建与删除文件权限 --> \n    <uses-permission android:name=\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\"/> \n\n    <!-- 往SDCard写入数据权限 --> \n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n\n**b. 检测外部存储的可用性**\n\n在使用外部存储时我们需要检测其状态，它可能被连接到计算机、丢失或者只读等。下面代码将说明如何检查状态：\n\n```java\n\t//获取外存储的状态\n\tString state = Environment.getExternalStorageState();\n\tif (Environment.MEDIA_MOUNTED.equals(state)) {\n\t    // 可读可写\n\t    mExternalStorageAvailable = mExternalStorageWriteable = true;\n\t} else if (Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {\n\t    // 可读\n\t} else {\n\t    // 可能有很多其他的状态，但是我们只需要知道，不能读也不能写  \n\t}\n```\n\n**c. 访问外部存储器中的文件**\n\n1) 如果 API 版本大于或等于８，使用\n\n```java\ngetExternalFilesDir (String type)\n```\n\n该方法打开一个外存储目录，此方法需要一个类型，指定你想要的子目录，如类型参数DIRECTORY_MUSIC和 DIRECTORY_RINGTONES（传null就是你应用程序的文件目录的根目录）。通过指定目录的类型，确保Android的媒体扫描仪将扫描分类系统中的文件（例如，铃声被确定为铃声）。如果用户卸载应用程序，这个目录及其所有内容将被删除。\n\n例如：\n\n```java\nFile file = new File(getExternalFilesDir(null), \"fanrunqi.jpg\");\n```\n\n2) 如果API 版本小于 8 （7或者更低）,使用\n\n```java\ngetExternalStorageDirectory ()\n```\n\n通过该方法打开外存储的根目录，你应该在以下目录下写入你的应用数据，这样当卸载应用程序时该目录及其所有内容也将被删除。目录：/Android/data/<package_name>/files/\n\n代码示例：\n\n```java\nif(Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)){  \n            File sdCardDir = Environment.getExternalStorageDirectory();//获取SDCard目录  \"/sdcard\"        \n\n               File saveFile = new File(sdCardDir,\"a.txt\"); \n\n               //写数据\n                try {\n                    FileOutputStream fos= new FileOutputStream(saveFile); \n                    fos.write(\"fanrunqi\".getBytes()); \n                    fos.close();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                } \n\n                //读数据\n                 try {\n                    FileInputStream fis= new FileInputStream(saveFile); \n                    int len =0;\n                    byte[] buf = new byte[1024];\n                    StringBuffer sb = new StringBuffer();\n                    while((len=fis.read(buf))!=-1){\n                        sb.append(new String(buf, 0, len));\n                    }\n                    fis.close();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }  \n        }\n```\n\n我们也可以在　/Android/data/package_name/cache/目录下做外部缓存。\n\n##### 3. 网路存储\n\n网路存储即是通过HttpUrlConnection或者HttpClint或者okhttp等http框架从服务器中获取数据。\n\n##### 4.SQLite存储\n\n请看我的另一篇博客《android基础之SQLite》\n\n##### 5.ContentProvider存储\n\n看我的另一篇博客《android基础之Content Provider》\n\n### 三 总结\n\n\n\n\n\n","slug":"android基础之数据存储","published":1,"updated":"2017-03-10T04:12:00.785Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk2m002haknzknlxl2r6","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Android提供了5种方式来让用户保存持久化应用程序数据。根据自己的需求来做选择，比如数据是否是应用程序私有的，是否能被其他程序访问，需要多少数据存储空间等。这五种数据存储方式分别是：</p>\n<ul>\n<li>使用SharedPreferences存储数据　</li>\n<li>文件存储数据</li>\n<li>SQLite数据库存储数据</li>\n<li>使用ContentProvider存储数据</li>\n<li>网络存储数据</li>\n</ul>\n<h3 id=\"二-五种存储方式介绍\"><a href=\"#二-五种存储方式介绍\" class=\"headerlink\" title=\"二 五种存储方式介绍\"></a>二 五种存储方式介绍</h3><h5 id=\"1-SharePreferences\"><a href=\"#1-SharePreferences\" class=\"headerlink\" title=\"1. SharePreferences\"></a>1. SharePreferences</h5><p>SharedPreference类提供了一个总体框架，使您可以保存和检索任何基本数据类型（ boolean, float, int, long, string）的持久键-值对（基于XML文件存储的“key-value”键值对数据）。将其以XML文件的形式保存起来。通常其存储在“data/data/程序包名/shared_prefs目录下。</p>\n<h6 id=\"获取SharedPreferences对象（通过Context）\"><a href=\"#获取SharedPreferences对象（通过Context）\" class=\"headerlink\" title=\"获取SharedPreferences对象（通过Context）\"></a>获取SharedPreferences对象（通过Context）</h6><ul>\n<li><p>getSharedPreferences (String name, int mode)<br>当我们有多个SharedPreferences的时候，根据第一个参数name获得相应的SharedPreferences对象。    </p>\n</li>\n<li><p>getPreferences (int mode)<br>如果你的Activity中只需要一个SharedPreferences的时候使用。</p>\n</li>\n</ul>\n<p>这里的mode有四个选项：</p>\n<ul>\n<li><p>Context.MODE_PRIVAT<br>该SharedPreferences数据只能被本应用程序读、写。</p>\n</li>\n<li><p>Context.MODE_WORLD_READABLE<br>该SharedPreferences数据能被其他应用程序读，但不能写。</p>\n</li>\n<li><p>Context.MODE_WORLD_WRITEABLE<br>该SharedPreferences数据能被其他应用程序读和写。</p>\n</li>\n<li><p>Context.MODE_MULTI_PROCESS<br>sdk2.3后添加的选项，当多个进程同时读写同一个SharedPreferences时它会检查文件是否修改。</p>\n</li>\n</ul>\n<h6 id=\"向Shared-Preferences中写入值\"><a href=\"#向Shared-Preferences中写入值\" class=\"headerlink\" title=\"向Shared Preferences中写入值\"></a>向Shared Preferences中写入值</h6><p>主要步骤：</p>\n<ul>\n<li>首先要通过 SharedPreferences.Editor获取到Editor对象；</li>\n<li>然后通过Editor的putBoolean() 或 putString()等方法存入值；</li>\n<li>最后调用Editor的commit()方法提交；</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Use 0 or MODE_PRIVATE for the default operation </span></div><div class=\"line\">SharedPreferences settings = getSharedPreferences(<span class=\"string\">\"fanrunqi\"</span>, <span class=\"number\">0</span>);</div><div class=\"line\">SharedPreferences.Editor editor = settings.edit();</div><div class=\"line\">editor.putBoolean(<span class=\"string\">\"isAmazing\"</span>, <span class=\"keyword\">true</span>); </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 提交本次编辑</span></div><div class=\"line\">editor.commit();</div></pre></td></tr></table></figure>\n<p>同时Edit还有两个常用的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">editor.remove(String key) ：下一次commit的时候会移除key对应的键值对</div><div class=\"line\"></div><div class=\"line\">editor.clear()：移除所有键值对</div></pre></td></tr></table></figure>\n<h6 id=\"从Shared-Preferences中读取值\"><a href=\"#从Shared-Preferences中读取值\" class=\"headerlink\" title=\"从Shared Preferences中读取值\"></a>从Shared Preferences中读取值</h6><p>读取值使用 SharedPreference对象的getBoolean()或getString()等方法就行了,如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">SharedPreferences settings = getSharedPreferences(<span class=\"string\">\"fanrunqi\"</span>, <span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"keyword\">boolean</span> isAmazing= settings.getBoolean(<span class=\"string\">\"isAmazing\"</span>,<span class=\"keyword\">true</span>);</div></pre></td></tr></table></figure>\n<h6 id=\"Shared-Preferences的优缺点\"><a href=\"#Shared-Preferences的优缺点\" class=\"headerlink\" title=\"Shared Preferences的优缺点\"></a>Shared Preferences的优缺点</h6><p>可以看出来Preferences是很轻量级的应用，使用起来也很方便，简洁。但存储数据类型比较单一（只有基本数据类型），无法进行条件查询，只能在不复杂的存储需求下使用，比如保存配置信息等。</p>\n<h5 id=\"2-文件存储\"><a href=\"#2-文件存储\" class=\"headerlink\" title=\"2.文件存储\"></a>2.文件存储</h5><h6 id=\"文件的内部存储（存储在手机中）\"><a href=\"#文件的内部存储（存储在手机中）\" class=\"headerlink\" title=\"文件的内部存储（存储在手机中）\"></a>文件的内部存储（存储在手机中）</h6><p>当文件被保存在内部存储中时，默认情况下，文件是应用程序私有的，其他应用不能访问。当用户卸载应用程序时这些文件也跟着被删除。文件默认存储位置：/data/data/包名/files/文件名。</p>\n<p><strong>a. 创建和写入一个内部存储的私有文件</strong> </p>\n<ul>\n<li>调用Context的openFileOutput()函数，填入文件名和操作模式，它会返回一个FileOutputStream对象。</li>\n<li>通过FileOutputStream对象的write()函数写入数据。</li>\n<li>FileOutputStream对象的close ()函数关闭流</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">String FILENAME = <span class=\"string\">\"a.txt\"</span>;</div><div class=\"line\">String string = <span class=\"string\">\"fanrunqi\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);</div><div class=\"line\">    fos.write(string.getBytes());</div><div class=\"line\">    fos.close();</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">    e.printStackTrace();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在 openFileOutput(String name, int mode)方法中:</p>\n<p>name参数:　用于指定文件名称，不能包含路径分隔符“/” ，如果文件不存在，Android 会自动创建它。<br>mode参数：用于指定操作模式，分为四种：</p>\n<ul>\n<li><p>Context.MODE_PRIVATE = 0<br>为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容。</p>\n</li>\n<li><p>Context.MODE_APPEND = 32768<br>该模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。　</p>\n</li>\n<li><p>Context.MODE_WORLD_READABLE = 1<br>表示当前文件可以被其他应用读取。</p>\n</li>\n<li><p>MODE_WORLD_WRITEABLE<br>表示当前文件可以被其他应用写入。</p>\n</li>\n</ul>\n<p><strong>b. 读取一个内部存储的私有文件</strong></p>\n<p>步骤：</p>\n<ul>\n<li>调用openFileInput( )，参数中填入文件名，会返回一个FileInputStream对象。</li>\n<li>使用流对象的 read()方法读取字节</li>\n<li>调用流的close()方法关闭流</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">String FILENAME = <span class=\"string\">\"a.txt\"</span>;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            FileInputStream inStream = openFileInput(FILENAME);</div><div class=\"line\">            <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</div><div class=\"line\">            StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">            <span class=\"keyword\">while</span> ((len = inStream.read(buf)) != -<span class=\"number\">1</span>) &#123;</div><div class=\"line\">                sb.append(<span class=\"keyword\">new</span> String(buf, <span class=\"number\">0</span>, len));</div><div class=\"line\">            &#125;</div><div class=\"line\">            inStream.close();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>其他一些经常用到的方法：</p>\n<ul>\n<li>getFilesDir()：　得到内存储文件的绝对路径</li>\n<li>getDir()：　在内存储空间中创建或打开一个已经存在的目录</li>\n<li>deleteFile()：　删除保存在内部存储的文件。　 </li>\n<li>fileList()：　返回当前由应用程序保存的文件的数组（内存储目录下的全部文件）。</li>\n</ul>\n<p><strong>c.获取编译时的静态文件</strong></p>\n<p>如果你想在应用编译时保存静态文件，应该把文件保存在项目的　res/raw/　目录下，你可以通过 openRawResource()方法去打开它（传入参数R.raw.filename），这个方法返回一个 InputStream流对象你可以读取文件但是不能修改原始文件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">InputStream is = <span class=\"keyword\">this</span>.getResources().openRawResource(R.raw.filename);</div></pre></td></tr></table></figure>\n<p><strong>d. 获取内存缓存文件</strong></p>\n<p>有时候我们只想缓存一些数据而不是持久化保存，可以使用getCacheDir（）去打开一个文件，文件的存储目录（ /data/data/包名/cache ）是一个应用专门来保存临时缓存文件的内存目录。当设备的内部存储空间比较低的时候，Android可能会删除这些缓存文件来恢复空间，但是你不应该依赖系统来回收，要自己维护这些缓存文件把它们的大小限制在一个合理的范围内，比如1ＭＢ．当你卸载应用的时候这些缓存文件也会被移除。</p>\n<h6 id=\"文件的外部存储（sdcard）\"><a href=\"#文件的外部存储（sdcard）\" class=\"headerlink\" title=\"文件的外部存储（sdcard）\"></a>文件的外部存储（sdcard）</h6><p>因为内部存储容量限制，有时候需要存储数据比较大的时候需要用到外部存储，使用外部存储分为以下几个步骤：</p>\n<p><strong>a. 添加外部存储访问限权</strong></p>\n<p>首先，要在AndroidManifest.xml中加入访问SDCard的权限，如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- 在SDCard中创建与删除文件权限 --&gt; </div><div class=\"line\">   &lt;uses-permission android:name=<span class=\"string\">\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\"</span>/&gt; </div><div class=\"line\"></div><div class=\"line\">   &lt;!-- 往SDCard写入数据权限 --&gt; </div><div class=\"line\">   &lt;uses-permission android:name=<span class=\"string\">\"android.permission.WRITE_EXTERNAL_STORAGE\"</span>/&gt;</div></pre></td></tr></table></figure>\n<p><strong>b. 检测外部存储的可用性</strong></p>\n<p>在使用外部存储时我们需要检测其状态，它可能被连接到计算机、丢失或者只读等。下面代码将说明如何检查状态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//获取外存储的状态</span></div><div class=\"line\">String state = Environment.getExternalStorageState();</div><div class=\"line\"><span class=\"keyword\">if</span> (Environment.MEDIA_MOUNTED.equals(state)) &#123;</div><div class=\"line\">    <span class=\"comment\">// 可读可写</span></div><div class=\"line\">    mExternalStorageAvailable = mExternalStorageWriteable = <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123;</div><div class=\"line\">    <span class=\"comment\">// 可读</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 可能有很多其他的状态，但是我们只需要知道，不能读也不能写  </span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>c. 访问外部存储器中的文件</strong></p>\n<p>1) 如果 API 版本大于或等于８，使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">getExternalFilesDir (String type)</div></pre></td></tr></table></figure>\n<p>该方法打开一个外存储目录，此方法需要一个类型，指定你想要的子目录，如类型参数DIRECTORY_MUSIC和 DIRECTORY_RINGTONES（传null就是你应用程序的文件目录的根目录）。通过指定目录的类型，确保Android的媒体扫描仪将扫描分类系统中的文件（例如，铃声被确定为铃声）。如果用户卸载应用程序，这个目录及其所有内容将被删除。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">File file = <span class=\"keyword\">new</span> File(getExternalFilesDir(<span class=\"keyword\">null</span>), <span class=\"string\">\"fanrunqi.jpg\"</span>);</div></pre></td></tr></table></figure>\n<p>2) 如果API 版本小于 8 （7或者更低）,使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">getExternalStorageDirectory ()</div></pre></td></tr></table></figure>\n<p>通过该方法打开外存储的根目录，你应该在以下目录下写入你的应用数据，这样当卸载应用程序时该目录及其所有内容也将被删除。目录：/Android/data/<package_name>/files/</package_name></p>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))&#123;  </div><div class=\"line\">            File sdCardDir = Environment.getExternalStorageDirectory();<span class=\"comment\">//获取SDCard目录  \"/sdcard\"        </span></div><div class=\"line\"></div><div class=\"line\">               File saveFile = <span class=\"keyword\">new</span> File(sdCardDir,<span class=\"string\">\"a.txt\"</span>); </div><div class=\"line\"></div><div class=\"line\">               <span class=\"comment\">//写数据</span></div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    FileOutputStream fos= <span class=\"keyword\">new</span> FileOutputStream(saveFile); </div><div class=\"line\">                    fos.write(<span class=\"string\">\"fanrunqi\"</span>.getBytes()); </div><div class=\"line\">                    fos.close();</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125; </div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">//读数据</span></div><div class=\"line\">                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    FileInputStream fis= <span class=\"keyword\">new</span> FileInputStream(saveFile); </div><div class=\"line\">                    <span class=\"keyword\">int</span> len =<span class=\"number\">0</span>;</div><div class=\"line\">                    <span class=\"keyword\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</div><div class=\"line\">                    StringBuffer sb = <span class=\"keyword\">new</span> StringBuffer();</div><div class=\"line\">                    <span class=\"keyword\">while</span>((len=fis.read(buf))!=-<span class=\"number\">1</span>)&#123;</div><div class=\"line\">                        sb.append(<span class=\"keyword\">new</span> String(buf, <span class=\"number\">0</span>, len));</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    fis.close();</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;  </div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>我们也可以在　/Android/data/package_name/cache/目录下做外部缓存。</p>\n<h5 id=\"3-网路存储\"><a href=\"#3-网路存储\" class=\"headerlink\" title=\"3. 网路存储\"></a>3. 网路存储</h5><p>网路存储即是通过HttpUrlConnection或者HttpClint或者okhttp等http框架从服务器中获取数据。</p>\n<h5 id=\"4-SQLite存储\"><a href=\"#4-SQLite存储\" class=\"headerlink\" title=\"4.SQLite存储\"></a>4.SQLite存储</h5><p>请看我的另一篇博客《android基础之SQLite》</p>\n<h5 id=\"5-ContentProvider存储\"><a href=\"#5-ContentProvider存储\" class=\"headerlink\" title=\"5.ContentProvider存储\"></a>5.ContentProvider存储</h5><p>看我的另一篇博客《android基础之Content Provider》</p>\n<h3 id=\"三-总结\"><a href=\"#三-总结\" class=\"headerlink\" title=\"三 总结\"></a>三 总结</h3>","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>Android提供了5种方式来让用户保存持久化应用程序数据。根据自己的需求来做选择，比如数据是否是应用程序私有的，是否能被其他程序访问，需要多少数据存储空间等。这五种数据存储方式分别是：</p>\n<ul>\n<li>使用SharedPreferences存储数据　</li>\n<li>文件存储数据</li>\n<li>SQLite数据库存储数据</li>\n<li>使用ContentProvider存储数据</li>\n<li>网络存储数据</li>\n</ul>\n<h3 id=\"二-五种存储方式介绍\"><a href=\"#二-五种存储方式介绍\" class=\"headerlink\" title=\"二 五种存储方式介绍\"></a>二 五种存储方式介绍</h3><h5 id=\"1-SharePreferences\"><a href=\"#1-SharePreferences\" class=\"headerlink\" title=\"1. SharePreferences\"></a>1. SharePreferences</h5><p>SharedPreference类提供了一个总体框架，使您可以保存和检索任何基本数据类型（ boolean, float, int, long, string）的持久键-值对（基于XML文件存储的“key-value”键值对数据）。将其以XML文件的形式保存起来。通常其存储在“data/data/程序包名/shared_prefs目录下。</p>\n<h6 id=\"获取SharedPreferences对象（通过Context）\"><a href=\"#获取SharedPreferences对象（通过Context）\" class=\"headerlink\" title=\"获取SharedPreferences对象（通过Context）\"></a>获取SharedPreferences对象（通过Context）</h6><ul>\n<li><p>getSharedPreferences (String name, int mode)<br>当我们有多个SharedPreferences的时候，根据第一个参数name获得相应的SharedPreferences对象。    </p>\n</li>\n<li><p>getPreferences (int mode)<br>如果你的Activity中只需要一个SharedPreferences的时候使用。</p>\n</li>\n</ul>\n<p>这里的mode有四个选项：</p>\n<ul>\n<li><p>Context.MODE_PRIVAT<br>该SharedPreferences数据只能被本应用程序读、写。</p>\n</li>\n<li><p>Context.MODE_WORLD_READABLE<br>该SharedPreferences数据能被其他应用程序读，但不能写。</p>\n</li>\n<li><p>Context.MODE_WORLD_WRITEABLE<br>该SharedPreferences数据能被其他应用程序读和写。</p>\n</li>\n<li><p>Context.MODE_MULTI_PROCESS<br>sdk2.3后添加的选项，当多个进程同时读写同一个SharedPreferences时它会检查文件是否修改。</p>\n</li>\n</ul>\n<h6 id=\"向Shared-Preferences中写入值\"><a href=\"#向Shared-Preferences中写入值\" class=\"headerlink\" title=\"向Shared Preferences中写入值\"></a>向Shared Preferences中写入值</h6><p>主要步骤：</p>\n<ul>\n<li>首先要通过 SharedPreferences.Editor获取到Editor对象；</li>\n<li>然后通过Editor的putBoolean() 或 putString()等方法存入值；</li>\n<li>最后调用Editor的commit()方法提交；</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Use 0 or MODE_PRIVATE for the default operation </span></div><div class=\"line\">SharedPreferences settings = getSharedPreferences(<span class=\"string\">\"fanrunqi\"</span>, <span class=\"number\">0</span>);</div><div class=\"line\">SharedPreferences.Editor editor = settings.edit();</div><div class=\"line\">editor.putBoolean(<span class=\"string\">\"isAmazing\"</span>, <span class=\"keyword\">true</span>); </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 提交本次编辑</span></div><div class=\"line\">editor.commit();</div></pre></td></tr></table></figure>\n<p>同时Edit还有两个常用的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">editor.remove(String key) ：下一次commit的时候会移除key对应的键值对</div><div class=\"line\"></div><div class=\"line\">editor.clear()：移除所有键值对</div></pre></td></tr></table></figure>\n<h6 id=\"从Shared-Preferences中读取值\"><a href=\"#从Shared-Preferences中读取值\" class=\"headerlink\" title=\"从Shared Preferences中读取值\"></a>从Shared Preferences中读取值</h6><p>读取值使用 SharedPreference对象的getBoolean()或getString()等方法就行了,如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">SharedPreferences settings = getSharedPreferences(<span class=\"string\">\"fanrunqi\"</span>, <span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"keyword\">boolean</span> isAmazing= settings.getBoolean(<span class=\"string\">\"isAmazing\"</span>,<span class=\"keyword\">true</span>);</div></pre></td></tr></table></figure>\n<h6 id=\"Shared-Preferences的优缺点\"><a href=\"#Shared-Preferences的优缺点\" class=\"headerlink\" title=\"Shared Preferences的优缺点\"></a>Shared Preferences的优缺点</h6><p>可以看出来Preferences是很轻量级的应用，使用起来也很方便，简洁。但存储数据类型比较单一（只有基本数据类型），无法进行条件查询，只能在不复杂的存储需求下使用，比如保存配置信息等。</p>\n<h5 id=\"2-文件存储\"><a href=\"#2-文件存储\" class=\"headerlink\" title=\"2.文件存储\"></a>2.文件存储</h5><h6 id=\"文件的内部存储（存储在手机中）\"><a href=\"#文件的内部存储（存储在手机中）\" class=\"headerlink\" title=\"文件的内部存储（存储在手机中）\"></a>文件的内部存储（存储在手机中）</h6><p>当文件被保存在内部存储中时，默认情况下，文件是应用程序私有的，其他应用不能访问。当用户卸载应用程序时这些文件也跟着被删除。文件默认存储位置：/data/data/包名/files/文件名。</p>\n<p><strong>a. 创建和写入一个内部存储的私有文件</strong> </p>\n<ul>\n<li>调用Context的openFileOutput()函数，填入文件名和操作模式，它会返回一个FileOutputStream对象。</li>\n<li>通过FileOutputStream对象的write()函数写入数据。</li>\n<li>FileOutputStream对象的close ()函数关闭流</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">String FILENAME = <span class=\"string\">\"a.txt\"</span>;</div><div class=\"line\">String string = <span class=\"string\">\"fanrunqi\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);</div><div class=\"line\">    fos.write(string.getBytes());</div><div class=\"line\">    fos.close();</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">    e.printStackTrace();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在 openFileOutput(String name, int mode)方法中:</p>\n<p>name参数:　用于指定文件名称，不能包含路径分隔符“/” ，如果文件不存在，Android 会自动创建它。<br>mode参数：用于指定操作模式，分为四种：</p>\n<ul>\n<li><p>Context.MODE_PRIVATE = 0<br>为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容。</p>\n</li>\n<li><p>Context.MODE_APPEND = 32768<br>该模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。　</p>\n</li>\n<li><p>Context.MODE_WORLD_READABLE = 1<br>表示当前文件可以被其他应用读取。</p>\n</li>\n<li><p>MODE_WORLD_WRITEABLE<br>表示当前文件可以被其他应用写入。</p>\n</li>\n</ul>\n<p><strong>b. 读取一个内部存储的私有文件</strong></p>\n<p>步骤：</p>\n<ul>\n<li>调用openFileInput( )，参数中填入文件名，会返回一个FileInputStream对象。</li>\n<li>使用流对象的 read()方法读取字节</li>\n<li>调用流的close()方法关闭流</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">String FILENAME = <span class=\"string\">\"a.txt\"</span>;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            FileInputStream inStream = openFileInput(FILENAME);</div><div class=\"line\">            <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</div><div class=\"line\">            StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">            <span class=\"keyword\">while</span> ((len = inStream.read(buf)) != -<span class=\"number\">1</span>) &#123;</div><div class=\"line\">                sb.append(<span class=\"keyword\">new</span> String(buf, <span class=\"number\">0</span>, len));</div><div class=\"line\">            &#125;</div><div class=\"line\">            inStream.close();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>其他一些经常用到的方法：</p>\n<ul>\n<li>getFilesDir()：　得到内存储文件的绝对路径</li>\n<li>getDir()：　在内存储空间中创建或打开一个已经存在的目录</li>\n<li>deleteFile()：　删除保存在内部存储的文件。　 </li>\n<li>fileList()：　返回当前由应用程序保存的文件的数组（内存储目录下的全部文件）。</li>\n</ul>\n<p><strong>c.获取编译时的静态文件</strong></p>\n<p>如果你想在应用编译时保存静态文件，应该把文件保存在项目的　res/raw/　目录下，你可以通过 openRawResource()方法去打开它（传入参数R.raw.filename），这个方法返回一个 InputStream流对象你可以读取文件但是不能修改原始文件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">InputStream is = <span class=\"keyword\">this</span>.getResources().openRawResource(R.raw.filename);</div></pre></td></tr></table></figure>\n<p><strong>d. 获取内存缓存文件</strong></p>\n<p>有时候我们只想缓存一些数据而不是持久化保存，可以使用getCacheDir（）去打开一个文件，文件的存储目录（ /data/data/包名/cache ）是一个应用专门来保存临时缓存文件的内存目录。当设备的内部存储空间比较低的时候，Android可能会删除这些缓存文件来恢复空间，但是你不应该依赖系统来回收，要自己维护这些缓存文件把它们的大小限制在一个合理的范围内，比如1ＭＢ．当你卸载应用的时候这些缓存文件也会被移除。</p>\n<h6 id=\"文件的外部存储（sdcard）\"><a href=\"#文件的外部存储（sdcard）\" class=\"headerlink\" title=\"文件的外部存储（sdcard）\"></a>文件的外部存储（sdcard）</h6><p>因为内部存储容量限制，有时候需要存储数据比较大的时候需要用到外部存储，使用外部存储分为以下几个步骤：</p>\n<p><strong>a. 添加外部存储访问限权</strong></p>\n<p>首先，要在AndroidManifest.xml中加入访问SDCard的权限，如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- 在SDCard中创建与删除文件权限 --&gt; </div><div class=\"line\">   &lt;uses-permission android:name=<span class=\"string\">\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\"</span>/&gt; </div><div class=\"line\"></div><div class=\"line\">   &lt;!-- 往SDCard写入数据权限 --&gt; </div><div class=\"line\">   &lt;uses-permission android:name=<span class=\"string\">\"android.permission.WRITE_EXTERNAL_STORAGE\"</span>/&gt;</div></pre></td></tr></table></figure>\n<p><strong>b. 检测外部存储的可用性</strong></p>\n<p>在使用外部存储时我们需要检测其状态，它可能被连接到计算机、丢失或者只读等。下面代码将说明如何检查状态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//获取外存储的状态</span></div><div class=\"line\">String state = Environment.getExternalStorageState();</div><div class=\"line\"><span class=\"keyword\">if</span> (Environment.MEDIA_MOUNTED.equals(state)) &#123;</div><div class=\"line\">    <span class=\"comment\">// 可读可写</span></div><div class=\"line\">    mExternalStorageAvailable = mExternalStorageWriteable = <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123;</div><div class=\"line\">    <span class=\"comment\">// 可读</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 可能有很多其他的状态，但是我们只需要知道，不能读也不能写  </span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>c. 访问外部存储器中的文件</strong></p>\n<p>1) 如果 API 版本大于或等于８，使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">getExternalFilesDir (String type)</div></pre></td></tr></table></figure>\n<p>该方法打开一个外存储目录，此方法需要一个类型，指定你想要的子目录，如类型参数DIRECTORY_MUSIC和 DIRECTORY_RINGTONES（传null就是你应用程序的文件目录的根目录）。通过指定目录的类型，确保Android的媒体扫描仪将扫描分类系统中的文件（例如，铃声被确定为铃声）。如果用户卸载应用程序，这个目录及其所有内容将被删除。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">File file = <span class=\"keyword\">new</span> File(getExternalFilesDir(<span class=\"keyword\">null</span>), <span class=\"string\">\"fanrunqi.jpg\"</span>);</div></pre></td></tr></table></figure>\n<p>2) 如果API 版本小于 8 （7或者更低）,使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">getExternalStorageDirectory ()</div></pre></td></tr></table></figure>\n<p>通过该方法打开外存储的根目录，你应该在以下目录下写入你的应用数据，这样当卸载应用程序时该目录及其所有内容也将被删除。目录：/Android/data/<package_name>/files/</p>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))&#123;  </div><div class=\"line\">            File sdCardDir = Environment.getExternalStorageDirectory();<span class=\"comment\">//获取SDCard目录  \"/sdcard\"        </span></div><div class=\"line\"></div><div class=\"line\">               File saveFile = <span class=\"keyword\">new</span> File(sdCardDir,<span class=\"string\">\"a.txt\"</span>); </div><div class=\"line\"></div><div class=\"line\">               <span class=\"comment\">//写数据</span></div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    FileOutputStream fos= <span class=\"keyword\">new</span> FileOutputStream(saveFile); </div><div class=\"line\">                    fos.write(<span class=\"string\">\"fanrunqi\"</span>.getBytes()); </div><div class=\"line\">                    fos.close();</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125; </div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">//读数据</span></div><div class=\"line\">                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    FileInputStream fis= <span class=\"keyword\">new</span> FileInputStream(saveFile); </div><div class=\"line\">                    <span class=\"keyword\">int</span> len =<span class=\"number\">0</span>;</div><div class=\"line\">                    <span class=\"keyword\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</div><div class=\"line\">                    StringBuffer sb = <span class=\"keyword\">new</span> StringBuffer();</div><div class=\"line\">                    <span class=\"keyword\">while</span>((len=fis.read(buf))!=-<span class=\"number\">1</span>)&#123;</div><div class=\"line\">                        sb.append(<span class=\"keyword\">new</span> String(buf, <span class=\"number\">0</span>, len));</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    fis.close();</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;  </div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>我们也可以在　/Android/data/package_name/cache/目录下做外部缓存。</p>\n<h5 id=\"3-网路存储\"><a href=\"#3-网路存储\" class=\"headerlink\" title=\"3. 网路存储\"></a>3. 网路存储</h5><p>网路存储即是通过HttpUrlConnection或者HttpClint或者okhttp等http框架从服务器中获取数据。</p>\n<h5 id=\"4-SQLite存储\"><a href=\"#4-SQLite存储\" class=\"headerlink\" title=\"4.SQLite存储\"></a>4.SQLite存储</h5><p>请看我的另一篇博客《android基础之SQLite》</p>\n<h5 id=\"5-ContentProvider存储\"><a href=\"#5-ContentProvider存储\" class=\"headerlink\" title=\"5.ContentProvider存储\"></a>5.ContentProvider存储</h5><p>看我的另一篇博客《android基础之Content Provider》</p>\n<h3 id=\"三-总结\"><a href=\"#三-总结\" class=\"headerlink\" title=\"三 总结\"></a>三 总结</h3>"},{"title":"hexo搭建博客指南（二）--主题配置","date":"2017-02-18T07:09:07.000Z","_content":"### 一 主题选择  \n\n&emsp;&emsp;由于hexo默认的主题并不让人满意，因此要想搭建一个让自己心仪的博客你还需要一款好看的主题。hexo的主题你可以冲一下两个网站中获取：  \n[https://github.com/hexojs/hexo/wiki/Themes](https://github.com/hexojs/hexo/wiki/Themes)  \n[https://hexo.io/zh-cn/docs/themes.html](https://hexo.io/zh-cn/docs/themes.html)  \n\n\n### 二 主题配置  \n\n#### 2.1 安装主题\n\n&emsp;&emsp;你可以选择自己心仪的主题，然后改一下hexo的配置文件_config.yml文件。  \n``` bash\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: hexo-theme-air\n``` \n你只需要将它改成你的主题名字  \n\n\n#### 2.2 配置主题  \n&emsp;&emsp;你需要了解一下hexo的主题配置文件_config.yml(注意与hexo根目录下的配置文件不是一个文件)的一些配置:\n``` bash\nmenu:\n  首页: /\n  项目: /项目/\n  职业生涯: /职业生涯/\n  随感: /随感/\n  归档: /archives\n  关于我: /about\n\nwidgets:\n- search\n- category\n- recent_posts\n- tagcloud\n\n```  \n##### **menu**\n&emsp;&emsp;下面的是你想要为你的网站划分的版块。前面是版块名称，后面是相应的路径。你可通过如下命令来新建新的版块页面：  \n``` bash\nhexo new page 版块名\n```  \nhexo会自动在source文件下建立相应的文件夹。   \n**注意：**这里有坑。  \n\n- 我曾新建完一个新的页面后却无法访问，究其原因是当我访问这个页面是浏览器的协议自动从https换成了http，结果找不到资源。原因未知，解决办法：将hexo中的东西都删掉，重搭。。。。。   \n- 又遇一坑，当我将我的版块页面所在的文件夹取名为中文时，我需要在主题配置文件中的menu下相应的版块路径后面多家一个“/”，否则报错，而英文的就不需要，原因未知。\n- 坑3，当使用md写博客时，网站默认quote是居中的，可通过修改主题下的source/css/_partial/article.styl文件中blockquote解决。  \n这些估计都是我选择的light主题中的坑。  \n\n##### **widget**  \n&emsp;&emsp;这下面的是一些网站侧边的一些小部件，比如我的网站右边的分类和标签云。你可以在你的主题下面的/layout/_widget下面找到你的主题支持哪些小部件，你只需要将这些部件名依照格式放在widget下即可显示在网站中。  \n\n##### **categories 和 tags**\n&emsp;&emsp;categories和tags是hexo内置的标签，你只需要在编写博客时加入以下配置：  \n``` bash\n---\ntitle: hexo搭建博客指南（二）--主题配置\ndate: 2017-02-18 15:09:07\ncategories: hexo\ntags:\n- hexo\n---\n``` \n即可在widget中的category和tag中显示你的分类与标签，categories一般用于文章分类，你也可用它来生成你的版块页；tags一般则是用于为搜索引擎提供你这篇博文的关键字。  \n\n### 三 总结\n\n&emsp;&emsp;文章到这里也差不多说完了，hexo的其他知识点你可以通过google搜索或者研究hexo的官方文档[https://hexo.io/zh-cn/docs/asset-folders.html](https://hexo.io/zh-cn/docs/asset-folders.html)来获得。下篇我将介绍hexo的相关插件使用。","source":"_posts/hexo搭建博客指南（二）-主题配置.md","raw":"---\ntitle: hexo搭建博客指南（二）--主题配置\ndate: 2017-02-18 15:09:07\ncategories: hexo\ntags:\n- hexo\n---\n### 一 主题选择  \n\n&emsp;&emsp;由于hexo默认的主题并不让人满意，因此要想搭建一个让自己心仪的博客你还需要一款好看的主题。hexo的主题你可以冲一下两个网站中获取：  \n[https://github.com/hexojs/hexo/wiki/Themes](https://github.com/hexojs/hexo/wiki/Themes)  \n[https://hexo.io/zh-cn/docs/themes.html](https://hexo.io/zh-cn/docs/themes.html)  \n\n\n### 二 主题配置  \n\n#### 2.1 安装主题\n\n&emsp;&emsp;你可以选择自己心仪的主题，然后改一下hexo的配置文件_config.yml文件。  \n``` bash\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: hexo-theme-air\n``` \n你只需要将它改成你的主题名字  \n\n\n#### 2.2 配置主题  \n&emsp;&emsp;你需要了解一下hexo的主题配置文件_config.yml(注意与hexo根目录下的配置文件不是一个文件)的一些配置:\n``` bash\nmenu:\n  首页: /\n  项目: /项目/\n  职业生涯: /职业生涯/\n  随感: /随感/\n  归档: /archives\n  关于我: /about\n\nwidgets:\n- search\n- category\n- recent_posts\n- tagcloud\n\n```  \n##### **menu**\n&emsp;&emsp;下面的是你想要为你的网站划分的版块。前面是版块名称，后面是相应的路径。你可通过如下命令来新建新的版块页面：  \n``` bash\nhexo new page 版块名\n```  \nhexo会自动在source文件下建立相应的文件夹。   \n**注意：**这里有坑。  \n\n- 我曾新建完一个新的页面后却无法访问，究其原因是当我访问这个页面是浏览器的协议自动从https换成了http，结果找不到资源。原因未知，解决办法：将hexo中的东西都删掉，重搭。。。。。   \n- 又遇一坑，当我将我的版块页面所在的文件夹取名为中文时，我需要在主题配置文件中的menu下相应的版块路径后面多家一个“/”，否则报错，而英文的就不需要，原因未知。\n- 坑3，当使用md写博客时，网站默认quote是居中的，可通过修改主题下的source/css/_partial/article.styl文件中blockquote解决。  \n这些估计都是我选择的light主题中的坑。  \n\n##### **widget**  \n&emsp;&emsp;这下面的是一些网站侧边的一些小部件，比如我的网站右边的分类和标签云。你可以在你的主题下面的/layout/_widget下面找到你的主题支持哪些小部件，你只需要将这些部件名依照格式放在widget下即可显示在网站中。  \n\n##### **categories 和 tags**\n&emsp;&emsp;categories和tags是hexo内置的标签，你只需要在编写博客时加入以下配置：  \n``` bash\n---\ntitle: hexo搭建博客指南（二）--主题配置\ndate: 2017-02-18 15:09:07\ncategories: hexo\ntags:\n- hexo\n---\n``` \n即可在widget中的category和tag中显示你的分类与标签，categories一般用于文章分类，你也可用它来生成你的版块页；tags一般则是用于为搜索引擎提供你这篇博文的关键字。  \n\n### 三 总结\n\n&emsp;&emsp;文章到这里也差不多说完了，hexo的其他知识点你可以通过google搜索或者研究hexo的官方文档[https://hexo.io/zh-cn/docs/asset-folders.html](https://hexo.io/zh-cn/docs/asset-folders.html)来获得。下篇我将介绍hexo的相关插件使用。","slug":"hexo搭建博客指南（二）-主题配置","published":1,"updated":"2017-02-23T10:55:17.467Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk2n002kaknz5uho2i22","content":"<h3 id=\"一-主题选择\"><a href=\"#一-主题选择\" class=\"headerlink\" title=\"一 主题选择\"></a>一 主题选择</h3><p>&emsp;&emsp;由于hexo默认的主题并不让人满意，因此要想搭建一个让自己心仪的博客你还需要一款好看的主题。hexo的主题你可以冲一下两个网站中获取：<br><a href=\"https://github.com/hexojs/hexo/wiki/Themes\" target=\"_blank\" rel=\"external\">https://github.com/hexojs/hexo/wiki/Themes</a><br><a href=\"https://hexo.io/zh-cn/docs/themes.html\" target=\"_blank\" rel=\"external\">https://hexo.io/zh-cn/docs/themes.html</a>  </p>\n<h3 id=\"二-主题配置\"><a href=\"#二-主题配置\" class=\"headerlink\" title=\"二 主题配置\"></a>二 主题配置</h3><h4 id=\"2-1-安装主题\"><a href=\"#2-1-安装主题\" class=\"headerlink\" title=\"2.1 安装主题\"></a>2.1 安装主题</h4><p>&emsp;&emsp;你可以选择自己心仪的主题，然后改一下hexo的配置文件_config.yml文件。  </p>\n<pre><code class=\"bash\"><span class=\"comment\"># Extensions</span>\n<span class=\"comment\">## Plugins: https://hexo.io/plugins/</span>\n<span class=\"comment\">## Themes: https://hexo.io/themes/</span>\ntheme: hexo-theme-air\n</code></pre>\n<p>你只需要将它改成你的主题名字  </p>\n<h4 id=\"2-2-配置主题\"><a href=\"#2-2-配置主题\" class=\"headerlink\" title=\"2.2 配置主题\"></a>2.2 配置主题</h4><p>&emsp;&emsp;你需要了解一下hexo的主题配置文件_config.yml(注意与hexo根目录下的配置文件不是一个文件)的一些配置:</p>\n<pre><code class=\"bash\">menu:\n  首页: /\n  项目: /项目/\n  职业生涯: /职业生涯/\n  随感: /随感/\n  归档: /archives\n  关于我: /about\n\nwidgets:\n- search\n- category\n- recent_posts\n- tagcloud\n</code></pre>\n<h5 id=\"menu\"><a href=\"#menu\" class=\"headerlink\" title=\"menu\"></a><strong>menu</strong></h5><p>&emsp;&emsp;下面的是你想要为你的网站划分的版块。前面是版块名称，后面是相应的路径。你可通过如下命令来新建新的版块页面：  </p>\n<pre><code class=\"bash\">hexo new page 版块名\n</code></pre>\n<p>hexo会自动在source文件下建立相应的文件夹。<br><strong>注意：</strong>这里有坑。  </p>\n<ul>\n<li>我曾新建完一个新的页面后却无法访问，究其原因是当我访问这个页面是浏览器的协议自动从https换成了http，结果找不到资源。原因未知，解决办法：将hexo中的东西都删掉，重搭。。。。。   </li>\n<li>又遇一坑，当我将我的版块页面所在的文件夹取名为中文时，我需要在主题配置文件中的menu下相应的版块路径后面多家一个“/”，否则报错，而英文的就不需要，原因未知。</li>\n<li>坑3，当使用md写博客时，网站默认quote是居中的，可通过修改主题下的source/css/_partial/article.styl文件中blockquote解决。<br>这些估计都是我选择的light主题中的坑。  </li>\n</ul>\n<h5 id=\"widget\"><a href=\"#widget\" class=\"headerlink\" title=\"widget\"></a><strong>widget</strong></h5><p>&emsp;&emsp;这下面的是一些网站侧边的一些小部件，比如我的网站右边的分类和标签云。你可以在你的主题下面的/layout/_widget下面找到你的主题支持哪些小部件，你只需要将这些部件名依照格式放在widget下即可显示在网站中。  </p>\n<h5 id=\"categories-和-tags\"><a href=\"#categories-和-tags\" class=\"headerlink\" title=\"categories 和 tags\"></a><strong>categories 和 tags</strong></h5><p>&emsp;&emsp;categories和tags是hexo内置的标签，你只需要在编写博客时加入以下配置：  </p>\n<pre><code class=\"bash\">---\ntitle: hexo搭建博客指南（二）--主题配置\ndate: 2017-02-18 15:09:07\ncategories: hexo\ntags:\n- hexo\n---\n</code></pre>\n<p>即可在widget中的category和tag中显示你的分类与标签，categories一般用于文章分类，你也可用它来生成你的版块页；tags一般则是用于为搜索引擎提供你这篇博文的关键字。  </p>\n<h3 id=\"三-总结\"><a href=\"#三-总结\" class=\"headerlink\" title=\"三 总结\"></a>三 总结</h3><p>&emsp;&emsp;文章到这里也差不多说完了，hexo的其他知识点你可以通过google搜索或者研究hexo的官方文档<a href=\"https://hexo.io/zh-cn/docs/asset-folders.html\" target=\"_blank\" rel=\"external\">https://hexo.io/zh-cn/docs/asset-folders.html</a>来获得。下篇我将介绍hexo的相关插件使用。</p>\n","excerpt":"","more":"<h3 id=\"一-主题选择\"><a href=\"#一-主题选择\" class=\"headerlink\" title=\"一 主题选择\"></a>一 主题选择</h3><p>&emsp;&emsp;由于hexo默认的主题并不让人满意，因此要想搭建一个让自己心仪的博客你还需要一款好看的主题。hexo的主题你可以冲一下两个网站中获取：<br><a href=\"https://github.com/hexojs/hexo/wiki/Themes\">https://github.com/hexojs/hexo/wiki/Themes</a><br><a href=\"https://hexo.io/zh-cn/docs/themes.html\">https://hexo.io/zh-cn/docs/themes.html</a>  </p>\n<h3 id=\"二-主题配置\"><a href=\"#二-主题配置\" class=\"headerlink\" title=\"二 主题配置\"></a>二 主题配置</h3><h4 id=\"2-1-安装主题\"><a href=\"#2-1-安装主题\" class=\"headerlink\" title=\"2.1 安装主题\"></a>2.1 安装主题</h4><p>&emsp;&emsp;你可以选择自己心仪的主题，然后改一下hexo的配置文件_config.yml文件。  </p>\n<pre><code class=\"bash\"><span class=\"comment\"># Extensions</span>\n<span class=\"comment\">## Plugins: https://hexo.io/plugins/</span>\n<span class=\"comment\">## Themes: https://hexo.io/themes/</span>\ntheme: hexo-theme-air\n</code></pre>\n<p>你只需要将它改成你的主题名字  </p>\n<h4 id=\"2-2-配置主题\"><a href=\"#2-2-配置主题\" class=\"headerlink\" title=\"2.2 配置主题\"></a>2.2 配置主题</h4><p>&emsp;&emsp;你需要了解一下hexo的主题配置文件_config.yml(注意与hexo根目录下的配置文件不是一个文件)的一些配置:</p>\n<pre><code class=\"bash\">menu:\n  首页: /\n  项目: /项目/\n  职业生涯: /职业生涯/\n  随感: /随感/\n  归档: /archives\n  关于我: /about\n\nwidgets:\n- search\n- category\n- recent_posts\n- tagcloud\n</code></pre>\n<h5 id=\"menu\"><a href=\"#menu\" class=\"headerlink\" title=\"menu\"></a><strong>menu</strong></h5><p>&emsp;&emsp;下面的是你想要为你的网站划分的版块。前面是版块名称，后面是相应的路径。你可通过如下命令来新建新的版块页面：  </p>\n<pre><code class=\"bash\">hexo new page 版块名\n</code></pre>\n<p>hexo会自动在source文件下建立相应的文件夹。<br><strong>注意：</strong>这里有坑。  </p>\n<ul>\n<li>我曾新建完一个新的页面后却无法访问，究其原因是当我访问这个页面是浏览器的协议自动从https换成了http，结果找不到资源。原因未知，解决办法：将hexo中的东西都删掉，重搭。。。。。   </li>\n<li>又遇一坑，当我将我的版块页面所在的文件夹取名为中文时，我需要在主题配置文件中的menu下相应的版块路径后面多家一个“/”，否则报错，而英文的就不需要，原因未知。</li>\n<li>坑3，当使用md写博客时，网站默认quote是居中的，可通过修改主题下的source/css/_partial/article.styl文件中blockquote解决。<br>这些估计都是我选择的light主题中的坑。  </li>\n</ul>\n<h5 id=\"widget\"><a href=\"#widget\" class=\"headerlink\" title=\"widget\"></a><strong>widget</strong></h5><p>&emsp;&emsp;这下面的是一些网站侧边的一些小部件，比如我的网站右边的分类和标签云。你可以在你的主题下面的/layout/_widget下面找到你的主题支持哪些小部件，你只需要将这些部件名依照格式放在widget下即可显示在网站中。  </p>\n<h5 id=\"categories-和-tags\"><a href=\"#categories-和-tags\" class=\"headerlink\" title=\"categories 和 tags\"></a><strong>categories 和 tags</strong></h5><p>&emsp;&emsp;categories和tags是hexo内置的标签，你只需要在编写博客时加入以下配置：  </p>\n<pre><code class=\"bash\">---\ntitle: hexo搭建博客指南（二）--主题配置\ndate: 2017-02-18 15:09:07\ncategories: hexo\ntags:\n- hexo\n---\n</code></pre>\n<p>即可在widget中的category和tag中显示你的分类与标签，categories一般用于文章分类，你也可用它来生成你的版块页；tags一般则是用于为搜索引擎提供你这篇博文的关键字。  </p>\n<h3 id=\"三-总结\"><a href=\"#三-总结\" class=\"headerlink\" title=\"三 总结\"></a>三 总结</h3><p>&emsp;&emsp;文章到这里也差不多说完了，hexo的其他知识点你可以通过google搜索或者研究hexo的官方文档<a href=\"https://hexo.io/zh-cn/docs/asset-folders.html\">https://hexo.io/zh-cn/docs/asset-folders.html</a>来获得。下篇我将介绍hexo的相关插件使用。</p>\n"},{"title":"SQL优化","date":"2017-03-30T07:24:52.000Z","_content":"\n### 一 概述\n\n对于一些大型应用而言，SQL优化一直是重中之重。我们必须想方设法提高SQL执行的性能，否则由于庞大的数据量，它将成为整个系统性能的瓶颈。\n\n### 二 SQL优化的一般步骤\n\n当面对一个有SQL性能问题的数据库时，我们应该明白如何对它进行系统的分析。\n\n- 通过show status命令了解各种SQL语句的执行频率\n- 定位执行效率较低的SQL语句（通过慢查询日志或show processlist）\n- 通过explain分析低效SQL的执行计划\n- 确定问题并采取相应的优化措施\n\n### 三 数据库优化\n\n##### 数据库的优化\n\n- 建立索引（B树和hash）\n- 定期分析表和检查表\n- 定期优化表\n\n\n##### SQl语句的优化\n\n- 使用load大批量插入数据\n- 优化insert语句。\n- 优化group by语句\n- 优化order by语句\n- 优化嵌套查询\n- 优化or条件\n- 使用SQL提示\n\n##### 优化数据库对象\n\n- 优化表的数据类型\n- 通过拆分提高表的访问效率（分库分表）\n- 逆规范化\n- 使用中间表提高统计查询速度\n\n##### 应用优化\n\n- 使用连接池\n- 减少对数据库的访问（避免重复检索，做缓存等）\n- 负载均衡（分库分表，查询分流）\n\n\n\n \n\n\n","source":"_posts/SQL优化.md","raw":"---\ntitle: SQL优化\ndate: 2017-03-30 15:24:52\ncategories: 数据库\ntags:\n---\n\n### 一 概述\n\n对于一些大型应用而言，SQL优化一直是重中之重。我们必须想方设法提高SQL执行的性能，否则由于庞大的数据量，它将成为整个系统性能的瓶颈。\n\n### 二 SQL优化的一般步骤\n\n当面对一个有SQL性能问题的数据库时，我们应该明白如何对它进行系统的分析。\n\n- 通过show status命令了解各种SQL语句的执行频率\n- 定位执行效率较低的SQL语句（通过慢查询日志或show processlist）\n- 通过explain分析低效SQL的执行计划\n- 确定问题并采取相应的优化措施\n\n### 三 数据库优化\n\n##### 数据库的优化\n\n- 建立索引（B树和hash）\n- 定期分析表和检查表\n- 定期优化表\n\n\n##### SQl语句的优化\n\n- 使用load大批量插入数据\n- 优化insert语句。\n- 优化group by语句\n- 优化order by语句\n- 优化嵌套查询\n- 优化or条件\n- 使用SQL提示\n\n##### 优化数据库对象\n\n- 优化表的数据类型\n- 通过拆分提高表的访问效率（分库分表）\n- 逆规范化\n- 使用中间表提高统计查询速度\n\n##### 应用优化\n\n- 使用连接池\n- 减少对数据库的访问（避免重复检索，做缓存等）\n- 负载均衡（分库分表，查询分流）\n\n\n\n \n\n\n","slug":"SQL优化","published":1,"updated":"2017-03-30T10:14:43.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0z0sk4a006taknzo6e1f4ek","content":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>对于一些大型应用而言，SQL优化一直是重中之重。我们必须想方设法提高SQL执行的性能，否则由于庞大的数据量，它将成为整个系统性能的瓶颈。</p>\n<h3 id=\"二-SQL优化的一般步骤\"><a href=\"#二-SQL优化的一般步骤\" class=\"headerlink\" title=\"二 SQL优化的一般步骤\"></a>二 SQL优化的一般步骤</h3><p>当面对一个有SQL性能问题的数据库时，我们应该明白如何对它进行系统的分析。</p>\n<ul>\n<li>通过show status命令了解各种SQL语句的执行频率</li>\n<li>定位执行效率较低的SQL语句（通过慢查询日志或show processlist）</li>\n<li>通过explain分析低效SQL的执行计划</li>\n<li>确定问题并采取相应的优化措施</li>\n</ul>\n<h3 id=\"三-数据库优化\"><a href=\"#三-数据库优化\" class=\"headerlink\" title=\"三 数据库优化\"></a>三 数据库优化</h3><h5 id=\"数据库的优化\"><a href=\"#数据库的优化\" class=\"headerlink\" title=\"数据库的优化\"></a>数据库的优化</h5><ul>\n<li>建立索引（B树和hash）</li>\n<li>定期分析表和检查表</li>\n<li>定期优化表</li>\n</ul>\n<h5 id=\"SQl语句的优化\"><a href=\"#SQl语句的优化\" class=\"headerlink\" title=\"SQl语句的优化\"></a>SQl语句的优化</h5><ul>\n<li>使用load大批量插入数据</li>\n<li>优化insert语句。</li>\n<li>优化group by语句</li>\n<li>优化order by语句</li>\n<li>优化嵌套查询</li>\n<li>优化or条件</li>\n<li>使用SQL提示</li>\n</ul>\n<h5 id=\"优化数据库对象\"><a href=\"#优化数据库对象\" class=\"headerlink\" title=\"优化数据库对象\"></a>优化数据库对象</h5><ul>\n<li>优化表的数据类型</li>\n<li>通过拆分提高表的访问效率（分库分表）</li>\n<li>逆规范化</li>\n<li>使用中间表提高统计查询速度</li>\n</ul>\n<h5 id=\"应用优化\"><a href=\"#应用优化\" class=\"headerlink\" title=\"应用优化\"></a>应用优化</h5><ul>\n<li>使用连接池</li>\n<li>减少对数据库的访问（避免重复检索，做缓存等）</li>\n<li>负载均衡（分库分表，查询分流）</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h3><p>对于一些大型应用而言，SQL优化一直是重中之重。我们必须想方设法提高SQL执行的性能，否则由于庞大的数据量，它将成为整个系统性能的瓶颈。</p>\n<h3 id=\"二-SQL优化的一般步骤\"><a href=\"#二-SQL优化的一般步骤\" class=\"headerlink\" title=\"二 SQL优化的一般步骤\"></a>二 SQL优化的一般步骤</h3><p>当面对一个有SQL性能问题的数据库时，我们应该明白如何对它进行系统的分析。</p>\n<ul>\n<li>通过show status命令了解各种SQL语句的执行频率</li>\n<li>定位执行效率较低的SQL语句（通过慢查询日志或show processlist）</li>\n<li>通过explain分析低效SQL的执行计划</li>\n<li>确定问题并采取相应的优化措施</li>\n</ul>\n<h3 id=\"三-数据库优化\"><a href=\"#三-数据库优化\" class=\"headerlink\" title=\"三 数据库优化\"></a>三 数据库优化</h3><h5 id=\"数据库的优化\"><a href=\"#数据库的优化\" class=\"headerlink\" title=\"数据库的优化\"></a>数据库的优化</h5><ul>\n<li>建立索引（B树和hash）</li>\n<li>定期分析表和检查表</li>\n<li>定期优化表</li>\n</ul>\n<h5 id=\"SQl语句的优化\"><a href=\"#SQl语句的优化\" class=\"headerlink\" title=\"SQl语句的优化\"></a>SQl语句的优化</h5><ul>\n<li>使用load大批量插入数据</li>\n<li>优化insert语句。</li>\n<li>优化group by语句</li>\n<li>优化order by语句</li>\n<li>优化嵌套查询</li>\n<li>优化or条件</li>\n<li>使用SQL提示</li>\n</ul>\n<h5 id=\"优化数据库对象\"><a href=\"#优化数据库对象\" class=\"headerlink\" title=\"优化数据库对象\"></a>优化数据库对象</h5><ul>\n<li>优化表的数据类型</li>\n<li>通过拆分提高表的访问效率（分库分表）</li>\n<li>逆规范化</li>\n<li>使用中间表提高统计查询速度</li>\n</ul>\n<h5 id=\"应用优化\"><a href=\"#应用优化\" class=\"headerlink\" title=\"应用优化\"></a>应用优化</h5><ul>\n<li>使用连接池</li>\n<li>减少对数据库的访问（避免重复检索，做缓存等）</li>\n<li>负载均衡（分库分表，查询分流）</li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/Java基础之反射与类加载器/类加载器的层次结构.png","slug":"类加载器的层次结构.png","post":"cj0z0sk0j0001aknzyenm8uo6","modified":0,"renderable":0},{"_id":"source/_posts/Java基础之异常/Java异常继承体系图.jpg","slug":"Java异常继承体系图.jpg","post":"cj0z0sk0r0005aknzmiu523y3","modified":0,"renderable":0},{"_id":"source/_posts/Java基础之线程/Java线程状态转换图.png","slug":"Java线程状态转换图.png","post":"cj0z0sk1b000caknz7br2kmml","modified":0,"renderable":0},{"_id":"source/_posts/TCP协议与UDP协议/TCP报文结构.png","slug":"TCP报文结构.png","post":"cj0z0sk1k000naknzqkg3rci2","modified":0,"renderable":0},{"_id":"source/_posts/android基础之Service/Service生命周期图.png","slug":"Service生命周期图.png","post":"cj0z0sk1x001baknzgstr1erc","modified":0,"renderable":0},{"_id":"source/_posts/android基础之缓存/文件缓存结果图.png","slug":"文件缓存结果图.png","post":"cj0z0sk27001paknzo6261zqn","modified":0,"renderable":0},{"_id":"source/_posts/android基础之自定义View与ViewGroup/View绘制过程.png","slug":"View绘制过程.png","post":"cj0z0sk29001saknzu78nxplw","modified":0,"renderable":0},{"_id":"source/_posts/设计模式之观察者模式/观察者模式类图.jpg","slug":"观察者模式类图.jpg","post":"cj0z0sk2k002faknz5mbbm2y6","modified":0,"renderable":0},{"_id":"source/_posts/android基础之事件分发机制/Touch事件分发机制流程图.png","slug":"Touch事件分发机制流程图.png","post":"cj0z0sk24001maknz23fm0hun","modified":0,"renderable":0},{"_id":"source/_posts/android基础之事件分发机制/android事件分发.png","slug":"android事件分发.png","post":"cj0z0sk24001maknz23fm0hun","modified":0,"renderable":0},{"_id":"source/_posts/android基础之Fragments/Fragment与Activity生命周期对比.png","slug":"Fragment与Activity生命周期对比.png","post":"cj0z0sk1q000xaknz8qbbv83b","modified":0,"renderable":0},{"_id":"source/_posts/android基础之Fragments/Fragment显示图.png","slug":"Fragment显示图.png","post":"cj0z0sk1q000xaknz8qbbv83b","modified":0,"renderable":0},{"_id":"source/_posts/android基础之Fragments/Fragment生命周期图.png","slug":"Fragment生命周期图.png","post":"cj0z0sk1q000xaknz8qbbv83b","modified":0,"renderable":0},{"_id":"source/_posts/http协议与https/1146631942.png","slug":"1146631942.png","post":"cj0z0sk2e0025aknz14bpg36w","modified":0,"renderable":0},{"_id":"source/_posts/http协议与https/474814076.png","slug":"474814076.png","post":"cj0z0sk2e0025aknz14bpg36w","modified":0,"renderable":0},{"_id":"source/_posts/http协议与https/HTTPS握手图.jpg","slug":"HTTPS握手图.jpg","post":"cj0z0sk2e0025aknz14bpg36w","modified":0,"renderable":0},{"_id":"source/_posts/设计模式之工厂模式/工厂方法模式类图.jpg","slug":"工厂方法模式类图.jpg","post":"cj0z0sk2h002caknzr2iyfk6t","modified":0,"renderable":0},{"_id":"source/_posts/设计模式之工厂模式/抽象工厂模式类图.jpg","slug":"抽象工厂模式类图.jpg","post":"cj0z0sk2h002caknzr2iyfk6t","modified":0,"renderable":0},{"_id":"source/_posts/设计模式之工厂模式/简单工厂模式类图.jpg","slug":"简单工厂模式类图.jpg","post":"cj0z0sk2h002caknzr2iyfk6t","modified":0,"renderable":0},{"_id":"source/_posts/android基础之activity/Activity状态保存示意图.png","slug":"Activity状态保存示意图.png","post":"cj0z0sk1z001eaknz5d9i713z","modified":0,"renderable":0},{"_id":"source/_posts/android基础之activity/activity回调方法汇总.png","slug":"activity回调方法汇总.png","post":"cj0z0sk1z001eaknz5d9i713z","modified":0,"renderable":0},{"_id":"source/_posts/android基础之activity/activity生命周期图.png","slug":"activity生命周期图.png","post":"cj0z0sk1z001eaknz5d9i713z","modified":0,"renderable":0},{"_id":"source/_posts/android基础之activity/startActivityForResult是被调用者的生命周期.png","slug":"startActivityForResult是被调用者的生命周期.png","post":"cj0z0sk1z001eaknz5d9i713z","modified":0,"renderable":0},{"_id":"source/_posts/Java基础之内存管理/Java类从加载到初始化的过程.png","slug":"Java类从加载到初始化的过程.png","post":"cj0z0sk0m0002aknzlnrmuxjh","modified":0,"renderable":0},{"_id":"source/_posts/Java基础之内存管理/根搜索算法判断对象是否可回收.jpg","slug":"根搜索算法判断对象是否可回收.jpg","post":"cj0z0sk0m0002aknzlnrmuxjh","modified":0,"renderable":0},{"_id":"source/_posts/Java基础之内存管理/运行时数据区域.jpg","slug":"运行时数据区域.jpg","post":"cj0z0sk0m0002aknzlnrmuxjh","modified":0,"renderable":0},{"_id":"source/_posts/Java基础之内存管理/通过句柄访问对象.jpg","slug":"通过句柄访问对象.jpg","post":"cj0z0sk0m0002aknzlnrmuxjh","modified":0,"renderable":0},{"_id":"source/_posts/Java基础之内存管理/通过直接指针访问对象.jpg","slug":"通过直接指针访问对象.jpg","post":"cj0z0sk0m0002aknzlnrmuxjh","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cj0z0sk0w0006aknzj2ioceyd","category_id":"cj0z0sk0o0003aknzykiigjsp","_id":"cj0z0sk19000baknz3rvfkf12"},{"post_id":"cj0z0sk0j0001aknzyenm8uo6","category_id":"cj0z0sk0o0003aknzykiigjsp","_id":"cj0z0sk1d000faknzuau046lp"},{"post_id":"cj0z0sk110007aknznbenjmza","category_id":"cj0z0sk0o0003aknzykiigjsp","_id":"cj0z0sk1g000iaknz9bdd4dmd"},{"post_id":"cj0z0sk14000aaknzbx8pt6tr","category_id":"cj0z0sk0o0003aknzykiigjsp","_id":"cj0z0sk1k000maknzdba7cvsu"},{"post_id":"cj0z0sk0m0002aknzlnrmuxjh","category_id":"cj0z0sk0o0003aknzykiigjsp","_id":"cj0z0sk1m000paknzm93zzzxi"},{"post_id":"cj0z0sk1b000caknz7br2kmml","category_id":"cj0z0sk0o0003aknzykiigjsp","_id":"cj0z0sk1n000raknzkemkayxm"},{"post_id":"cj0z0sk0r0005aknzmiu523y3","category_id":"cj0z0sk0o0003aknzykiigjsp","_id":"cj0z0sk1p000uaknzdjdd4ylx"},{"post_id":"cj0z0sk1o000taknzt4bpv7qo","category_id":"cj0z0sk0o0003aknzykiigjsp","_id":"cj0z0sk1r000zaknzzeba3sv5"},{"post_id":"cj0z0sk1h000jaknzna7z366z","category_id":"cj0z0sk1m000oaknzxir5r19p","_id":"cj0z0sk1s0013aknz4mthcghw"},{"post_id":"cj0z0sk1k000naknzqkg3rci2","category_id":"cj0z0sk1p000waknzifkuhxf1","_id":"cj0z0sk1w0019aknzzmwlm1gf"},{"post_id":"cj0z0sk1t0015aknzibyq4z5p","category_id":"cj0z0sk1s0012aknzvh0ef27q","_id":"cj0z0sk1z001daknz57a0m7r7"},{"post_id":"cj0z0sk1m000qaknz3yzojsld","category_id":"cj0z0sk1s0012aknzvh0ef27q","_id":"cj0z0sk20001haknzujdouvjc"},{"post_id":"cj0z0sk1v0018aknzpsw0t5eu","category_id":"cj0z0sk1s0012aknzvh0ef27q","_id":"cj0z0sk24001laknzfcywabv3"},{"post_id":"cj0z0sk1x001baknzgstr1erc","category_id":"cj0z0sk1s0012aknzvh0ef27q","_id":"cj0z0sk26001oaknz94xc6kd2"},{"post_id":"cj0z0sk1p000vaknzebwczbek","category_id":"cj0z0sk1s0012aknzvh0ef27q","_id":"cj0z0sk28001raknz7jpps1wr"},{"post_id":"cj0z0sk1z001eaknz5d9i713z","category_id":"cj0z0sk1s0012aknzvh0ef27q","_id":"cj0z0sk2a001uaknz8dg0z9p8"},{"post_id":"cj0z0sk21001iaknzfqnjed6r","category_id":"cj0z0sk1s0012aknzvh0ef27q","_id":"cj0z0sk2b001yaknzq25z86bp"},{"post_id":"cj0z0sk1q000xaknz8qbbv83b","category_id":"cj0z0sk1s0012aknzvh0ef27q","_id":"cj0z0sk2d0020aknztte58w8n"},{"post_id":"cj0z0sk24001maknz23fm0hun","category_id":"cj0z0sk1s0012aknzvh0ef27q","_id":"cj0z0sk2e0023aknzfabxdvu6"},{"post_id":"cj0z0sk27001paknzo6261zqn","category_id":"cj0z0sk1s0012aknzvh0ef27q","_id":"cj0z0sk2g0027aknzbd0e9h5a"},{"post_id":"cj0z0sk1r0011aknz3ay7jkr4","category_id":"cj0z0sk1s0012aknzvh0ef27q","_id":"cj0z0sk2h002aaknzkciqf4xs"},{"post_id":"cj0z0sk29001saknzu78nxplw","category_id":"cj0z0sk1s0012aknzvh0ef27q","_id":"cj0z0sk2k002eaknzv7hyiord"},{"post_id":"cj0z0sk2d0021aknzwe6d7x1o","category_id":"cj0z0sk1s0012aknzvh0ef27q","_id":"cj0z0sk2l002gaknzx6ayo7i7"},{"post_id":"cj0z0sk2e0025aknz14bpg36w","category_id":"cj0z0sk1p000waknzifkuhxf1","_id":"cj0z0sk2n002jaknzh72zbwz4"},{"post_id":"cj0z0sk2c001zaknzlrfu9opv","category_id":"cj0z0sk2e0022aknz40ikrgh4","_id":"cj0z0sk2o002maknzz5fq6lj1"},{"post_id":"cj0z0sk2m002haknzknlxl2r6","category_id":"cj0z0sk1s0012aknzvh0ef27q","_id":"cj0z0sk2p002oaknzcu9kgk5w"},{"post_id":"cj0z0sk2g0028aknz8rlnu6be","category_id":"cj0z0sk2k002daknz0kz4iy67","_id":"cj0z0sk2q002raknzpo842h0t"},{"post_id":"cj0z0sk2n002kaknz5uho2i22","category_id":"cj0z0sk2e0022aknz40ikrgh4","_id":"cj0z0sk2r002uaknzcll6qghj"},{"post_id":"cj0z0sk2h002caknzr2iyfk6t","category_id":"cj0z0sk2k002daknz0kz4iy67","_id":"cj0z0sk2s002waknz5kt33r5c"},{"post_id":"cj0z0sk2k002faknz5mbbm2y6","category_id":"cj0z0sk2k002daknz0kz4iy67","_id":"cj0z0sk2s002yaknzfqxj88ng"},{"post_id":"cj0z0sk4a006taknzo6e1f4ek","category_id":"cj0z0sk1m000oaknzxir5r19p","_id":"cj0z0sk4c006uaknzy3t6qpcj"}],"PostTag":[{"post_id":"cj0z0sk0j0001aknzyenm8uo6","tag_id":"cj0z0sk0q0004aknz6q6pqiw7","_id":"cj0z0sk1f000haknz7dd8987l"},{"post_id":"cj0z0sk0j0001aknzyenm8uo6","tag_id":"cj0z0sk130009aknz66jtsnrn","_id":"cj0z0sk1j000kaknzdk01p8if"},{"post_id":"cj0z0sk0m0002aknzlnrmuxjh","tag_id":"cj0z0sk1d000eaknzsqbudlyr","_id":"cj0z0sk1r0010aknz1hkkepk6"},{"post_id":"cj0z0sk0m0002aknzlnrmuxjh","tag_id":"cj0z0sk1j000laknz04y4p5nh","_id":"cj0z0sk1s0014aknzgdugqrn2"},{"post_id":"cj0z0sk0m0002aknzlnrmuxjh","tag_id":"cj0z0sk1n000saknzc4xb7qw2","_id":"cj0z0sk1v0017aknzthm9kk3q"},{"post_id":"cj0z0sk0r0005aknzmiu523y3","tag_id":"cj0z0sk1d000eaknzsqbudlyr","_id":"cj0z0sk20001faknzqwfw8rfb"},{"post_id":"cj0z0sk0r0005aknzmiu523y3","tag_id":"cj0z0sk1t0016aknz7m26f174","_id":"cj0z0sk22001jaknzng84abaf"},{"post_id":"cj0z0sk0w0006aknzj2ioceyd","tag_id":"cj0z0sk1d000eaknzsqbudlyr","_id":"cj0z0sk29001taknzv52xyqdx"},{"post_id":"cj0z0sk0w0006aknzj2ioceyd","tag_id":"cj0z0sk22001kaknzar1t2v8r","_id":"cj0z0sk2b001waknzmgr5z9fb"},{"post_id":"cj0z0sk110007aknznbenjmza","tag_id":"cj0z0sk1d000eaknzsqbudlyr","_id":"cj0z0sk2g0026aknzqtj74x5l"},{"post_id":"cj0z0sk110007aknznbenjmza","tag_id":"cj0z0sk2b001xaknzaioi0ek9","_id":"cj0z0sk2h0029aknzllt7itub"},{"post_id":"cj0z0sk14000aaknzbx8pt6tr","tag_id":"cj0z0sk1d000eaknzsqbudlyr","_id":"cj0z0sk2q002qaknz2lw5768l"},{"post_id":"cj0z0sk14000aaknzbx8pt6tr","tag_id":"cj0z0sk2h002baknz5jy1zqo4","_id":"cj0z0sk2q002saknz46l49uxu"},{"post_id":"cj0z0sk14000aaknzbx8pt6tr","tag_id":"cj0z0sk2m002iaknzkp4dim18","_id":"cj0z0sk2r002vaknzjscdn22k"},{"post_id":"cj0z0sk1b000caknz7br2kmml","tag_id":"cj0z0sk1d000eaknzsqbudlyr","_id":"cj0z0sk2s002zaknzvhjav4nq"},{"post_id":"cj0z0sk1b000caknz7br2kmml","tag_id":"cj0z0sk2r002taknzbh1sysi9","_id":"cj0z0sk2t0030aknz3r1emtlv"},{"post_id":"cj0z0sk1h000jaknzna7z366z","tag_id":"cj0z0sk2s002xaknzihd2k3rk","_id":"cj0z0sk2t0032aknz8zwzgwgf"},{"post_id":"cj0z0sk1k000naknzqkg3rci2","tag_id":"cj0z0sk2t0031aknz837n1b9s","_id":"cj0z0sk2u0035aknznyclj80i"},{"post_id":"cj0z0sk1k000naknzqkg3rci2","tag_id":"cj0z0sk2u0033aknzx4m7gugc","_id":"cj0z0sk2u0036aknzt5gysrdy"},{"post_id":"cj0z0sk1m000qaknz3yzojsld","tag_id":"cj0z0sk2u0034aknzcilvnhj2","_id":"cj0z0sk2v003aaknzjo1gvqap"},{"post_id":"cj0z0sk1m000qaknz3yzojsld","tag_id":"cj0z0sk2u0037aknzeao87ng9","_id":"cj0z0sk2v003baknzrjvjtz7v"},{"post_id":"cj0z0sk1m000qaknz3yzojsld","tag_id":"cj0z0sk2v0038aknzht6739dn","_id":"cj0z0sk2v003daknznaxsbf1b"},{"post_id":"cj0z0sk1o000taknzt4bpv7qo","tag_id":"cj0z0sk1d000eaknzsqbudlyr","_id":"cj0z0sk2z003haknz6xdnfxjk"},{"post_id":"cj0z0sk1o000taknzt4bpv7qo","tag_id":"cj0z0sk2v0039aknzd7g6fel5","_id":"cj0z0sk2z003iaknzdord2eu5"},{"post_id":"cj0z0sk1o000taknzt4bpv7qo","tag_id":"cj0z0sk2v003caknzyvod5zx7","_id":"cj0z0sk30003kaknz1ks0z83b"},{"post_id":"cj0z0sk1o000taknzt4bpv7qo","tag_id":"cj0z0sk2w003eaknzmtfs3juh","_id":"cj0z0sk30003laknz4btimfza"},{"post_id":"cj0z0sk1o000taknzt4bpv7qo","tag_id":"cj0z0sk2w003faknzqhxpclxb","_id":"cj0z0sk30003naknz4cqbp0z4"},{"post_id":"cj0z0sk1p000vaknzebwczbek","tag_id":"cj0z0sk2u0034aknzcilvnhj2","_id":"cj0z0sk31003paknz5uphux9x"},{"post_id":"cj0z0sk1p000vaknzebwczbek","tag_id":"cj0z0sk2u0037aknzeao87ng9","_id":"cj0z0sk31003qaknz6hbyb8rw"},{"post_id":"cj0z0sk1p000vaknzebwczbek","tag_id":"cj0z0sk30003maknz3z5xcbk2","_id":"cj0z0sk31003saknzd87d700t"},{"post_id":"cj0z0sk1q000xaknz8qbbv83b","tag_id":"cj0z0sk2u0034aknzcilvnhj2","_id":"cj0z0sk33003vaknzfqucndll"},{"post_id":"cj0z0sk1q000xaknz8qbbv83b","tag_id":"cj0z0sk2u0037aknzeao87ng9","_id":"cj0z0sk33003waknzyu0k4xaf"},{"post_id":"cj0z0sk1q000xaknz8qbbv83b","tag_id":"cj0z0sk32003taknzgh48ahjc","_id":"cj0z0sk34003yaknzvdso2vnv"},{"post_id":"cj0z0sk1r0011aknz3ay7jkr4","tag_id":"cj0z0sk2u0034aknzcilvnhj2","_id":"cj0z0sk350042aknzau7qf3vg"},{"post_id":"cj0z0sk1r0011aknz3ay7jkr4","tag_id":"cj0z0sk2u0037aknzeao87ng9","_id":"cj0z0sk350043aknz70xmi3f7"},{"post_id":"cj0z0sk1r0011aknz3ay7jkr4","tag_id":"cj0z0sk34003zaknz480oytoc","_id":"cj0z0sk350045aknz60qfoonk"},{"post_id":"cj0z0sk1r0011aknz3ay7jkr4","tag_id":"cj0z0sk340040aknz0ljkeoid","_id":"cj0z0sk350046aknzugsgpjku"},{"post_id":"cj0z0sk1t0015aknzibyq4z5p","tag_id":"cj0z0sk2u0034aknzcilvnhj2","_id":"cj0z0sk36004aaknzu84mouaa"},{"post_id":"cj0z0sk1t0015aknzibyq4z5p","tag_id":"cj0z0sk2u0037aknzeao87ng9","_id":"cj0z0sk37004baknzctv1hx5g"},{"post_id":"cj0z0sk1t0015aknzibyq4z5p","tag_id":"cj0z0sk350047aknzvw1vl51b","_id":"cj0z0sk37004daknzj6zqfjci"},{"post_id":"cj0z0sk1t0015aknzibyq4z5p","tag_id":"cj0z0sk360048aknz0vxtthsy","_id":"cj0z0sk38004eaknzrpk8sul1"},{"post_id":"cj0z0sk1v0018aknzpsw0t5eu","tag_id":"cj0z0sk2u0034aknzcilvnhj2","_id":"cj0z0sk38004haknzin7yokel"},{"post_id":"cj0z0sk1v0018aknzpsw0t5eu","tag_id":"cj0z0sk2u0037aknzeao87ng9","_id":"cj0z0sk39004iaknzzjnqsdx8"},{"post_id":"cj0z0sk1v0018aknzpsw0t5eu","tag_id":"cj0z0sk38004faknz60j658ri","_id":"cj0z0sk39004kaknzp3nrk9o5"},{"post_id":"cj0z0sk1x001baknzgstr1erc","tag_id":"cj0z0sk2u0034aknzcilvnhj2","_id":"cj0z0sk3a004naknz2mbsdtdd"},{"post_id":"cj0z0sk1x001baknzgstr1erc","tag_id":"cj0z0sk2u0037aknzeao87ng9","_id":"cj0z0sk3a004oaknzokdscwi1"},{"post_id":"cj0z0sk1x001baknzgstr1erc","tag_id":"cj0z0sk39004laknzubzkfzqf","_id":"cj0z0sk3a004qaknztxegvlld"},{"post_id":"cj0z0sk1z001eaknz5d9i713z","tag_id":"cj0z0sk2u0037aknzeao87ng9","_id":"cj0z0sk3c004taknzddda1r5t"},{"post_id":"cj0z0sk1z001eaknz5d9i713z","tag_id":"cj0z0sk2u0034aknzcilvnhj2","_id":"cj0z0sk3c004uaknzofo2eimw"},{"post_id":"cj0z0sk1z001eaknz5d9i713z","tag_id":"cj0z0sk3a004raknzh36lvmym","_id":"cj0z0sk3d004waknz94ya4klz"},{"post_id":"cj0z0sk21001iaknzfqnjed6r","tag_id":"cj0z0sk2u0034aknzcilvnhj2","_id":"cj0z0sk3e004zaknz4c805f85"},{"post_id":"cj0z0sk21001iaknzfqnjed6r","tag_id":"cj0z0sk2u0037aknzeao87ng9","_id":"cj0z0sk3e0050aknzjyqvvnu7"},{"post_id":"cj0z0sk21001iaknzfqnjed6r","tag_id":"cj0z0sk3d004xaknzdva53p88","_id":"cj0z0sk3e0052aknzswzx18hv"},{"post_id":"cj0z0sk24001maknz23fm0hun","tag_id":"cj0z0sk2u0034aknzcilvnhj2","_id":"cj0z0sk3g0056aknze78vdgnz"},{"post_id":"cj0z0sk24001maknz23fm0hun","tag_id":"cj0z0sk2u0037aknzeao87ng9","_id":"cj0z0sk3g0057aknzqbu8qzur"},{"post_id":"cj0z0sk24001maknz23fm0hun","tag_id":"cj0z0sk3f0053aknzvjccbkcb","_id":"cj0z0sk3g0059aknztzne6e0q"},{"post_id":"cj0z0sk24001maknz23fm0hun","tag_id":"cj0z0sk3f0054aknzthkbphon","_id":"cj0z0sk3g005aaknzxt0bhcln"},{"post_id":"cj0z0sk27001paknzo6261zqn","tag_id":"cj0z0sk2u0034aknzcilvnhj2","_id":"cj0z0sk3h005daknzxc2qqg38"},{"post_id":"cj0z0sk27001paknzo6261zqn","tag_id":"cj0z0sk2u0037aknzeao87ng9","_id":"cj0z0sk3h005eaknznt9zu6ue"},{"post_id":"cj0z0sk27001paknzo6261zqn","tag_id":"cj0z0sk3g005baknz4le2hvcc","_id":"cj0z0sk3i005gaknzvonx788x"},{"post_id":"cj0z0sk29001saknzu78nxplw","tag_id":"cj0z0sk2u0034aknzcilvnhj2","_id":"cj0z0sk3j005kaknzjea74tng"},{"post_id":"cj0z0sk29001saknzu78nxplw","tag_id":"cj0z0sk2u0037aknzeao87ng9","_id":"cj0z0sk3q005laknzdibyx5yu"},{"post_id":"cj0z0sk29001saknzu78nxplw","tag_id":"cj0z0sk3i005haknzpw86nn2u","_id":"cj0z0sk3s005naknzklw9fmlg"},{"post_id":"cj0z0sk29001saknzu78nxplw","tag_id":"cj0z0sk3i005iaknzlv1jo29c","_id":"cj0z0sk3t005oaknzpfofd2gc"},{"post_id":"cj0z0sk2c001zaknzlrfu9opv","tag_id":"cj0z0sk3i005jaknzp7n6csi8","_id":"cj0z0sk3t005qaknz223qqvgc"},{"post_id":"cj0z0sk2d0021aknzwe6d7x1o","tag_id":"cj0z0sk2u0034aknzcilvnhj2","_id":"cj0z0sk3w005waknz4dllhoti"},{"post_id":"cj0z0sk2d0021aknzwe6d7x1o","tag_id":"cj0z0sk2u0037aknzeao87ng9","_id":"cj0z0sk3w005xaknzfkcyvuub"},{"post_id":"cj0z0sk2d0021aknzwe6d7x1o","tag_id":"cj0z0sk3u005raknzvpupnbfq","_id":"cj0z0sk3w005zaknzunyyk3d6"},{"post_id":"cj0z0sk2d0021aknzwe6d7x1o","tag_id":"cj0z0sk3u005saknznhdvaqbp","_id":"cj0z0sk3x0060aknztil4bgky"},{"post_id":"cj0z0sk2d0021aknzwe6d7x1o","tag_id":"cj0z0sk3u005taknzgx4tesjf","_id":"cj0z0sk3x0062aknzojp7xviu"},{"post_id":"cj0z0sk2d0021aknzwe6d7x1o","tag_id":"cj0z0sk3v005uaknzp0g0lvmo","_id":"cj0z0sk3x0063aknzutafdjy7"},{"post_id":"cj0z0sk2e0025aknz14bpg36w","tag_id":"cj0z0sk3v005vaknz6kcmednw","_id":"cj0z0sk3x0065aknzowui38bb"},{"post_id":"cj0z0sk2e0025aknz14bpg36w","tag_id":"cj0z0sk3w005yaknzckwjjw8a","_id":"cj0z0sk3y0066aknzm9mfdi6h"},{"post_id":"cj0z0sk2g0028aknz8rlnu6be","tag_id":"cj0z0sk3x0061aknzpwfa8q4d","_id":"cj0z0sk3y0068aknz5dtzg7ax"},{"post_id":"cj0z0sk2g0028aknz8rlnu6be","tag_id":"cj0z0sk3x0064aknzz9n020ir","_id":"cj0z0sk3y0069aknz0y8g7om4"},{"post_id":"cj0z0sk2h002caknzr2iyfk6t","tag_id":"cj0z0sk3x0064aknzz9n020ir","_id":"cj0z0sk41006eaknzcql7y0wj"},{"post_id":"cj0z0sk2h002caknzr2iyfk6t","tag_id":"cj0z0sk3y006aaknzgluzsk6x","_id":"cj0z0sk41006faknzcscsu7ut"},{"post_id":"cj0z0sk2h002caknzr2iyfk6t","tag_id":"cj0z0sk3z006baknzuvjac7pl","_id":"cj0z0sk41006haknz14ugfscc"},{"post_id":"cj0z0sk2h002caknzr2iyfk6t","tag_id":"cj0z0sk40006caknzq8coi5e4","_id":"cj0z0sk41006iaknzdcqgfo33"},{"post_id":"cj0z0sk2k002faknz5mbbm2y6","tag_id":"cj0z0sk40006daknzduw7ai3d","_id":"cj0z0sk42006kaknzpr67d46j"},{"post_id":"cj0z0sk2k002faknz5mbbm2y6","tag_id":"cj0z0sk41006gaknz3x2tch2e","_id":"cj0z0sk42006laknz39uj8p1p"},{"post_id":"cj0z0sk2m002haknzknlxl2r6","tag_id":"cj0z0sk2u0034aknzcilvnhj2","_id":"cj0z0sk43006paknz9h9ju8au"},{"post_id":"cj0z0sk2m002haknzknlxl2r6","tag_id":"cj0z0sk2u0037aknzeao87ng9","_id":"cj0z0sk43006qaknz62w7fnh1"},{"post_id":"cj0z0sk2m002haknzknlxl2r6","tag_id":"cj0z0sk42006naknzj4m8hoal","_id":"cj0z0sk44006raknza2qn3kcc"},{"post_id":"cj0z0sk2n002kaknz5uho2i22","tag_id":"cj0z0sk3i005jaknzp7n6csi8","_id":"cj0z0sk44006saknzm65nhbf8"}],"Tag":[{"name":"类加载器","_id":"cj0z0sk0q0004aknz6q6pqiw7"},{"name":"反射","_id":"cj0z0sk130009aknz66jtsnrn"},{"name":"Java","_id":"cj0z0sk1d000eaknzsqbudlyr"},{"name":"内存管理","_id":"cj0z0sk1j000laknz04y4p5nh"},{"name":"垃圾回收","_id":"cj0z0sk1n000saknzc4xb7qw2"},{"name":"异常","_id":"cj0z0sk1t0016aknz7m26f174"},{"name":"泛型","_id":"cj0z0sk22001kaknzar1t2v8r"},{"name":"IO","_id":"cj0z0sk2b001xaknzaioi0ek9"},{"name":"注解","_id":"cj0z0sk2h002baknz5jy1zqo4"},{"name":"注释","_id":"cj0z0sk2m002iaknzkp4dim18"},{"name":"线程","_id":"cj0z0sk2r002taknzbh1sysi9"},{"name":"SQL","_id":"cj0z0sk2s002xaknzihd2k3rk"},{"name":"TCP","_id":"cj0z0sk2t0031aknz837n1b9s"},{"name":"UDP","_id":"cj0z0sk2u0033aknzx4m7gugc"},{"name":"android","_id":"cj0z0sk2u0034aknzcilvnhj2"},{"name":"java","_id":"cj0z0sk2u0037aknzeao87ng9"},{"name":"Content Provider","_id":"cj0z0sk2v0038aknzht6739dn"},{"name":"List","_id":"cj0z0sk2v0039aknzd7g6fel5"},{"name":"Map","_id":"cj0z0sk2v003caknzyvod5zx7"},{"name":"Set","_id":"cj0z0sk2w003eaknzmtfs3juh"},{"name":"集合","_id":"cj0z0sk2w003faknzqhxpclxb"},{"name":"BroadcastReceiver","_id":"cj0z0sk30003maknz3z5xcbk2"},{"name":"Fragment","_id":"cj0z0sk32003taknzgh48ahjc"},{"name":"Handler","_id":"cj0z0sk34003zaknz480oytoc"},{"name":"AsycTask","_id":"cj0z0sk340040aknz0ljkeoid"},{"name":"Intent","_id":"cj0z0sk350047aknzvw1vl51b"},{"name":"IntentFilter","_id":"cj0z0sk360048aknz0vxtthsy"},{"name":"SQLite","_id":"cj0z0sk38004faknz60j658ri"},{"name":"service","_id":"cj0z0sk39004laknzubzkfzqf"},{"name":"activity","_id":"cj0z0sk3a004raknzh36lvmym"},{"name":"loader","_id":"cj0z0sk3d004xaknzdva53p88"},{"name":"View","_id":"cj0z0sk3f0053aknzvjccbkcb"},{"name":"事件分发","_id":"cj0z0sk3f0054aknzthkbphon"},{"name":"缓存","_id":"cj0z0sk3g005baknz4le2hvcc"},{"name":"view","_id":"cj0z0sk3i005haknzpw86nn2u"},{"name":"ViewGroup","_id":"cj0z0sk3i005iaknzlv1jo29c"},{"name":"hexo","_id":"cj0z0sk3i005jaknzp7n6csi8"},{"name":"长连接","_id":"cj0z0sk3u005raknzvpupnbfq"},{"name":"推送","_id":"cj0z0sk3u005saknznhdvaqbp"},{"name":"push","_id":"cj0z0sk3u005taknzgx4tesjf"},{"name":"pull","_id":"cj0z0sk3v005uaknzp0g0lvmo"},{"name":"HTTP","_id":"cj0z0sk3v005vaknz6kcmednw"},{"name":"HTTPS","_id":"cj0z0sk3w005yaknzckwjjw8a"},{"name":"单例模式","_id":"cj0z0sk3x0061aknzpwfa8q4d"},{"name":"创建型模式","_id":"cj0z0sk3x0064aknzz9n020ir"},{"name":"简单工厂模式","_id":"cj0z0sk3y006aaknzgluzsk6x"},{"name":"抽象工厂模式","_id":"cj0z0sk3z006baknzuvjac7pl"},{"name":"工厂方法模式","_id":"cj0z0sk40006caknzq8coi5e4"},{"name":"观察者模式","_id":"cj0z0sk40006daknzduw7ai3d"},{"name":"行为模式","_id":"cj0z0sk41006gaknz3x2tch2e"},{"name":"数据存储","_id":"cj0z0sk42006naknzj4m8hoal"}]}}